// SCHEMA_VERSION=2.0.0

/**
 * Official FlatBuffers Compiler: https://flatbuffers.ar.je/
 * Official FlatBuffers Documentation: https://flatbuffers.dev/tutorial/
 *
 * To maintain backward compatibility when evolving FlatBuffers schemas, follow these guidelines:
 *
 * - **Should be fine to rename fields**
 * - **Add new fields at the END of tables**: This ensures older code can still read the data without issues.
 * - **DONT REMOVE FIELDS**: Instead of deleting unused fields, mark them as deprecated to prevent their use in new code while maintaining compatibility with existing data.
 * - **DONT CHANGE FIELD TYPES**: Modifying a field's type can lead to incompatibilities. If necessary, add a new field with the desired type and depreciate the old one.
 * - **BE CAREFUL WITH DEFAULT VALUES**: Changing default values can cause inconsistencies when reading older data. It's best to set appropriate defaults initially and avoid altering them.
 * - **STRING or TABLE CANNOT FALLBACK TO NULL**: these fields cannot be null. They already have a default null value.
 */

namespace Duc;

file_identifier "DUC_";

/**
 * =============================================================================
 * ENUMS
 * =============================================================================
 */

/**
 * Usually we start from the value 10 on enums because on some languages, 0 is treated as false and 1 is treated as true on if statements
 */
enum VERTICAL_ALIGN:ubyte {
  /** Aligns text to the top of its bounding box. */
  TOP = 10,
  /** Aligns text to the middle of its bounding box. */
  MIDDLE = 11,
  /** Aligns text to the bottom of its bounding box. */
  BOTTOM = 12
}

enum TEXT_ALIGN:ubyte {
  /** Aligns text to the left of its bounding box. */
  LEFT = 10,
  /** Centers text horizontally within its bounding box. */
  CENTER = 11,
  /** Aligns text to the right of its bounding box. */
  RIGHT = 12
}

enum LINE_SPACING_TYPE:ubyte {
  /**
   * The line spacing is the larger of the `value` or the tallest character's natural height.
   * This ensures text doesn't overlap but respects a minimum spacing.
   */
  AT_LEAST = 10,
  /**
   * Forces the line spacing to the specified `value`, even if characters
   * (especially tall ones like ascenders/descenders or special symbols) overlap.
   * Useful for precise layout control where overlapping might be acceptable or handled externally.
   */
  EXACTLY = 11,
  /**
   * The base line height (often derived from the font's intrinsic metrics and font size)
   * is multiplied by the `value` (e.g., a `value` of 1.5 would mean 150% of the base line height).
   * This is very common for relative spacing.
   */
  MULTIPLE = 12
}

enum STACKED_TEXT_ALIGN:ubyte {
  /** Aligns stacked text segments to their center. */
  CENTER = 10,
  /** Aligns stacked text segments along their decimal points. */
  DECIMAL = 11,
  /** Aligns stacked text segments around a slash character. */
  SLASH = 12
}

/** Defines the type of source a dynamic part can link to. */
enum TEXT_FIELD_SOURCE_TYPE:ubyte {
  /** Links to a property of another element in the scene. */
  ELEMENT = 10,
  /** Links to a value in a global key-value store (a drawing dictionary/variables). */
  DICTIONARY = 20,
}

enum TEXT_FIELD_SOURCE_PROPERTY:ubyte {
  /** Represents the area property of an element. */
  AREA = 10,
  /** Represents the perimeter property of an element. */
  PERIMETER = 11,
  /** Represents the volume property of an element. */
  VOLUME = 12,
  /** Represents the length property of an element. */
  LENGTH = 13,
  /** Represents the width property of an element. */
  WIDTH = 14,
  /** Represents the height property of an element. */
  HEIGHT = 15,
  /** Represents the radius property of an element. */
  RADIUS = 16,
  /** Represents the diameter property of an element. */
  DIAMETER = 17,
  /** Represents the X coordinate property of an element. */
  X_COORDINATE = 18,
  /** Represents the Y coordinate property of an element. */
  Y_COORDINATE = 19,
  /** Represents the label property of an element. */
  LABEL = 20,
}

enum STROKE_PLACEMENT:ubyte {
  /** Places the stroke inside the element's boundary. */
  INSIDE = 10,
  /** Centers the stroke on the element's boundary. */
  CENTER = 11,
  /** Places the stroke outside the element's boundary. */
  OUTSIDE = 12
}

enum STROKE_WIDTH:ubyte {
  /** A thin stroke width. */
  THIN = 1,
  /** A bold stroke width. */
  BOLD = 2,
  /** An extra bold stroke width. */
  EXTRA_BOLD = 4
}

enum ELEMENT_CONTENT_PREFERENCE:ubyte {
  /** Fills the element with a solid color. */
  SOLID = 12,
  /** Fills the element with a solid color or gradient (similar to FILL). */
  FILL = 14,
  /** Scales the content to fit within the element's bounds, maintaining aspect ratio. */
  FIT = 15,
  /** Tiles the content within the element's bounds. */
  TILE = 16,
  /** Stretches the content to fill the element's bounds, potentially distorting aspect ratio. */
  STRETCH = 17,
  /** Fills the element with a hatch pattern. */
  HATCH = 18
}

enum STROKE_PREFERENCE:ubyte {
  /** Renders the stroke as a continuous solid line. */
  SOLID = 10,
  /** Renders the stroke as a series of dashes. */
  DASHED = 11,
  /** Renders the stroke as a series of dots. */
  DOTTED = 12,
  /** Renders the stroke using a custom pattern. */
  CUSTOM = 13
}

enum STROKE_SIDE_PREFERENCE:ubyte {
  /** Applies the stroke to the top side. */
  TOP = 10,
  /** Applies the stroke to the bottom side. */
  BOTTOM = 11,
  /** Applies the stroke to the left side. */
  LEFT = 12,
  /** Applies the stroke to the right side. */
  RIGHT = 13,
  /** Applies the stroke to custom-defined sides. */
  CUSTOM = 14,
  /** Applies the stroke to all sides. */
  ALL = 15
}

enum STROKE_CAP:ubyte {
  /** A butt cap cuts off the line at the endpoint. */
  BUTT = 10,
  /** A round cap adds a rounded end to the line. */
  ROUND = 11,
  /** A square cap adds a square end to the line. */
  SQUARE = 12
}

enum STROKE_JOIN:ubyte {
  /** A miter join creates a sharp corner. */
  MITER = 10,
  /** A round join creates a rounded corner. */
  ROUND = 11,
  /** A bevel join creates a flattened corner. */
  BEVEL = 12
}

enum LINE_HEAD:ubyte {
  /** An arrow-shaped line end. */
  ARROW = 10,
  /** A bar-shaped line end. */
  BAR = 11,
  /** A circular line end. */
  CIRCLE = 12,
  /** An outlined circular line end. */
  CIRCLE_OUTLINED = 13,
  /** A triangle-shaped line end. */
  TRIANGLE = 14,
  /** An outlined triangle-shaped line end. */
  TRIANGLE_OUTLINED = 15,
  /** A diamond-shaped line end. */
  DIAMOND = 16,
  /** An outlined diamond-shaped line end. */
  DIAMOND_OUTLINED = 17,
  /** A cross-shaped line end. */
  CROSS = 18,
  /** An open arrow-shaped line end. */
  OPEN_ARROW = 19,
  /** A reversed arrow-shaped line end. */
  REVERSED_ARROW = 20,
  /** A reversed triangle-shaped line end. */
  REVERSED_TRIANGLE = 21,
  /** A reversed outlined triangle-shaped line end. */
  REVERSED_TRIANGLE_OUTLINED = 22,
  /** A cone-shaped line end. */
  CONE = 23,
  /** A half-cone shaped line end. */
  HALF_CONE = 24
}

enum BEZIER_MIRRORING:ubyte {
  /** No mirroring of Bezier handles. */
  NONE = 10,
  /** Bezier handles mirror their angle. */
  ANGLE = 11,
  /** Bezier handles mirror both their angle and length. */
  ANGLE_LENGTH = 12
}

enum HANDLE_TYPE:ubyte {
  /** An "in" handle for Bezier curves, controlling the curve as it enters the point. */
  HANDLE_IN = 10,
  /** An "out" handle for Bezier curves, controlling the curve as it leaves the point. */
  HANDLE_OUT = 11
}

enum YOUTUBE_STATES:byte {
  /** The YouTube player is unstarted. */
  UNSTARTED = -1,
  /** The YouTube player has ended. */
  ENDED = 0,
  /** The YouTube player is currently playing. */
  PLAYING = 1,
  /** The YouTube player is paused. */
  PAUSED = 2,
  /** The YouTube player is buffering. */
  BUFFERING = 3,
  /** The YouTube player is cued. */
  CUED = 5
}

enum BLENDING:ubyte {
  /** Multiplies the colors of overlapping elements. */
  MULTIPLY = 11,
  /** Screens the colors of overlapping elements. */
  SCREEN = 12,
  /** Overlays the colors of overlapping elements. */
  OVERLAY = 13,
  /** Darkens the colors of overlapping elements. */
  DARKEN = 14,
  /** Lightens the colors of overlapping elements. */
  LIGHTEN = 15,
  /** Calculates the difference between the colors of overlapping elements. */
  DIFFERENCE = 16,
  /** Calculates the exclusion of the colors of overlapping elements. */
  EXCLUSION = 17
}

enum GRID_DISPLAY_TYPE:ubyte {
  /** Displays the grid as lines. */
  LINES = 10,
  /** Displays the grid as dots. */
  DOTS = 11,
  /** Displays the grid as crosses. */
  CROSSES = 12,
  /** Displays the grid adaptively based on zoom level. */
  ADAPTIVE = 13
}

enum GRID_TYPE:ubyte {
  /** A rectangular grid. */
  RECTANGULAR = 10,
  /** An isometric grid. */
  ISOMETRIC = 11,
  /** A polar grid. */
  POLAR = 12,
  /** A triangular grid. */
  TRIANGULAR = 13,
  /** A custom grid. */
  CUSTOM = 14
}

enum OBJECT_SNAP_MODE:ubyte {
  /** Snaps to the endpoint of a line or arc. */
  ENDPOINT = 10,
  /** Snaps to the midpoint of a line or arc. */
  MIDPOINT = 11,
  /** Snaps to the center of a circle, arc, or ellipse. */
  CENTER = 12,
  /** Snaps to quadrant points of circles, arcs, or ellipses. */
  QUADRANT = 13,
  /** Snaps to the intersection of two objects. */
  INTERSECTION = 14,
  /** Snaps to an imaginary extension line of an object. */
  EXTENSION = 15,
  /** Snaps to a point perpendicular to another object. */
  PERPENDICULAR = 16,
  /** Snaps to a tangent point on a circle or arc. */
  TANGENT = 17,
  /** Snaps to the nearest point on an object. */
  NEAREST = 18,
  /** Snaps to a point object (node). */
  NODE = 19,
  /** Snaps to the insertion point of a block or text. */
  INSERT = 20,
  /** Snaps to a point parallel to another object. */
  PARALLEL = 21,
  /** Snaps to the apparent intersection of two objects that do not actually intersect in 3D space. */
  APPARENT = 22,
  /** Snaps from a reference point. */
  FROM = 23,
  /** Filters snap points by X, Y, or Z coordinates. */
  POINT_FILTER = 24,
  /** Snaps to a temporary tracking point. */
  TEMPORARY = 25,
  /** Snaps to a point midway between two selected points. */
  BETWEEN_TWO_POINTS = 26,
  /** Snaps to a point directly on a curve. */
  POINT_ON_CURVE = 27,
  /** Snaps to the geometric center of an object. */
  GEOMETRIC = 28
}

enum SNAP_MODE:ubyte {
  /** Running object snap, continuously active. */
  RUNNING = 10,
  /** Single object snap, active for one selection only. */
  SINGLE = 11
}

enum SNAP_OVERRIDE_BEHAVIOR:ubyte {
  /** Disables all snapping. */
  DISABLE = 10,
  /** Forces snapping to the grid. */
  FORCE_GRID = 11,
  /** Forces snapping to objects. */
  FORCE_OBJECT = 12
}

enum SNAP_MARKER_SHAPE:ubyte {
  /** Displays the snap marker as a square. */
  SQUARE = 10,
  /** Displays the snap marker as a circle. */
  CIRCLE = 11,
  /** Displays the snap marker as a triangle. */
  TRIANGLE = 12,
  /** Displays the snap marker as an 'X'. */
  X = 13
}

enum TABLE_CELL_ALIGNMENT:ubyte {
  /** Aligns content to the top-left of the cell. */
  TOP_LEFT = 10,
  /** Aligns content to the top-center of the cell. */
  TOP_CENTER = 11,
  /** Aligns content to the top-right of the cell. */
  TOP_RIGHT = 12,
  /** Aligns content to the middle-left of the cell. */
  MIDDLE_LEFT = 13,
  /** Aligns content to the middle-center of the cell. */
  MIDDLE_CENTER = 14,
  /** Aligns content to the middle-right of the cell. */
  MIDDLE_RIGHT = 15,
  /** Aligns content to the bottom-left of the cell. */
  BOTTOM_LEFT = 16,
  /** Aligns content to the bottom-center of the cell. */
  BOTTOM_CENTER = 17,
  /** Aligns content to the bottom-right of the cell. */
  BOTTOM_RIGHT = 18
}

enum TABLE_FLOW_DIRECTION:ubyte {
  /** New rows are added downwards. */
  DOWN = 10,
  /** New rows are added upwards. */
  UP = 11
}

enum TOLERANCE_DISPLAY:ubyte {
  /** No tolerance displayed. */
  NONE = 10,
  /** Displays symmetrical tolerance (e.g., ±0.05). */
  SYMMETRICAL = 11,
  /** Displays deviation tolerance (e.g., +0.1/-0.05). */
  DEVIATION = 12,
  /** Displays upper and lower limits directly. */
  LIMITS = 13,
  /** Displays a basic, boxed dimension. */
  BASIC = 14
}

enum DIMENSION_TYPE:ubyte {
  /** A horizontal or vertical linear dimension. */
  LINEAR = 10,
  /** A linear dimension aligned with two points. */
  ALIGNED = 11,
  /** An angular dimension. */
  ANGULAR = 12,
  /** Measures the length of an arc. */
  ARC_LENGTH = 13,
  /** A radial dimension for circles or arcs. */
  RADIUS = 14,
  /** A diameter dimension for circles or arcs. */
  DIAMETER = 15,
  /** A center mark for circles or arcs. */
  CENTER_MARK = 16,
  /** A linear dimension rotated at a specific angle. */
  ROTATED = 17,
  /** Measures spacing between objects. */
  SPACING = 18,
  /** Continues a dimension from a previous linear dimension. */
  CONTINUE = 19,
  /** Creates dimensions from a common baseline. */
  BASELINE = 20,
  /** A linear dimension with a jogged dimension line. */
  JOGGED_LINEAR = 21,
  /** An ordinate dimension (measures X or Y coordinate from an origin). */
  ORDINATE = 22
}

enum MARK_ELLIPSE_CENTER:ubyte {
  /** Marks the center with a cross. */
  MARK = 10,
  /** Marks the center with intersecting lines. */
  LINE = 11
}

enum TEXT_FLOW_DIRECTION:ubyte {
  /** Text flows from left to right. */
  LEFT_TO_RIGHT = 10,
  /** Text flows from right to left. */
  RIGHT_TO_LEFT = 11,
  /** Text flows from top to bottom. */
  TOP_TO_BOTTOM = 12,
  /** Text flows from bottom to top. */
  BOTTOM_TO_TOP = 13
}

enum COLUMN_TYPE:ubyte {
  /** No columns, single column layout. */
  NO_COLUMNS = 10,
  /** Fixed number of columns with defined widths. */
  STATIC_COLUMNS = 11,
  /** Text flows automatically between columns based on height. */
  DYNAMIC_COLUMNS = 12
}

enum GDT_SYMBOL:ubyte {
  /** Geometric characteristic symbol for straightness. "⏤" */
  STRAIGHTNESS = 10,
  /** Geometric characteristic symbol for flatness. "⏥"  */
  FLATNESS = 11,
  /** Geometric characteristic symbol for circularity. "○" */
  CIRCULARITY = 12,
  /** Geometric characteristic symbol for cylindricity. "⌭"  */
  CYLINDRICITY = 13,
  
  /** Geometric characteristic symbol for perpendicularity. "⊥" */
  PERPENDICULARITY = 14,
  /** Geometric characteristic symbol for angularity. "∠" */
  ANGULARITY = 15,
  /** Geometric characteristic symbol for parallelism. "∥" */
  PARALLELISM = 16,
  
  /** Geometric characteristic symbol for position. "⌖" */
  POSITION = 17,
  /** Geometric characteristic symbol for true position (alternative name for POSITION). "⌖" */
  TRUE_POSITION = 18,
  /** Geometric characteristic symbol for concentricity. "◎" */
  CONCENTRICITY = 19,
  /** Geometric characteristic symbol for coaxiality. "◯" */
  COAXIALITY = 20,
  /** Geometric characteristic symbol for symmetry. "⌯" */
  SYMMETRY = 21,
  
  /** Geometric characteristic symbol for circular runout. "↗" */
  CIRCULAR_RUNOUT = 22,
  /** Geometric characteristic symbol for total runout. "↗↗" */
  TOTAL_RUNOUT = 23,
  
  /** Geometric characteristic symbol for profile of a line. "⌒" */
  PROFILE_OF_LINE = 24,
  /** Geometric characteristic symbol for profile of a surface. "⌓" */
  PROFILE_OF_SURFACE = 25,
  
  /** Geometric characteristic symbol for statistical tolerance. "◊" */
  STATISTICAL = 26,
  /** Geometric characteristic symbol for all around. "⭕" */
  ALL_AROUND = 27,
  /** Geometric characteristic symbol for all over. "🔄" */
  ALL_OVER = 28,
  /** Geometric characteristic symbol for between. "↔" */
  BETWEEN = 29
}

enum MATERIAL_CONDITION:ubyte {
  /** Maximum Material Condition (MMC). "Ⓜ" */
  MAXIMUM = 10,
  /** Least Material Condition (LMC). "Ⓛ" */
  LEAST = 11,
  /** Regardless of Feature Size (RFS). "Ⓢ" */
  REGARDLESS = 12
}

enum FEATURE_MODIFIER:ubyte {
  /** Free State modifier. "Ⓕ" */
  FREE_STATE = 10,
  /** Tangent Plane modifier. "Ⓣ" */
  TANGENT_PLANE = 11,
  /** Projected Tolerance Zone modifier. "Ⓟ" */
  PROJECTED_TOLERANCE_ZONE = 12,
  /** Diameter symbol. "⌀" */
  DIAMETER = 13,
  /** Spherical diameter symbol. "S⌀" */
  SPHERICAL_DIAMETER = 14,
  /** Radius symbol. "R" */
  RADIUS = 15,
  /** Spherical radius symbol. "SR" */ 
  SPHERICAL_RADIUS = 16,
  /** Controlled Radius symbol. "CR" */ 
  CONTROLLED_RADIUS = 17,
  /** Square symbol. "□" */
  SQUARE = 18,
  /** Translation modifier for position. "⧗" */
  TRANSLATION = 19,
  /** All Around modifier. "⭕" */
  ALL_AROUND = 20,
  /** All Over modifier. "🔄" */
  ALL_OVER = 21,
  /** Statistical modifier. "◊" */
  STATISTICAL = 22,
  /** Continuous Feature modifier. "CF" */
  CONTINUOUS_FEATURE = 23,
  /** Unequally Disposed Tolerance modifier. "UEQ" */
  UNEQUALLY_DISPOSED = 24
}

enum TOLERANCE_ZONE_TYPE:ubyte {
  /** Cylindrical tolerance zone. */
  CYLINDRICAL = 10,
  /** Spherical tolerance zone. */
  SPHERICAL = 11,
  /** Rectangular tolerance zone. */
  RECTANGULAR = 12,
  /** Linear tolerance zone. */
  LINEAR = 13,
  /** Circular tolerance zone. */
  CIRCULAR = 14
}

enum DATUM_TARGET_TYPE:ubyte {
  /** Datum target is a point. */
  POINT = 10,
  /** Datum target is a line. */
  LINE = 11,
  /** Datum target is an area. */
  AREA = 12,
  /** Datum target is movable. */
  MOVABLE = 13
}

enum TOLERANCE_TYPE:ubyte {
  /** Single tolerance specification. */
  SINGLE = 10,
  /** Composite tolerance (multiple rows, related). */
  COMPOSITE = 11,
  /** Multiple single-segment tolerances (independent). */
  MULTIPLE = 12
}

enum DATUM_BRACKET_STYLE:ubyte {
  /** Square bracket style for datum references. */
  SQUARE = 10,
  /** Round bracket style for datum references. */
  ROUND = 11,
  /** No bracket style for datum references. */
  NONE = 12
}

enum DIMENSION_UNITS_FORMAT:ubyte {
  /** Decimal format for dimension units. */
  DECIMAL = 10,
  /** Engineering format (feet and decimal inches). */
  ENGINEERING = 11,
  /** Architectural format (feet and fractional inches). */
  ARCHITECTURAL = 12,
  /** Fractional inches format. */
  FRACTIONAL = 13,
  /** Scientific format. */
  SCIENTIFIC = 14
}

enum DIMENSION_FIT_RULE:ubyte {
  /** Moves text and arrows outside if they don't fit. */
  TEXT_AND_ARROWS = 10,
  /** Moves arrows only outside if they don't fit. */
  ARROWS_ONLY = 11,
  /** Moves text only outside if it doesn't fit. */
  TEXT_ONLY = 12,
  /** Automatically determines best fit for text and arrows. */
  BEST_FIT = 13
}

enum DIMENSION_TEXT_PLACEMENT:ubyte {
  /** Places text beside the dimension line. */
  BESIDE_LINE = 10,
  /** Places text over the dimension line. */
  OVER_LINE = 11,
  /** Places text over the dimension line with a leader. */
  OVER_LINE_WITH_LEADER = 12
}

enum ANGULAR_UNITS_FORMAT:ubyte {
  /** Angular units in decimal degrees. */
  DECIMAL_DEGREES = 10,
  /** Angular units in degrees, minutes, and seconds. */
  DEGREES_MINUTES_SECONDS = 11,
  /** Angular units in grads. */
  GRADS = 12,
  /** Angular units in radians. */
  RADIANS = 13,
  /** Angular units in surveyor's units. */
  SURVEYOR = 14
}

enum UNIT_SYSTEM:ubyte {
  /** Metric unit system. */
  METRIC = 10,
  /** Imperial unit system. */
  IMPERIAL = 11
}

enum DECIMAL_SEPARATOR:ubyte {
  /** Uses a dot as the decimal separator. "." */
  DOT = 10,
  /** Uses a comma as the decimal separator. "," */
  COMMA = 11
}

enum VIEWPORT_SHADE_PLOT:ubyte {
  /** Plots the viewport as displayed on screen. */
  AS_DISPLAYED = 10,
  /** Plots the viewport in wireframe mode. */
  WIREFRAME = 11,
  /** Plots the viewport with hidden lines removed. */
  HIDDEN = 12,
  /** Plots the viewport as a rendered image. */
  RENDERED = 13
}

enum HATCH_STYLE:ubyte {
  /** Normal hatch, fills closed boundaries. */
  NORMAL = 10,
  /** Outermost boundary only, ignores internal islands. */
  OUTER = 11,
  /** Ignores internal structures when hatching. */
  IGNORE = 12
}

enum IMAGE_STATUS:ubyte {
  /** Image is pending upload/saving. */
  PENDING = 10,
  /** Image is saved and available. */
  SAVED = 11,
  /** An error occurred with the image. */
  ERROR = 12
}

enum BLOCK_ATTACHMENT:ubyte {
  /** Attaches the block instance to the center of the block's extents. */
  CENTER_EXTENTS = 10,
  /** Attaches the block instance to its insertion point. */
  INSERTION_POINT = 11
}

enum AXIS:ubyte {
  /** X-axis. */
  X = 10,
  /** Y-axis. */
  Y = 20,
  /** Z-axis. */
  Z = 30
}

enum PRUNING_LEVEL:ubyte {
  /** Conservative pruning, retains more history. */
  CONSERVATIVE = 10,
  /** Balanced pruning, optimizes between history and size. */
  BALANCED = 20,
  /** Aggressive pruning, retains less history for smaller size. */
  AGGRESSIVE = 30
}

enum PARAMETRIC_SOURCE_TYPE:ubyte {
  /** Parametric element defined by executable code. */
  CODE = 10,
  /** Parametric element defined by a file. */
  FILE = 11
}

enum LEADER_CONTENT_TYPE:ubyte {
  /** Leader content is text. */
  TEXT = 10,
  /** Leader content is a block. */
  BLOCK = 11
}

/** Defines the types of boolean operations that can be performed. */
enum BOOLEAN_OPERATION:ubyte {
  /** Combines all child shapes into a single shape. */
  UNION = 10,
  /** Subtracts all subsequent shapes from the first shape. Order is critical. */
  SUBTRACT = 11,
  /** Creates a shape from the overlapping areas of all child shapes. */
  INTERSECT = 12,
  /** Creates a shape from the non-overlapping areas (XOR). */
  EXCLUDE = 13,
}

/**
 * =============================================================================
 * UTILITY & GEOMETRY TYPES
 * =============================================================================
 */

/** A generic key-value pair for string dictionaries. */
table DictionaryEntry {
  key: string (key);
  value: string;
}

/** A generic key-value pair for more complex structures like DucBlock attribute values. */
table StringValueEntry {
  key: string (key);
  value: string;
}

/** A generic identifier used across various components like Standards, Layers, etc. */
table Identifier {
  /** Unique identifier for this standard */
  id: string (key);
  /** Human-readable name */
  name: string;
  /** Description of the standard */
  description: string;
}

/** A high-precision 2D point in the World Coordinate System. */
struct GeometricPoint {
  x: double;
  y: double;
}

/** Defines a User Coordinate System (UCS) with an origin and rotation. */
table DucUcs {
  /**
   * The origin point of the UCS in World Coordinate System (WCS) coordinates.
   * This defines the (0,0) point of the new local system.
   */
  origin: GeometricPoint;
  /**
   * The rotation angle of the UCS's X-axis, measured in radians,
   * relative to the World Coordinate System's X-axis.
   * An angle of 0 means the UCS is aligned with the WCS.
   */
  angle: double; // Radian
}

/** Defines a view with scroll, zoom, and center point. */
table DucView {
  scroll_x: double;
  scroll_y: double;
  zoom: double;
  twist_angle: double; // Radian
  /** The specific spot on that plane that you want to be in the middle of your screen when this view is active */
  center_point: DucPoint;
  scope: string; // Scope
}

/** Represents margins for layouts and cells. */
table Margins {
  top: double;
  right: double;
  bottom: double;
  left: double;
}

/**
 * =============================================================================
 * STYLING & CONTENT
 * =============================================================================
 */

table TilingProperties {
  size_in_percent: float;
  angle: double; // Radian
  spacing: double = null;
  offset_x: double = null;
  offset_y: double = null;
}

table HatchPatternLine {
  /** Line angle in radians */
  angle: double; // Radian
  /** Line origin point */
  origin: DucPoint;
  /** Offset between parallel lines [x, y] */
  offset: [double]; // [x, y]
  /** Dash pattern (empty array = solid line) */
  dash_pattern: [double];
}

table CustomHatchPattern {
  /** Pattern name */
  name: string;
  /** Pattern description */
  description: string;
  /** Pattern line definitions */
  lines: [HatchPatternLine];
}

table DucHatchStyle {
  /** Default hatch style */
  hatch_style: HATCH_STYLE = null;
  /** Pattern name (for predefined) or reference to custom pattern */
  pattern_name: string;
  /** Pattern scale factor */
  pattern_scale: float;
  /** Pattern rotation angle */
  pattern_angle: double; // Radian
  /** Pattern origin point */
  pattern_origin: DucPoint;
  /** Double pattern (second pattern at 90 degrees) */
  pattern_double: bool;
  custom_pattern: CustomHatchPattern;
}

table DucImageFilter {
  brightness: float; // Percentage
  contrast: float; // Percentage
}

table ElementContentBase {
  preference: ELEMENT_CONTENT_PREFERENCE = null;
  /** Can be a color, gradient, image, DucBlock, (fileId or url), frame element's content `@el/${elementId}` */
  src: string;
  visible: bool;
  opacity: double;
  
  tiling: TilingProperties;
  hatch: DucHatchStyle;
  image_filter: DucImageFilter;
}

table StrokeStyle {
  preference: STROKE_PREFERENCE = null;
  /**
   * The cap of the stroke
   */
  cap: STROKE_CAP = null;
  /**
   * The join of the stroke
   */
  join: STROKE_JOIN = null;
  /**
   * The dash of the stroke
   */
  dash: [double];
  /** Override the dash line into a custom shape */
  dash_line_override: string; // DucBlockInstance ID
  /**
   * The cap of the dash
   */
  dash_cap: STROKE_CAP = null;
  /**
   * The miter limit of the stroke
   */
  miter_limit: double = null;
}

table StrokeSides {
  preference: STROKE_SIDE_PREFERENCE = null;
  /** [0, 1] for x and y || [0, 1, 2, 3] for top, bottom, left, right */
  values: [double]; // [0,1] or [0,1,2,3]
}

table ElementStroke {
  content: ElementContentBase;
  width: double;
  style: StrokeStyle;
  placement: STROKE_PLACEMENT = null;
  stroke_sides: StrokeSides;
}

table ElementBackground {
  content: ElementContentBase;
}

/** Base style properties shared by many elements. */
table _DucElementStylesBase {
  roundness: double;
  blending: BLENDING = null;
  background: [ElementBackground];
  stroke: [ElementStroke];
  opacity: double;
}


/**
 * =============================================================================
 * BASE ELEMENT & COMMON ELEMENT COMPONENTS
 * =============================================================================
 */

table BoundElement {
  id: string;
  type: string; // Represents DucElementType
}

/** The foundational table for all scene elements, containing common properties. */
table _DucElementBase {
  id: string (key);
  styles: _DucElementStylesBase;

  x: double;
  y: double;
  width: double;
  height: double;
  angle: double; // Radian
  
  /**
   * The scope where the element is currently
   * mm, cm, m, in, ft, yd, mi, etc...
   */
  scope: string; // Scope
  label: string;
  description: string;
  is_visible: bool;

  /**
   * Random integer used to seed shape generation
   * doesn't differ across renders.
   */
  seed: int;
  /**
   * Integer that is sequentially incremented on each change. Used to reconcile
   * elements during collaboration or when saving to server.
   */
  version: int;
  /**
   * Random integer that is regenerated on each change.
   * Used for deterministic reconciliation of updates during collaboration,
   * in case the versions (see above) are identical.
   */
  version_nonce: int;
  /** Epoch timestamp (ms) of last element update */
  updated: long; // Epoch timestamp (ms)
  /**
   * String in a fractional form defined by https://github.com/rocicorp/fractional-indexing.
   * Used for ordering in multiplayer scenarios, such as during reconciliation or undo / redo.
   * Always kept in sync with the array order by `syncMovedIndices` and `syncInvalidIndices`.
   * Could be null, i.e. for new elements which were not yet assigned to the scene.
   */
  index: string; // FractionalIndex

  /** Whether the element is a plot (i.e. visible on plotting) */
  is_plot: bool;
  /** Whether the element is annotative (scales with DucViewport) */
  is_annotative: bool;
  /** Whether the element is deleted */
  is_deleted: bool;
  
  /**
   * List of groups the element belongs to.
   * Ordered from deepest to shallowest.
   */
  group_ids: [string];
  /**
   * List of regions the element belongs.
   * Used to define boolean operations between elements.
   * Ordered from deepest to shallowest.
   */
  region_ids: [string];
  /** The layer the element belongs to */
  layer_id: string;
  /** The frame the element belongs to */
  frame_id: string;
  
  /**
   * other elements that are bound to this element
   * if we mutate this element, the bound elements will be updated automatically
   * for transform properties like x, y, angle, etc.
   */
  bound_elements: [BoundElement];
  /**
   * z-index of the element in the scene
   * Explicit stacking order, higher values are rendered on top
   */
  z_index: float;

  link: string;
  locked: bool;
  
  /** Contains a JSON string of custom key-value data. */
  custom_data: string;
}

table DucPoint {
  x: double;
  y: double;
  /** Only meaningful if the point is referenced in exactly two lines */
  mirroring: BEZIER_MIRRORING = null;
}

table DucHead {
  type: LINE_HEAD = null;
  /** If the head is a block, this is the id of the block */
  block_id: string;
  size: double;
}

table PointBindingPoint {
  /** The index of the target point within the element. */
  index: int;
  /**
   * The offset from the point. Ranges from -1 to 1: 0 corresponds to the actual point.
   * -1 and 1 represent the percentage of the distance between the point at `index`
   * and the previous or next point in the points array, respectively.
   */
  offset: double;
}

table DucPointBinding {
  element_id: string;
  /**
   * Determines where along the edge of the bound element the arrow endpoint should attach.
   * This value ranges from -1 to 1: -1 -> Attaches to the far left/top; 0 -> Attaches to the center; 1 -> Attaches to the far right/bottom.
   * Focus ensures that the arrow dynamically adjusts as the bound element moves, resizes, or rotates.
   */
  focus: float;
  /** The gap distance between the bound element and the binding element. */
  gap: double;
  /**
   * Represents a fixed point inside the bound element, defined as a normalized coordinate.
   * This value is an array [x, y], where: x (0.0 - 1.0) -> Horizontal position; y (0.0 - 1.0) -> Vertical position.
   * FixedPoint ensures the arrow stays pinned to a precise location inside the element.
   * If null, focus is used. If set, it overrides focus.
   */
  fixed_point: GeometricPoint;
  point: PointBindingPoint;
  /**
   * The head of the line.
   * Reference: https://www.figma.com/design/5rYcUlscflBabQ9di2iFJ5/duc-Architecture?node-id=313-43&t=gNEFgevk9KZ3oAun-1
   */
  head: DucHead;
}

table DucLineReference {
  /** index of the point in the points array */
  index: int;
  /** Bezier handle of the point on the line segment */
  handle: GeometricPoint;
}

table DucLine {
  start: DucLineReference;
  end: DucLineReference;
}

table DucPath {
  line_indices: [int];
  /** Override the background and stroke from the base in case is different than null */
  background: ElementBackground;
  /** Override the background and stroke from the base in case is different than null */
  stroke: ElementStroke;
}

/** The base for linear elements like lines and arrows. */
table _DucLinearElementBase {
  base: _DucElementBase;
  points: [DucPoint];
  lines: [DucLine];
  path_overrides: [DucPath];
  last_committed_point: DucPoint;
  start_binding: DucPointBinding;
  end_binding: DucPointBinding;
}

table DucStackLikeStyles {
  opacity: double;
  labeling_color: string;
}

table _DucStackBase {
  label: string;
  description: string;
  is_collapsed: bool;
  is_plot: bool;
  is_visible: bool;
  locked: bool;
  styles: DucStackLikeStyles;
}

table _DucStackElementBase {
  base: _DucElementBase;
  stack_base: _DucStackBase;
  clip: bool;
  label_visible: bool;
  /** Everything inside the stack will use this standard */
  standard_override: Standard;
}


/**
 * =============================================================================
 * ELEMENT-SPECIFIC STYLES
 * =============================================================================
 */

table LineSpacing {
  /**
   * The numerical value for the line spacing. Its interpretation depends on the `type` property.
   * Can also be interpreted as ScaleFactor
   */
  value: double; // Can also be interpreted as ScaleFactor
  /**
   * Determines how the line spacing factor is applied.
   * - `AT_LEAST`: The line spacing is the larger of the `value` or the tallest character's natural height.
   * This ensures text doesn't overlap but respects a minimum spacing.
   * - `EXACTLY`: Forces the line spacing to the specified `value`, even if characters
   * (especially tall ones like ascenders/descenders or special symbols) overlap.
   * Useful for precise layout control where overlapping might be acceptable or handled externally.
   * - `MULTIPLE`: The base line height (often derived from the font's intrinsic metrics and font size)
   * is multiplied by the `value` (e.g., a `value` of 1.5 would mean 150% of the base line height).
   * This is very common for relative spacing.
   */
  type: LINE_SPACING_TYPE = null;
}

table DucTextStyle {
  base_style: _DucElementStylesBase;
  /**
   * Whether the text is left-to-right or right-to-left
   */
  is_ltr: bool;
  /** The primary font family to use for the text */
  font_family: string;
  /**
   * Fallback font family for broader compatibility across all systems and languages
   * Useful for emojis, non-latin characters, etc.
   */
  big_font_family: string;
  
  /** Horizontal alignment of the text within its bounding box */
  text_align: TEXT_ALIGN = null;
  /** Vertical alignment of the text within its bounding box */
  vertical_align: VERTICAL_ALIGN = null;
  
  /**
   * Unitless line height multiplier (follows W3C standard).
   * Actual line height in drawing units = fontSize × lineHeight
   * Use `getLineHeightInPx` helper for pixel calculations.
   * @example 1.2 means 20% extra space between lines
   */
  line_height: float; // Unitless multiplier
  /** Defines the line spacing properties for text. */
  line_spacing: LineSpacing;
  
  /**
   * Italic angle in radians for oblique text rendering
   * Positive values slant right, negative values slant left
   */
  oblique_angle: double; // Radian
  /**
   * Text height in drawing units (primary size parameter)
   * This determines the height of capital letters
   */
  font_size: double;
  /** Desired height on printed page (for annotative text) */
  paper_text_height: double;
  /**
   * Character width as a ratio of text height
   * Controls horizontal spacing and character proportions
   * @example 0.7 means each character is 70% as wide as the text is tall
   */
  width_factor: float; // ScaleFactor
  
  /** Render upside down */
  is_upside_down: bool;
  /** Render backwards/mirrored */
  is_backwards: bool;
}

table DucTableCellStyle {
  base_style: _DucElementStylesBase;
  /** The text style for content within the cell */
  text_style: DucTextStyle;
  /** Margin space inside the cell, between the content and the border */
  margins: Margins;
  /** The alignment of content within the cell */
  alignment: TABLE_CELL_ALIGNMENT = null;
}

table DucTableStyle {
  base_style: _DucElementStylesBase;
  /** The direction in which new rows are added */
  flow_direction: TABLE_FLOW_DIRECTION = null;
  /** Default style for the header row(s) */
  header_row_style: DucTableCellStyle;
  /** Default style for the data row(s) */
  data_row_style: DucTableCellStyle;
  /** Default style for the data column(s) */
  data_column_style: DucTableCellStyle;
}

table DucLeaderStyle {
  base_style: _DucElementStylesBase;
  /**
   * Override the heads of the leader
   * The tuple represents [startHead, endHead]
   */
  heads_override: [DucHead]; // [start, end]
  /** The "dogleg" or "landing" segment that connects the leader line to the content. */
  dogleg: double;
  /** Default styling for text content. */
  text_style: DucTextStyle;
  /**
   * How the text content attaches to the leader's landing line.
   * 'top': Text is below the line. 'middle': Text is centered on the line.
   */
  text_attachment: VERTICAL_ALIGN = null;
  /** How the block content attaches to the leader's landing line. */
  block_attachment: BLOCK_ATTACHMENT = null;
}

table DimensionToleranceStyle {
  /** Whether to display tolerances by default */
  enabled: bool;
  /** Default display method (e.g., Symmetrical, Limits) */
  display_method: TOLERANCE_DISPLAY = null;
  /** Default upper tolerance value */
  upper_value: double;
  /** Default lower tolerance value */
  lower_value: double;
  /** Decimal places for tolerance values */
  precision: int;
  /** The text style for the tolerance values, inheriting from the main textStyle */
  text_style: DucTextStyle;
}

table DimensionFitStyle {
  /** Determines what to move when text and arrows don't fit between extension lines */
  rule: DIMENSION_FIT_RULE = null;
  /** If text is moved, determines its placement relative to the dimension line */
  text_placement: DIMENSION_TEXT_PLACEMENT = null;
  /** Forces text to always be placed between extension lines */
  force_text_inside: bool;
}

table DimensionLineStyle {
  stroke: ElementStroke;
  /** Gap between the dimension line and the text when text is placed inside */
  text_gap: double;
}

table DimensionExtLineStyle {
  stroke: ElementStroke;
  /** Distance to extend the line beyond the dimension line */
  overshoot: double;
  /** Gap between the feature origin and the start of the extension line */
  offset: double;
}

table DimensionSymbolStyle {
  /**
   * Override the arrow heads for each dimension line
   * The tuple represents [startHead, endHead]
   */
  heads_override: [DucHead]; // [start, end]
  /** Center mark configuration for radial/diameter dimensions */
  center_mark_type: MARK_ELLIPSE_CENTER = null;
  center_mark_size: double;
}

table DucDimensionStyle {
  /** Style for the main dimension line and its arrowheads */
  dim_line: DimensionLineStyle;
  /** Style for the extension lines that connect the dimension to the feature */
  ext_line: DimensionExtLineStyle;
  /** The text style used for the dimension's measurement and annotations */
  text_style: DucTextStyle;
  /** Configuration for arrowheads and other symbols */
  symbols: DimensionSymbolStyle;
  /** Default settings for dimensional tolerances */
  tolerance: DimensionToleranceStyle;
  /** Rules for how to arrange text and arrows when space is limited */
  fit: DimensionFitStyle;
}

table FCFLayoutStyle {
  /** Padding between the content and the outer frame border */
  padding: double;
  /** Spacing between segments (vertical lines) in a row */
  segment_spacing: double;
  /** Spacing between rows in a composite frame */
  row_spacing: double;
}

table FCFSymbolStyle {
  /** Scale factor for symbols relative to the text height */
  scale: float;
}

table FCFDatumStyle {
  /** The style of bracket to draw around datum letters */
  bracket_style: DATUM_BRACKET_STYLE = null;
}

table DucFeatureControlFrameStyle {
  base_style: _DucElementStylesBase;
  /** The base text style for numbers and letters within the frame */
  text_style: DucTextStyle;
  /** Layout and spacing properties */
  layout: FCFLayoutStyle;
  /** Configuration for GD&T symbols */
  symbols: FCFSymbolStyle;
  /** Styling for datum references */
  datum_style: FCFDatumStyle;
}

table ParagraphFormatting {
  /** Indentation for the first line of each paragraph */
  first_line_indent: double;
  /** Indentation for all lines except the first (hanging indent) */
  hanging_indent: double;
  /** Indentation from the left edge of the element's bounding box */
  left_indent: double;
  /** Indentation from the right edge of the element's bounding box */
  right_indent: double;
  /** Extra spacing added before each paragraph */
  space_before: double;
  /** Extra spacing added after each paragraph */
  space_after: double;
  /** A list of tab stop positions from the left indent */
  tab_stops: [double];
}

table StackFormatProperties {
  /** Scale of the upper text relative to the main font size */
  upper_scale: double; // e.g., 0.7
  /** Scale of the lower text relative to the main font size */
  lower_scale: double; // e.g., 0.7
  /** Alignment of stacked text (e.g., center, decimal) */
  alignment: STACKED_TEXT_ALIGN = null;
}

table StackFormat {
  /** Enable automatic stacking of text around specified characters */
  auto_stack: bool;
  /** Characters that trigger stacking (e.g., "/", "#", "^") */
  stack_chars: [string];
  /** Properties for how stacked text is rendered */
  properties: StackFormatProperties;
}

table DucDocStyle {
  text_style: DucTextStyle;
  paragraph: ParagraphFormatting;
  stack_format: StackFormat;
}

table DucViewportStyle {
  base_style: _DucElementStylesBase;
  scale_indicator_visible: bool;
}

table DucPlotStyle {
  base_style: _DucElementStylesBase;
}

table DucXRayStyle {
  base_style: _DucElementStylesBase;
  /** The color of the x-ray */
  color: string;
}

/**
 * =============================================================================
 * ELEMENT DEFINITIONS
 * =============================================================================
 */

table DucRectangleElement {
  base: _DucElementBase;
}

table DucPolygonElement {
  base: _DucElementBase;
  /** number of sides of the polygon */
  sides: int;
}

table DucEllipseElement {
  base: _DucElementBase;
  ratio: float; // Percentage
  start_angle: double; // Radian
  end_angle: double; // Radian
  show_aux_crosshair: bool;
}

table DucEmbeddableElement {
  base: _DucElementBase;
}

table DucPdfElement {
  base: _DucElementBase;
  file_id: string; // ExternalFileId
}

table DucMermaidElement {
  base: _DucElementBase;
  source: string;
  /**
   * if not provided, the theme will be the same as the document's theme, or default to 'default'
   * we decided to go with a string type because of the unpredictably of having different themes
   */
  theme: string;
  /** optional cached SVG string */
  svg_path: string;
}

table DucTableColumn {
  id: string (key);
  width: double;
  /** Style overrides for this column */
  style_overrides: DucTableCellStyle;
}

table DucTableRow {
  id: string (key);
  height: double;
  /** Style overrides for this row */
  style_overrides: DucTableCellStyle;
}

table DucTableCellSpan {
  columns: int;
  rows: int;
}

table DucTableCell {
  row_id: string;
  column_id: string;
  /**
   * The content of the cell, stored as a Markdown string. This allows for rich text
   * within cells without complicating the table's main data structure.
   */
  data: string; // Markdown content
  /**
   * Defines if and how this cell merges with adjacent cells.
   * A span of 1 means no merging.
   * The root cell of a merge (top-left) holds the content and span data.
   * Other cells covered by the span are effectively hidden.
   */
  span: DucTableCellSpan;
  /** Whether the content of this cell can be edited */
  locked: bool;
  /**
   * Style overrides for this specific cell.
   * Any property set here will take precedence over row, column, and table styles.
   */
  style_overrides: DucTableCellStyle;
}

table DucTableColumnEntry {
  key: string (key);
  value: DucTableColumn;
}

table DucTableRowEntry {
  key: string (key);
  value: DucTableRow;
}

table DucTableCellEntry {
  key: string (key); // "rowId:columnId"
  value: DucTableCell;
}

table DucTableAutoSize {
  columns: bool;
  rows: bool;
}

table DucTableElement {
  base: _DucElementBase;
  style: DucTableStyle;
  
  /** An ordered list of column IDs, defining the horizontal layout */
  column_order: [string];
  /** An ordered list of row IDs, defining the vertical layout */
  row_order: [string];
  
  /** A record of all column definitions, keyed by their ID */
  columns: [DucTableColumnEntry];
  /** A record of all row definitions, keyed by their ID */
  rows: [DucTableRowEntry];
  /**
   * A record of all cell data, keyed by a composite "rowId:columnId" string.
   * This flat structure is efficient for lookups and updates.
   */
  cells: [DucTableCellEntry];
  
  /** Number of top rows to be treated as headers, using the headerRowStyle */
  header_row_count: int;
  /** Whether table auto-sizes to content */
  auto_size: DucTableAutoSize;
}

table ImageCrop {
  x: double;
  y: double;
  width: double;
  height: double;
  natural_width: double;
  natural_height: double;
}

table DucImageElement {
  base: _DucElementBase;
  file_id: string;
  /** whether respective file is persisted */
  status: IMAGE_STATUS = null;
  /** X and Y scale factors <-1, 1>, used for image axis flipping */
  scale: [double]; // [x, y]
  /** whether an element is cropped */
  crop: ImageCrop;
  /** clipping boundary for the image */
  clipping_boundary: _DucLinearElementBase;
  filter: DucImageFilter;
}

/** Dynamic text field source types */
table DucTextDynamicElementSource {
  /** The unique ID of the source element. */
  element_id: string;
  /** The specific property to retrieve from the source element. */
  property: TEXT_FIELD_SOURCE_PROPERTY = null;
}

table DucTextDynamicDictionarySource {
  /** The key to look up in the global drawing dictionary. */
  key: string;
}

union DucTextDynamicSourceData {
  DucTextDynamicElementSource,
  DucTextDynamicDictionarySource
}

table DucTextDynamicSource {
  text_source_type: TEXT_FIELD_SOURCE_TYPE = null;
  source: DucTextDynamicSourceData;
}

table DucTextDynamicPart {
  /**
   * A unique key for this part, which matches the placeholder in the text string.
   * E.g., for a placeholder `{{PartNumber}}`, the tag would be "PartNumber".
   */
  tag: string;
  /** The source of the data for this dynamic part. */
  source: DucTextDynamicSource;
  /** Formatting rules for displaying the final value. */
  formatting: PrimaryUnits;
  /** The last known value, used as a fallback or for initial display. */
  cached_value: string;
}

table DucTextElement {
  base: _DucElementBase;
  style: DucTextStyle;
  /**
   * The display text, which can contain zero or more placeholders in the
   * format `{{tag}}`. Each tag corresponds to an object in the `dynamic` array.
   * Example: "Part: {{PN}} on Layer: {{LAYER}}"
   */
  text: string; // Markdown
  /**
   * An array of metadata objects that define the behavior of the placeholders
   * found in the `text` property. If this is empty, the text is treated
   * as purely static.
   */
  dynamic: [DucTextDynamicPart];
  /**
   * Text sizing behavior:
   * - `true`: Width adjusts to fit text content (single line or natural wrapping)
   * - `false`: Text wraps to fit within the element's fixed width
   */
  auto_resize: bool;
  /** The ID of an element that this text is contained within (e.g., for labels on shapes) */
  container_id: string;
  /** A non-rendered, original version of the text, e.g., before finishing writing the text */
  original_text: string;
}

table DucLinearElement {
  linear_base: _DucLinearElementBase;
  /**
   * If true, the element's shape will wipe out the content below the element
   */
  wipeout_below: bool;
}

table DucArrowElement {
  linear_base: _DucLinearElementBase;
  elbowed: bool;
}

table DucFreeDrawEnds {
  cap: bool;
  taper: float;
  easing: string;
}

table DucFreeDrawElement {
  base: _DucElementBase;
  points: [DucPoint];
  size: double;
  thinning: float; // Percentage
  smoothing: float; // Percentage
  streamline: float; // Percentage
  easing: string; // key that maps to an easing function
  start: DucFreeDrawEnds;
  end: DucFreeDrawEnds;
  pressures: [float];
  simulate_pressure: bool;
  last_committed_point: DucPoint;
  /** optional cached SVG string */
  svg_path: string;
}

table DucBlockAttributeDefinition {
  /** The unique identifier for this attribute within the block (e.g., "PART_NUMBER"). */
  tag: string;
  /** The prompt displayed to the user when inserting the block (e.g., "Enter the part number:"). */
  prompt: string;
  /** The default value for this attribute. */
  default_value: string;
  /** If true, the attribute's value is fixed and cannot be changed after insertion. */
  is_constant: bool;
}

table DucBlockAttributeDefinitionEntry {
  key: string (key);
  value: DucBlockAttributeDefinition;
}

table DucBlock {
  id: string (key);
  label: string;
  description: string;
  version: int;
  /** An array of all elements that constitute the block's geometry and annotations. */
  elements: [ElementWrapper];
  /**
   * A record of attribute definitions for this block, keyed by their tag.
   * This defines the "slots" for data that each instance can fill.
   */
  attribute_definitions: [DucBlockAttributeDefinitionEntry];
}

table DucBlockDuplicationArray {
  rows: int;
  cols: int;
  row_spacing: double;
  col_spacing: double;
}

table DucBlockInstanceElement {
  base: _DucElementBase;
  block_id: string;
  /**
   * Keys are the element ids of the block instance
   * Values are the element overrides
   */
  element_overrides: [StringValueEntry];
  /**
   * A record of the actual values for the attributes of this specific instance,
   * keyed by the attribute tag defined in the DucBlock.
   */
  attribute_values: [StringValueEntry];
  duplication_array: DucBlockDuplicationArray;
}

table DucFrameElement {
  stack_element_base: _DucStackElementBase;
}

table PlotLayout {
  /** Margins inset from the edge of the paper. */
  margins: Margins;
}

table DucPlotElement {
  stack_element_base: _DucStackElementBase;
  style: DucPlotStyle;
  /** The layout definition for this plot, including paper size and margins. */
  layout: PlotLayout;
}

table DucViewportElement {
  linear_base: _DucLinearElementBase;
  stack_base: _DucStackBase;
  style: DucViewportStyle;
  /** View configuration */
  view: DucView;
  /** Viewport scale settings */
  scale: float; // ViewportScale
  /** Shade plot setting */
  shade_plot: VIEWPORT_SHADE_PLOT = null;
  /** Frozen layers in this viewport */
  frozen_group_ids: [string];
  /** Everything inside the viewport will use this standard */
  standard_override: Standard;
}

table DucXRayElement {
  base: _DucElementBase;
  style: DucXRayStyle;
  origin: DucPoint;
  direction: DucPoint;
  /**
   * If true, the x-ray will start from the origin.
   * If false, the x-ray will be a full infinite line.
   */
  start_from_origin: bool;
}

table LeaderTextBlockContent {
  /** The rich text or markdown string for the content. */
  text: string;
}

table LeaderBlockContent {
  /** The ID of the DucBlock definition to use as content. */
  block_id: string;
  /**
   * The attribute values and element overrides for this specific block instance.
   * This is a subset of the properties from DucBlockInstanceElement.
   */
  attribute_values: [StringValueEntry];
  element_overrides: [StringValueEntry];
}

union LeaderContentData {
  LeaderTextBlockContent,
  LeaderBlockContent
}

table LeaderContent {
  leader_content_type: LEADER_CONTENT_TYPE = null;
  content: LeaderContentData;
}

table DucLeaderElement {
  linear_base: _DucLinearElementBase;
  style: DucLeaderStyle;
  /**
   * The content attached to the leader. Stored internally to keep the element atomic.
   */
  content: LeaderContent;
  /**
   * The anchor point for the content block, in world coordinates.
   * The leader's dogleg/landing connects to this point.
   */
  content_anchor: GeometricPoint;
}

table DimensionDefinitionPoints {
  /**
   * Primary origin point (e.g., start of a linear dimension, point on a circle for radius).
   * DXF DefPoint1
   */
  origin1: GeometricPoint;
  /**
   * Secondary origin point (e.g., end of a linear dimension, end of an arc).
   * DXF DefPoint2
   */
  origin2: GeometricPoint;
  /**
   * A point that defines the position of the dimension line or arc.
   * DXF DefPoint3
   */
  location: GeometricPoint;
  /**
   * Center point (for radial/angular/diameter) or vertex (for angular).
   * DXF DefPoint4
   */
  center: GeometricPoint;
  /**
   * A point defining a jog in the dimension line.
   * DXF DefPoint5
   */
  jog: GeometricPoint;
}

table DimensionBindings {
  /**
   * Defines how the definition points are associated with other elements when `isAssociative` is true.
   * The keys correspond to the keys in `definitionPoints`.
   */
  origin1: DucPointBinding;
  origin2: DucPointBinding;
  center: DucPointBinding;
}

table DimensionBaselineData {
  /** If this is a baseline dimension, contains data linking it to the base */
  base_dimension_id: string;
}

table DimensionContinueData {
  /** If this is a continued dimension, contains data linking it to the previous one */
  continue_from_dimension_id: string;
}

table DucDimensionElement {
  base: _DucElementBase;
  style: DucDimensionStyle;
  
  /** The type of dimension, which determines how definition points are interpreted */
  dimension_type: DIMENSION_TYPE = null;
  /** The core geometric points that define what is being measured */
  definition_points: DimensionDefinitionPoints;
  
  /**
   * The oblique angle for the extension lines, used for isometric-style dimensions.
   * An angle of 0 means they are perpendicular to the dimension line.
   */
  oblique_angle: float; // Radian
  /** For 'ordinate' dimensions, specifies whether it measures the X or Y coordinate. */
  ordinate_axis: AXIS = null;
  
  bindings: DimensionBindings;
  
  /**
   * User-override for the dimension text content.
   * - If `null`, the measured value is automatically calculated and displayed.
   * - If a string, this value is displayed instead.
   * Use `<>` within the string (e.g., "R<>") to include the calculated measurement.
   */
  text_override: string;
  /**
   * User-override for the text position.
   * - If `null`, the position is automatically determined by the 'fit' rules in the style.
   * - If a point, the text is moved to this exact location.
   */
  text_position: GeometricPoint;
  
  /** Instance-specific overrides for tolerance, taking precedence over the style's defaults */
  tolerance_override: DimensionToleranceStyle;
  
  baseline_data: DimensionBaselineData;
  continue_data: DimensionContinueData;
  
  // calculated_value: double; // This is readonly runtime data, should not be serialized
}

table DatumReference {
  /** The datum letter or letters (e.g., "A", "B", "A-B") */
  letters: string;
  /** Material condition modifier, if any (e.g., Maximum, Least) */
  modifier: MATERIAL_CONDITION = null;
}

table ToleranceClause {
  /** The primary tolerance value, represented as a string to support various formats */
  value: string;
  /** The type of tolerance zone (e.g., Cylindrical, Spherical) */
  zone_type: TOLERANCE_ZONE_TYPE = null;
  /** A list of modifiers that apply directly to the feature, like Diameter or Projected Zone */
  feature_modifiers: [FEATURE_MODIFIER];
  /** Material condition modifier for the tolerance itself */
  material_condition: MATERIAL_CONDITION = null;
}

table FeatureControlFrameSegment {
  /** The geometric characteristic symbol (e.g., Position, Flatness, Profile) */
  symbol: GDT_SYMBOL = null;
  /** The tolerance specification for this segment */
  tolerance: ToleranceClause;
  /** The datum reference frame, ordered by priority */
  datums: [DatumReference]; // [primary, secondary, tertiary]
}

table FCFBetweenModifier {
  /** Identifier for start point, e.g., "A" */
  start: string;
  /** Identifier for end point, e.g., "B" */
  end: string;
}

table FCFProjectedZoneModifier {
  value: double;
}

table FCFFrameModifiers {
  all_around: bool;
  all_over: bool;
  continuous_feature: bool;
  between: FCFBetweenModifier;
  projected_tolerance_zone: FCFProjectedZoneModifier;
}

table FCFDatumDefinition {
  /** The datum letter this symbol defines (e.g., "A", "B") */
  letter: string;
  /**
   * An optional binding directly to a point on the feature being identified as the datum.
   * Used when a leader is not present.
   */
  feature_binding: DucPointBinding;
}

table DucFeatureControlFrameElement {
  base: _DucElementBase;
  style: DucFeatureControlFrameStyle;
  
  /**
   * An array of rows. Most FCFs have one row. Composite frames have multiple rows.
   * Each row is an array of segments that are drawn horizontally.
   */
  rows: [FeatureControlFrameSegment];
  /** Modifiers that apply to the entire feature control frame. */
  frame_modifiers: FCFFrameModifiers;
  /**
   * A reference to a leader element that points to this FCF.
   * The leader element itself holds the geometry and start/end bindings.
   * This provides a simple, one-way link.
   */
  leader_element_id: string;
  /**
   * If present, this element acts as a **Datum Feature Symbol**, defining the specified
   * datum letter and attached to a feature. The `rows` property would be empty.
   */
  datum_definition: FCFDatumDefinition;
}

table TextColumn {
  /** The width of the column in drawing units. */
  width: double;
  /** The space between this column and the next, also known as the gutter. */
  gutter: double;
}

table ColumnLayout {
  /**
   * - `NONE`: A single column.
   * - `STATIC_COLUMNS`: A fixed number of columns with defined widths/heights.
   * - `DYNAMIC_COLUMNS`: Text flows automatically between columns based on height.
   */
  type: COLUMN_TYPE = null;
  /** An array defining each column's properties */
  definitions: [TextColumn];
  /** Whether column height adjusts automatically in dynamic mode */
  auto_height: bool;
}

table DucDocElement {
  base: _DucElementBase;
  style: DucDocStyle;
  /**
   * The content of the document, stored as a Markdown string.
   * This approach allows a rich text editor to manage the complex
   * inline formatting (bold, italic, colors, hyperlinks, etc.) while keeping the
   * core data structure simple and clean.
   *
   * It can also contain wildcards like `{@fieldname}` for dynamic data insertion.
   * Example: "This is **bold text** and this is a {color:red}red word{/color}."
   *
   * It can also contain zero or more placeholders in the format `{{tag}}`.
   * Example: "This document was last saved on {{SaveDate}} by {{Author}}."
   */
  text: string; // Markdown
  /**
   * An array of metadata objects that define the behavior of the placeholders
   * found in the `text` property. If this is empty, the text is treated
   * as purely static.
   */
  dynamic: [DucTextDynamicPart];
  /** Direction of text flow for multi-column layouts */
  flow_direction: TEXT_FLOW_DIRECTION = null;
  /** Defines the structural properties of the columns. */
  columns: ColumnLayout;
  /**
   * Text sizing behavior:
   * - `true`: Width and/or height adjust to fit text content.
   * - `false`: Text wraps or is clipped to fit the element's fixed bounds.
   */
  auto_resize: bool;
}

table ParametricSource {
  /**
   * The geometry is defined by executable code.
   * The geometry is loaded from a static 3D file.
   */
  type: PARAMETRIC_SOURCE_TYPE = null;
  code: string; // Used if type is CODE
  /** A reference to the imported file in the DucExternalFiles collection. */
  file_id: string; // Used if type is FILE
}

table DucParametricElement {
  base: _DucElementBase;
  /** Defines the source of the 3D geometry (either from code or a file). */
  source: ParametricSource;
}

/**
 * =============================================================================
 * ELEMENT UNION & WRAPPER
 * =============================================================================
 */

/** A union of all possible scene elements. */
union Element {
  DucRectangleElement,
  DucPolygonElement,
  DucEllipseElement,
  DucEmbeddableElement,
  DucPdfElement,
  DucMermaidElement,
  DucTableElement,
  DucImageElement,
  DucTextElement,
  DucLinearElement,
  DucArrowElement,
  DucFreeDrawElement,
  DucBlockInstanceElement,
  DucFrameElement,
  DucPlotElement,
  DucViewportElement,
  DucXRayElement,
  DucLeaderElement,
  DucDimensionElement,
  DucFeatureControlFrameElement,
  DucDocElement,
  DucParametricElement
}

/** A wrapper to hold an element from the union. */
table ElementWrapper {
  element: Element;
}


/**
 * =============================================================================
 * APP & DOCUMENT STATE
 * =============================================================================
 */

table DucGlobalState {
  /** The name of the drawing */
  name: string;
  /** The background color of the drawing */
  view_background_color: string;
  /** The master unit system for the entire drawing, used for block/file insertion scaling. */
  main_scope: string; // Scope
  /** The global linetype scale for the entire drawing. */
  dash_spacing_scale: float; // ScaleFactor
  /** Governs if linetype scale is affected by paper space viewport scale. */
  is_dash_spacing_affected_by_viewport_scale: bool;
  /**
   * Exponent threshold for determining when to change measurement scope (up or down).
   * This value defines a +/- tolerance range around the exponent of the current scope.
   * A scope change is triggered if the exponent of *either* the calculated real viewport width
   * or the calculated real viewport height falls outside this tolerance range relative to the current scope's exponent.
   * Example scenario:
   *   appState.scopeExponentThreshold = 2
   *   appState.scope = "mm" // (approximately 1e-3 relative to reference unit (meter))
   *   appState.zoom = dynamic value representing the current zoom level
   * The real viewport size is calculated as: viewportSize * zoom
   * This system ensures measurements remain representable with appropriate precision
   * as users zoom in and out, automatically adjusting between units like mm, μm, nm, etc.
   */
  scope_exponent_threshold: byte;
  /** A rule for whether newly created dimensions should be associative by default. */
  dimensions_associative_by_default: bool;
  /** A fundamental choice for the drawing's scaling architecture. */
  use_annotative_scaling: bool;
  /**
   * Default display precision for various unit types. The user can override
   * this temporarily in their session state (DucState).
   */
  display_precision_linear: int;
  display_precision_angular: int;
}

table DucLocalState {
  /**
   * The current scope of the design
   * mm, cm, m, in, ft, yd, mi, etc...
   */
  scope: string; // Scope
  /** The active standard for the design */
  active_standard_id: string;
  
  scroll_x: double;
  scroll_y: double;
  zoom: double;
  
  /** list of active grids ordered by z index, most on top is first */
  active_grid_settings: [string]; // Identifier["id"][]
  active_snap_settings: string; // Identifier["id"]
  
  is_binding_enabled: bool;
  
  /** Current item is usually a quick access state to apply as default to certain things when drawing */
  current_item_stroke: ElementStroke;
  current_item_background: ElementBackground;
  current_item_opacity: float; // Percentage
  current_item_font_family: string; 
  current_item_font_size: double;
  current_item_text_align: TEXT_ALIGN = null;
  current_item_start_line_head: DucHead;
  current_item_end_line_head: DucHead;
  current_item_roundness: double;
  
  /** Pen mode is enabled, creates a better experience for drawing with a pen */
  pen_mode: bool;
  /** In view mode the user is not allowed to edit the canvas. */
  view_mode_enabled: bool;
  /** Object snapping on the environment is enabled */
  objects_snap_mode_enabled: bool;
  /** Available grids are visible */
  grid_mode_enabled: bool;
  /** Whether to disable the fill on all shapes */
  outline_mode_enabled: bool;
}

table DucGroup {
  id: string (key);
  stack_base: _DucStackBase;
}

table DucRegion {
  id: string (key);
  stack_base: _DucStackBase;
  /** The boolean operation to apply to all child elements. */
  boolean_operation: BOOLEAN_OPERATION = null;
}

table DucLayerOverrides {
  stroke: ElementStroke;
  background: ElementBackground;
}

table DucLayer {
  id: string (key);
  stack_base: _DucStackBase;
  readonly: bool;
  /** A container for the default styling properties that elements on this layer will inherit */
  overrides: DucLayerOverrides;
}

/**
 * =============================================================================
 * STANDARDS & SETTINGS
 * =============================================================================
 */

table _UnitSystemBase {
  /** Unit system */
  system: UNIT_SYSTEM = null;
  /** Precision (decimal places) */
  precision: int;
  /** Suppress leading zeros */
  suppress_leading_zeros: bool;
  /** Suppress trailing zeros */
  suppress_trailing_zeros: bool;
}

table LinearUnitSystem {
  base: _UnitSystemBase;
  /** Unit format */
  format: DIMENSION_UNITS_FORMAT = null;
  /** Decimal separator character */
  decimal_separator: DECIMAL_SEPARATOR = null;
  /** Suppress zero feet */
  suppress_zero_feet: bool;
  /** Suppress zero inches */
  suppress_zero_inches: bool;
}

table AngularUnitSystem {
  base: _UnitSystemBase;
  /** Unit format */
  format: ANGULAR_UNITS_FORMAT = null;
}

table AlternateUnits {
  base: _UnitSystemBase;
  format: DIMENSION_UNITS_FORMAT = null;
  /** Whether to display alternate units */
  is_visible: bool;
  /** Multiplier for alternate units */
  multiplier: float;
}

table PrimaryUnits {
  /** Linear units */
  linear: LinearUnitSystem;
  /** Angular units */
  angular: AngularUnitSystem;
}

table StandardUnits {
  primary_units: PrimaryUnits;
  alternate_units: AlternateUnits;
}

table UnitPrecision {
  linear: int;
  angular: int;
  area: int;
  volume: int;
}

table StandardOverrides {
  main_scope: string;
  elements_stroke_width_override: double;
  common_style_id: string;
  stack_like_style_id: string;
  text_style_id: string;
  dimension_style_id: string;
  leader_style_id: string;
  feature_control_frame_style_id: string;
  table_style_id: string;
  doc_style_id: string;
  viewport_style_id: string;
  plot_style_id: string;
  hatch_style_id: string;
  active_grid_settings_id: [string];
  active_snap_settings_id: string;
  dash_line_override: string;
  /** Default precision for various dimension types */
  unit_precision: UnitPrecision;
}

table DucCommonStyle {
  background: ElementBackground;
  stroke: ElementStroke;
}
table IdentifiedCommonStyle { id: Identifier; style: DucCommonStyle; }
table IdentifiedStackLikeStyle { id: Identifier; style: DucStackLikeStyles; }
table IdentifiedTextStyle { id: Identifier; style: DucTextStyle; }
table IdentifiedDimensionStyle { id: Identifier; style: DucDimensionStyle; }
table IdentifiedLeaderStyle { id: Identifier; style: DucLeaderStyle; }
table IdentifiedFCFStyle { id: Identifier; style: DucFeatureControlFrameStyle; }
table IdentifiedTableStyle { id: Identifier; style: DucTableStyle; }
table IdentifiedDocStyle { id: Identifier; style: DucDocStyle; }
table IdentifiedViewportStyle { id: Identifier; style: DucViewportStyle; }
table IdentifiedHatchStyle { id: Identifier; style: DucHatchStyle; }
table IdentifiedXRayStyle { id: Identifier; style: DucXRayStyle; }

table StandardStyles {
  common_styles: [IdentifiedCommonStyle];
  stack_like_styles: [IdentifiedStackLikeStyle];
  text_styles: [IdentifiedTextStyle];
  dimension_styles: [IdentifiedDimensionStyle];
  leader_styles: [IdentifiedLeaderStyle];
  feature_control_frame_styles: [IdentifiedFCFStyle];
  table_styles: [IdentifiedTableStyle];
  doc_styles: [IdentifiedDocStyle];
  viewport_styles: [IdentifiedViewportStyle];
  hatch_styles: [IdentifiedHatchStyle];
  xray_styles: [IdentifiedXRayStyle];
}

table GridStyle {
  color: string;
  opacity: double;
  /** for dashed lines */
  dash_pattern: [double];
}

table PolarGridSettings {
  /** Number of radial divisions (spokes) */
  radial_divisions: int;
  /** Radial spacing between concentric circles */
  radial_spacing: double;
  /** Whether to show angle labels */
  show_labels: bool;
}

table IsometricGridSettings {
  /** Left plane angle (typically 30 degrees) */
  left_angle: double; // Radian
  /** Right plane angle (typically 30 degrees) */
  right_angle: double; // Radian
}

table GridSettings {
  /** Grid coordinate system type */
  type: GRID_TYPE = null;
  /** Whether this grid is read-only */
  readonly: bool;
  /** How the grid is displayed */
  display_type: GRID_DISPLAY_TYPE = null;
  /** Whether the grid spacing is adaptive (changes with zoom level) or fixed. */
  is_adaptive: bool;
  /** Spacing between major grid lines along X-axis */
  x_spacing: double;
  /** Spacing between major grid lines along Y-axis */
  y_spacing: double;
  /** Number of minor divisions between major lines */
  subdivisions: int;
  /** Grid origin point */
  origin: GeometricPoint;
  /** Grid rotation angle */
  rotation: double; // Radian
  /** Whether grid follows the active UCS */
  follow_ucs: bool;
  /** Major grid line/dot styling */
  major_style: GridStyle;
  /** Minor grid line/dot styling */
  minor_style: GridStyle;
  /** Show minor subdivisions */
  show_minor: bool;
  /** Minimum zoom level where grid becomes visible */
  min_zoom: double;
  /** Maximum zoom level where grid remains visible */
  max_zoom: double;
  /** Whether to auto-hide when too dense */
  auto_hide: bool;
  /** Polar grid settings (when type is POLAR) */
  polar_settings: PolarGridSettings;
  /** Isometric grid settings (when type is ISOMETRIC) */
  isometric_settings: IsometricGridSettings;
  /** Whether this grid affects snapping */
  enable_snapping: bool;
}

table SnapOverride {
  key: string; // keyboard key
  behavior: SNAP_OVERRIDE_BEHAVIOR = null;
}

table DynamicSnapSettings {
  enabled_during_drag: bool;
  enabled_during_rotation: bool;
  enabled_during_scale: bool;
}

table PolarTrackingSettings {
  enabled: bool;
  angles: [double]; // Radian
  /** Additional increment angle for polar tracking */
  increment_angle: double; // Radian
  /** Whether to track from last point or from base */
  track_from_last_point: bool;
  /** Display polar distance and angle */
  show_polar_coordinates: bool;
}

table TrackingLineStyle {
  color: string;
  opacity: double;
  dash_pattern: [double];
}

table LayerSnapFilters {
  include_layers: [string];
  exclude_layers: [string];
}

table SnapMarkerStyle {
  shape: SNAP_MARKER_SHAPE = null;
  color: string;
}

table SnapMarkerStyleEntry {
  key: OBJECT_SNAP_MODE = null;
  value: SnapMarkerStyle;
}

table SnapMarkerSettings {
  enabled: bool;
  size: int;
  /** for temporary markers (ms) */
  duration: int; // ms
  styles: [SnapMarkerStyleEntry];
}

table SnapSettings {
  /** Whether this snap settings is read-only */
  readonly: bool;
  /**
   * The snap angle for rotated snap grids (e.g., for isometric snapping).
   * In radians.
   */
  twist_angle: double; // Radian;
  /** Snap tolerance in pixels - how close cursor must be to trigger snap */
  snap_tolerance: int;
  /** Aperture size for object snap detection (in pixels) */
  object_snap_aperture: int;
  /** Whether orthogonal mode is enabled (constrains to 0/90 degrees) */
  is_ortho_mode_on: bool;
  /** Polar tracking configuration */
  polar_tracking: PolarTrackingSettings;
  /**
   * Whether object snap (Osnap) is enabled.
   * Osnap allows snapping to geometric points on existing objects.
   */
  is_object_snap_on: bool;
  /** Set of active object snap modes */
  active_object_snap_modes: [OBJECT_SNAP_MODE];
  /** Priority order when multiple snaps are available at cursor position */
  snap_priority: [OBJECT_SNAP_MODE];
  /** Whether to show tracking lines/vectors */
  show_tracking_lines: bool;
  /** Tracking line display settings */
  tracking_line_style: TrackingLineStyle;
  /** Snap behavior during element creation/modification */
  dynamic_snap: DynamicSnapSettings;
  /** Temporary snap override settings (e.g., holding shift) */
  temporary_overrides: [SnapOverride];
  /** Incremental snap distance (for relative movements) */
  incremental_distance: double;
  /** Magnetic snap strength (0-100) */
  magnetic_strength: double;
  /** Layer-specific snap settings */
  layer_snap_filters: LayerSnapFilters;
  /** Element type filters for object snap */
  element_type_filters: [string];
  /** Running object snap vs single pick mode */
  snap_mode: SNAP_MODE = null;
  /** Visual feedback settings */
  snap_markers: SnapMarkerSettings;
  /** Construction/guide line snapping */
  construction_snap_enabled: bool;
  /** Snap to grid intersections only */
  snap_to_grid_intersections: bool;
}

table IdentifiedGridSettings { id: Identifier; settings: GridSettings; }
table IdentifiedSnapSettings { id: Identifier; settings: SnapSettings; }
table IdentifiedUcs { id: Identifier; ucs: DucUcs; }
table IdentifiedView { id: Identifier; view: DucView; }

table StandardViewSettings {
  views: [IdentifiedView];
  ucs: [IdentifiedUcs];
  grid_settings: [IdentifiedGridSettings];
  snap_settings: [IdentifiedSnapSettings];
}

table DimensionValidationRules {
  min_text_height: double;
  max_text_height: double;
  allowed_precisions: [int];
}

table LayerValidationRules {
  prohibited_layer_names: [string];
}

table StandardValidation {
  dimension_rules: DimensionValidationRules;
  layer_rules: LayerValidationRules;
}

table Standard {
  identifier: Identifier;
  /** Version of the standard */
  version: string;
  /** Whether this is a built-in standard (read-only) */
  readonly: bool;
  /** Overrides for all elements projected to this standard */
  overrides: StandardOverrides;
  /** Styles */
  styles: StandardStyles;
  /** Views and canvas interaction settings */
  view_settings: StandardViewSettings;
  /** Units */
  units: StandardUnits;
  /** Validation rules */
  validation: StandardValidation;
}


/**
 * =============================================================================
 * VERSION CONTROL
 * =============================================================================
 */

table VersionBase {
  id: string;
  parent_id: string;
  timestamp: long;
  description: string;
  is_manual_save: bool;
  user_id: string;
}

table Checkpoint {
  base: VersionBase;
  data: [ubyte];
  size_bytes: long;
}

table JSONPatchOperation {
  op: string;
  path: string;
  /** Can be any JSON type. It is stored here as a serialized JSON string. */
  value: string;
}

table Delta {
  base: VersionBase;
  patch: [JSONPatchOperation];
}

table VersionGraphMetadata {
  pruning_level: PRUNING_LEVEL = null;
  last_pruned: long;
  total_size: long;
}

table VersionGraph {
  /** The ID of the user-designated checkpoint version. */
  user_checkpoint_version_id: string;
  /** The ID of the latest version in the graph. */
  latest_version_id: string;
  /** An array of all checkpoint versions. */
  checkpoints: [Checkpoint];
  /** An array of all delta versions (patches). */
  deltas: [Delta];
  metadata: VersionGraphMetadata;
}

/**
 * =============================================================================
 * EXTERNAL FILES
 * =============================================================================
 */

table DucExternalFileData {
  mime_type: string;
  id: string (key);
  /** The base64 encoded data URL of the file. This is the actual file content. */
  data: [ubyte];
  /** Epoch timestamp in milliseconds when the file was created. */
  created: long;
  /**
   * Epoch timestamp in milliseconds when the file was last retrieved from storage to be loaded onto the scene.
   * We use this flag to determine whether to delete unused files from storage.
   */
  last_retrieved: long;
}

table DucExternalFileEntry {
  key: string (key);
  value: DucExternalFileData;
}

/**
 * =============================================================================
 * ROOT TYPE
 * =============================================================================
 */

/** Root data structure for the stored data state */
table ExportedDataState {
  /** Untouchable fields even on Breaking Versions. */
  type: string;
  version_legacy: int (deprecated);
  source: string;
  version: string;
  //
  
  thumbnail: [ubyte];
  dictionary: [DictionaryEntry];
  
  elements: [ElementWrapper];
  blocks: [DucBlock];
  groups: [DucGroup];
  regions: [DucRegion];
  layers: [DucLayer];
  standards: [Standard];

  /** The user's current session state for a specific project */
  duc_local_state: DucLocalState;
  /** Project-wide settings that are saved with the document and shared by all users */
  duc_global_state: DucGlobalState;
  
  files: [DucExternalFileEntry];
  
  /** In case it is needed to embed the version control into the file format */
  version_graph: VersionGraph;
}

root_type ExportedDataState;