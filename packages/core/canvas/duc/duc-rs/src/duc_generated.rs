// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod duc {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

pub enum PointOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Point<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Point<'a> {
  type Inner = Point<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Point<'a> {
  pub const VT_X: flatbuffers::VOffsetT = 4;
  pub const VT_Y: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Point { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PointArgs
  ) -> flatbuffers::WIPOffset<Point<'bldr>> {
    let mut builder = PointBuilder::new(_fbb);
    builder.add_y(args.y);
    builder.add_x(args.x);
    builder.finish()
  }


  #[inline]
  pub fn x(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Point::VT_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn y(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Point::VT_Y, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Point<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("x", Self::VT_X, false)?
     .visit_field::<f32>("y", Self::VT_Y, false)?
     .finish();
    Ok(())
  }
}
pub struct PointArgs {
    pub x: f32,
    pub y: f32,
}
impl<'a> Default for PointArgs {
  #[inline]
  fn default() -> Self {
    PointArgs {
      x: 0.0,
      y: 0.0,
    }
  }
}

pub struct PointBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PointBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_x(&mut self, x: f32) {
    self.fbb_.push_slot::<f32>(Point::VT_X, x, 0.0);
  }
  #[inline]
  pub fn add_y(&mut self, y: f32) {
    self.fbb_.push_slot::<f32>(Point::VT_Y, y, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PointBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PointBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Point<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Point<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Point");
      ds.field("x", &self.x());
      ds.field("y", &self.y());
      ds.finish()
  }
}
pub enum PointBindingOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PointBinding<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PointBinding<'a> {
  type Inner = PointBinding<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PointBinding<'a> {
  pub const VT_ELEMENTID: flatbuffers::VOffsetT = 4;
  pub const VT_FOCUS: flatbuffers::VOffsetT = 6;
  pub const VT_GAP: flatbuffers::VOffsetT = 8;
  pub const VT_FIXEDPOINT: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PointBinding { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PointBindingArgs<'args>
  ) -> flatbuffers::WIPOffset<PointBinding<'bldr>> {
    let mut builder = PointBindingBuilder::new(_fbb);
    if let Some(x) = args.fixedPoint { builder.add_fixedPoint(x); }
    builder.add_gap(args.gap);
    builder.add_focus(args.focus);
    if let Some(x) = args.elementId { builder.add_elementId(x); }
    builder.finish()
  }


  #[inline]
  pub fn elementId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PointBinding::VT_ELEMENTID, None)}
  }
  #[inline]
  pub fn focus(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(PointBinding::VT_FOCUS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn gap(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(PointBinding::VT_GAP, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn fixedPoint(&self) -> Option<Point<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Point>>(PointBinding::VT_FIXEDPOINT, None)}
  }
}

impl flatbuffers::Verifiable for PointBinding<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("elementId", Self::VT_ELEMENTID, false)?
     .visit_field::<f32>("focus", Self::VT_FOCUS, false)?
     .visit_field::<f32>("gap", Self::VT_GAP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Point>>("fixedPoint", Self::VT_FIXEDPOINT, false)?
     .finish();
    Ok(())
  }
}
pub struct PointBindingArgs<'a> {
    pub elementId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub focus: f32,
    pub gap: f32,
    pub fixedPoint: Option<flatbuffers::WIPOffset<Point<'a>>>,
}
impl<'a> Default for PointBindingArgs<'a> {
  #[inline]
  fn default() -> Self {
    PointBindingArgs {
      elementId: None,
      focus: 0.0,
      gap: 0.0,
      fixedPoint: None,
    }
  }
}

pub struct PointBindingBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PointBindingBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_elementId(&mut self, elementId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PointBinding::VT_ELEMENTID, elementId);
  }
  #[inline]
  pub fn add_focus(&mut self, focus: f32) {
    self.fbb_.push_slot::<f32>(PointBinding::VT_FOCUS, focus, 0.0);
  }
  #[inline]
  pub fn add_gap(&mut self, gap: f32) {
    self.fbb_.push_slot::<f32>(PointBinding::VT_GAP, gap, 0.0);
  }
  #[inline]
  pub fn add_fixedPoint(&mut self, fixedPoint: flatbuffers::WIPOffset<Point<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Point>>(PointBinding::VT_FIXEDPOINT, fixedPoint);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PointBindingBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PointBindingBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PointBinding<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PointBinding<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PointBinding");
      ds.field("elementId", &self.elementId());
      ds.field("focus", &self.focus());
      ds.field("gap", &self.gap());
      ds.field("fixedPoint", &self.fixedPoint());
      ds.finish()
  }
}
pub enum DucElementOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucElement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucElement<'a> {
  type Inner = DucElement<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucElement<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
  pub const VT_X: flatbuffers::VOffsetT = 8;
  pub const VT_Y: flatbuffers::VOffsetT = 10;
  pub const VT_INDEX: flatbuffers::VOffsetT = 12;
  pub const VT_SCOPE: flatbuffers::VOffsetT = 14;
  pub const VT_WRITINGLAYER: flatbuffers::VOffsetT = 16;
  pub const VT_LABEL: flatbuffers::VOffsetT = 18;
  pub const VT_ISVISIBLE: flatbuffers::VOffsetT = 20;
  pub const VT_ROUNDNESSTYPE: flatbuffers::VOffsetT = 22;
  pub const VT_ROUNDNESSVALUE: flatbuffers::VOffsetT = 24;
  pub const VT_BACKGROUNDCOLOR: flatbuffers::VOffsetT = 26;
  pub const VT_STROKECOLOR: flatbuffers::VOffsetT = 28;
  pub const VT_STROKEWIDTH: flatbuffers::VOffsetT = 30;
  pub const VT_STROKESTYLE: flatbuffers::VOffsetT = 32;
  pub const VT_FILLSTYLE: flatbuffers::VOffsetT = 34;
  pub const VT_STROKEPLACEMENT: flatbuffers::VOffsetT = 36;
  pub const VT_OPACITY: flatbuffers::VOffsetT = 38;
  pub const VT_WIDTH: flatbuffers::VOffsetT = 40;
  pub const VT_HEIGHT: flatbuffers::VOffsetT = 42;
  pub const VT_ANGLE: flatbuffers::VOffsetT = 44;
  pub const VT_ISDELETED: flatbuffers::VOffsetT = 46;
  pub const VT_GROUPIDS: flatbuffers::VOffsetT = 48;
  pub const VT_FRAMEID: flatbuffers::VOffsetT = 50;
  pub const VT_BOUNDELEMENTS: flatbuffers::VOffsetT = 52;
  pub const VT_LINK: flatbuffers::VOffsetT = 54;
  pub const VT_LOCKED: flatbuffers::VOffsetT = 56;
  pub const VT_CUSTOMDATA: flatbuffers::VOffsetT = 58;
  pub const VT_ISSTROKEDISABLED: flatbuffers::VOffsetT = 60;
  pub const VT_ISBACKGROUNDDISABLED: flatbuffers::VOffsetT = 62;
  pub const VT_FONTSIZE: flatbuffers::VOffsetT = 64;
  pub const VT_FONTFAMILY: flatbuffers::VOffsetT = 66;
  pub const VT_TEXT: flatbuffers::VOffsetT = 68;
  pub const VT_TEXTALIGN: flatbuffers::VOffsetT = 70;
  pub const VT_VERTICALALIGN: flatbuffers::VOffsetT = 72;
  pub const VT_CONTAINERID: flatbuffers::VOffsetT = 74;
  pub const VT_ORIGINALTEXT: flatbuffers::VOffsetT = 76;
  pub const VT_LINEHEIGHT: flatbuffers::VOffsetT = 78;
  pub const VT_AUTORESIZE: flatbuffers::VOffsetT = 80;
  pub const VT_POINTS: flatbuffers::VOffsetT = 82;
  pub const VT_LASTCOMMITTEDPOINT: flatbuffers::VOffsetT = 84;
  pub const VT_STARTBINDING: flatbuffers::VOffsetT = 86;
  pub const VT_ENDBINDING: flatbuffers::VOffsetT = 88;
  pub const VT_STARTARROWHEAD: flatbuffers::VOffsetT = 90;
  pub const VT_ENDARROWHEAD: flatbuffers::VOffsetT = 92;
  pub const VT_ELBOWED: flatbuffers::VOffsetT = 94;
  pub const VT_PRESSURES: flatbuffers::VOffsetT = 96;
  pub const VT_SIMULATEPRESSURE: flatbuffers::VOffsetT = 98;
  pub const VT_FILEID: flatbuffers::VOffsetT = 100;
  pub const VT_STATUS: flatbuffers::VOffsetT = 102;
  pub const VT_SCALE: flatbuffers::VOffsetT = 104;
  pub const VT_ISCOLLAPSED: flatbuffers::VOffsetT = 106;
  pub const VT_NAME: flatbuffers::VOffsetT = 108;
  pub const VT_GROUPIDREF: flatbuffers::VOffsetT = 110;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucElement { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucElementArgs<'args>
  ) -> flatbuffers::WIPOffset<DucElement<'bldr>> {
    let mut builder = DucElementBuilder::new(_fbb);
    if let Some(x) = args.groupIdRef { builder.add_groupIdRef(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    if let Some(x) = args.scale { builder.add_scale(x); }
    if let Some(x) = args.status { builder.add_status(x); }
    if let Some(x) = args.fileId { builder.add_fileId(x); }
    if let Some(x) = args.pressures { builder.add_pressures(x); }
    if let Some(x) = args.endArrowhead { builder.add_endArrowhead(x); }
    if let Some(x) = args.startArrowhead { builder.add_startArrowhead(x); }
    if let Some(x) = args.endBinding { builder.add_endBinding(x); }
    if let Some(x) = args.startBinding { builder.add_startBinding(x); }
    if let Some(x) = args.lastCommittedPoint { builder.add_lastCommittedPoint(x); }
    if let Some(x) = args.points { builder.add_points(x); }
    builder.add_lineHeight(args.lineHeight);
    if let Some(x) = args.originalText { builder.add_originalText(x); }
    if let Some(x) = args.containerId { builder.add_containerId(x); }
    if let Some(x) = args.verticalAlign { builder.add_verticalAlign(x); }
    if let Some(x) = args.textAlign { builder.add_textAlign(x); }
    if let Some(x) = args.text { builder.add_text(x); }
    if let Some(x) = args.fontFamily { builder.add_fontFamily(x); }
    builder.add_fontSize(args.fontSize);
    if let Some(x) = args.customData { builder.add_customData(x); }
    if let Some(x) = args.link { builder.add_link(x); }
    if let Some(x) = args.boundElements { builder.add_boundElements(x); }
    if let Some(x) = args.frameId { builder.add_frameId(x); }
    if let Some(x) = args.groupIds { builder.add_groupIds(x); }
    builder.add_angle(args.angle);
    builder.add_height(args.height);
    builder.add_width(args.width);
    builder.add_opacity(args.opacity);
    builder.add_strokePlacement(args.strokePlacement);
    if let Some(x) = args.fillStyle { builder.add_fillStyle(x); }
    if let Some(x) = args.strokeStyle { builder.add_strokeStyle(x); }
    builder.add_strokeWidth(args.strokeWidth);
    if let Some(x) = args.strokeColor { builder.add_strokeColor(x); }
    if let Some(x) = args.backgroundColor { builder.add_backgroundColor(x); }
    builder.add_roundnessValue(args.roundnessValue);
    if let Some(x) = args.roundnessType { builder.add_roundnessType(x); }
    if let Some(x) = args.label { builder.add_label(x); }
    if let Some(x) = args.writingLayer { builder.add_writingLayer(x); }
    if let Some(x) = args.scope { builder.add_scope(x); }
    if let Some(x) = args.index { builder.add_index(x); }
    builder.add_y(args.y);
    builder.add_x(args.x);
    if let Some(x) = args.type_ { builder.add_type_(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_isCollapsed(args.isCollapsed);
    builder.add_simulatePressure(args.simulatePressure);
    builder.add_elbowed(args.elbowed);
    builder.add_autoResize(args.autoResize);
    builder.add_isBackgroundDisabled(args.isBackgroundDisabled);
    builder.add_isStrokeDisabled(args.isStrokeDisabled);
    builder.add_locked(args.locked);
    builder.add_isDeleted(args.isDeleted);
    builder.add_isVisible(args.isVisible);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_ID, None)}
  }
  #[inline]
  pub fn type_(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_TYPE_, None)}
  }
  #[inline]
  pub fn x(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucElement::VT_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn y(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucElement::VT_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn index(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_INDEX, None)}
  }
  #[inline]
  pub fn scope(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_SCOPE, None)}
  }
  #[inline]
  pub fn writingLayer(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_WRITINGLAYER, None)}
  }
  #[inline]
  pub fn label(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_LABEL, None)}
  }
  #[inline]
  pub fn isVisible(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucElement::VT_ISVISIBLE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn roundnessType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_ROUNDNESSTYPE, None)}
  }
  #[inline]
  pub fn roundnessValue(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DucElement::VT_ROUNDNESSVALUE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn backgroundColor(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_BACKGROUNDCOLOR, None)}
  }
  #[inline]
  pub fn strokeColor(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_STROKECOLOR, None)}
  }
  #[inline]
  pub fn strokeWidth(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DucElement::VT_STROKEWIDTH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn strokeStyle(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_STROKESTYLE, None)}
  }
  #[inline]
  pub fn fillStyle(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_FILLSTYLE, None)}
  }
  #[inline]
  pub fn strokePlacement(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DucElement::VT_STROKEPLACEMENT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn opacity(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucElement::VT_OPACITY, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn width(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucElement::VT_WIDTH, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn height(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucElement::VT_HEIGHT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn angle(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucElement::VT_ANGLE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn isDeleted(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucElement::VT_ISDELETED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn groupIds(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(DucElement::VT_GROUPIDS, None)}
  }
  #[inline]
  pub fn frameId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_FRAMEID, None)}
  }
  #[inline]
  pub fn boundElements(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BoundElement<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BoundElement>>>>(DucElement::VT_BOUNDELEMENTS, None)}
  }
  #[inline]
  pub fn link(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_LINK, None)}
  }
  #[inline]
  pub fn locked(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucElement::VT_LOCKED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn customData(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_CUSTOMDATA, None)}
  }
  #[inline]
  pub fn isStrokeDisabled(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucElement::VT_ISSTROKEDISABLED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn isBackgroundDisabled(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucElement::VT_ISBACKGROUNDDISABLED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn fontSize(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DucElement::VT_FONTSIZE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn fontFamily(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_FONTFAMILY, None)}
  }
  #[inline]
  pub fn text(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_TEXT, None)}
  }
  #[inline]
  pub fn textAlign(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_TEXTALIGN, None)}
  }
  #[inline]
  pub fn verticalAlign(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_VERTICALALIGN, None)}
  }
  #[inline]
  pub fn containerId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_CONTAINERID, None)}
  }
  #[inline]
  pub fn originalText(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_ORIGINALTEXT, None)}
  }
  #[inline]
  pub fn lineHeight(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucElement::VT_LINEHEIGHT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn autoResize(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucElement::VT_AUTORESIZE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn points(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Point<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Point>>>>(DucElement::VT_POINTS, None)}
  }
  #[inline]
  pub fn lastCommittedPoint(&self) -> Option<Point<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Point>>(DucElement::VT_LASTCOMMITTEDPOINT, None)}
  }
  #[inline]
  pub fn startBinding(&self) -> Option<PointBinding<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<PointBinding>>(DucElement::VT_STARTBINDING, None)}
  }
  #[inline]
  pub fn endBinding(&self) -> Option<PointBinding<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<PointBinding>>(DucElement::VT_ENDBINDING, None)}
  }
  #[inline]
  pub fn startArrowhead(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_STARTARROWHEAD, None)}
  }
  #[inline]
  pub fn endArrowhead(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_ENDARROWHEAD, None)}
  }
  #[inline]
  pub fn elbowed(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucElement::VT_ELBOWED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn pressures(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(DucElement::VT_PRESSURES, None)}
  }
  #[inline]
  pub fn simulatePressure(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucElement::VT_SIMULATEPRESSURE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn fileId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_FILEID, None)}
  }
  #[inline]
  pub fn status(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_STATUS, None)}
  }
  #[inline]
  pub fn scale(&self) -> Option<Point<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Point>>(DucElement::VT_SCALE, None)}
  }
  #[inline]
  pub fn isCollapsed(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucElement::VT_ISCOLLAPSED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_NAME, None)}
  }
  #[inline]
  pub fn groupIdRef(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_GROUPIDREF, None)}
  }
}

impl flatbuffers::Verifiable for DucElement<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, false)?
     .visit_field::<f32>("x", Self::VT_X, false)?
     .visit_field::<f32>("y", Self::VT_Y, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("index", Self::VT_INDEX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("scope", Self::VT_SCOPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("writingLayer", Self::VT_WRITINGLAYER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("label", Self::VT_LABEL, false)?
     .visit_field::<bool>("isVisible", Self::VT_ISVISIBLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("roundnessType", Self::VT_ROUNDNESSTYPE, false)?
     .visit_field::<i32>("roundnessValue", Self::VT_ROUNDNESSVALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("backgroundColor", Self::VT_BACKGROUNDCOLOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("strokeColor", Self::VT_STROKECOLOR, false)?
     .visit_field::<i32>("strokeWidth", Self::VT_STROKEWIDTH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("strokeStyle", Self::VT_STROKESTYLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("fillStyle", Self::VT_FILLSTYLE, false)?
     .visit_field::<i32>("strokePlacement", Self::VT_STROKEPLACEMENT, false)?
     .visit_field::<f32>("opacity", Self::VT_OPACITY, false)?
     .visit_field::<f32>("width", Self::VT_WIDTH, false)?
     .visit_field::<f32>("height", Self::VT_HEIGHT, false)?
     .visit_field::<f32>("angle", Self::VT_ANGLE, false)?
     .visit_field::<bool>("isDeleted", Self::VT_ISDELETED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("groupIds", Self::VT_GROUPIDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("frameId", Self::VT_FRAMEID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BoundElement>>>>("boundElements", Self::VT_BOUNDELEMENTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("link", Self::VT_LINK, false)?
     .visit_field::<bool>("locked", Self::VT_LOCKED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("customData", Self::VT_CUSTOMDATA, false)?
     .visit_field::<bool>("isStrokeDisabled", Self::VT_ISSTROKEDISABLED, false)?
     .visit_field::<bool>("isBackgroundDisabled", Self::VT_ISBACKGROUNDDISABLED, false)?
     .visit_field::<i32>("fontSize", Self::VT_FONTSIZE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("fontFamily", Self::VT_FONTFAMILY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("text", Self::VT_TEXT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("textAlign", Self::VT_TEXTALIGN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("verticalAlign", Self::VT_VERTICALALIGN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("containerId", Self::VT_CONTAINERID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("originalText", Self::VT_ORIGINALTEXT, false)?
     .visit_field::<f32>("lineHeight", Self::VT_LINEHEIGHT, false)?
     .visit_field::<bool>("autoResize", Self::VT_AUTORESIZE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Point>>>>("points", Self::VT_POINTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Point>>("lastCommittedPoint", Self::VT_LASTCOMMITTEDPOINT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<PointBinding>>("startBinding", Self::VT_STARTBINDING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<PointBinding>>("endBinding", Self::VT_ENDBINDING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("startArrowhead", Self::VT_STARTARROWHEAD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("endArrowhead", Self::VT_ENDARROWHEAD, false)?
     .visit_field::<bool>("elbowed", Self::VT_ELBOWED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>("pressures", Self::VT_PRESSURES, false)?
     .visit_field::<bool>("simulatePressure", Self::VT_SIMULATEPRESSURE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("fileId", Self::VT_FILEID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("status", Self::VT_STATUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Point>>("scale", Self::VT_SCALE, false)?
     .visit_field::<bool>("isCollapsed", Self::VT_ISCOLLAPSED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("groupIdRef", Self::VT_GROUPIDREF, false)?
     .finish();
    Ok(())
  }
}
pub struct DucElementArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
    pub x: f32,
    pub y: f32,
    pub index: Option<flatbuffers::WIPOffset<&'a str>>,
    pub scope: Option<flatbuffers::WIPOffset<&'a str>>,
    pub writingLayer: Option<flatbuffers::WIPOffset<&'a str>>,
    pub label: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isVisible: bool,
    pub roundnessType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub roundnessValue: i32,
    pub backgroundColor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub strokeColor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub strokeWidth: i32,
    pub strokeStyle: Option<flatbuffers::WIPOffset<&'a str>>,
    pub fillStyle: Option<flatbuffers::WIPOffset<&'a str>>,
    pub strokePlacement: i32,
    pub opacity: f32,
    pub width: f32,
    pub height: f32,
    pub angle: f32,
    pub isDeleted: bool,
    pub groupIds: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub frameId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub boundElements: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BoundElement<'a>>>>>,
    pub link: Option<flatbuffers::WIPOffset<&'a str>>,
    pub locked: bool,
    pub customData: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isStrokeDisabled: bool,
    pub isBackgroundDisabled: bool,
    pub fontSize: i32,
    pub fontFamily: Option<flatbuffers::WIPOffset<&'a str>>,
    pub text: Option<flatbuffers::WIPOffset<&'a str>>,
    pub textAlign: Option<flatbuffers::WIPOffset<&'a str>>,
    pub verticalAlign: Option<flatbuffers::WIPOffset<&'a str>>,
    pub containerId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub originalText: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lineHeight: f32,
    pub autoResize: bool,
    pub points: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Point<'a>>>>>,
    pub lastCommittedPoint: Option<flatbuffers::WIPOffset<Point<'a>>>,
    pub startBinding: Option<flatbuffers::WIPOffset<PointBinding<'a>>>,
    pub endBinding: Option<flatbuffers::WIPOffset<PointBinding<'a>>>,
    pub startArrowhead: Option<flatbuffers::WIPOffset<&'a str>>,
    pub endArrowhead: Option<flatbuffers::WIPOffset<&'a str>>,
    pub elbowed: bool,
    pub pressures: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub simulatePressure: bool,
    pub fileId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub status: Option<flatbuffers::WIPOffset<&'a str>>,
    pub scale: Option<flatbuffers::WIPOffset<Point<'a>>>,
    pub isCollapsed: bool,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub groupIdRef: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DucElementArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucElementArgs {
      id: None,
      type_: None,
      x: 0.0,
      y: 0.0,
      index: None,
      scope: None,
      writingLayer: None,
      label: None,
      isVisible: false,
      roundnessType: None,
      roundnessValue: 0,
      backgroundColor: None,
      strokeColor: None,
      strokeWidth: 0,
      strokeStyle: None,
      fillStyle: None,
      strokePlacement: 0,
      opacity: 0.0,
      width: 0.0,
      height: 0.0,
      angle: 0.0,
      isDeleted: false,
      groupIds: None,
      frameId: None,
      boundElements: None,
      link: None,
      locked: false,
      customData: None,
      isStrokeDisabled: false,
      isBackgroundDisabled: false,
      fontSize: 0,
      fontFamily: None,
      text: None,
      textAlign: None,
      verticalAlign: None,
      containerId: None,
      originalText: None,
      lineHeight: 0.0,
      autoResize: false,
      points: None,
      lastCommittedPoint: None,
      startBinding: None,
      endBinding: None,
      startArrowhead: None,
      endArrowhead: None,
      elbowed: false,
      pressures: None,
      simulatePressure: false,
      fileId: None,
      status: None,
      scale: None,
      isCollapsed: false,
      name: None,
      groupIdRef: None,
    }
  }
}

pub struct DucElementBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucElementBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_ID, id);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_x(&mut self, x: f32) {
    self.fbb_.push_slot::<f32>(DucElement::VT_X, x, 0.0);
  }
  #[inline]
  pub fn add_y(&mut self, y: f32) {
    self.fbb_.push_slot::<f32>(DucElement::VT_Y, y, 0.0);
  }
  #[inline]
  pub fn add_index(&mut self, index: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_INDEX, index);
  }
  #[inline]
  pub fn add_scope(&mut self, scope: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_SCOPE, scope);
  }
  #[inline]
  pub fn add_writingLayer(&mut self, writingLayer: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_WRITINGLAYER, writingLayer);
  }
  #[inline]
  pub fn add_label(&mut self, label: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_LABEL, label);
  }
  #[inline]
  pub fn add_isVisible(&mut self, isVisible: bool) {
    self.fbb_.push_slot::<bool>(DucElement::VT_ISVISIBLE, isVisible, false);
  }
  #[inline]
  pub fn add_roundnessType(&mut self, roundnessType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_ROUNDNESSTYPE, roundnessType);
  }
  #[inline]
  pub fn add_roundnessValue(&mut self, roundnessValue: i32) {
    self.fbb_.push_slot::<i32>(DucElement::VT_ROUNDNESSVALUE, roundnessValue, 0);
  }
  #[inline]
  pub fn add_backgroundColor(&mut self, backgroundColor: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_BACKGROUNDCOLOR, backgroundColor);
  }
  #[inline]
  pub fn add_strokeColor(&mut self, strokeColor: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_STROKECOLOR, strokeColor);
  }
  #[inline]
  pub fn add_strokeWidth(&mut self, strokeWidth: i32) {
    self.fbb_.push_slot::<i32>(DucElement::VT_STROKEWIDTH, strokeWidth, 0);
  }
  #[inline]
  pub fn add_strokeStyle(&mut self, strokeStyle: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_STROKESTYLE, strokeStyle);
  }
  #[inline]
  pub fn add_fillStyle(&mut self, fillStyle: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_FILLSTYLE, fillStyle);
  }
  #[inline]
  pub fn add_strokePlacement(&mut self, strokePlacement: i32) {
    self.fbb_.push_slot::<i32>(DucElement::VT_STROKEPLACEMENT, strokePlacement, 0);
  }
  #[inline]
  pub fn add_opacity(&mut self, opacity: f32) {
    self.fbb_.push_slot::<f32>(DucElement::VT_OPACITY, opacity, 0.0);
  }
  #[inline]
  pub fn add_width(&mut self, width: f32) {
    self.fbb_.push_slot::<f32>(DucElement::VT_WIDTH, width, 0.0);
  }
  #[inline]
  pub fn add_height(&mut self, height: f32) {
    self.fbb_.push_slot::<f32>(DucElement::VT_HEIGHT, height, 0.0);
  }
  #[inline]
  pub fn add_angle(&mut self, angle: f32) {
    self.fbb_.push_slot::<f32>(DucElement::VT_ANGLE, angle, 0.0);
  }
  #[inline]
  pub fn add_isDeleted(&mut self, isDeleted: bool) {
    self.fbb_.push_slot::<bool>(DucElement::VT_ISDELETED, isDeleted, false);
  }
  #[inline]
  pub fn add_groupIds(&mut self, groupIds: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_GROUPIDS, groupIds);
  }
  #[inline]
  pub fn add_frameId(&mut self, frameId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_FRAMEID, frameId);
  }
  #[inline]
  pub fn add_boundElements(&mut self, boundElements: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BoundElement<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_BOUNDELEMENTS, boundElements);
  }
  #[inline]
  pub fn add_link(&mut self, link: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_LINK, link);
  }
  #[inline]
  pub fn add_locked(&mut self, locked: bool) {
    self.fbb_.push_slot::<bool>(DucElement::VT_LOCKED, locked, false);
  }
  #[inline]
  pub fn add_customData(&mut self, customData: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_CUSTOMDATA, customData);
  }
  #[inline]
  pub fn add_isStrokeDisabled(&mut self, isStrokeDisabled: bool) {
    self.fbb_.push_slot::<bool>(DucElement::VT_ISSTROKEDISABLED, isStrokeDisabled, false);
  }
  #[inline]
  pub fn add_isBackgroundDisabled(&mut self, isBackgroundDisabled: bool) {
    self.fbb_.push_slot::<bool>(DucElement::VT_ISBACKGROUNDDISABLED, isBackgroundDisabled, false);
  }
  #[inline]
  pub fn add_fontSize(&mut self, fontSize: i32) {
    self.fbb_.push_slot::<i32>(DucElement::VT_FONTSIZE, fontSize, 0);
  }
  #[inline]
  pub fn add_fontFamily(&mut self, fontFamily: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_FONTFAMILY, fontFamily);
  }
  #[inline]
  pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_TEXT, text);
  }
  #[inline]
  pub fn add_textAlign(&mut self, textAlign: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_TEXTALIGN, textAlign);
  }
  #[inline]
  pub fn add_verticalAlign(&mut self, verticalAlign: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_VERTICALALIGN, verticalAlign);
  }
  #[inline]
  pub fn add_containerId(&mut self, containerId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_CONTAINERID, containerId);
  }
  #[inline]
  pub fn add_originalText(&mut self, originalText: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_ORIGINALTEXT, originalText);
  }
  #[inline]
  pub fn add_lineHeight(&mut self, lineHeight: f32) {
    self.fbb_.push_slot::<f32>(DucElement::VT_LINEHEIGHT, lineHeight, 0.0);
  }
  #[inline]
  pub fn add_autoResize(&mut self, autoResize: bool) {
    self.fbb_.push_slot::<bool>(DucElement::VT_AUTORESIZE, autoResize, false);
  }
  #[inline]
  pub fn add_points(&mut self, points: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Point<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_POINTS, points);
  }
  #[inline]
  pub fn add_lastCommittedPoint(&mut self, lastCommittedPoint: flatbuffers::WIPOffset<Point<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Point>>(DucElement::VT_LASTCOMMITTEDPOINT, lastCommittedPoint);
  }
  #[inline]
  pub fn add_startBinding(&mut self, startBinding: flatbuffers::WIPOffset<PointBinding<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PointBinding>>(DucElement::VT_STARTBINDING, startBinding);
  }
  #[inline]
  pub fn add_endBinding(&mut self, endBinding: flatbuffers::WIPOffset<PointBinding<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PointBinding>>(DucElement::VT_ENDBINDING, endBinding);
  }
  #[inline]
  pub fn add_startArrowhead(&mut self, startArrowhead: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_STARTARROWHEAD, startArrowhead);
  }
  #[inline]
  pub fn add_endArrowhead(&mut self, endArrowhead: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_ENDARROWHEAD, endArrowhead);
  }
  #[inline]
  pub fn add_elbowed(&mut self, elbowed: bool) {
    self.fbb_.push_slot::<bool>(DucElement::VT_ELBOWED, elbowed, false);
  }
  #[inline]
  pub fn add_pressures(&mut self, pressures: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_PRESSURES, pressures);
  }
  #[inline]
  pub fn add_simulatePressure(&mut self, simulatePressure: bool) {
    self.fbb_.push_slot::<bool>(DucElement::VT_SIMULATEPRESSURE, simulatePressure, false);
  }
  #[inline]
  pub fn add_fileId(&mut self, fileId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_FILEID, fileId);
  }
  #[inline]
  pub fn add_status(&mut self, status: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_STATUS, status);
  }
  #[inline]
  pub fn add_scale(&mut self, scale: flatbuffers::WIPOffset<Point<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Point>>(DucElement::VT_SCALE, scale);
  }
  #[inline]
  pub fn add_isCollapsed(&mut self, isCollapsed: bool) {
    self.fbb_.push_slot::<bool>(DucElement::VT_ISCOLLAPSED, isCollapsed, false);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_NAME, name);
  }
  #[inline]
  pub fn add_groupIdRef(&mut self, groupIdRef: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_GROUPIDREF, groupIdRef);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucElementBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucElementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucElement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucElement<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucElement");
      ds.field("id", &self.id());
      ds.field("type_", &self.type_());
      ds.field("x", &self.x());
      ds.field("y", &self.y());
      ds.field("index", &self.index());
      ds.field("scope", &self.scope());
      ds.field("writingLayer", &self.writingLayer());
      ds.field("label", &self.label());
      ds.field("isVisible", &self.isVisible());
      ds.field("roundnessType", &self.roundnessType());
      ds.field("roundnessValue", &self.roundnessValue());
      ds.field("backgroundColor", &self.backgroundColor());
      ds.field("strokeColor", &self.strokeColor());
      ds.field("strokeWidth", &self.strokeWidth());
      ds.field("strokeStyle", &self.strokeStyle());
      ds.field("fillStyle", &self.fillStyle());
      ds.field("strokePlacement", &self.strokePlacement());
      ds.field("opacity", &self.opacity());
      ds.field("width", &self.width());
      ds.field("height", &self.height());
      ds.field("angle", &self.angle());
      ds.field("isDeleted", &self.isDeleted());
      ds.field("groupIds", &self.groupIds());
      ds.field("frameId", &self.frameId());
      ds.field("boundElements", &self.boundElements());
      ds.field("link", &self.link());
      ds.field("locked", &self.locked());
      ds.field("customData", &self.customData());
      ds.field("isStrokeDisabled", &self.isStrokeDisabled());
      ds.field("isBackgroundDisabled", &self.isBackgroundDisabled());
      ds.field("fontSize", &self.fontSize());
      ds.field("fontFamily", &self.fontFamily());
      ds.field("text", &self.text());
      ds.field("textAlign", &self.textAlign());
      ds.field("verticalAlign", &self.verticalAlign());
      ds.field("containerId", &self.containerId());
      ds.field("originalText", &self.originalText());
      ds.field("lineHeight", &self.lineHeight());
      ds.field("autoResize", &self.autoResize());
      ds.field("points", &self.points());
      ds.field("lastCommittedPoint", &self.lastCommittedPoint());
      ds.field("startBinding", &self.startBinding());
      ds.field("endBinding", &self.endBinding());
      ds.field("startArrowhead", &self.startArrowhead());
      ds.field("endArrowhead", &self.endArrowhead());
      ds.field("elbowed", &self.elbowed());
      ds.field("pressures", &self.pressures());
      ds.field("simulatePressure", &self.simulatePressure());
      ds.field("fileId", &self.fileId());
      ds.field("status", &self.status());
      ds.field("scale", &self.scale());
      ds.field("isCollapsed", &self.isCollapsed());
      ds.field("name", &self.name());
      ds.field("groupIdRef", &self.groupIdRef());
      ds.finish()
  }
}
pub enum BoundElementOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BoundElement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BoundElement<'a> {
  type Inner = BoundElement<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BoundElement<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BoundElement { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BoundElementArgs<'args>
  ) -> flatbuffers::WIPOffset<BoundElement<'bldr>> {
    let mut builder = BoundElementBuilder::new(_fbb);
    if let Some(x) = args.type_ { builder.add_type_(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BoundElement::VT_ID, None)}
  }
  #[inline]
  pub fn type_(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BoundElement::VT_TYPE_, None)}
  }
}

impl flatbuffers::Verifiable for BoundElement<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, false)?
     .finish();
    Ok(())
  }
}
pub struct BoundElementArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for BoundElementArgs<'a> {
  #[inline]
  fn default() -> Self {
    BoundElementArgs {
      id: None,
      type_: None,
    }
  }
}

pub struct BoundElementBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BoundElementBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BoundElement::VT_ID, id);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BoundElement::VT_TYPE_, type_);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BoundElementBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BoundElementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BoundElement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BoundElement<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BoundElement");
      ds.field("id", &self.id());
      ds.field("type_", &self.type_());
      ds.finish()
  }
}
pub enum DucGroupOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucGroup<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucGroup<'a> {
  type Inner = DucGroup<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucGroup<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
  pub const VT_ISCOLLAPSED: flatbuffers::VOffsetT = 8;
  pub const VT_LABEL: flatbuffers::VOffsetT = 10;
  pub const VT_SCOPE: flatbuffers::VOffsetT = 12;
  pub const VT_WRITINGLAYER: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucGroup { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucGroupArgs<'args>
  ) -> flatbuffers::WIPOffset<DucGroup<'bldr>> {
    let mut builder = DucGroupBuilder::new(_fbb);
    if let Some(x) = args.writingLayer { builder.add_writingLayer(x); }
    if let Some(x) = args.scope { builder.add_scope(x); }
    if let Some(x) = args.label { builder.add_label(x); }
    if let Some(x) = args.type_ { builder.add_type_(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_isCollapsed(args.isCollapsed);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucGroup::VT_ID, None)}
  }
  #[inline]
  pub fn type_(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucGroup::VT_TYPE_, None)}
  }
  #[inline]
  pub fn isCollapsed(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucGroup::VT_ISCOLLAPSED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn label(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucGroup::VT_LABEL, None)}
  }
  #[inline]
  pub fn scope(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucGroup::VT_SCOPE, None)}
  }
  #[inline]
  pub fn writingLayer(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucGroup::VT_WRITINGLAYER, None)}
  }
}

impl flatbuffers::Verifiable for DucGroup<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, false)?
     .visit_field::<bool>("isCollapsed", Self::VT_ISCOLLAPSED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("label", Self::VT_LABEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("scope", Self::VT_SCOPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("writingLayer", Self::VT_WRITINGLAYER, false)?
     .finish();
    Ok(())
  }
}
pub struct DucGroupArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isCollapsed: bool,
    pub label: Option<flatbuffers::WIPOffset<&'a str>>,
    pub scope: Option<flatbuffers::WIPOffset<&'a str>>,
    pub writingLayer: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DucGroupArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucGroupArgs {
      id: None,
      type_: None,
      isCollapsed: false,
      label: None,
      scope: None,
      writingLayer: None,
    }
  }
}

pub struct DucGroupBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucGroupBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucGroup::VT_ID, id);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucGroup::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_isCollapsed(&mut self, isCollapsed: bool) {
    self.fbb_.push_slot::<bool>(DucGroup::VT_ISCOLLAPSED, isCollapsed, false);
  }
  #[inline]
  pub fn add_label(&mut self, label: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucGroup::VT_LABEL, label);
  }
  #[inline]
  pub fn add_scope(&mut self, scope: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucGroup::VT_SCOPE, scope);
  }
  #[inline]
  pub fn add_writingLayer(&mut self, writingLayer: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucGroup::VT_WRITINGLAYER, writingLayer);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucGroupBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucGroupBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucGroup<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucGroup<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucGroup");
      ds.field("id", &self.id());
      ds.field("type_", &self.type_());
      ds.field("isCollapsed", &self.isCollapsed());
      ds.field("label", &self.label());
      ds.field("scope", &self.scope());
      ds.field("writingLayer", &self.writingLayer());
      ds.finish()
  }
}
pub enum AppStateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AppState<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AppState<'a> {
  type Inner = AppState<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AppState<'a> {
  pub const VT_ACTIVEEMBEDDABLEELEMENT: flatbuffers::VOffsetT = 4;
  pub const VT_ACTIVEEMBEDDABLESTATE: flatbuffers::VOffsetT = 6;
  pub const VT_DRAGGINGELEMENT: flatbuffers::VOffsetT = 8;
  pub const VT_RESIZINGELEMENT: flatbuffers::VOffsetT = 10;
  pub const VT_MULTIELEMENT: flatbuffers::VOffsetT = 12;
  pub const VT_SELECTIONELEMENT: flatbuffers::VOffsetT = 14;
  pub const VT_FRAMETOHIGHLIGHT: flatbuffers::VOffsetT = 16;
  pub const VT_FRAMERENDERINGENABLED: flatbuffers::VOffsetT = 18;
  pub const VT_FRAMERENDERINGNAME: flatbuffers::VOffsetT = 20;
  pub const VT_FRAMERENDERINGOUTLINE: flatbuffers::VOffsetT = 22;
  pub const VT_FRAMERENDERINGCLIP: flatbuffers::VOffsetT = 24;
  pub const VT_EDITINGFRAME: flatbuffers::VOffsetT = 26;
  pub const VT_ELEMENTSTOHIGHLIGHT: flatbuffers::VOffsetT = 28;
  pub const VT_EDITINGELEMENT: flatbuffers::VOffsetT = 30;
  pub const VT_CURRENTITEMSTROKECOLOR: flatbuffers::VOffsetT = 32;
  pub const VT_CURRENTITEMSTROKEPLACEMENT: flatbuffers::VOffsetT = 34;
  pub const VT_CURRENTITEMBACKGROUNDCOLOR: flatbuffers::VOffsetT = 36;
  pub const VT_CURRENTITEMFILLSTYLE: flatbuffers::VOffsetT = 38;
  pub const VT_CURRENTITEMSTROKEWIDTH: flatbuffers::VOffsetT = 40;
  pub const VT_CURRENTITEMSTROKESTYLE: flatbuffers::VOffsetT = 42;
  pub const VT_CURRENTITEMROUGHNESS: flatbuffers::VOffsetT = 44;
  pub const VT_CURRENTITEMOPACITY: flatbuffers::VOffsetT = 46;
  pub const VT_CURRENTITEMFONTFAMILY: flatbuffers::VOffsetT = 48;
  pub const VT_CURRENTITEMFONTSIZE: flatbuffers::VOffsetT = 50;
  pub const VT_CURRENTITEMTEXTALIGN: flatbuffers::VOffsetT = 52;
  pub const VT_CURRENTITEMSTARTARROWHEAD: flatbuffers::VOffsetT = 54;
  pub const VT_CURRENTITEMENDARROWHEAD: flatbuffers::VOffsetT = 56;
  pub const VT_CURRENTITEMROUNDNESS: flatbuffers::VOffsetT = 58;
  pub const VT_VIEWBACKGROUNDCOLOR: flatbuffers::VOffsetT = 60;
  pub const VT_SCOPE: flatbuffers::VOffsetT = 62;
  pub const VT_WRITINGLAYER: flatbuffers::VOffsetT = 64;
  pub const VT_GROUPS: flatbuffers::VOffsetT = 66;
  pub const VT_SCROLLX: flatbuffers::VOffsetT = 68;
  pub const VT_SCROLLY: flatbuffers::VOffsetT = 70;
  pub const VT_CURSORBUTTON: flatbuffers::VOffsetT = 72;
  pub const VT_SCROLLEDOUTSIDE: flatbuffers::VOffsetT = 74;
  pub const VT_NAME: flatbuffers::VOffsetT = 76;
  pub const VT_ZOOM: flatbuffers::VOffsetT = 78;
  pub const VT_LASTPOINTERDOWNWITH: flatbuffers::VOffsetT = 80;
  pub const VT_SELECTEDELEMENTIDS: flatbuffers::VOffsetT = 82;
  pub const VT_PREVIOUSSELECTEDELEMENTIDS: flatbuffers::VOffsetT = 84;
  pub const VT_SELECTEDELEMENTSAREBEINGDRAGGED: flatbuffers::VOffsetT = 86;
  pub const VT_SHOULDCACHEIGNOREZOOM: flatbuffers::VOffsetT = 88;
  pub const VT_GRIDSIZE: flatbuffers::VOffsetT = 90;
  pub const VT_SELECTEDGROUPIDS: flatbuffers::VOffsetT = 92;
  pub const VT_EDITINGGROUPID: flatbuffers::VOffsetT = 94;
  pub const VT_PASTEDIALOGSHOWN: flatbuffers::VOffsetT = 96;
  pub const VT_PASTEDIALOGDATA: flatbuffers::VOffsetT = 98;
  pub const VT_SCALERATIOLOCKED: flatbuffers::VOffsetT = 100;
  pub const VT_DISPLAYALLPOINTDISTANCES: flatbuffers::VOffsetT = 102;
  pub const VT_DISPLAYDISTANCEONDRAWING: flatbuffers::VOffsetT = 104;
  pub const VT_DISPLAYALLPOINTCOORDINATES: flatbuffers::VOffsetT = 106;
  pub const VT_DISPLAYALLPOINTINFOSELECTED: flatbuffers::VOffsetT = 108;
  pub const VT_DISPLAYROOTAXIS: flatbuffers::VOffsetT = 110;
  pub const VT_ENABLELINEBENDINGONEDIT: flatbuffers::VOffsetT = 112;
  pub const VT_ALLOWINDEPENDENTCURVEHANDLES: flatbuffers::VOffsetT = 114;
  pub const VT_COORDDECIMALPLACES: flatbuffers::VOffsetT = 116;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AppState { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AppStateArgs<'args>
  ) -> flatbuffers::WIPOffset<AppState<'bldr>> {
    let mut builder = AppStateBuilder::new(_fbb);
    builder.add_coordDecimalPlaces(args.coordDecimalPlaces);
    if let Some(x) = args.pasteDialogData { builder.add_pasteDialogData(x); }
    if let Some(x) = args.editingGroupId { builder.add_editingGroupId(x); }
    if let Some(x) = args.selectedGroupIds { builder.add_selectedGroupIds(x); }
    builder.add_gridSize(args.gridSize);
    if let Some(x) = args.previousSelectedElementIds { builder.add_previousSelectedElementIds(x); }
    if let Some(x) = args.selectedElementIds { builder.add_selectedElementIds(x); }
    if let Some(x) = args.lastPointerDownWith { builder.add_lastPointerDownWith(x); }
    builder.add_zoom(args.zoom);
    if let Some(x) = args.name { builder.add_name(x); }
    if let Some(x) = args.cursorButton { builder.add_cursorButton(x); }
    builder.add_scrollY(args.scrollY);
    builder.add_scrollX(args.scrollX);
    if let Some(x) = args.groups { builder.add_groups(x); }
    if let Some(x) = args.writingLayer { builder.add_writingLayer(x); }
    if let Some(x) = args.scope { builder.add_scope(x); }
    if let Some(x) = args.viewBackgroundColor { builder.add_viewBackgroundColor(x); }
    if let Some(x) = args.currentItemRoundness { builder.add_currentItemRoundness(x); }
    if let Some(x) = args.currentItemEndArrowhead { builder.add_currentItemEndArrowhead(x); }
    if let Some(x) = args.currentItemStartArrowhead { builder.add_currentItemStartArrowhead(x); }
    if let Some(x) = args.currentItemTextAlign { builder.add_currentItemTextAlign(x); }
    builder.add_currentItemFontSize(args.currentItemFontSize);
    builder.add_currentItemFontFamily(args.currentItemFontFamily);
    builder.add_currentItemOpacity(args.currentItemOpacity);
    builder.add_currentItemRoughness(args.currentItemRoughness);
    if let Some(x) = args.currentItemStrokeStyle { builder.add_currentItemStrokeStyle(x); }
    builder.add_currentItemStrokeWidth(args.currentItemStrokeWidth);
    if let Some(x) = args.currentItemFillStyle { builder.add_currentItemFillStyle(x); }
    if let Some(x) = args.currentItemBackgroundColor { builder.add_currentItemBackgroundColor(x); }
    builder.add_currentItemStrokePlacement(args.currentItemStrokePlacement);
    if let Some(x) = args.currentItemStrokeColor { builder.add_currentItemStrokeColor(x); }
    if let Some(x) = args.editingElement { builder.add_editingElement(x); }
    if let Some(x) = args.elementsToHighlight { builder.add_elementsToHighlight(x); }
    if let Some(x) = args.editingFrame { builder.add_editingFrame(x); }
    if let Some(x) = args.frameToHighlight { builder.add_frameToHighlight(x); }
    if let Some(x) = args.selectionElement { builder.add_selectionElement(x); }
    if let Some(x) = args.multiElement { builder.add_multiElement(x); }
    if let Some(x) = args.resizingElement { builder.add_resizingElement(x); }
    if let Some(x) = args.draggingElement { builder.add_draggingElement(x); }
    if let Some(x) = args.activeEmbeddableState { builder.add_activeEmbeddableState(x); }
    if let Some(x) = args.activeEmbeddableElement { builder.add_activeEmbeddableElement(x); }
    builder.add_allowIndependentCurveHandles(args.allowIndependentCurveHandles);
    builder.add_enableLineBendingOnEdit(args.enableLineBendingOnEdit);
    builder.add_displayRootAxis(args.displayRootAxis);
    builder.add_displayAllPointInfoSelected(args.displayAllPointInfoSelected);
    builder.add_displayAllPointCoordinates(args.displayAllPointCoordinates);
    builder.add_displayDistanceOnDrawing(args.displayDistanceOnDrawing);
    builder.add_displayAllPointDistances(args.displayAllPointDistances);
    builder.add_scaleRatioLocked(args.scaleRatioLocked);
    builder.add_pasteDialogShown(args.pasteDialogShown);
    builder.add_shouldCacheIgnoreZoom(args.shouldCacheIgnoreZoom);
    builder.add_selectedElementsAreBeingDragged(args.selectedElementsAreBeingDragged);
    builder.add_scrolledOutside(args.scrolledOutside);
    builder.add_frameRenderingClip(args.frameRenderingClip);
    builder.add_frameRenderingOutline(args.frameRenderingOutline);
    builder.add_frameRenderingName(args.frameRenderingName);
    builder.add_frameRenderingEnabled(args.frameRenderingEnabled);
    builder.finish()
  }


  #[inline]
  pub fn activeEmbeddableElement(&self) -> Option<DucElement<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucElement>>(AppState::VT_ACTIVEEMBEDDABLEELEMENT, None)}
  }
  #[inline]
  pub fn activeEmbeddableState(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_ACTIVEEMBEDDABLESTATE, None)}
  }
  #[inline]
  pub fn draggingElement(&self) -> Option<DucElement<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucElement>>(AppState::VT_DRAGGINGELEMENT, None)}
  }
  #[inline]
  pub fn resizingElement(&self) -> Option<DucElement<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucElement>>(AppState::VT_RESIZINGELEMENT, None)}
  }
  #[inline]
  pub fn multiElement(&self) -> Option<DucElement<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucElement>>(AppState::VT_MULTIELEMENT, None)}
  }
  #[inline]
  pub fn selectionElement(&self) -> Option<DucElement<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucElement>>(AppState::VT_SELECTIONELEMENT, None)}
  }
  #[inline]
  pub fn frameToHighlight(&self) -> Option<DucElement<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucElement>>(AppState::VT_FRAMETOHIGHLIGHT, None)}
  }
  #[inline]
  pub fn frameRenderingEnabled(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_FRAMERENDERINGENABLED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn frameRenderingName(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_FRAMERENDERINGNAME, Some(false)).unwrap()}
  }
  #[inline]
  pub fn frameRenderingOutline(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_FRAMERENDERINGOUTLINE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn frameRenderingClip(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_FRAMERENDERINGCLIP, Some(false)).unwrap()}
  }
  #[inline]
  pub fn editingFrame(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_EDITINGFRAME, None)}
  }
  #[inline]
  pub fn elementsToHighlight(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucElement<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucElement>>>>(AppState::VT_ELEMENTSTOHIGHLIGHT, None)}
  }
  #[inline]
  pub fn editingElement(&self) -> Option<DucElement<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucElement>>(AppState::VT_EDITINGELEMENT, None)}
  }
  #[inline]
  pub fn currentItemStrokeColor(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_CURRENTITEMSTROKECOLOR, None)}
  }
  #[inline]
  pub fn currentItemStrokePlacement(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AppState::VT_CURRENTITEMSTROKEPLACEMENT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn currentItemBackgroundColor(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_CURRENTITEMBACKGROUNDCOLOR, None)}
  }
  #[inline]
  pub fn currentItemFillStyle(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_CURRENTITEMFILLSTYLE, None)}
  }
  #[inline]
  pub fn currentItemStrokeWidth(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AppState::VT_CURRENTITEMSTROKEWIDTH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn currentItemStrokeStyle(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_CURRENTITEMSTROKESTYLE, None)}
  }
  #[inline]
  pub fn currentItemRoughness(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AppState::VT_CURRENTITEMROUGHNESS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn currentItemOpacity(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(AppState::VT_CURRENTITEMOPACITY, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn currentItemFontFamily(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AppState::VT_CURRENTITEMFONTFAMILY, Some(0)).unwrap()}
  }
  #[inline]
  pub fn currentItemFontSize(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AppState::VT_CURRENTITEMFONTSIZE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn currentItemTextAlign(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_CURRENTITEMTEXTALIGN, None)}
  }
  #[inline]
  pub fn currentItemStartArrowhead(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_CURRENTITEMSTARTARROWHEAD, None)}
  }
  #[inline]
  pub fn currentItemEndArrowhead(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_CURRENTITEMENDARROWHEAD, None)}
  }
  #[inline]
  pub fn currentItemRoundness(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_CURRENTITEMROUNDNESS, None)}
  }
  #[inline]
  pub fn viewBackgroundColor(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_VIEWBACKGROUNDCOLOR, None)}
  }
  #[inline]
  pub fn scope(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_SCOPE, None)}
  }
  #[inline]
  pub fn writingLayer(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_WRITINGLAYER, None)}
  }
  #[inline]
  pub fn groups(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucGroup<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucGroup>>>>(AppState::VT_GROUPS, None)}
  }
  #[inline]
  pub fn scrollX(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(AppState::VT_SCROLLX, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn scrollY(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(AppState::VT_SCROLLY, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn cursorButton(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_CURSORBUTTON, None)}
  }
  #[inline]
  pub fn scrolledOutside(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_SCROLLEDOUTSIDE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_NAME, None)}
  }
  #[inline]
  pub fn zoom(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(AppState::VT_ZOOM, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn lastPointerDownWith(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_LASTPOINTERDOWNWITH, None)}
  }
  #[inline]
  pub fn selectedElementIds(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(AppState::VT_SELECTEDELEMENTIDS, None)}
  }
  #[inline]
  pub fn previousSelectedElementIds(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(AppState::VT_PREVIOUSSELECTEDELEMENTIDS, None)}
  }
  #[inline]
  pub fn selectedElementsAreBeingDragged(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_SELECTEDELEMENTSAREBEINGDRAGGED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn shouldCacheIgnoreZoom(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_SHOULDCACHEIGNOREZOOM, Some(false)).unwrap()}
  }
  #[inline]
  pub fn gridSize(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AppState::VT_GRIDSIZE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn selectedGroupIds(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(AppState::VT_SELECTEDGROUPIDS, None)}
  }
  #[inline]
  pub fn editingGroupId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_EDITINGGROUPID, None)}
  }
  #[inline]
  pub fn pasteDialogShown(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_PASTEDIALOGSHOWN, Some(false)).unwrap()}
  }
  #[inline]
  pub fn pasteDialogData(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_PASTEDIALOGDATA, None)}
  }
  #[inline]
  pub fn scaleRatioLocked(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_SCALERATIOLOCKED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn displayAllPointDistances(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_DISPLAYALLPOINTDISTANCES, Some(false)).unwrap()}
  }
  #[inline]
  pub fn displayDistanceOnDrawing(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_DISPLAYDISTANCEONDRAWING, Some(false)).unwrap()}
  }
  #[inline]
  pub fn displayAllPointCoordinates(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_DISPLAYALLPOINTCOORDINATES, Some(false)).unwrap()}
  }
  #[inline]
  pub fn displayAllPointInfoSelected(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_DISPLAYALLPOINTINFOSELECTED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn displayRootAxis(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_DISPLAYROOTAXIS, Some(false)).unwrap()}
  }
  #[inline]
  pub fn enableLineBendingOnEdit(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_ENABLELINEBENDINGONEDIT, Some(false)).unwrap()}
  }
  #[inline]
  pub fn allowIndependentCurveHandles(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_ALLOWINDEPENDENTCURVEHANDLES, Some(false)).unwrap()}
  }
  #[inline]
  pub fn coordDecimalPlaces(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AppState::VT_COORDDECIMALPLACES, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for AppState<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucElement>>("activeEmbeddableElement", Self::VT_ACTIVEEMBEDDABLEELEMENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("activeEmbeddableState", Self::VT_ACTIVEEMBEDDABLESTATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucElement>>("draggingElement", Self::VT_DRAGGINGELEMENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucElement>>("resizingElement", Self::VT_RESIZINGELEMENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucElement>>("multiElement", Self::VT_MULTIELEMENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucElement>>("selectionElement", Self::VT_SELECTIONELEMENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucElement>>("frameToHighlight", Self::VT_FRAMETOHIGHLIGHT, false)?
     .visit_field::<bool>("frameRenderingEnabled", Self::VT_FRAMERENDERINGENABLED, false)?
     .visit_field::<bool>("frameRenderingName", Self::VT_FRAMERENDERINGNAME, false)?
     .visit_field::<bool>("frameRenderingOutline", Self::VT_FRAMERENDERINGOUTLINE, false)?
     .visit_field::<bool>("frameRenderingClip", Self::VT_FRAMERENDERINGCLIP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("editingFrame", Self::VT_EDITINGFRAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DucElement>>>>("elementsToHighlight", Self::VT_ELEMENTSTOHIGHLIGHT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucElement>>("editingElement", Self::VT_EDITINGELEMENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("currentItemStrokeColor", Self::VT_CURRENTITEMSTROKECOLOR, false)?
     .visit_field::<i32>("currentItemStrokePlacement", Self::VT_CURRENTITEMSTROKEPLACEMENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("currentItemBackgroundColor", Self::VT_CURRENTITEMBACKGROUNDCOLOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("currentItemFillStyle", Self::VT_CURRENTITEMFILLSTYLE, false)?
     .visit_field::<i32>("currentItemStrokeWidth", Self::VT_CURRENTITEMSTROKEWIDTH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("currentItemStrokeStyle", Self::VT_CURRENTITEMSTROKESTYLE, false)?
     .visit_field::<i32>("currentItemRoughness", Self::VT_CURRENTITEMROUGHNESS, false)?
     .visit_field::<f32>("currentItemOpacity", Self::VT_CURRENTITEMOPACITY, false)?
     .visit_field::<i32>("currentItemFontFamily", Self::VT_CURRENTITEMFONTFAMILY, false)?
     .visit_field::<i32>("currentItemFontSize", Self::VT_CURRENTITEMFONTSIZE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("currentItemTextAlign", Self::VT_CURRENTITEMTEXTALIGN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("currentItemStartArrowhead", Self::VT_CURRENTITEMSTARTARROWHEAD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("currentItemEndArrowhead", Self::VT_CURRENTITEMENDARROWHEAD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("currentItemRoundness", Self::VT_CURRENTITEMROUNDNESS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("viewBackgroundColor", Self::VT_VIEWBACKGROUNDCOLOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("scope", Self::VT_SCOPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("writingLayer", Self::VT_WRITINGLAYER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DucGroup>>>>("groups", Self::VT_GROUPS, false)?
     .visit_field::<f32>("scrollX", Self::VT_SCROLLX, false)?
     .visit_field::<f32>("scrollY", Self::VT_SCROLLY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("cursorButton", Self::VT_CURSORBUTTON, false)?
     .visit_field::<bool>("scrolledOutside", Self::VT_SCROLLEDOUTSIDE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<f32>("zoom", Self::VT_ZOOM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("lastPointerDownWith", Self::VT_LASTPOINTERDOWNWITH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("selectedElementIds", Self::VT_SELECTEDELEMENTIDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("previousSelectedElementIds", Self::VT_PREVIOUSSELECTEDELEMENTIDS, false)?
     .visit_field::<bool>("selectedElementsAreBeingDragged", Self::VT_SELECTEDELEMENTSAREBEINGDRAGGED, false)?
     .visit_field::<bool>("shouldCacheIgnoreZoom", Self::VT_SHOULDCACHEIGNOREZOOM, false)?
     .visit_field::<i32>("gridSize", Self::VT_GRIDSIZE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("selectedGroupIds", Self::VT_SELECTEDGROUPIDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("editingGroupId", Self::VT_EDITINGGROUPID, false)?
     .visit_field::<bool>("pasteDialogShown", Self::VT_PASTEDIALOGSHOWN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pasteDialogData", Self::VT_PASTEDIALOGDATA, false)?
     .visit_field::<bool>("scaleRatioLocked", Self::VT_SCALERATIOLOCKED, false)?
     .visit_field::<bool>("displayAllPointDistances", Self::VT_DISPLAYALLPOINTDISTANCES, false)?
     .visit_field::<bool>("displayDistanceOnDrawing", Self::VT_DISPLAYDISTANCEONDRAWING, false)?
     .visit_field::<bool>("displayAllPointCoordinates", Self::VT_DISPLAYALLPOINTCOORDINATES, false)?
     .visit_field::<bool>("displayAllPointInfoSelected", Self::VT_DISPLAYALLPOINTINFOSELECTED, false)?
     .visit_field::<bool>("displayRootAxis", Self::VT_DISPLAYROOTAXIS, false)?
     .visit_field::<bool>("enableLineBendingOnEdit", Self::VT_ENABLELINEBENDINGONEDIT, false)?
     .visit_field::<bool>("allowIndependentCurveHandles", Self::VT_ALLOWINDEPENDENTCURVEHANDLES, false)?
     .visit_field::<i32>("coordDecimalPlaces", Self::VT_COORDDECIMALPLACES, false)?
     .finish();
    Ok(())
  }
}
pub struct AppStateArgs<'a> {
    pub activeEmbeddableElement: Option<flatbuffers::WIPOffset<DucElement<'a>>>,
    pub activeEmbeddableState: Option<flatbuffers::WIPOffset<&'a str>>,
    pub draggingElement: Option<flatbuffers::WIPOffset<DucElement<'a>>>,
    pub resizingElement: Option<flatbuffers::WIPOffset<DucElement<'a>>>,
    pub multiElement: Option<flatbuffers::WIPOffset<DucElement<'a>>>,
    pub selectionElement: Option<flatbuffers::WIPOffset<DucElement<'a>>>,
    pub frameToHighlight: Option<flatbuffers::WIPOffset<DucElement<'a>>>,
    pub frameRenderingEnabled: bool,
    pub frameRenderingName: bool,
    pub frameRenderingOutline: bool,
    pub frameRenderingClip: bool,
    pub editingFrame: Option<flatbuffers::WIPOffset<&'a str>>,
    pub elementsToHighlight: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucElement<'a>>>>>,
    pub editingElement: Option<flatbuffers::WIPOffset<DucElement<'a>>>,
    pub currentItemStrokeColor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub currentItemStrokePlacement: i32,
    pub currentItemBackgroundColor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub currentItemFillStyle: Option<flatbuffers::WIPOffset<&'a str>>,
    pub currentItemStrokeWidth: i32,
    pub currentItemStrokeStyle: Option<flatbuffers::WIPOffset<&'a str>>,
    pub currentItemRoughness: i32,
    pub currentItemOpacity: f32,
    pub currentItemFontFamily: i32,
    pub currentItemFontSize: i32,
    pub currentItemTextAlign: Option<flatbuffers::WIPOffset<&'a str>>,
    pub currentItemStartArrowhead: Option<flatbuffers::WIPOffset<&'a str>>,
    pub currentItemEndArrowhead: Option<flatbuffers::WIPOffset<&'a str>>,
    pub currentItemRoundness: Option<flatbuffers::WIPOffset<&'a str>>,
    pub viewBackgroundColor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub scope: Option<flatbuffers::WIPOffset<&'a str>>,
    pub writingLayer: Option<flatbuffers::WIPOffset<&'a str>>,
    pub groups: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucGroup<'a>>>>>,
    pub scrollX: f32,
    pub scrollY: f32,
    pub cursorButton: Option<flatbuffers::WIPOffset<&'a str>>,
    pub scrolledOutside: bool,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub zoom: f32,
    pub lastPointerDownWith: Option<flatbuffers::WIPOffset<&'a str>>,
    pub selectedElementIds: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub previousSelectedElementIds: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub selectedElementsAreBeingDragged: bool,
    pub shouldCacheIgnoreZoom: bool,
    pub gridSize: i32,
    pub selectedGroupIds: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub editingGroupId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub pasteDialogShown: bool,
    pub pasteDialogData: Option<flatbuffers::WIPOffset<&'a str>>,
    pub scaleRatioLocked: bool,
    pub displayAllPointDistances: bool,
    pub displayDistanceOnDrawing: bool,
    pub displayAllPointCoordinates: bool,
    pub displayAllPointInfoSelected: bool,
    pub displayRootAxis: bool,
    pub enableLineBendingOnEdit: bool,
    pub allowIndependentCurveHandles: bool,
    pub coordDecimalPlaces: i32,
}
impl<'a> Default for AppStateArgs<'a> {
  #[inline]
  fn default() -> Self {
    AppStateArgs {
      activeEmbeddableElement: None,
      activeEmbeddableState: None,
      draggingElement: None,
      resizingElement: None,
      multiElement: None,
      selectionElement: None,
      frameToHighlight: None,
      frameRenderingEnabled: false,
      frameRenderingName: false,
      frameRenderingOutline: false,
      frameRenderingClip: false,
      editingFrame: None,
      elementsToHighlight: None,
      editingElement: None,
      currentItemStrokeColor: None,
      currentItemStrokePlacement: 0,
      currentItemBackgroundColor: None,
      currentItemFillStyle: None,
      currentItemStrokeWidth: 0,
      currentItemStrokeStyle: None,
      currentItemRoughness: 0,
      currentItemOpacity: 0.0,
      currentItemFontFamily: 0,
      currentItemFontSize: 0,
      currentItemTextAlign: None,
      currentItemStartArrowhead: None,
      currentItemEndArrowhead: None,
      currentItemRoundness: None,
      viewBackgroundColor: None,
      scope: None,
      writingLayer: None,
      groups: None,
      scrollX: 0.0,
      scrollY: 0.0,
      cursorButton: None,
      scrolledOutside: false,
      name: None,
      zoom: 0.0,
      lastPointerDownWith: None,
      selectedElementIds: None,
      previousSelectedElementIds: None,
      selectedElementsAreBeingDragged: false,
      shouldCacheIgnoreZoom: false,
      gridSize: 0,
      selectedGroupIds: None,
      editingGroupId: None,
      pasteDialogShown: false,
      pasteDialogData: None,
      scaleRatioLocked: false,
      displayAllPointDistances: false,
      displayDistanceOnDrawing: false,
      displayAllPointCoordinates: false,
      displayAllPointInfoSelected: false,
      displayRootAxis: false,
      enableLineBendingOnEdit: false,
      allowIndependentCurveHandles: false,
      coordDecimalPlaces: 0,
    }
  }
}

pub struct AppStateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AppStateBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_activeEmbeddableElement(&mut self, activeEmbeddableElement: flatbuffers::WIPOffset<DucElement<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucElement>>(AppState::VT_ACTIVEEMBEDDABLEELEMENT, activeEmbeddableElement);
  }
  #[inline]
  pub fn add_activeEmbeddableState(&mut self, activeEmbeddableState: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_ACTIVEEMBEDDABLESTATE, activeEmbeddableState);
  }
  #[inline]
  pub fn add_draggingElement(&mut self, draggingElement: flatbuffers::WIPOffset<DucElement<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucElement>>(AppState::VT_DRAGGINGELEMENT, draggingElement);
  }
  #[inline]
  pub fn add_resizingElement(&mut self, resizingElement: flatbuffers::WIPOffset<DucElement<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucElement>>(AppState::VT_RESIZINGELEMENT, resizingElement);
  }
  #[inline]
  pub fn add_multiElement(&mut self, multiElement: flatbuffers::WIPOffset<DucElement<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucElement>>(AppState::VT_MULTIELEMENT, multiElement);
  }
  #[inline]
  pub fn add_selectionElement(&mut self, selectionElement: flatbuffers::WIPOffset<DucElement<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucElement>>(AppState::VT_SELECTIONELEMENT, selectionElement);
  }
  #[inline]
  pub fn add_frameToHighlight(&mut self, frameToHighlight: flatbuffers::WIPOffset<DucElement<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucElement>>(AppState::VT_FRAMETOHIGHLIGHT, frameToHighlight);
  }
  #[inline]
  pub fn add_frameRenderingEnabled(&mut self, frameRenderingEnabled: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_FRAMERENDERINGENABLED, frameRenderingEnabled, false);
  }
  #[inline]
  pub fn add_frameRenderingName(&mut self, frameRenderingName: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_FRAMERENDERINGNAME, frameRenderingName, false);
  }
  #[inline]
  pub fn add_frameRenderingOutline(&mut self, frameRenderingOutline: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_FRAMERENDERINGOUTLINE, frameRenderingOutline, false);
  }
  #[inline]
  pub fn add_frameRenderingClip(&mut self, frameRenderingClip: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_FRAMERENDERINGCLIP, frameRenderingClip, false);
  }
  #[inline]
  pub fn add_editingFrame(&mut self, editingFrame: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_EDITINGFRAME, editingFrame);
  }
  #[inline]
  pub fn add_elementsToHighlight(&mut self, elementsToHighlight: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DucElement<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_ELEMENTSTOHIGHLIGHT, elementsToHighlight);
  }
  #[inline]
  pub fn add_editingElement(&mut self, editingElement: flatbuffers::WIPOffset<DucElement<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucElement>>(AppState::VT_EDITINGELEMENT, editingElement);
  }
  #[inline]
  pub fn add_currentItemStrokeColor(&mut self, currentItemStrokeColor: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_CURRENTITEMSTROKECOLOR, currentItemStrokeColor);
  }
  #[inline]
  pub fn add_currentItemStrokePlacement(&mut self, currentItemStrokePlacement: i32) {
    self.fbb_.push_slot::<i32>(AppState::VT_CURRENTITEMSTROKEPLACEMENT, currentItemStrokePlacement, 0);
  }
  #[inline]
  pub fn add_currentItemBackgroundColor(&mut self, currentItemBackgroundColor: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_CURRENTITEMBACKGROUNDCOLOR, currentItemBackgroundColor);
  }
  #[inline]
  pub fn add_currentItemFillStyle(&mut self, currentItemFillStyle: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_CURRENTITEMFILLSTYLE, currentItemFillStyle);
  }
  #[inline]
  pub fn add_currentItemStrokeWidth(&mut self, currentItemStrokeWidth: i32) {
    self.fbb_.push_slot::<i32>(AppState::VT_CURRENTITEMSTROKEWIDTH, currentItemStrokeWidth, 0);
  }
  #[inline]
  pub fn add_currentItemStrokeStyle(&mut self, currentItemStrokeStyle: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_CURRENTITEMSTROKESTYLE, currentItemStrokeStyle);
  }
  #[inline]
  pub fn add_currentItemRoughness(&mut self, currentItemRoughness: i32) {
    self.fbb_.push_slot::<i32>(AppState::VT_CURRENTITEMROUGHNESS, currentItemRoughness, 0);
  }
  #[inline]
  pub fn add_currentItemOpacity(&mut self, currentItemOpacity: f32) {
    self.fbb_.push_slot::<f32>(AppState::VT_CURRENTITEMOPACITY, currentItemOpacity, 0.0);
  }
  #[inline]
  pub fn add_currentItemFontFamily(&mut self, currentItemFontFamily: i32) {
    self.fbb_.push_slot::<i32>(AppState::VT_CURRENTITEMFONTFAMILY, currentItemFontFamily, 0);
  }
  #[inline]
  pub fn add_currentItemFontSize(&mut self, currentItemFontSize: i32) {
    self.fbb_.push_slot::<i32>(AppState::VT_CURRENTITEMFONTSIZE, currentItemFontSize, 0);
  }
  #[inline]
  pub fn add_currentItemTextAlign(&mut self, currentItemTextAlign: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_CURRENTITEMTEXTALIGN, currentItemTextAlign);
  }
  #[inline]
  pub fn add_currentItemStartArrowhead(&mut self, currentItemStartArrowhead: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_CURRENTITEMSTARTARROWHEAD, currentItemStartArrowhead);
  }
  #[inline]
  pub fn add_currentItemEndArrowhead(&mut self, currentItemEndArrowhead: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_CURRENTITEMENDARROWHEAD, currentItemEndArrowhead);
  }
  #[inline]
  pub fn add_currentItemRoundness(&mut self, currentItemRoundness: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_CURRENTITEMROUNDNESS, currentItemRoundness);
  }
  #[inline]
  pub fn add_viewBackgroundColor(&mut self, viewBackgroundColor: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_VIEWBACKGROUNDCOLOR, viewBackgroundColor);
  }
  #[inline]
  pub fn add_scope(&mut self, scope: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_SCOPE, scope);
  }
  #[inline]
  pub fn add_writingLayer(&mut self, writingLayer: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_WRITINGLAYER, writingLayer);
  }
  #[inline]
  pub fn add_groups(&mut self, groups: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DucGroup<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_GROUPS, groups);
  }
  #[inline]
  pub fn add_scrollX(&mut self, scrollX: f32) {
    self.fbb_.push_slot::<f32>(AppState::VT_SCROLLX, scrollX, 0.0);
  }
  #[inline]
  pub fn add_scrollY(&mut self, scrollY: f32) {
    self.fbb_.push_slot::<f32>(AppState::VT_SCROLLY, scrollY, 0.0);
  }
  #[inline]
  pub fn add_cursorButton(&mut self, cursorButton: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_CURSORBUTTON, cursorButton);
  }
  #[inline]
  pub fn add_scrolledOutside(&mut self, scrolledOutside: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_SCROLLEDOUTSIDE, scrolledOutside, false);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_NAME, name);
  }
  #[inline]
  pub fn add_zoom(&mut self, zoom: f32) {
    self.fbb_.push_slot::<f32>(AppState::VT_ZOOM, zoom, 0.0);
  }
  #[inline]
  pub fn add_lastPointerDownWith(&mut self, lastPointerDownWith: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_LASTPOINTERDOWNWITH, lastPointerDownWith);
  }
  #[inline]
  pub fn add_selectedElementIds(&mut self, selectedElementIds: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_SELECTEDELEMENTIDS, selectedElementIds);
  }
  #[inline]
  pub fn add_previousSelectedElementIds(&mut self, previousSelectedElementIds: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_PREVIOUSSELECTEDELEMENTIDS, previousSelectedElementIds);
  }
  #[inline]
  pub fn add_selectedElementsAreBeingDragged(&mut self, selectedElementsAreBeingDragged: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_SELECTEDELEMENTSAREBEINGDRAGGED, selectedElementsAreBeingDragged, false);
  }
  #[inline]
  pub fn add_shouldCacheIgnoreZoom(&mut self, shouldCacheIgnoreZoom: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_SHOULDCACHEIGNOREZOOM, shouldCacheIgnoreZoom, false);
  }
  #[inline]
  pub fn add_gridSize(&mut self, gridSize: i32) {
    self.fbb_.push_slot::<i32>(AppState::VT_GRIDSIZE, gridSize, 0);
  }
  #[inline]
  pub fn add_selectedGroupIds(&mut self, selectedGroupIds: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_SELECTEDGROUPIDS, selectedGroupIds);
  }
  #[inline]
  pub fn add_editingGroupId(&mut self, editingGroupId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_EDITINGGROUPID, editingGroupId);
  }
  #[inline]
  pub fn add_pasteDialogShown(&mut self, pasteDialogShown: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_PASTEDIALOGSHOWN, pasteDialogShown, false);
  }
  #[inline]
  pub fn add_pasteDialogData(&mut self, pasteDialogData: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_PASTEDIALOGDATA, pasteDialogData);
  }
  #[inline]
  pub fn add_scaleRatioLocked(&mut self, scaleRatioLocked: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_SCALERATIOLOCKED, scaleRatioLocked, false);
  }
  #[inline]
  pub fn add_displayAllPointDistances(&mut self, displayAllPointDistances: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_DISPLAYALLPOINTDISTANCES, displayAllPointDistances, false);
  }
  #[inline]
  pub fn add_displayDistanceOnDrawing(&mut self, displayDistanceOnDrawing: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_DISPLAYDISTANCEONDRAWING, displayDistanceOnDrawing, false);
  }
  #[inline]
  pub fn add_displayAllPointCoordinates(&mut self, displayAllPointCoordinates: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_DISPLAYALLPOINTCOORDINATES, displayAllPointCoordinates, false);
  }
  #[inline]
  pub fn add_displayAllPointInfoSelected(&mut self, displayAllPointInfoSelected: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_DISPLAYALLPOINTINFOSELECTED, displayAllPointInfoSelected, false);
  }
  #[inline]
  pub fn add_displayRootAxis(&mut self, displayRootAxis: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_DISPLAYROOTAXIS, displayRootAxis, false);
  }
  #[inline]
  pub fn add_enableLineBendingOnEdit(&mut self, enableLineBendingOnEdit: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_ENABLELINEBENDINGONEDIT, enableLineBendingOnEdit, false);
  }
  #[inline]
  pub fn add_allowIndependentCurveHandles(&mut self, allowIndependentCurveHandles: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_ALLOWINDEPENDENTCURVEHANDLES, allowIndependentCurveHandles, false);
  }
  #[inline]
  pub fn add_coordDecimalPlaces(&mut self, coordDecimalPlaces: i32) {
    self.fbb_.push_slot::<i32>(AppState::VT_COORDDECIMALPLACES, coordDecimalPlaces, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AppStateBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AppStateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AppState<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AppState<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AppState");
      ds.field("activeEmbeddableElement", &self.activeEmbeddableElement());
      ds.field("activeEmbeddableState", &self.activeEmbeddableState());
      ds.field("draggingElement", &self.draggingElement());
      ds.field("resizingElement", &self.resizingElement());
      ds.field("multiElement", &self.multiElement());
      ds.field("selectionElement", &self.selectionElement());
      ds.field("frameToHighlight", &self.frameToHighlight());
      ds.field("frameRenderingEnabled", &self.frameRenderingEnabled());
      ds.field("frameRenderingName", &self.frameRenderingName());
      ds.field("frameRenderingOutline", &self.frameRenderingOutline());
      ds.field("frameRenderingClip", &self.frameRenderingClip());
      ds.field("editingFrame", &self.editingFrame());
      ds.field("elementsToHighlight", &self.elementsToHighlight());
      ds.field("editingElement", &self.editingElement());
      ds.field("currentItemStrokeColor", &self.currentItemStrokeColor());
      ds.field("currentItemStrokePlacement", &self.currentItemStrokePlacement());
      ds.field("currentItemBackgroundColor", &self.currentItemBackgroundColor());
      ds.field("currentItemFillStyle", &self.currentItemFillStyle());
      ds.field("currentItemStrokeWidth", &self.currentItemStrokeWidth());
      ds.field("currentItemStrokeStyle", &self.currentItemStrokeStyle());
      ds.field("currentItemRoughness", &self.currentItemRoughness());
      ds.field("currentItemOpacity", &self.currentItemOpacity());
      ds.field("currentItemFontFamily", &self.currentItemFontFamily());
      ds.field("currentItemFontSize", &self.currentItemFontSize());
      ds.field("currentItemTextAlign", &self.currentItemTextAlign());
      ds.field("currentItemStartArrowhead", &self.currentItemStartArrowhead());
      ds.field("currentItemEndArrowhead", &self.currentItemEndArrowhead());
      ds.field("currentItemRoundness", &self.currentItemRoundness());
      ds.field("viewBackgroundColor", &self.viewBackgroundColor());
      ds.field("scope", &self.scope());
      ds.field("writingLayer", &self.writingLayer());
      ds.field("groups", &self.groups());
      ds.field("scrollX", &self.scrollX());
      ds.field("scrollY", &self.scrollY());
      ds.field("cursorButton", &self.cursorButton());
      ds.field("scrolledOutside", &self.scrolledOutside());
      ds.field("name", &self.name());
      ds.field("zoom", &self.zoom());
      ds.field("lastPointerDownWith", &self.lastPointerDownWith());
      ds.field("selectedElementIds", &self.selectedElementIds());
      ds.field("previousSelectedElementIds", &self.previousSelectedElementIds());
      ds.field("selectedElementsAreBeingDragged", &self.selectedElementsAreBeingDragged());
      ds.field("shouldCacheIgnoreZoom", &self.shouldCacheIgnoreZoom());
      ds.field("gridSize", &self.gridSize());
      ds.field("selectedGroupIds", &self.selectedGroupIds());
      ds.field("editingGroupId", &self.editingGroupId());
      ds.field("pasteDialogShown", &self.pasteDialogShown());
      ds.field("pasteDialogData", &self.pasteDialogData());
      ds.field("scaleRatioLocked", &self.scaleRatioLocked());
      ds.field("displayAllPointDistances", &self.displayAllPointDistances());
      ds.field("displayDistanceOnDrawing", &self.displayDistanceOnDrawing());
      ds.field("displayAllPointCoordinates", &self.displayAllPointCoordinates());
      ds.field("displayAllPointInfoSelected", &self.displayAllPointInfoSelected());
      ds.field("displayRootAxis", &self.displayRootAxis());
      ds.field("enableLineBendingOnEdit", &self.enableLineBendingOnEdit());
      ds.field("allowIndependentCurveHandles", &self.allowIndependentCurveHandles());
      ds.field("coordDecimalPlaces", &self.coordDecimalPlaces());
      ds.finish()
  }
}
pub enum BinaryFileDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BinaryFileData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BinaryFileData<'a> {
  type Inner = BinaryFileData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BinaryFileData<'a> {
  pub const VT_MIMETYPE: flatbuffers::VOffsetT = 4;
  pub const VT_ID: flatbuffers::VOffsetT = 6;
  pub const VT_DATA: flatbuffers::VOffsetT = 8;
  pub const VT_CREATED: flatbuffers::VOffsetT = 10;
  pub const VT_LASTRETRIEVED: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BinaryFileData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BinaryFileDataArgs<'args>
  ) -> flatbuffers::WIPOffset<BinaryFileData<'bldr>> {
    let mut builder = BinaryFileDataBuilder::new(_fbb);
    builder.add_lastRetrieved(args.lastRetrieved);
    builder.add_created(args.created);
    if let Some(x) = args.data { builder.add_data(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    if let Some(x) = args.mimeType { builder.add_mimeType(x); }
    builder.finish()
  }


  #[inline]
  pub fn mimeType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BinaryFileData::VT_MIMETYPE, None)}
  }
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BinaryFileData::VT_ID, None)}
  }
  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(BinaryFileData::VT_DATA, None)}
  }
  #[inline]
  pub fn created(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(BinaryFileData::VT_CREATED, Some(0)).unwrap()}
  }
  #[inline]
  pub fn lastRetrieved(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(BinaryFileData::VT_LASTRETRIEVED, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for BinaryFileData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("mimeType", Self::VT_MIMETYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("data", Self::VT_DATA, false)?
     .visit_field::<i64>("created", Self::VT_CREATED, false)?
     .visit_field::<i64>("lastRetrieved", Self::VT_LASTRETRIEVED, false)?
     .finish();
    Ok(())
  }
}
pub struct BinaryFileDataArgs<'a> {
    pub mimeType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub created: i64,
    pub lastRetrieved: i64,
}
impl<'a> Default for BinaryFileDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    BinaryFileDataArgs {
      mimeType: None,
      id: None,
      data: None,
      created: 0,
      lastRetrieved: 0,
    }
  }
}

pub struct BinaryFileDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BinaryFileDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_mimeType(&mut self, mimeType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryFileData::VT_MIMETYPE, mimeType);
  }
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryFileData::VT_ID, id);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryFileData::VT_DATA, data);
  }
  #[inline]
  pub fn add_created(&mut self, created: i64) {
    self.fbb_.push_slot::<i64>(BinaryFileData::VT_CREATED, created, 0);
  }
  #[inline]
  pub fn add_lastRetrieved(&mut self, lastRetrieved: i64) {
    self.fbb_.push_slot::<i64>(BinaryFileData::VT_LASTRETRIEVED, lastRetrieved, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BinaryFileDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BinaryFileDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BinaryFileData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BinaryFileData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BinaryFileData");
      ds.field("mimeType", &self.mimeType());
      ds.field("id", &self.id());
      ds.field("data", &self.data());
      ds.field("created", &self.created());
      ds.field("lastRetrieved", &self.lastRetrieved());
      ds.finish()
  }
}
pub enum BinaryFilesEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BinaryFilesEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BinaryFilesEntry<'a> {
  type Inner = BinaryFilesEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BinaryFilesEntry<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BinaryFilesEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BinaryFilesEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<BinaryFilesEntry<'bldr>> {
    let mut builder = BinaryFilesEntryBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BinaryFilesEntry::VT_KEY, None)}
  }
  #[inline]
  pub fn value(&self) -> Option<BinaryFileData<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<BinaryFileData>>(BinaryFilesEntry::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for BinaryFilesEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<BinaryFileData>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct BinaryFilesEntryArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<BinaryFileData<'a>>>,
}
impl<'a> Default for BinaryFilesEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    BinaryFilesEntryArgs {
      key: None,
      value: None,
    }
  }
}

pub struct BinaryFilesEntryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BinaryFilesEntryBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryFilesEntry::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<BinaryFileData<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<BinaryFileData>>(BinaryFilesEntry::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BinaryFilesEntryBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BinaryFilesEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BinaryFilesEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BinaryFilesEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BinaryFilesEntry");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum BinaryFilesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BinaryFiles<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BinaryFiles<'a> {
  type Inner = BinaryFiles<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BinaryFiles<'a> {
  pub const VT_ENTRIES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BinaryFiles { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BinaryFilesArgs<'args>
  ) -> flatbuffers::WIPOffset<BinaryFiles<'bldr>> {
    let mut builder = BinaryFilesBuilder::new(_fbb);
    if let Some(x) = args.entries { builder.add_entries(x); }
    builder.finish()
  }


  #[inline]
  pub fn entries(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinaryFilesEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinaryFilesEntry>>>>(BinaryFiles::VT_ENTRIES, None)}
  }
}

impl flatbuffers::Verifiable for BinaryFiles<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BinaryFilesEntry>>>>("entries", Self::VT_ENTRIES, false)?
     .finish();
    Ok(())
  }
}
pub struct BinaryFilesArgs<'a> {
    pub entries: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinaryFilesEntry<'a>>>>>,
}
impl<'a> Default for BinaryFilesArgs<'a> {
  #[inline]
  fn default() -> Self {
    BinaryFilesArgs {
      entries: None,
    }
  }
}

pub struct BinaryFilesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BinaryFilesBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_entries(&mut self, entries: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinaryFilesEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryFiles::VT_ENTRIES, entries);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BinaryFilesBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BinaryFilesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BinaryFiles<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BinaryFiles<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BinaryFiles");
      ds.field("entries", &self.entries());
      ds.finish()
  }
}
pub enum ExportedDataStateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ExportedDataState<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExportedDataState<'a> {
  type Inner = ExportedDataState<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ExportedDataState<'a> {
  pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
  pub const VT_VERSION: flatbuffers::VOffsetT = 6;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 8;
  pub const VT_ELEMENTS: flatbuffers::VOffsetT = 10;
  pub const VT_APPSTATE: flatbuffers::VOffsetT = 12;
  pub const VT_FILES: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ExportedDataState { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ExportedDataStateArgs<'args>
  ) -> flatbuffers::WIPOffset<ExportedDataState<'bldr>> {
    let mut builder = ExportedDataStateBuilder::new(_fbb);
    if let Some(x) = args.files { builder.add_files(x); }
    if let Some(x) = args.appState { builder.add_appState(x); }
    if let Some(x) = args.elements { builder.add_elements(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    builder.add_version(args.version);
    if let Some(x) = args.type_ { builder.add_type_(x); }
    builder.finish()
  }


  #[inline]
  pub fn type_(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ExportedDataState::VT_TYPE_, None)}
  }
  #[inline]
  pub fn version(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ExportedDataState::VT_VERSION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ExportedDataState::VT_SOURCE, None)}
  }
  #[inline]
  pub fn elements(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucElement<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucElement>>>>(ExportedDataState::VT_ELEMENTS, None)}
  }
  #[inline]
  pub fn appState(&self) -> Option<AppState<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<AppState>>(ExportedDataState::VT_APPSTATE, None)}
  }
  #[inline]
  pub fn files(&self) -> Option<BinaryFiles<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<BinaryFiles>>(ExportedDataState::VT_FILES, None)}
  }
}

impl flatbuffers::Verifiable for ExportedDataState<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, false)?
     .visit_field::<i32>("version", Self::VT_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DucElement>>>>("elements", Self::VT_ELEMENTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<AppState>>("appState", Self::VT_APPSTATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<BinaryFiles>>("files", Self::VT_FILES, false)?
     .finish();
    Ok(())
  }
}
pub struct ExportedDataStateArgs<'a> {
    pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
    pub version: i32,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub elements: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucElement<'a>>>>>,
    pub appState: Option<flatbuffers::WIPOffset<AppState<'a>>>,
    pub files: Option<flatbuffers::WIPOffset<BinaryFiles<'a>>>,
}
impl<'a> Default for ExportedDataStateArgs<'a> {
  #[inline]
  fn default() -> Self {
    ExportedDataStateArgs {
      type_: None,
      version: 0,
      source: None,
      elements: None,
      appState: None,
      files: None,
    }
  }
}

pub struct ExportedDataStateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ExportedDataStateBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ExportedDataState::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_version(&mut self, version: i32) {
    self.fbb_.push_slot::<i32>(ExportedDataState::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ExportedDataState::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_elements(&mut self, elements: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DucElement<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ExportedDataState::VT_ELEMENTS, elements);
  }
  #[inline]
  pub fn add_appState(&mut self, appState: flatbuffers::WIPOffset<AppState<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<AppState>>(ExportedDataState::VT_APPSTATE, appState);
  }
  #[inline]
  pub fn add_files(&mut self, files: flatbuffers::WIPOffset<BinaryFiles<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<BinaryFiles>>(ExportedDataState::VT_FILES, files);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ExportedDataStateBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ExportedDataStateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ExportedDataState<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ExportedDataState<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ExportedDataState");
      ds.field("type_", &self.type_());
      ds.field("version", &self.version());
      ds.field("source", &self.source());
      ds.field("elements", &self.elements());
      ds.field("appState", &self.appState());
      ds.field("files", &self.files());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `ExportedDataState`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_exported_data_state_unchecked`.
pub fn root_as_exported_data_state(buf: &[u8]) -> Result<ExportedDataState, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<ExportedDataState>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `ExportedDataState` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_exported_data_state_unchecked`.
pub fn size_prefixed_root_as_exported_data_state(buf: &[u8]) -> Result<ExportedDataState, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<ExportedDataState>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `ExportedDataState` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_exported_data_state_unchecked`.
pub fn root_as_exported_data_state_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ExportedDataState<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<ExportedDataState<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `ExportedDataState` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_exported_data_state_unchecked`.
pub fn size_prefixed_root_as_exported_data_state_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ExportedDataState<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<ExportedDataState<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a ExportedDataState and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `ExportedDataState`.
pub unsafe fn root_as_exported_data_state_unchecked(buf: &[u8]) -> ExportedDataState {
  flatbuffers::root_unchecked::<ExportedDataState>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed ExportedDataState and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `ExportedDataState`.
pub unsafe fn size_prefixed_root_as_exported_data_state_unchecked(buf: &[u8]) -> ExportedDataState {
  flatbuffers::size_prefixed_root_unchecked::<ExportedDataState>(buf)
}
#[inline]
pub fn finish_exported_data_state_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<ExportedDataState<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_exported_data_state_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<ExportedDataState<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod Duc

