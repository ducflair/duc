// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod duc {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

pub enum PointOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Point<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Point<'a> {
  type Inner = Point<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Point<'a> {
  pub const VT_X_V2: flatbuffers::VOffsetT = 4;
  pub const VT_Y_V2: flatbuffers::VOffsetT = 6;
  pub const VT_ISCURVE: flatbuffers::VOffsetT = 8;
  pub const VT_MIRRORING: flatbuffers::VOffsetT = 10;
  pub const VT_BORDERRADIUS: flatbuffers::VOffsetT = 12;
  pub const VT_HANDLEIN: flatbuffers::VOffsetT = 14;
  pub const VT_HANDLEOUT: flatbuffers::VOffsetT = 16;
  pub const VT_X_V3: flatbuffers::VOffsetT = 18;
  pub const VT_Y_V3: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Point { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PointArgs<'args>
  ) -> flatbuffers::WIPOffset<Point<'bldr>> {
    let mut builder = PointBuilder::new(_fbb);
    builder.add_y_v3(args.y_v3);
    builder.add_x_v3(args.x_v3);
    if let Some(x) = args.borderRadius { builder.add_borderRadius(x); }
    if let Some(x) = args.handleOut { builder.add_handleOut(x); }
    if let Some(x) = args.handleIn { builder.add_handleIn(x); }
    if let Some(x) = args.y_v2 { builder.add_y_v2(x); }
    if let Some(x) = args.x_v2 { builder.add_x_v2(x); }
    if let Some(x) = args.mirroring { builder.add_mirroring(x); }
    if let Some(x) = args.isCurve { builder.add_isCurve(x); }
    builder.finish()
  }


  #[inline]
  pub fn x_v2(&self) -> Option<f32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Point::VT_X_V2, None)}
  }
  #[inline]
  pub fn y_v2(&self) -> Option<f32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Point::VT_Y_V2, None)}
  }
  #[inline]
  pub fn isCurve(&self) -> Option<bool> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Point::VT_ISCURVE, None)}
  }
  #[inline]
  pub fn mirroring(&self) -> Option<i8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(Point::VT_MIRRORING, None)}
  }
  #[inline]
  pub fn borderRadius(&self) -> Option<f64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Point::VT_BORDERRADIUS, None)}
  }
  #[inline]
  pub fn handleIn(&self) -> Option<SimplePoint<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SimplePoint>>(Point::VT_HANDLEIN, None)}
  }
  #[inline]
  pub fn handleOut(&self) -> Option<SimplePoint<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SimplePoint>>(Point::VT_HANDLEOUT, None)}
  }
  #[inline]
  pub fn x_v3(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Point::VT_X_V3, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn y_v3(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Point::VT_Y_V3, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Point<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("x_v2", Self::VT_X_V2, false)?
     .visit_field::<f32>("y_v2", Self::VT_Y_V2, false)?
     .visit_field::<bool>("isCurve", Self::VT_ISCURVE, false)?
     .visit_field::<i8>("mirroring", Self::VT_MIRRORING, false)?
     .visit_field::<f64>("borderRadius", Self::VT_BORDERRADIUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SimplePoint>>("handleIn", Self::VT_HANDLEIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SimplePoint>>("handleOut", Self::VT_HANDLEOUT, false)?
     .visit_field::<f64>("x_v3", Self::VT_X_V3, false)?
     .visit_field::<f64>("y_v3", Self::VT_Y_V3, false)?
     .finish();
    Ok(())
  }
}
pub struct PointArgs<'a> {
    pub x_v2: Option<f32>,
    pub y_v2: Option<f32>,
    pub isCurve: Option<bool>,
    pub mirroring: Option<i8>,
    pub borderRadius: Option<f64>,
    pub handleIn: Option<flatbuffers::WIPOffset<SimplePoint<'a>>>,
    pub handleOut: Option<flatbuffers::WIPOffset<SimplePoint<'a>>>,
    pub x_v3: f64,
    pub y_v3: f64,
}
impl<'a> Default for PointArgs<'a> {
  #[inline]
  fn default() -> Self {
    PointArgs {
      x_v2: None,
      y_v2: None,
      isCurve: None,
      mirroring: None,
      borderRadius: None,
      handleIn: None,
      handleOut: None,
      x_v3: 0.0,
      y_v3: 0.0,
    }
  }
}

pub struct PointBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PointBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_x_v2(&mut self, x_v2: f32) {
    self.fbb_.push_slot_always::<f32>(Point::VT_X_V2, x_v2);
  }
  #[inline]
  pub fn add_y_v2(&mut self, y_v2: f32) {
    self.fbb_.push_slot_always::<f32>(Point::VT_Y_V2, y_v2);
  }
  #[inline]
  pub fn add_isCurve(&mut self, isCurve: bool) {
    self.fbb_.push_slot_always::<bool>(Point::VT_ISCURVE, isCurve);
  }
  #[inline]
  pub fn add_mirroring(&mut self, mirroring: i8) {
    self.fbb_.push_slot_always::<i8>(Point::VT_MIRRORING, mirroring);
  }
  #[inline]
  pub fn add_borderRadius(&mut self, borderRadius: f64) {
    self.fbb_.push_slot_always::<f64>(Point::VT_BORDERRADIUS, borderRadius);
  }
  #[inline]
  pub fn add_handleIn(&mut self, handleIn: flatbuffers::WIPOffset<SimplePoint<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SimplePoint>>(Point::VT_HANDLEIN, handleIn);
  }
  #[inline]
  pub fn add_handleOut(&mut self, handleOut: flatbuffers::WIPOffset<SimplePoint<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SimplePoint>>(Point::VT_HANDLEOUT, handleOut);
  }
  #[inline]
  pub fn add_x_v3(&mut self, x_v3: f64) {
    self.fbb_.push_slot::<f64>(Point::VT_X_V3, x_v3, 0.0);
  }
  #[inline]
  pub fn add_y_v3(&mut self, y_v3: f64) {
    self.fbb_.push_slot::<f64>(Point::VT_Y_V3, y_v3, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PointBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PointBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Point<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Point<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Point");
      ds.field("x_v2", &self.x_v2());
      ds.field("y_v2", &self.y_v2());
      ds.field("isCurve", &self.isCurve());
      ds.field("mirroring", &self.mirroring());
      ds.field("borderRadius", &self.borderRadius());
      ds.field("handleIn", &self.handleIn());
      ds.field("handleOut", &self.handleOut());
      ds.field("x_v3", &self.x_v3());
      ds.field("y_v3", &self.y_v3());
      ds.finish()
  }
}
pub enum PointBindingOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PointBinding<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PointBinding<'a> {
  type Inner = PointBinding<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PointBinding<'a> {
  pub const VT_ELEMENTID: flatbuffers::VOffsetT = 4;
  pub const VT_FOCUS: flatbuffers::VOffsetT = 6;
  pub const VT_GAP: flatbuffers::VOffsetT = 8;
  pub const VT_FIXEDPOINT: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PointBinding { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PointBindingArgs<'args>
  ) -> flatbuffers::WIPOffset<PointBinding<'bldr>> {
    let mut builder = PointBindingBuilder::new(_fbb);
    if let Some(x) = args.fixedPoint { builder.add_fixedPoint(x); }
    builder.add_gap(args.gap);
    builder.add_focus(args.focus);
    if let Some(x) = args.elementId { builder.add_elementId(x); }
    builder.finish()
  }


  #[inline]
  pub fn elementId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PointBinding::VT_ELEMENTID, None)}
  }
  #[inline]
  pub fn focus(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(PointBinding::VT_FOCUS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn gap(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(PointBinding::VT_GAP, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn fixedPoint(&self) -> Option<Point<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Point>>(PointBinding::VT_FIXEDPOINT, None)}
  }
}

impl flatbuffers::Verifiable for PointBinding<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("elementId", Self::VT_ELEMENTID, false)?
     .visit_field::<f32>("focus", Self::VT_FOCUS, false)?
     .visit_field::<f32>("gap", Self::VT_GAP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Point>>("fixedPoint", Self::VT_FIXEDPOINT, false)?
     .finish();
    Ok(())
  }
}
pub struct PointBindingArgs<'a> {
    pub elementId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub focus: f32,
    pub gap: f32,
    pub fixedPoint: Option<flatbuffers::WIPOffset<Point<'a>>>,
}
impl<'a> Default for PointBindingArgs<'a> {
  #[inline]
  fn default() -> Self {
    PointBindingArgs {
      elementId: None,
      focus: 0.0,
      gap: 0.0,
      fixedPoint: None,
    }
  }
}

pub struct PointBindingBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PointBindingBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_elementId(&mut self, elementId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PointBinding::VT_ELEMENTID, elementId);
  }
  #[inline]
  pub fn add_focus(&mut self, focus: f32) {
    self.fbb_.push_slot::<f32>(PointBinding::VT_FOCUS, focus, 0.0);
  }
  #[inline]
  pub fn add_gap(&mut self, gap: f32) {
    self.fbb_.push_slot::<f32>(PointBinding::VT_GAP, gap, 0.0);
  }
  #[inline]
  pub fn add_fixedPoint(&mut self, fixedPoint: flatbuffers::WIPOffset<Point<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Point>>(PointBinding::VT_FIXEDPOINT, fixedPoint);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PointBindingBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PointBindingBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PointBinding<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PointBinding<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PointBinding");
      ds.field("elementId", &self.elementId());
      ds.field("focus", &self.focus());
      ds.field("gap", &self.gap());
      ds.field("fixedPoint", &self.fixedPoint());
      ds.finish()
  }
}
pub enum SimplePointOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SimplePoint<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SimplePoint<'a> {
  type Inner = SimplePoint<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SimplePoint<'a> {
  pub const VT_X: flatbuffers::VOffsetT = 4;
  pub const VT_Y: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SimplePoint { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SimplePointArgs
  ) -> flatbuffers::WIPOffset<SimplePoint<'bldr>> {
    let mut builder = SimplePointBuilder::new(_fbb);
    builder.add_y(args.y);
    builder.add_x(args.x);
    builder.finish()
  }


  #[inline]
  pub fn x(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SimplePoint::VT_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SimplePoint::VT_Y, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for SimplePoint<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("x", Self::VT_X, false)?
     .visit_field::<f64>("y", Self::VT_Y, false)?
     .finish();
    Ok(())
  }
}
pub struct SimplePointArgs {
    pub x: f64,
    pub y: f64,
}
impl<'a> Default for SimplePointArgs {
  #[inline]
  fn default() -> Self {
    SimplePointArgs {
      x: 0.0,
      y: 0.0,
    }
  }
}

pub struct SimplePointBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SimplePointBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_x(&mut self, x: f64) {
    self.fbb_.push_slot::<f64>(SimplePoint::VT_X, x, 0.0);
  }
  #[inline]
  pub fn add_y(&mut self, y: f64) {
    self.fbb_.push_slot::<f64>(SimplePoint::VT_Y, y, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SimplePointBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SimplePointBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SimplePoint<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SimplePoint<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SimplePoint");
      ds.field("x", &self.x());
      ds.field("y", &self.y());
      ds.finish()
  }
}
pub enum DucElementOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucElement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucElement<'a> {
  type Inner = DucElement<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucElement<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
  pub const VT_X_V2: flatbuffers::VOffsetT = 8;
  pub const VT_Y_V2: flatbuffers::VOffsetT = 10;
  pub const VT_SCOPE: flatbuffers::VOffsetT = 14;
  pub const VT_LABEL: flatbuffers::VOffsetT = 18;
  pub const VT_ISVISIBLE: flatbuffers::VOffsetT = 20;
  pub const VT_BACKGROUNDCOLOR: flatbuffers::VOffsetT = 26;
  pub const VT_STROKECOLOR: flatbuffers::VOffsetT = 28;
  pub const VT_STROKEWIDTH_V2: flatbuffers::VOffsetT = 30;
  pub const VT_STROKEPLACEMENT: flatbuffers::VOffsetT = 36;
  pub const VT_OPACITY: flatbuffers::VOffsetT = 38;
  pub const VT_WIDTH_V2: flatbuffers::VOffsetT = 40;
  pub const VT_HEIGHT_V2: flatbuffers::VOffsetT = 42;
  pub const VT_ANGLE_V2: flatbuffers::VOffsetT = 44;
  pub const VT_ISDELETED: flatbuffers::VOffsetT = 46;
  pub const VT_GROUPIDS: flatbuffers::VOffsetT = 48;
  pub const VT_FRAMEID: flatbuffers::VOffsetT = 50;
  pub const VT_BOUNDELEMENTS: flatbuffers::VOffsetT = 52;
  pub const VT_LINK: flatbuffers::VOffsetT = 54;
  pub const VT_LOCKED: flatbuffers::VOffsetT = 56;
  pub const VT_ISSTROKEDISABLED: flatbuffers::VOffsetT = 60;
  pub const VT_ISBACKGROUNDDISABLED: flatbuffers::VOffsetT = 62;
  pub const VT_FONTSIZE_V2: flatbuffers::VOffsetT = 64;
  pub const VT_FONTFAMILY: flatbuffers::VOffsetT = 66;
  pub const VT_TEXT: flatbuffers::VOffsetT = 68;
  pub const VT_CONTAINERID: flatbuffers::VOffsetT = 74;
  pub const VT_LINEHEIGHT_V2: flatbuffers::VOffsetT = 78;
  pub const VT_AUTORESIZE: flatbuffers::VOffsetT = 80;
  pub const VT_POINTS: flatbuffers::VOffsetT = 82;
  pub const VT_LASTCOMMITTEDPOINT: flatbuffers::VOffsetT = 84;
  pub const VT_STARTBINDING: flatbuffers::VOffsetT = 86;
  pub const VT_ENDBINDING: flatbuffers::VOffsetT = 88;
  pub const VT_STARTARROWHEAD: flatbuffers::VOffsetT = 90;
  pub const VT_ENDARROWHEAD: flatbuffers::VOffsetT = 92;
  pub const VT_ELBOWED: flatbuffers::VOffsetT = 94;
  pub const VT_SIMULATEPRESSURE: flatbuffers::VOffsetT = 98;
  pub const VT_FILEID: flatbuffers::VOffsetT = 100;
  pub const VT_STATUS: flatbuffers::VOffsetT = 102;
  pub const VT_ISCOLLAPSED: flatbuffers::VOffsetT = 106;
  pub const VT_NAME: flatbuffers::VOffsetT = 108;
  pub const VT_GROUPIDREF: flatbuffers::VOffsetT = 110;
  pub const VT_STROKESTYLE_V3: flatbuffers::VOffsetT = 112;
  pub const VT_FILLSTYLE_V3: flatbuffers::VOffsetT = 114;
  pub const VT_TEXTALIGN_V3: flatbuffers::VOffsetT = 116;
  pub const VT_VERTICALALIGN_V3: flatbuffers::VOffsetT = 118;
  pub const VT_X_V3: flatbuffers::VOffsetT = 120;
  pub const VT_Y_V3: flatbuffers::VOffsetT = 122;
  pub const VT_SCALE_V3: flatbuffers::VOffsetT = 124;
  pub const VT_PRESSURES_V3: flatbuffers::VOffsetT = 126;
  pub const VT_STROKEWIDTH_V3: flatbuffers::VOffsetT = 128;
  pub const VT_ANGLE_V3: flatbuffers::VOffsetT = 130;
  pub const VT_BORDERRADIUS: flatbuffers::VOffsetT = 132;
  pub const VT_WIDTH_V3: flatbuffers::VOffsetT = 134;
  pub const VT_HEIGHT_V3: flatbuffers::VOffsetT = 136;
  pub const VT_FONTSIZE_V3: flatbuffers::VOffsetT = 138;
  pub const VT_LINEHEIGHT_V3: flatbuffers::VOffsetT = 140;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucElement { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucElementArgs<'args>
  ) -> flatbuffers::WIPOffset<DucElement<'bldr>> {
    let mut builder = DucElementBuilder::new(_fbb);
    if let Some(x) = args.lineHeight_v3 { builder.add_lineHeight_v3(x); }
    if let Some(x) = args.fontSize_v3 { builder.add_fontSize_v3(x); }
    builder.add_height_v3(args.height_v3);
    builder.add_width_v3(args.width_v3);
    builder.add_borderRadius(args.borderRadius);
    builder.add_angle_v3(args.angle_v3);
    builder.add_strokeWidth_v3(args.strokeWidth_v3);
    builder.add_y_v3(args.y_v3);
    builder.add_x_v3(args.x_v3);
    if let Some(x) = args.pressures_v3 { builder.add_pressures_v3(x); }
    if let Some(x) = args.scale_v3 { builder.add_scale_v3(x); }
    if let Some(x) = args.groupIdRef { builder.add_groupIdRef(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    if let Some(x) = args.status { builder.add_status(x); }
    if let Some(x) = args.fileId { builder.add_fileId(x); }
    if let Some(x) = args.endArrowhead { builder.add_endArrowhead(x); }
    if let Some(x) = args.startArrowhead { builder.add_startArrowhead(x); }
    if let Some(x) = args.endBinding { builder.add_endBinding(x); }
    if let Some(x) = args.startBinding { builder.add_startBinding(x); }
    if let Some(x) = args.lastCommittedPoint { builder.add_lastCommittedPoint(x); }
    if let Some(x) = args.points { builder.add_points(x); }
    if let Some(x) = args.lineHeight_v2 { builder.add_lineHeight_v2(x); }
    if let Some(x) = args.containerId { builder.add_containerId(x); }
    if let Some(x) = args.text { builder.add_text(x); }
    if let Some(x) = args.fontFamily { builder.add_fontFamily(x); }
    if let Some(x) = args.fontSize_v2 { builder.add_fontSize_v2(x); }
    if let Some(x) = args.link { builder.add_link(x); }
    if let Some(x) = args.boundElements { builder.add_boundElements(x); }
    if let Some(x) = args.frameId { builder.add_frameId(x); }
    if let Some(x) = args.groupIds { builder.add_groupIds(x); }
    if let Some(x) = args.angle_v2 { builder.add_angle_v2(x); }
    if let Some(x) = args.height_v2 { builder.add_height_v2(x); }
    if let Some(x) = args.width_v2 { builder.add_width_v2(x); }
    builder.add_opacity(args.opacity);
    if let Some(x) = args.strokeWidth_v2 { builder.add_strokeWidth_v2(x); }
    if let Some(x) = args.strokeColor { builder.add_strokeColor(x); }
    if let Some(x) = args.backgroundColor { builder.add_backgroundColor(x); }
    if let Some(x) = args.label { builder.add_label(x); }
    if let Some(x) = args.scope { builder.add_scope(x); }
    if let Some(x) = args.y_v2 { builder.add_y_v2(x); }
    if let Some(x) = args.x_v2 { builder.add_x_v2(x); }
    if let Some(x) = args.type_ { builder.add_type_(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_verticalAlign_v3(args.verticalAlign_v3);
    if let Some(x) = args.textAlign_v3 { builder.add_textAlign_v3(x); }
    builder.add_fillStyle_v3(args.fillStyle_v3);
    builder.add_strokeStyle_v3(args.strokeStyle_v3);
    if let Some(x) = args.isCollapsed { builder.add_isCollapsed(x); }
    if let Some(x) = args.simulatePressure { builder.add_simulatePressure(x); }
    if let Some(x) = args.elbowed { builder.add_elbowed(x); }
    if let Some(x) = args.autoResize { builder.add_autoResize(x); }
    builder.add_isBackgroundDisabled(args.isBackgroundDisabled);
    builder.add_isStrokeDisabled(args.isStrokeDisabled);
    builder.add_locked(args.locked);
    builder.add_isDeleted(args.isDeleted);
    builder.add_strokePlacement(args.strokePlacement);
    builder.add_isVisible(args.isVisible);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_ID, None)}
  }
  #[inline]
  pub fn type_(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_TYPE_, None)}
  }
  #[inline]
  pub fn x_v2(&self) -> Option<f32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucElement::VT_X_V2, None)}
  }
  #[inline]
  pub fn y_v2(&self) -> Option<f32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucElement::VT_Y_V2, None)}
  }
  #[inline]
  pub fn scope(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_SCOPE, None)}
  }
  #[inline]
  pub fn label(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_LABEL, None)}
  }
  #[inline]
  pub fn isVisible(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucElement::VT_ISVISIBLE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn backgroundColor(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_BACKGROUNDCOLOR, None)}
  }
  #[inline]
  pub fn strokeColor(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_STROKECOLOR, None)}
  }
  #[inline]
  pub fn strokeWidth_v2(&self) -> Option<i32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DucElement::VT_STROKEWIDTH_V2, None)}
  }
  #[inline]
  pub fn strokePlacement(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(DucElement::VT_STROKEPLACEMENT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn opacity(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucElement::VT_OPACITY, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn width_v2(&self) -> Option<f32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucElement::VT_WIDTH_V2, None)}
  }
  #[inline]
  pub fn height_v2(&self) -> Option<f32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucElement::VT_HEIGHT_V2, None)}
  }
  #[inline]
  pub fn angle_v2(&self) -> Option<f32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucElement::VT_ANGLE_V2, None)}
  }
  #[inline]
  pub fn isDeleted(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucElement::VT_ISDELETED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn groupIds(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(DucElement::VT_GROUPIDS, None)}
  }
  #[inline]
  pub fn frameId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_FRAMEID, None)}
  }
  #[inline]
  pub fn boundElements(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BoundElement<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BoundElement>>>>(DucElement::VT_BOUNDELEMENTS, None)}
  }
  #[inline]
  pub fn link(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_LINK, None)}
  }
  #[inline]
  pub fn locked(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucElement::VT_LOCKED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn isStrokeDisabled(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucElement::VT_ISSTROKEDISABLED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn isBackgroundDisabled(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucElement::VT_ISBACKGROUNDDISABLED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn fontSize_v2(&self) -> Option<i32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DucElement::VT_FONTSIZE_V2, None)}
  }
  #[inline]
  pub fn fontFamily(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_FONTFAMILY, None)}
  }
  #[inline]
  pub fn text(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_TEXT, None)}
  }
  #[inline]
  pub fn containerId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_CONTAINERID, None)}
  }
  #[inline]
  pub fn lineHeight_v2(&self) -> Option<f32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucElement::VT_LINEHEIGHT_V2, None)}
  }
  #[inline]
  pub fn autoResize(&self) -> Option<bool> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucElement::VT_AUTORESIZE, None)}
  }
  #[inline]
  pub fn points(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Point<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Point>>>>(DucElement::VT_POINTS, None)}
  }
  #[inline]
  pub fn lastCommittedPoint(&self) -> Option<Point<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Point>>(DucElement::VT_LASTCOMMITTEDPOINT, None)}
  }
  #[inline]
  pub fn startBinding(&self) -> Option<PointBinding<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<PointBinding>>(DucElement::VT_STARTBINDING, None)}
  }
  #[inline]
  pub fn endBinding(&self) -> Option<PointBinding<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<PointBinding>>(DucElement::VT_ENDBINDING, None)}
  }
  #[inline]
  pub fn startArrowhead(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_STARTARROWHEAD, None)}
  }
  #[inline]
  pub fn endArrowhead(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_ENDARROWHEAD, None)}
  }
  #[inline]
  pub fn elbowed(&self) -> Option<bool> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucElement::VT_ELBOWED, None)}
  }
  #[inline]
  pub fn simulatePressure(&self) -> Option<bool> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucElement::VT_SIMULATEPRESSURE, None)}
  }
  #[inline]
  pub fn fileId(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_FILEID, None)}
  }
  #[inline]
  pub fn status(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_STATUS, None)}
  }
  #[inline]
  pub fn isCollapsed(&self) -> Option<bool> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucElement::VT_ISCOLLAPSED, None)}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_NAME, None)}
  }
  #[inline]
  pub fn groupIdRef(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_GROUPIDREF, None)}
  }
  #[inline]
  pub fn strokeStyle_v3(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(DucElement::VT_STROKESTYLE_V3, Some(0)).unwrap()}
  }
  #[inline]
  pub fn fillStyle_v3(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(DucElement::VT_FILLSTYLE_V3, Some(0)).unwrap()}
  }
  #[inline]
  pub fn textAlign_v3(&self) -> Option<i8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(DucElement::VT_TEXTALIGN_V3, None)}
  }
  #[inline]
  pub fn verticalAlign_v3(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(DucElement::VT_VERTICALALIGN_V3, Some(0)).unwrap()}
  }
  #[inline]
  pub fn x_v3(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucElement::VT_X_V3, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn y_v3(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucElement::VT_Y_V3, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn scale_v3(&self) -> Option<SimplePoint<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SimplePoint>>(DucElement::VT_SCALE_V3, None)}
  }
  #[inline]
  pub fn pressures_v3(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(DucElement::VT_PRESSURES_V3, None)}
  }
  #[inline]
  pub fn strokeWidth_v3(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucElement::VT_STROKEWIDTH_V3, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn angle_v3(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucElement::VT_ANGLE_V3, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn borderRadius(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucElement::VT_BORDERRADIUS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn width_v3(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucElement::VT_WIDTH_V3, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn height_v3(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucElement::VT_HEIGHT_V3, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn fontSize_v3(&self) -> Option<f64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucElement::VT_FONTSIZE_V3, None)}
  }
  #[inline]
  pub fn lineHeight_v3(&self) -> Option<f64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucElement::VT_LINEHEIGHT_V3, None)}
  }
}

impl flatbuffers::Verifiable for DucElement<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, false)?
     .visit_field::<f32>("x_v2", Self::VT_X_V2, false)?
     .visit_field::<f32>("y_v2", Self::VT_Y_V2, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("scope", Self::VT_SCOPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("label", Self::VT_LABEL, false)?
     .visit_field::<bool>("isVisible", Self::VT_ISVISIBLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("backgroundColor", Self::VT_BACKGROUNDCOLOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("strokeColor", Self::VT_STROKECOLOR, false)?
     .visit_field::<i32>("strokeWidth_v2", Self::VT_STROKEWIDTH_V2, false)?
     .visit_field::<i8>("strokePlacement", Self::VT_STROKEPLACEMENT, false)?
     .visit_field::<f32>("opacity", Self::VT_OPACITY, false)?
     .visit_field::<f32>("width_v2", Self::VT_WIDTH_V2, false)?
     .visit_field::<f32>("height_v2", Self::VT_HEIGHT_V2, false)?
     .visit_field::<f32>("angle_v2", Self::VT_ANGLE_V2, false)?
     .visit_field::<bool>("isDeleted", Self::VT_ISDELETED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("groupIds", Self::VT_GROUPIDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("frameId", Self::VT_FRAMEID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BoundElement>>>>("boundElements", Self::VT_BOUNDELEMENTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("link", Self::VT_LINK, false)?
     .visit_field::<bool>("locked", Self::VT_LOCKED, false)?
     .visit_field::<bool>("isStrokeDisabled", Self::VT_ISSTROKEDISABLED, false)?
     .visit_field::<bool>("isBackgroundDisabled", Self::VT_ISBACKGROUNDDISABLED, false)?
     .visit_field::<i32>("fontSize_v2", Self::VT_FONTSIZE_V2, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("fontFamily", Self::VT_FONTFAMILY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("text", Self::VT_TEXT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("containerId", Self::VT_CONTAINERID, false)?
     .visit_field::<f32>("lineHeight_v2", Self::VT_LINEHEIGHT_V2, false)?
     .visit_field::<bool>("autoResize", Self::VT_AUTORESIZE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Point>>>>("points", Self::VT_POINTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Point>>("lastCommittedPoint", Self::VT_LASTCOMMITTEDPOINT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<PointBinding>>("startBinding", Self::VT_STARTBINDING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<PointBinding>>("endBinding", Self::VT_ENDBINDING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("startArrowhead", Self::VT_STARTARROWHEAD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("endArrowhead", Self::VT_ENDARROWHEAD, false)?
     .visit_field::<bool>("elbowed", Self::VT_ELBOWED, false)?
     .visit_field::<bool>("simulatePressure", Self::VT_SIMULATEPRESSURE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("fileId", Self::VT_FILEID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("status", Self::VT_STATUS, false)?
     .visit_field::<bool>("isCollapsed", Self::VT_ISCOLLAPSED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("groupIdRef", Self::VT_GROUPIDREF, false)?
     .visit_field::<i8>("strokeStyle_v3", Self::VT_STROKESTYLE_V3, false)?
     .visit_field::<i8>("fillStyle_v3", Self::VT_FILLSTYLE_V3, false)?
     .visit_field::<i8>("textAlign_v3", Self::VT_TEXTALIGN_V3, false)?
     .visit_field::<i8>("verticalAlign_v3", Self::VT_VERTICALALIGN_V3, false)?
     .visit_field::<f64>("x_v3", Self::VT_X_V3, false)?
     .visit_field::<f64>("y_v3", Self::VT_Y_V3, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SimplePoint>>("scale_v3", Self::VT_SCALE_V3, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("pressures_v3", Self::VT_PRESSURES_V3, false)?
     .visit_field::<f64>("strokeWidth_v3", Self::VT_STROKEWIDTH_V3, false)?
     .visit_field::<f64>("angle_v3", Self::VT_ANGLE_V3, false)?
     .visit_field::<f64>("borderRadius", Self::VT_BORDERRADIUS, false)?
     .visit_field::<f64>("width_v3", Self::VT_WIDTH_V3, false)?
     .visit_field::<f64>("height_v3", Self::VT_HEIGHT_V3, false)?
     .visit_field::<f64>("fontSize_v3", Self::VT_FONTSIZE_V3, false)?
     .visit_field::<f64>("lineHeight_v3", Self::VT_LINEHEIGHT_V3, false)?
     .finish();
    Ok(())
  }
}
pub struct DucElementArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
    pub x_v2: Option<f32>,
    pub y_v2: Option<f32>,
    pub scope: Option<flatbuffers::WIPOffset<&'a str>>,
    pub label: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isVisible: bool,
    pub backgroundColor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub strokeColor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub strokeWidth_v2: Option<i32>,
    pub strokePlacement: i8,
    pub opacity: f32,
    pub width_v2: Option<f32>,
    pub height_v2: Option<f32>,
    pub angle_v2: Option<f32>,
    pub isDeleted: bool,
    pub groupIds: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub frameId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub boundElements: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BoundElement<'a>>>>>,
    pub link: Option<flatbuffers::WIPOffset<&'a str>>,
    pub locked: bool,
    pub isStrokeDisabled: bool,
    pub isBackgroundDisabled: bool,
    pub fontSize_v2: Option<i32>,
    pub fontFamily: Option<flatbuffers::WIPOffset<&'a str>>,
    pub text: Option<flatbuffers::WIPOffset<&'a str>>,
    pub containerId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lineHeight_v2: Option<f32>,
    pub autoResize: Option<bool>,
    pub points: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Point<'a>>>>>,
    pub lastCommittedPoint: Option<flatbuffers::WIPOffset<Point<'a>>>,
    pub startBinding: Option<flatbuffers::WIPOffset<PointBinding<'a>>>,
    pub endBinding: Option<flatbuffers::WIPOffset<PointBinding<'a>>>,
    pub startArrowhead: Option<flatbuffers::WIPOffset<&'a str>>,
    pub endArrowhead: Option<flatbuffers::WIPOffset<&'a str>>,
    pub elbowed: Option<bool>,
    pub simulatePressure: Option<bool>,
    pub fileId: Option<flatbuffers::WIPOffset<&'a str>>,
    pub status: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isCollapsed: Option<bool>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub groupIdRef: Option<flatbuffers::WIPOffset<&'a str>>,
    pub strokeStyle_v3: i8,
    pub fillStyle_v3: i8,
    pub textAlign_v3: Option<i8>,
    pub verticalAlign_v3: i8,
    pub x_v3: f64,
    pub y_v3: f64,
    pub scale_v3: Option<flatbuffers::WIPOffset<SimplePoint<'a>>>,
    pub pressures_v3: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub strokeWidth_v3: f64,
    pub angle_v3: f64,
    pub borderRadius: f64,
    pub width_v3: f64,
    pub height_v3: f64,
    pub fontSize_v3: Option<f64>,
    pub lineHeight_v3: Option<f64>,
}
impl<'a> Default for DucElementArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucElementArgs {
      id: None,
      type_: None,
      x_v2: None,
      y_v2: None,
      scope: None,
      label: None,
      isVisible: false,
      backgroundColor: None,
      strokeColor: None,
      strokeWidth_v2: None,
      strokePlacement: 0,
      opacity: 0.0,
      width_v2: None,
      height_v2: None,
      angle_v2: None,
      isDeleted: false,
      groupIds: None,
      frameId: None,
      boundElements: None,
      link: None,
      locked: false,
      isStrokeDisabled: false,
      isBackgroundDisabled: false,
      fontSize_v2: None,
      fontFamily: None,
      text: None,
      containerId: None,
      lineHeight_v2: None,
      autoResize: None,
      points: None,
      lastCommittedPoint: None,
      startBinding: None,
      endBinding: None,
      startArrowhead: None,
      endArrowhead: None,
      elbowed: None,
      simulatePressure: None,
      fileId: None,
      status: None,
      isCollapsed: None,
      name: None,
      groupIdRef: None,
      strokeStyle_v3: 0,
      fillStyle_v3: 0,
      textAlign_v3: None,
      verticalAlign_v3: 0,
      x_v3: 0.0,
      y_v3: 0.0,
      scale_v3: None,
      pressures_v3: None,
      strokeWidth_v3: 0.0,
      angle_v3: 0.0,
      borderRadius: 0.0,
      width_v3: 0.0,
      height_v3: 0.0,
      fontSize_v3: None,
      lineHeight_v3: None,
    }
  }
}

pub struct DucElementBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucElementBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_ID, id);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_x_v2(&mut self, x_v2: f32) {
    self.fbb_.push_slot_always::<f32>(DucElement::VT_X_V2, x_v2);
  }
  #[inline]
  pub fn add_y_v2(&mut self, y_v2: f32) {
    self.fbb_.push_slot_always::<f32>(DucElement::VT_Y_V2, y_v2);
  }
  #[inline]
  pub fn add_scope(&mut self, scope: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_SCOPE, scope);
  }
  #[inline]
  pub fn add_label(&mut self, label: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_LABEL, label);
  }
  #[inline]
  pub fn add_isVisible(&mut self, isVisible: bool) {
    self.fbb_.push_slot::<bool>(DucElement::VT_ISVISIBLE, isVisible, false);
  }
  #[inline]
  pub fn add_backgroundColor(&mut self, backgroundColor: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_BACKGROUNDCOLOR, backgroundColor);
  }
  #[inline]
  pub fn add_strokeColor(&mut self, strokeColor: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_STROKECOLOR, strokeColor);
  }
  #[inline]
  pub fn add_strokeWidth_v2(&mut self, strokeWidth_v2: i32) {
    self.fbb_.push_slot_always::<i32>(DucElement::VT_STROKEWIDTH_V2, strokeWidth_v2);
  }
  #[inline]
  pub fn add_strokePlacement(&mut self, strokePlacement: i8) {
    self.fbb_.push_slot::<i8>(DucElement::VT_STROKEPLACEMENT, strokePlacement, 0);
  }
  #[inline]
  pub fn add_opacity(&mut self, opacity: f32) {
    self.fbb_.push_slot::<f32>(DucElement::VT_OPACITY, opacity, 0.0);
  }
  #[inline]
  pub fn add_width_v2(&mut self, width_v2: f32) {
    self.fbb_.push_slot_always::<f32>(DucElement::VT_WIDTH_V2, width_v2);
  }
  #[inline]
  pub fn add_height_v2(&mut self, height_v2: f32) {
    self.fbb_.push_slot_always::<f32>(DucElement::VT_HEIGHT_V2, height_v2);
  }
  #[inline]
  pub fn add_angle_v2(&mut self, angle_v2: f32) {
    self.fbb_.push_slot_always::<f32>(DucElement::VT_ANGLE_V2, angle_v2);
  }
  #[inline]
  pub fn add_isDeleted(&mut self, isDeleted: bool) {
    self.fbb_.push_slot::<bool>(DucElement::VT_ISDELETED, isDeleted, false);
  }
  #[inline]
  pub fn add_groupIds(&mut self, groupIds: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_GROUPIDS, groupIds);
  }
  #[inline]
  pub fn add_frameId(&mut self, frameId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_FRAMEID, frameId);
  }
  #[inline]
  pub fn add_boundElements(&mut self, boundElements: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BoundElement<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_BOUNDELEMENTS, boundElements);
  }
  #[inline]
  pub fn add_link(&mut self, link: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_LINK, link);
  }
  #[inline]
  pub fn add_locked(&mut self, locked: bool) {
    self.fbb_.push_slot::<bool>(DucElement::VT_LOCKED, locked, false);
  }
  #[inline]
  pub fn add_isStrokeDisabled(&mut self, isStrokeDisabled: bool) {
    self.fbb_.push_slot::<bool>(DucElement::VT_ISSTROKEDISABLED, isStrokeDisabled, false);
  }
  #[inline]
  pub fn add_isBackgroundDisabled(&mut self, isBackgroundDisabled: bool) {
    self.fbb_.push_slot::<bool>(DucElement::VT_ISBACKGROUNDDISABLED, isBackgroundDisabled, false);
  }
  #[inline]
  pub fn add_fontSize_v2(&mut self, fontSize_v2: i32) {
    self.fbb_.push_slot_always::<i32>(DucElement::VT_FONTSIZE_V2, fontSize_v2);
  }
  #[inline]
  pub fn add_fontFamily(&mut self, fontFamily: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_FONTFAMILY, fontFamily);
  }
  #[inline]
  pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_TEXT, text);
  }
  #[inline]
  pub fn add_containerId(&mut self, containerId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_CONTAINERID, containerId);
  }
  #[inline]
  pub fn add_lineHeight_v2(&mut self, lineHeight_v2: f32) {
    self.fbb_.push_slot_always::<f32>(DucElement::VT_LINEHEIGHT_V2, lineHeight_v2);
  }
  #[inline]
  pub fn add_autoResize(&mut self, autoResize: bool) {
    self.fbb_.push_slot_always::<bool>(DucElement::VT_AUTORESIZE, autoResize);
  }
  #[inline]
  pub fn add_points(&mut self, points: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Point<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_POINTS, points);
  }
  #[inline]
  pub fn add_lastCommittedPoint(&mut self, lastCommittedPoint: flatbuffers::WIPOffset<Point<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Point>>(DucElement::VT_LASTCOMMITTEDPOINT, lastCommittedPoint);
  }
  #[inline]
  pub fn add_startBinding(&mut self, startBinding: flatbuffers::WIPOffset<PointBinding<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PointBinding>>(DucElement::VT_STARTBINDING, startBinding);
  }
  #[inline]
  pub fn add_endBinding(&mut self, endBinding: flatbuffers::WIPOffset<PointBinding<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PointBinding>>(DucElement::VT_ENDBINDING, endBinding);
  }
  #[inline]
  pub fn add_startArrowhead(&mut self, startArrowhead: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_STARTARROWHEAD, startArrowhead);
  }
  #[inline]
  pub fn add_endArrowhead(&mut self, endArrowhead: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_ENDARROWHEAD, endArrowhead);
  }
  #[inline]
  pub fn add_elbowed(&mut self, elbowed: bool) {
    self.fbb_.push_slot_always::<bool>(DucElement::VT_ELBOWED, elbowed);
  }
  #[inline]
  pub fn add_simulatePressure(&mut self, simulatePressure: bool) {
    self.fbb_.push_slot_always::<bool>(DucElement::VT_SIMULATEPRESSURE, simulatePressure);
  }
  #[inline]
  pub fn add_fileId(&mut self, fileId: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_FILEID, fileId);
  }
  #[inline]
  pub fn add_status(&mut self, status: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_STATUS, status);
  }
  #[inline]
  pub fn add_isCollapsed(&mut self, isCollapsed: bool) {
    self.fbb_.push_slot_always::<bool>(DucElement::VT_ISCOLLAPSED, isCollapsed);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_NAME, name);
  }
  #[inline]
  pub fn add_groupIdRef(&mut self, groupIdRef: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_GROUPIDREF, groupIdRef);
  }
  #[inline]
  pub fn add_strokeStyle_v3(&mut self, strokeStyle_v3: i8) {
    self.fbb_.push_slot::<i8>(DucElement::VT_STROKESTYLE_V3, strokeStyle_v3, 0);
  }
  #[inline]
  pub fn add_fillStyle_v3(&mut self, fillStyle_v3: i8) {
    self.fbb_.push_slot::<i8>(DucElement::VT_FILLSTYLE_V3, fillStyle_v3, 0);
  }
  #[inline]
  pub fn add_textAlign_v3(&mut self, textAlign_v3: i8) {
    self.fbb_.push_slot_always::<i8>(DucElement::VT_TEXTALIGN_V3, textAlign_v3);
  }
  #[inline]
  pub fn add_verticalAlign_v3(&mut self, verticalAlign_v3: i8) {
    self.fbb_.push_slot::<i8>(DucElement::VT_VERTICALALIGN_V3, verticalAlign_v3, 0);
  }
  #[inline]
  pub fn add_x_v3(&mut self, x_v3: f64) {
    self.fbb_.push_slot::<f64>(DucElement::VT_X_V3, x_v3, 0.0);
  }
  #[inline]
  pub fn add_y_v3(&mut self, y_v3: f64) {
    self.fbb_.push_slot::<f64>(DucElement::VT_Y_V3, y_v3, 0.0);
  }
  #[inline]
  pub fn add_scale_v3(&mut self, scale_v3: flatbuffers::WIPOffset<SimplePoint<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SimplePoint>>(DucElement::VT_SCALE_V3, scale_v3);
  }
  #[inline]
  pub fn add_pressures_v3(&mut self, pressures_v3: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_PRESSURES_V3, pressures_v3);
  }
  #[inline]
  pub fn add_strokeWidth_v3(&mut self, strokeWidth_v3: f64) {
    self.fbb_.push_slot::<f64>(DucElement::VT_STROKEWIDTH_V3, strokeWidth_v3, 0.0);
  }
  #[inline]
  pub fn add_angle_v3(&mut self, angle_v3: f64) {
    self.fbb_.push_slot::<f64>(DucElement::VT_ANGLE_V3, angle_v3, 0.0);
  }
  #[inline]
  pub fn add_borderRadius(&mut self, borderRadius: f64) {
    self.fbb_.push_slot::<f64>(DucElement::VT_BORDERRADIUS, borderRadius, 0.0);
  }
  #[inline]
  pub fn add_width_v3(&mut self, width_v3: f64) {
    self.fbb_.push_slot::<f64>(DucElement::VT_WIDTH_V3, width_v3, 0.0);
  }
  #[inline]
  pub fn add_height_v3(&mut self, height_v3: f64) {
    self.fbb_.push_slot::<f64>(DucElement::VT_HEIGHT_V3, height_v3, 0.0);
  }
  #[inline]
  pub fn add_fontSize_v3(&mut self, fontSize_v3: f64) {
    self.fbb_.push_slot_always::<f64>(DucElement::VT_FONTSIZE_V3, fontSize_v3);
  }
  #[inline]
  pub fn add_lineHeight_v3(&mut self, lineHeight_v3: f64) {
    self.fbb_.push_slot_always::<f64>(DucElement::VT_LINEHEIGHT_V3, lineHeight_v3);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucElementBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucElementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucElement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucElement<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucElement");
      ds.field("id", &self.id());
      ds.field("type_", &self.type_());
      ds.field("x_v2", &self.x_v2());
      ds.field("y_v2", &self.y_v2());
      ds.field("scope", &self.scope());
      ds.field("label", &self.label());
      ds.field("isVisible", &self.isVisible());
      ds.field("backgroundColor", &self.backgroundColor());
      ds.field("strokeColor", &self.strokeColor());
      ds.field("strokeWidth_v2", &self.strokeWidth_v2());
      ds.field("strokePlacement", &self.strokePlacement());
      ds.field("opacity", &self.opacity());
      ds.field("width_v2", &self.width_v2());
      ds.field("height_v2", &self.height_v2());
      ds.field("angle_v2", &self.angle_v2());
      ds.field("isDeleted", &self.isDeleted());
      ds.field("groupIds", &self.groupIds());
      ds.field("frameId", &self.frameId());
      ds.field("boundElements", &self.boundElements());
      ds.field("link", &self.link());
      ds.field("locked", &self.locked());
      ds.field("isStrokeDisabled", &self.isStrokeDisabled());
      ds.field("isBackgroundDisabled", &self.isBackgroundDisabled());
      ds.field("fontSize_v2", &self.fontSize_v2());
      ds.field("fontFamily", &self.fontFamily());
      ds.field("text", &self.text());
      ds.field("containerId", &self.containerId());
      ds.field("lineHeight_v2", &self.lineHeight_v2());
      ds.field("autoResize", &self.autoResize());
      ds.field("points", &self.points());
      ds.field("lastCommittedPoint", &self.lastCommittedPoint());
      ds.field("startBinding", &self.startBinding());
      ds.field("endBinding", &self.endBinding());
      ds.field("startArrowhead", &self.startArrowhead());
      ds.field("endArrowhead", &self.endArrowhead());
      ds.field("elbowed", &self.elbowed());
      ds.field("simulatePressure", &self.simulatePressure());
      ds.field("fileId", &self.fileId());
      ds.field("status", &self.status());
      ds.field("isCollapsed", &self.isCollapsed());
      ds.field("name", &self.name());
      ds.field("groupIdRef", &self.groupIdRef());
      ds.field("strokeStyle_v3", &self.strokeStyle_v3());
      ds.field("fillStyle_v3", &self.fillStyle_v3());
      ds.field("textAlign_v3", &self.textAlign_v3());
      ds.field("verticalAlign_v3", &self.verticalAlign_v3());
      ds.field("x_v3", &self.x_v3());
      ds.field("y_v3", &self.y_v3());
      ds.field("scale_v3", &self.scale_v3());
      ds.field("pressures_v3", &self.pressures_v3());
      ds.field("strokeWidth_v3", &self.strokeWidth_v3());
      ds.field("angle_v3", &self.angle_v3());
      ds.field("borderRadius", &self.borderRadius());
      ds.field("width_v3", &self.width_v3());
      ds.field("height_v3", &self.height_v3());
      ds.field("fontSize_v3", &self.fontSize_v3());
      ds.field("lineHeight_v3", &self.lineHeight_v3());
      ds.finish()
  }
}
pub enum BoundElementOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BoundElement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BoundElement<'a> {
  type Inner = BoundElement<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BoundElement<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BoundElement { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BoundElementArgs<'args>
  ) -> flatbuffers::WIPOffset<BoundElement<'bldr>> {
    let mut builder = BoundElementBuilder::new(_fbb);
    if let Some(x) = args.type_ { builder.add_type_(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BoundElement::VT_ID, None)}
  }
  #[inline]
  pub fn type_(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BoundElement::VT_TYPE_, None)}
  }
}

impl flatbuffers::Verifiable for BoundElement<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, false)?
     .finish();
    Ok(())
  }
}
pub struct BoundElementArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for BoundElementArgs<'a> {
  #[inline]
  fn default() -> Self {
    BoundElementArgs {
      id: None,
      type_: None,
    }
  }
}

pub struct BoundElementBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BoundElementBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BoundElement::VT_ID, id);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BoundElement::VT_TYPE_, type_);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BoundElementBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BoundElementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BoundElement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BoundElement<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BoundElement");
      ds.field("id", &self.id());
      ds.field("type_", &self.type_());
      ds.finish()
  }
}
pub enum DucGroupOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucGroup<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucGroup<'a> {
  type Inner = DucGroup<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucGroup<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
  pub const VT_ISCOLLAPSED: flatbuffers::VOffsetT = 8;
  pub const VT_LABEL: flatbuffers::VOffsetT = 10;
  pub const VT_SCOPE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucGroup { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucGroupArgs<'args>
  ) -> flatbuffers::WIPOffset<DucGroup<'bldr>> {
    let mut builder = DucGroupBuilder::new(_fbb);
    if let Some(x) = args.scope { builder.add_scope(x); }
    if let Some(x) = args.label { builder.add_label(x); }
    if let Some(x) = args.type_ { builder.add_type_(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_isCollapsed(args.isCollapsed);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucGroup::VT_ID, None)}
  }
  #[inline]
  pub fn type_(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucGroup::VT_TYPE_, None)}
  }
  #[inline]
  pub fn isCollapsed(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucGroup::VT_ISCOLLAPSED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn label(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucGroup::VT_LABEL, None)}
  }
  #[inline]
  pub fn scope(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucGroup::VT_SCOPE, None)}
  }
}

impl flatbuffers::Verifiable for DucGroup<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, false)?
     .visit_field::<bool>("isCollapsed", Self::VT_ISCOLLAPSED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("label", Self::VT_LABEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("scope", Self::VT_SCOPE, false)?
     .finish();
    Ok(())
  }
}
pub struct DucGroupArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
    pub isCollapsed: bool,
    pub label: Option<flatbuffers::WIPOffset<&'a str>>,
    pub scope: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DucGroupArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucGroupArgs {
      id: None,
      type_: None,
      isCollapsed: false,
      label: None,
      scope: None,
    }
  }
}

pub struct DucGroupBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucGroupBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucGroup::VT_ID, id);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucGroup::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_isCollapsed(&mut self, isCollapsed: bool) {
    self.fbb_.push_slot::<bool>(DucGroup::VT_ISCOLLAPSED, isCollapsed, false);
  }
  #[inline]
  pub fn add_label(&mut self, label: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucGroup::VT_LABEL, label);
  }
  #[inline]
  pub fn add_scope(&mut self, scope: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucGroup::VT_SCOPE, scope);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucGroupBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucGroupBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucGroup<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucGroup<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucGroup");
      ds.field("id", &self.id());
      ds.field("type_", &self.type_());
      ds.field("isCollapsed", &self.isCollapsed());
      ds.field("label", &self.label());
      ds.field("scope", &self.scope());
      ds.finish()
  }
}
pub enum AppStateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AppState<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AppState<'a> {
  type Inner = AppState<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AppState<'a> {
  pub const VT_FRAMERENDERINGENABLED: flatbuffers::VOffsetT = 18;
  pub const VT_FRAMERENDERINGNAME: flatbuffers::VOffsetT = 20;
  pub const VT_FRAMERENDERINGOUTLINE: flatbuffers::VOffsetT = 22;
  pub const VT_FRAMERENDERINGCLIP: flatbuffers::VOffsetT = 24;
  pub const VT_CURRENTITEMSTROKECOLOR: flatbuffers::VOffsetT = 32;
  pub const VT_CURRENTITEMBACKGROUNDCOLOR: flatbuffers::VOffsetT = 36;
  pub const VT_CURRENTITEMOPACITY: flatbuffers::VOffsetT = 46;
  pub const VT_CURRENTITEMFONTFAMILY: flatbuffers::VOffsetT = 48;
  pub const VT_CURRENTITEMSTARTARROWHEAD: flatbuffers::VOffsetT = 54;
  pub const VT_CURRENTITEMENDARROWHEAD: flatbuffers::VOffsetT = 56;
  pub const VT_VIEWBACKGROUNDCOLOR: flatbuffers::VOffsetT = 60;
  pub const VT_SCOPE: flatbuffers::VOffsetT = 62;
  pub const VT_GROUPS: flatbuffers::VOffsetT = 66;
  pub const VT_SCROLLX: flatbuffers::VOffsetT = 68;
  pub const VT_SCROLLY: flatbuffers::VOffsetT = 70;
  pub const VT_CURSORBUTTON: flatbuffers::VOffsetT = 72;
  pub const VT_SCROLLEDOUTSIDE: flatbuffers::VOffsetT = 74;
  pub const VT_NAME: flatbuffers::VOffsetT = 76;
  pub const VT_ZOOM: flatbuffers::VOffsetT = 78;
  pub const VT_LASTPOINTERDOWNWITH: flatbuffers::VOffsetT = 80;
  pub const VT_SELECTEDELEMENTIDS: flatbuffers::VOffsetT = 82;
  pub const VT_SHOULDCACHEIGNOREZOOM: flatbuffers::VOffsetT = 88;
  pub const VT_GRIDSIZE: flatbuffers::VOffsetT = 90;
  pub const VT_SCALERATIOLOCKED: flatbuffers::VOffsetT = 100;
  pub const VT_DISPLAYALLPOINTDISTANCES: flatbuffers::VOffsetT = 102;
  pub const VT_DISPLAYDISTANCEONDRAWING: flatbuffers::VOffsetT = 104;
  pub const VT_DISPLAYALLPOINTCOORDINATES: flatbuffers::VOffsetT = 106;
  pub const VT_DISPLAYALLPOINTINFOSELECTED: flatbuffers::VOffsetT = 108;
  pub const VT_DISPLAYROOTAXIS: flatbuffers::VOffsetT = 110;
  pub const VT_CURRENTITEMFILLSTYLE_V3: flatbuffers::VOffsetT = 118;
  pub const VT_CURRENTITEMSTROKESTYLE_V3: flatbuffers::VOffsetT = 120;
  pub const VT_CURRENTITEMTEXTALIGN_V3: flatbuffers::VOffsetT = 122;
  pub const VT_LINEBENDINGMODE: flatbuffers::VOffsetT = 124;
  pub const VT_CURRENTITEMSTROKEWIDTH_V3: flatbuffers::VOffsetT = 126;
  pub const VT_CURRENTITEMSTROKEPLACEMENT_V3: flatbuffers::VOffsetT = 128;
  pub const VT_CURRENTITEMFONTSIZE_V3: flatbuffers::VOffsetT = 130;
  pub const VT_COORDDECIMALPLACES_V3: flatbuffers::VOffsetT = 132;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AppState { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AppStateArgs<'args>
  ) -> flatbuffers::WIPOffset<AppState<'bldr>> {
    let mut builder = AppStateBuilder::new(_fbb);
    builder.add_currentItemFontSize_v3(args.currentItemFontSize_v3);
    builder.add_currentItemStrokeWidth_v3(args.currentItemStrokeWidth_v3);
    builder.add_gridSize(args.gridSize);
    if let Some(x) = args.selectedElementIds { builder.add_selectedElementIds(x); }
    if let Some(x) = args.lastPointerDownWith { builder.add_lastPointerDownWith(x); }
    builder.add_zoom(args.zoom);
    if let Some(x) = args.name { builder.add_name(x); }
    if let Some(x) = args.cursorButton { builder.add_cursorButton(x); }
    builder.add_scrollY(args.scrollY);
    builder.add_scrollX(args.scrollX);
    if let Some(x) = args.groups { builder.add_groups(x); }
    if let Some(x) = args.scope { builder.add_scope(x); }
    if let Some(x) = args.viewBackgroundColor { builder.add_viewBackgroundColor(x); }
    if let Some(x) = args.currentItemEndArrowhead { builder.add_currentItemEndArrowhead(x); }
    if let Some(x) = args.currentItemStartArrowhead { builder.add_currentItemStartArrowhead(x); }
    builder.add_currentItemFontFamily(args.currentItemFontFamily);
    builder.add_currentItemOpacity(args.currentItemOpacity);
    if let Some(x) = args.currentItemBackgroundColor { builder.add_currentItemBackgroundColor(x); }
    if let Some(x) = args.currentItemStrokeColor { builder.add_currentItemStrokeColor(x); }
    builder.add_coordDecimalPlaces_v3(args.coordDecimalPlaces_v3);
    builder.add_currentItemStrokePlacement_v3(args.currentItemStrokePlacement_v3);
    builder.add_lineBendingMode(args.lineBendingMode);
    builder.add_currentItemTextAlign_v3(args.currentItemTextAlign_v3);
    builder.add_currentItemStrokeStyle_v3(args.currentItemStrokeStyle_v3);
    builder.add_currentItemFillStyle_v3(args.currentItemFillStyle_v3);
    builder.add_displayRootAxis(args.displayRootAxis);
    builder.add_displayAllPointInfoSelected(args.displayAllPointInfoSelected);
    builder.add_displayAllPointCoordinates(args.displayAllPointCoordinates);
    builder.add_displayDistanceOnDrawing(args.displayDistanceOnDrawing);
    builder.add_displayAllPointDistances(args.displayAllPointDistances);
    builder.add_scaleRatioLocked(args.scaleRatioLocked);
    builder.add_shouldCacheIgnoreZoom(args.shouldCacheIgnoreZoom);
    builder.add_scrolledOutside(args.scrolledOutside);
    builder.add_frameRenderingClip(args.frameRenderingClip);
    builder.add_frameRenderingOutline(args.frameRenderingOutline);
    builder.add_frameRenderingName(args.frameRenderingName);
    builder.add_frameRenderingEnabled(args.frameRenderingEnabled);
    builder.finish()
  }


  #[inline]
  pub fn frameRenderingEnabled(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_FRAMERENDERINGENABLED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn frameRenderingName(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_FRAMERENDERINGNAME, Some(false)).unwrap()}
  }
  #[inline]
  pub fn frameRenderingOutline(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_FRAMERENDERINGOUTLINE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn frameRenderingClip(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_FRAMERENDERINGCLIP, Some(false)).unwrap()}
  }
  #[inline]
  pub fn currentItemStrokeColor(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_CURRENTITEMSTROKECOLOR, None)}
  }
  #[inline]
  pub fn currentItemBackgroundColor(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_CURRENTITEMBACKGROUNDCOLOR, None)}
  }
  #[inline]
  pub fn currentItemOpacity(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(AppState::VT_CURRENTITEMOPACITY, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn currentItemFontFamily(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AppState::VT_CURRENTITEMFONTFAMILY, Some(0)).unwrap()}
  }
  #[inline]
  pub fn currentItemStartArrowhead(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_CURRENTITEMSTARTARROWHEAD, None)}
  }
  #[inline]
  pub fn currentItemEndArrowhead(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_CURRENTITEMENDARROWHEAD, None)}
  }
  #[inline]
  pub fn viewBackgroundColor(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_VIEWBACKGROUNDCOLOR, None)}
  }
  #[inline]
  pub fn scope(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_SCOPE, None)}
  }
  #[inline]
  pub fn groups(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucGroup<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucGroup>>>>(AppState::VT_GROUPS, None)}
  }
  #[inline]
  pub fn scrollX(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(AppState::VT_SCROLLX, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn scrollY(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(AppState::VT_SCROLLY, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn cursorButton(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_CURSORBUTTON, None)}
  }
  #[inline]
  pub fn scrolledOutside(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_SCROLLEDOUTSIDE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_NAME, None)}
  }
  #[inline]
  pub fn zoom(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(AppState::VT_ZOOM, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn lastPointerDownWith(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_LASTPOINTERDOWNWITH, None)}
  }
  #[inline]
  pub fn selectedElementIds(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(AppState::VT_SELECTEDELEMENTIDS, None)}
  }
  #[inline]
  pub fn shouldCacheIgnoreZoom(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_SHOULDCACHEIGNOREZOOM, Some(false)).unwrap()}
  }
  #[inline]
  pub fn gridSize(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AppState::VT_GRIDSIZE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn scaleRatioLocked(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_SCALERATIOLOCKED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn displayAllPointDistances(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_DISPLAYALLPOINTDISTANCES, Some(false)).unwrap()}
  }
  #[inline]
  pub fn displayDistanceOnDrawing(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_DISPLAYDISTANCEONDRAWING, Some(false)).unwrap()}
  }
  #[inline]
  pub fn displayAllPointCoordinates(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_DISPLAYALLPOINTCOORDINATES, Some(false)).unwrap()}
  }
  #[inline]
  pub fn displayAllPointInfoSelected(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_DISPLAYALLPOINTINFOSELECTED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn displayRootAxis(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_DISPLAYROOTAXIS, Some(false)).unwrap()}
  }
  #[inline]
  pub fn currentItemFillStyle_v3(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(AppState::VT_CURRENTITEMFILLSTYLE_V3, Some(0)).unwrap()}
  }
  #[inline]
  pub fn currentItemStrokeStyle_v3(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(AppState::VT_CURRENTITEMSTROKESTYLE_V3, Some(0)).unwrap()}
  }
  #[inline]
  pub fn currentItemTextAlign_v3(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(AppState::VT_CURRENTITEMTEXTALIGN_V3, Some(0)).unwrap()}
  }
  #[inline]
  pub fn lineBendingMode(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_LINEBENDINGMODE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn currentItemStrokeWidth_v3(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AppState::VT_CURRENTITEMSTROKEWIDTH_V3, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn currentItemStrokePlacement_v3(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(AppState::VT_CURRENTITEMSTROKEPLACEMENT_V3, Some(0)).unwrap()}
  }
  #[inline]
  pub fn currentItemFontSize_v3(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AppState::VT_CURRENTITEMFONTSIZE_V3, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn coordDecimalPlaces_v3(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(AppState::VT_COORDDECIMALPLACES_V3, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for AppState<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("frameRenderingEnabled", Self::VT_FRAMERENDERINGENABLED, false)?
     .visit_field::<bool>("frameRenderingName", Self::VT_FRAMERENDERINGNAME, false)?
     .visit_field::<bool>("frameRenderingOutline", Self::VT_FRAMERENDERINGOUTLINE, false)?
     .visit_field::<bool>("frameRenderingClip", Self::VT_FRAMERENDERINGCLIP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("currentItemStrokeColor", Self::VT_CURRENTITEMSTROKECOLOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("currentItemBackgroundColor", Self::VT_CURRENTITEMBACKGROUNDCOLOR, false)?
     .visit_field::<f32>("currentItemOpacity", Self::VT_CURRENTITEMOPACITY, false)?
     .visit_field::<i32>("currentItemFontFamily", Self::VT_CURRENTITEMFONTFAMILY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("currentItemStartArrowhead", Self::VT_CURRENTITEMSTARTARROWHEAD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("currentItemEndArrowhead", Self::VT_CURRENTITEMENDARROWHEAD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("viewBackgroundColor", Self::VT_VIEWBACKGROUNDCOLOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("scope", Self::VT_SCOPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DucGroup>>>>("groups", Self::VT_GROUPS, false)?
     .visit_field::<f32>("scrollX", Self::VT_SCROLLX, false)?
     .visit_field::<f32>("scrollY", Self::VT_SCROLLY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("cursorButton", Self::VT_CURSORBUTTON, false)?
     .visit_field::<bool>("scrolledOutside", Self::VT_SCROLLEDOUTSIDE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<f32>("zoom", Self::VT_ZOOM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("lastPointerDownWith", Self::VT_LASTPOINTERDOWNWITH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("selectedElementIds", Self::VT_SELECTEDELEMENTIDS, false)?
     .visit_field::<bool>("shouldCacheIgnoreZoom", Self::VT_SHOULDCACHEIGNOREZOOM, false)?
     .visit_field::<i32>("gridSize", Self::VT_GRIDSIZE, false)?
     .visit_field::<bool>("scaleRatioLocked", Self::VT_SCALERATIOLOCKED, false)?
     .visit_field::<bool>("displayAllPointDistances", Self::VT_DISPLAYALLPOINTDISTANCES, false)?
     .visit_field::<bool>("displayDistanceOnDrawing", Self::VT_DISPLAYDISTANCEONDRAWING, false)?
     .visit_field::<bool>("displayAllPointCoordinates", Self::VT_DISPLAYALLPOINTCOORDINATES, false)?
     .visit_field::<bool>("displayAllPointInfoSelected", Self::VT_DISPLAYALLPOINTINFOSELECTED, false)?
     .visit_field::<bool>("displayRootAxis", Self::VT_DISPLAYROOTAXIS, false)?
     .visit_field::<i8>("currentItemFillStyle_v3", Self::VT_CURRENTITEMFILLSTYLE_V3, false)?
     .visit_field::<i8>("currentItemStrokeStyle_v3", Self::VT_CURRENTITEMSTROKESTYLE_V3, false)?
     .visit_field::<i8>("currentItemTextAlign_v3", Self::VT_CURRENTITEMTEXTALIGN_V3, false)?
     .visit_field::<bool>("lineBendingMode", Self::VT_LINEBENDINGMODE, false)?
     .visit_field::<f64>("currentItemStrokeWidth_v3", Self::VT_CURRENTITEMSTROKEWIDTH_V3, false)?
     .visit_field::<i8>("currentItemStrokePlacement_v3", Self::VT_CURRENTITEMSTROKEPLACEMENT_V3, false)?
     .visit_field::<f64>("currentItemFontSize_v3", Self::VT_CURRENTITEMFONTSIZE_V3, false)?
     .visit_field::<i8>("coordDecimalPlaces_v3", Self::VT_COORDDECIMALPLACES_V3, false)?
     .finish();
    Ok(())
  }
}
pub struct AppStateArgs<'a> {
    pub frameRenderingEnabled: bool,
    pub frameRenderingName: bool,
    pub frameRenderingOutline: bool,
    pub frameRenderingClip: bool,
    pub currentItemStrokeColor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub currentItemBackgroundColor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub currentItemOpacity: f32,
    pub currentItemFontFamily: i32,
    pub currentItemStartArrowhead: Option<flatbuffers::WIPOffset<&'a str>>,
    pub currentItemEndArrowhead: Option<flatbuffers::WIPOffset<&'a str>>,
    pub viewBackgroundColor: Option<flatbuffers::WIPOffset<&'a str>>,
    pub scope: Option<flatbuffers::WIPOffset<&'a str>>,
    pub groups: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucGroup<'a>>>>>,
    pub scrollX: f32,
    pub scrollY: f32,
    pub cursorButton: Option<flatbuffers::WIPOffset<&'a str>>,
    pub scrolledOutside: bool,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub zoom: f32,
    pub lastPointerDownWith: Option<flatbuffers::WIPOffset<&'a str>>,
    pub selectedElementIds: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub shouldCacheIgnoreZoom: bool,
    pub gridSize: i32,
    pub scaleRatioLocked: bool,
    pub displayAllPointDistances: bool,
    pub displayDistanceOnDrawing: bool,
    pub displayAllPointCoordinates: bool,
    pub displayAllPointInfoSelected: bool,
    pub displayRootAxis: bool,
    pub currentItemFillStyle_v3: i8,
    pub currentItemStrokeStyle_v3: i8,
    pub currentItemTextAlign_v3: i8,
    pub lineBendingMode: bool,
    pub currentItemStrokeWidth_v3: f64,
    pub currentItemStrokePlacement_v3: i8,
    pub currentItemFontSize_v3: f64,
    pub coordDecimalPlaces_v3: i8,
}
impl<'a> Default for AppStateArgs<'a> {
  #[inline]
  fn default() -> Self {
    AppStateArgs {
      frameRenderingEnabled: false,
      frameRenderingName: false,
      frameRenderingOutline: false,
      frameRenderingClip: false,
      currentItemStrokeColor: None,
      currentItemBackgroundColor: None,
      currentItemOpacity: 0.0,
      currentItemFontFamily: 0,
      currentItemStartArrowhead: None,
      currentItemEndArrowhead: None,
      viewBackgroundColor: None,
      scope: None,
      groups: None,
      scrollX: 0.0,
      scrollY: 0.0,
      cursorButton: None,
      scrolledOutside: false,
      name: None,
      zoom: 0.0,
      lastPointerDownWith: None,
      selectedElementIds: None,
      shouldCacheIgnoreZoom: false,
      gridSize: 0,
      scaleRatioLocked: false,
      displayAllPointDistances: false,
      displayDistanceOnDrawing: false,
      displayAllPointCoordinates: false,
      displayAllPointInfoSelected: false,
      displayRootAxis: false,
      currentItemFillStyle_v3: 0,
      currentItemStrokeStyle_v3: 0,
      currentItemTextAlign_v3: 0,
      lineBendingMode: false,
      currentItemStrokeWidth_v3: 0.0,
      currentItemStrokePlacement_v3: 0,
      currentItemFontSize_v3: 0.0,
      coordDecimalPlaces_v3: 0,
    }
  }
}

pub struct AppStateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AppStateBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_frameRenderingEnabled(&mut self, frameRenderingEnabled: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_FRAMERENDERINGENABLED, frameRenderingEnabled, false);
  }
  #[inline]
  pub fn add_frameRenderingName(&mut self, frameRenderingName: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_FRAMERENDERINGNAME, frameRenderingName, false);
  }
  #[inline]
  pub fn add_frameRenderingOutline(&mut self, frameRenderingOutline: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_FRAMERENDERINGOUTLINE, frameRenderingOutline, false);
  }
  #[inline]
  pub fn add_frameRenderingClip(&mut self, frameRenderingClip: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_FRAMERENDERINGCLIP, frameRenderingClip, false);
  }
  #[inline]
  pub fn add_currentItemStrokeColor(&mut self, currentItemStrokeColor: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_CURRENTITEMSTROKECOLOR, currentItemStrokeColor);
  }
  #[inline]
  pub fn add_currentItemBackgroundColor(&mut self, currentItemBackgroundColor: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_CURRENTITEMBACKGROUNDCOLOR, currentItemBackgroundColor);
  }
  #[inline]
  pub fn add_currentItemOpacity(&mut self, currentItemOpacity: f32) {
    self.fbb_.push_slot::<f32>(AppState::VT_CURRENTITEMOPACITY, currentItemOpacity, 0.0);
  }
  #[inline]
  pub fn add_currentItemFontFamily(&mut self, currentItemFontFamily: i32) {
    self.fbb_.push_slot::<i32>(AppState::VT_CURRENTITEMFONTFAMILY, currentItemFontFamily, 0);
  }
  #[inline]
  pub fn add_currentItemStartArrowhead(&mut self, currentItemStartArrowhead: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_CURRENTITEMSTARTARROWHEAD, currentItemStartArrowhead);
  }
  #[inline]
  pub fn add_currentItemEndArrowhead(&mut self, currentItemEndArrowhead: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_CURRENTITEMENDARROWHEAD, currentItemEndArrowhead);
  }
  #[inline]
  pub fn add_viewBackgroundColor(&mut self, viewBackgroundColor: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_VIEWBACKGROUNDCOLOR, viewBackgroundColor);
  }
  #[inline]
  pub fn add_scope(&mut self, scope: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_SCOPE, scope);
  }
  #[inline]
  pub fn add_groups(&mut self, groups: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DucGroup<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_GROUPS, groups);
  }
  #[inline]
  pub fn add_scrollX(&mut self, scrollX: f32) {
    self.fbb_.push_slot::<f32>(AppState::VT_SCROLLX, scrollX, 0.0);
  }
  #[inline]
  pub fn add_scrollY(&mut self, scrollY: f32) {
    self.fbb_.push_slot::<f32>(AppState::VT_SCROLLY, scrollY, 0.0);
  }
  #[inline]
  pub fn add_cursorButton(&mut self, cursorButton: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_CURSORBUTTON, cursorButton);
  }
  #[inline]
  pub fn add_scrolledOutside(&mut self, scrolledOutside: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_SCROLLEDOUTSIDE, scrolledOutside, false);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_NAME, name);
  }
  #[inline]
  pub fn add_zoom(&mut self, zoom: f32) {
    self.fbb_.push_slot::<f32>(AppState::VT_ZOOM, zoom, 0.0);
  }
  #[inline]
  pub fn add_lastPointerDownWith(&mut self, lastPointerDownWith: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_LASTPOINTERDOWNWITH, lastPointerDownWith);
  }
  #[inline]
  pub fn add_selectedElementIds(&mut self, selectedElementIds: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_SELECTEDELEMENTIDS, selectedElementIds);
  }
  #[inline]
  pub fn add_shouldCacheIgnoreZoom(&mut self, shouldCacheIgnoreZoom: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_SHOULDCACHEIGNOREZOOM, shouldCacheIgnoreZoom, false);
  }
  #[inline]
  pub fn add_gridSize(&mut self, gridSize: i32) {
    self.fbb_.push_slot::<i32>(AppState::VT_GRIDSIZE, gridSize, 0);
  }
  #[inline]
  pub fn add_scaleRatioLocked(&mut self, scaleRatioLocked: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_SCALERATIOLOCKED, scaleRatioLocked, false);
  }
  #[inline]
  pub fn add_displayAllPointDistances(&mut self, displayAllPointDistances: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_DISPLAYALLPOINTDISTANCES, displayAllPointDistances, false);
  }
  #[inline]
  pub fn add_displayDistanceOnDrawing(&mut self, displayDistanceOnDrawing: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_DISPLAYDISTANCEONDRAWING, displayDistanceOnDrawing, false);
  }
  #[inline]
  pub fn add_displayAllPointCoordinates(&mut self, displayAllPointCoordinates: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_DISPLAYALLPOINTCOORDINATES, displayAllPointCoordinates, false);
  }
  #[inline]
  pub fn add_displayAllPointInfoSelected(&mut self, displayAllPointInfoSelected: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_DISPLAYALLPOINTINFOSELECTED, displayAllPointInfoSelected, false);
  }
  #[inline]
  pub fn add_displayRootAxis(&mut self, displayRootAxis: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_DISPLAYROOTAXIS, displayRootAxis, false);
  }
  #[inline]
  pub fn add_currentItemFillStyle_v3(&mut self, currentItemFillStyle_v3: i8) {
    self.fbb_.push_slot::<i8>(AppState::VT_CURRENTITEMFILLSTYLE_V3, currentItemFillStyle_v3, 0);
  }
  #[inline]
  pub fn add_currentItemStrokeStyle_v3(&mut self, currentItemStrokeStyle_v3: i8) {
    self.fbb_.push_slot::<i8>(AppState::VT_CURRENTITEMSTROKESTYLE_V3, currentItemStrokeStyle_v3, 0);
  }
  #[inline]
  pub fn add_currentItemTextAlign_v3(&mut self, currentItemTextAlign_v3: i8) {
    self.fbb_.push_slot::<i8>(AppState::VT_CURRENTITEMTEXTALIGN_V3, currentItemTextAlign_v3, 0);
  }
  #[inline]
  pub fn add_lineBendingMode(&mut self, lineBendingMode: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_LINEBENDINGMODE, lineBendingMode, false);
  }
  #[inline]
  pub fn add_currentItemStrokeWidth_v3(&mut self, currentItemStrokeWidth_v3: f64) {
    self.fbb_.push_slot::<f64>(AppState::VT_CURRENTITEMSTROKEWIDTH_V3, currentItemStrokeWidth_v3, 0.0);
  }
  #[inline]
  pub fn add_currentItemStrokePlacement_v3(&mut self, currentItemStrokePlacement_v3: i8) {
    self.fbb_.push_slot::<i8>(AppState::VT_CURRENTITEMSTROKEPLACEMENT_V3, currentItemStrokePlacement_v3, 0);
  }
  #[inline]
  pub fn add_currentItemFontSize_v3(&mut self, currentItemFontSize_v3: f64) {
    self.fbb_.push_slot::<f64>(AppState::VT_CURRENTITEMFONTSIZE_V3, currentItemFontSize_v3, 0.0);
  }
  #[inline]
  pub fn add_coordDecimalPlaces_v3(&mut self, coordDecimalPlaces_v3: i8) {
    self.fbb_.push_slot::<i8>(AppState::VT_COORDDECIMALPLACES_V3, coordDecimalPlaces_v3, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AppStateBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AppStateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AppState<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AppState<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AppState");
      ds.field("frameRenderingEnabled", &self.frameRenderingEnabled());
      ds.field("frameRenderingName", &self.frameRenderingName());
      ds.field("frameRenderingOutline", &self.frameRenderingOutline());
      ds.field("frameRenderingClip", &self.frameRenderingClip());
      ds.field("currentItemStrokeColor", &self.currentItemStrokeColor());
      ds.field("currentItemBackgroundColor", &self.currentItemBackgroundColor());
      ds.field("currentItemOpacity", &self.currentItemOpacity());
      ds.field("currentItemFontFamily", &self.currentItemFontFamily());
      ds.field("currentItemStartArrowhead", &self.currentItemStartArrowhead());
      ds.field("currentItemEndArrowhead", &self.currentItemEndArrowhead());
      ds.field("viewBackgroundColor", &self.viewBackgroundColor());
      ds.field("scope", &self.scope());
      ds.field("groups", &self.groups());
      ds.field("scrollX", &self.scrollX());
      ds.field("scrollY", &self.scrollY());
      ds.field("cursorButton", &self.cursorButton());
      ds.field("scrolledOutside", &self.scrolledOutside());
      ds.field("name", &self.name());
      ds.field("zoom", &self.zoom());
      ds.field("lastPointerDownWith", &self.lastPointerDownWith());
      ds.field("selectedElementIds", &self.selectedElementIds());
      ds.field("shouldCacheIgnoreZoom", &self.shouldCacheIgnoreZoom());
      ds.field("gridSize", &self.gridSize());
      ds.field("scaleRatioLocked", &self.scaleRatioLocked());
      ds.field("displayAllPointDistances", &self.displayAllPointDistances());
      ds.field("displayDistanceOnDrawing", &self.displayDistanceOnDrawing());
      ds.field("displayAllPointCoordinates", &self.displayAllPointCoordinates());
      ds.field("displayAllPointInfoSelected", &self.displayAllPointInfoSelected());
      ds.field("displayRootAxis", &self.displayRootAxis());
      ds.field("currentItemFillStyle_v3", &self.currentItemFillStyle_v3());
      ds.field("currentItemStrokeStyle_v3", &self.currentItemStrokeStyle_v3());
      ds.field("currentItemTextAlign_v3", &self.currentItemTextAlign_v3());
      ds.field("lineBendingMode", &self.lineBendingMode());
      ds.field("currentItemStrokeWidth_v3", &self.currentItemStrokeWidth_v3());
      ds.field("currentItemStrokePlacement_v3", &self.currentItemStrokePlacement_v3());
      ds.field("currentItemFontSize_v3", &self.currentItemFontSize_v3());
      ds.field("coordDecimalPlaces_v3", &self.coordDecimalPlaces_v3());
      ds.finish()
  }
}
pub enum BinaryFileDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BinaryFileData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BinaryFileData<'a> {
  type Inner = BinaryFileData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BinaryFileData<'a> {
  pub const VT_MIMETYPE: flatbuffers::VOffsetT = 4;
  pub const VT_ID: flatbuffers::VOffsetT = 6;
  pub const VT_DATA: flatbuffers::VOffsetT = 8;
  pub const VT_CREATED: flatbuffers::VOffsetT = 10;
  pub const VT_LASTRETRIEVED: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BinaryFileData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BinaryFileDataArgs<'args>
  ) -> flatbuffers::WIPOffset<BinaryFileData<'bldr>> {
    let mut builder = BinaryFileDataBuilder::new(_fbb);
    builder.add_lastRetrieved(args.lastRetrieved);
    builder.add_created(args.created);
    if let Some(x) = args.data { builder.add_data(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    if let Some(x) = args.mimeType { builder.add_mimeType(x); }
    builder.finish()
  }


  #[inline]
  pub fn mimeType(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BinaryFileData::VT_MIMETYPE, None)}
  }
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BinaryFileData::VT_ID, None)}
  }
  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(BinaryFileData::VT_DATA, None)}
  }
  #[inline]
  pub fn created(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(BinaryFileData::VT_CREATED, Some(0)).unwrap()}
  }
  #[inline]
  pub fn lastRetrieved(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(BinaryFileData::VT_LASTRETRIEVED, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for BinaryFileData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("mimeType", Self::VT_MIMETYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("data", Self::VT_DATA, false)?
     .visit_field::<i64>("created", Self::VT_CREATED, false)?
     .visit_field::<i64>("lastRetrieved", Self::VT_LASTRETRIEVED, false)?
     .finish();
    Ok(())
  }
}
pub struct BinaryFileDataArgs<'a> {
    pub mimeType: Option<flatbuffers::WIPOffset<&'a str>>,
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub created: i64,
    pub lastRetrieved: i64,
}
impl<'a> Default for BinaryFileDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    BinaryFileDataArgs {
      mimeType: None,
      id: None,
      data: None,
      created: 0,
      lastRetrieved: 0,
    }
  }
}

pub struct BinaryFileDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BinaryFileDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_mimeType(&mut self, mimeType: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryFileData::VT_MIMETYPE, mimeType);
  }
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryFileData::VT_ID, id);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryFileData::VT_DATA, data);
  }
  #[inline]
  pub fn add_created(&mut self, created: i64) {
    self.fbb_.push_slot::<i64>(BinaryFileData::VT_CREATED, created, 0);
  }
  #[inline]
  pub fn add_lastRetrieved(&mut self, lastRetrieved: i64) {
    self.fbb_.push_slot::<i64>(BinaryFileData::VT_LASTRETRIEVED, lastRetrieved, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BinaryFileDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BinaryFileDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BinaryFileData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BinaryFileData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BinaryFileData");
      ds.field("mimeType", &self.mimeType());
      ds.field("id", &self.id());
      ds.field("data", &self.data());
      ds.field("created", &self.created());
      ds.field("lastRetrieved", &self.lastRetrieved());
      ds.finish()
  }
}
pub enum BinaryFilesEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BinaryFilesEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BinaryFilesEntry<'a> {
  type Inner = BinaryFilesEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BinaryFilesEntry<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BinaryFilesEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BinaryFilesEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<BinaryFilesEntry<'bldr>> {
    let mut builder = BinaryFilesEntryBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BinaryFilesEntry::VT_KEY, None)}
  }
  #[inline]
  pub fn value(&self) -> Option<BinaryFileData<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<BinaryFileData>>(BinaryFilesEntry::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for BinaryFilesEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<BinaryFileData>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct BinaryFilesEntryArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<BinaryFileData<'a>>>,
}
impl<'a> Default for BinaryFilesEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    BinaryFilesEntryArgs {
      key: None,
      value: None,
    }
  }
}

pub struct BinaryFilesEntryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BinaryFilesEntryBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryFilesEntry::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<BinaryFileData<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<BinaryFileData>>(BinaryFilesEntry::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BinaryFilesEntryBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BinaryFilesEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BinaryFilesEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BinaryFilesEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BinaryFilesEntry");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum BinaryFilesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BinaryFiles<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BinaryFiles<'a> {
  type Inner = BinaryFiles<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BinaryFiles<'a> {
  pub const VT_ENTRIES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BinaryFiles { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BinaryFilesArgs<'args>
  ) -> flatbuffers::WIPOffset<BinaryFiles<'bldr>> {
    let mut builder = BinaryFilesBuilder::new(_fbb);
    if let Some(x) = args.entries { builder.add_entries(x); }
    builder.finish()
  }


  #[inline]
  pub fn entries(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinaryFilesEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinaryFilesEntry>>>>(BinaryFiles::VT_ENTRIES, None)}
  }
}

impl flatbuffers::Verifiable for BinaryFiles<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BinaryFilesEntry>>>>("entries", Self::VT_ENTRIES, false)?
     .finish();
    Ok(())
  }
}
pub struct BinaryFilesArgs<'a> {
    pub entries: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinaryFilesEntry<'a>>>>>,
}
impl<'a> Default for BinaryFilesArgs<'a> {
  #[inline]
  fn default() -> Self {
    BinaryFilesArgs {
      entries: None,
    }
  }
}

pub struct BinaryFilesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BinaryFilesBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_entries(&mut self, entries: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinaryFilesEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryFiles::VT_ENTRIES, entries);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BinaryFilesBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BinaryFilesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BinaryFiles<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BinaryFiles<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BinaryFiles");
      ds.field("entries", &self.entries());
      ds.finish()
  }
}
pub enum ExportedDataStateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ExportedDataState<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExportedDataState<'a> {
  type Inner = ExportedDataState<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ExportedDataState<'a> {
  pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
  pub const VT_VERSION: flatbuffers::VOffsetT = 6;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 8;
  pub const VT_ELEMENTS: flatbuffers::VOffsetT = 10;
  pub const VT_APPSTATE: flatbuffers::VOffsetT = 12;
  pub const VT_FILES: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ExportedDataState { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ExportedDataStateArgs<'args>
  ) -> flatbuffers::WIPOffset<ExportedDataState<'bldr>> {
    let mut builder = ExportedDataStateBuilder::new(_fbb);
    if let Some(x) = args.files { builder.add_files(x); }
    if let Some(x) = args.appState { builder.add_appState(x); }
    if let Some(x) = args.elements { builder.add_elements(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    builder.add_version(args.version);
    if let Some(x) = args.type_ { builder.add_type_(x); }
    builder.finish()
  }


  #[inline]
  pub fn type_(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ExportedDataState::VT_TYPE_, None)}
  }
  #[inline]
  pub fn version(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ExportedDataState::VT_VERSION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ExportedDataState::VT_SOURCE, None)}
  }
  #[inline]
  pub fn elements(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucElement<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucElement>>>>(ExportedDataState::VT_ELEMENTS, None)}
  }
  #[inline]
  pub fn appState(&self) -> Option<AppState<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<AppState>>(ExportedDataState::VT_APPSTATE, None)}
  }
  #[inline]
  pub fn files(&self) -> Option<BinaryFiles<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<BinaryFiles>>(ExportedDataState::VT_FILES, None)}
  }
}

impl flatbuffers::Verifiable for ExportedDataState<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, false)?
     .visit_field::<i32>("version", Self::VT_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DucElement>>>>("elements", Self::VT_ELEMENTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<AppState>>("appState", Self::VT_APPSTATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<BinaryFiles>>("files", Self::VT_FILES, false)?
     .finish();
    Ok(())
  }
}
pub struct ExportedDataStateArgs<'a> {
    pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
    pub version: i32,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub elements: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucElement<'a>>>>>,
    pub appState: Option<flatbuffers::WIPOffset<AppState<'a>>>,
    pub files: Option<flatbuffers::WIPOffset<BinaryFiles<'a>>>,
}
impl<'a> Default for ExportedDataStateArgs<'a> {
  #[inline]
  fn default() -> Self {
    ExportedDataStateArgs {
      type_: None,
      version: 0,
      source: None,
      elements: None,
      appState: None,
      files: None,
    }
  }
}

pub struct ExportedDataStateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ExportedDataStateBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ExportedDataState::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_version(&mut self, version: i32) {
    self.fbb_.push_slot::<i32>(ExportedDataState::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ExportedDataState::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_elements(&mut self, elements: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DucElement<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ExportedDataState::VT_ELEMENTS, elements);
  }
  #[inline]
  pub fn add_appState(&mut self, appState: flatbuffers::WIPOffset<AppState<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<AppState>>(ExportedDataState::VT_APPSTATE, appState);
  }
  #[inline]
  pub fn add_files(&mut self, files: flatbuffers::WIPOffset<BinaryFiles<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<BinaryFiles>>(ExportedDataState::VT_FILES, files);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ExportedDataStateBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ExportedDataStateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ExportedDataState<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ExportedDataState<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ExportedDataState");
      ds.field("type_", &self.type_());
      ds.field("version", &self.version());
      ds.field("source", &self.source());
      ds.field("elements", &self.elements());
      ds.field("appState", &self.appState());
      ds.field("files", &self.files());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `ExportedDataState`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_exported_data_state_unchecked`.
pub fn root_as_exported_data_state(buf: &[u8]) -> Result<ExportedDataState, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<ExportedDataState>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `ExportedDataState` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_exported_data_state_unchecked`.
pub fn size_prefixed_root_as_exported_data_state(buf: &[u8]) -> Result<ExportedDataState, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<ExportedDataState>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `ExportedDataState` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_exported_data_state_unchecked`.
pub fn root_as_exported_data_state_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ExportedDataState<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<ExportedDataState<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `ExportedDataState` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_exported_data_state_unchecked`.
pub fn size_prefixed_root_as_exported_data_state_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ExportedDataState<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<ExportedDataState<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a ExportedDataState and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `ExportedDataState`.
pub unsafe fn root_as_exported_data_state_unchecked(buf: &[u8]) -> ExportedDataState {
  flatbuffers::root_unchecked::<ExportedDataState>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed ExportedDataState and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `ExportedDataState`.
pub unsafe fn size_prefixed_root_as_exported_data_state_unchecked(buf: &[u8]) -> ExportedDataState {
  flatbuffers::size_prefixed_root_unchecked::<ExportedDataState>(buf)
}
#[inline]
pub fn finish_exported_data_state_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<ExportedDataState<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_exported_data_state_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<ExportedDataState<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod Duc

