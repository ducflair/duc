// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod duconfig {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_THEME: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_THEME: u8 = 11;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_THEME: [THEME; 2] = [
  THEME::LIGHT,
  THEME::DARK,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct THEME(pub u8);
#[allow(non_upper_case_globals)]
impl THEME {
  pub const LIGHT: Self = Self(10);
  pub const DARK: Self = Self(11);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 11;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::LIGHT,
    Self::DARK,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::LIGHT => Some("LIGHT"),
      Self::DARK => Some("DARK"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for THEME {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for THEME {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for THEME {
    type Output = THEME;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for THEME {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for THEME {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for THEME {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ANTI_ALIASING: u8 = 8;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ANTI_ALIASING: u8 = 16;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ANTI_ALIASING: [ANTI_ALIASING; 4] = [
  ANTI_ALIASING::MSAA_8,
  ANTI_ALIASING::NONE,
  ANTI_ALIASING::ANALYTIC,
  ANTI_ALIASING::MSAA_16,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ANTI_ALIASING(pub u8);
#[allow(non_upper_case_globals)]
impl ANTI_ALIASING {
  pub const MSAA_8: Self = Self(8);
  pub const NONE: Self = Self(10);
  pub const ANALYTIC: Self = Self(11);
  pub const MSAA_16: Self = Self(16);

  pub const ENUM_MIN: u8 = 8;
  pub const ENUM_MAX: u8 = 16;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::MSAA_8,
    Self::NONE,
    Self::ANALYTIC,
    Self::MSAA_16,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::MSAA_8 => Some("MSAA_8"),
      Self::NONE => Some("NONE"),
      Self::ANALYTIC => Some("ANALYTIC"),
      Self::MSAA_16 => Some("MSAA_16"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ANTI_ALIASING {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ANTI_ALIASING {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ANTI_ALIASING {
    type Output = ANTI_ALIASING;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ANTI_ALIASING {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ANTI_ALIASING {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ANTI_ALIASING {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SHOW_HYPERLINK_POPUP: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SHOW_HYPERLINK_POPUP: u8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SHOW_HYPERLINK_POPUP: [SHOW_HYPERLINK_POPUP; 3] = [
  SHOW_HYPERLINK_POPUP::NONE,
  SHOW_HYPERLINK_POPUP::INFO,
  SHOW_HYPERLINK_POPUP::EDITOR,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SHOW_HYPERLINK_POPUP(pub u8);
#[allow(non_upper_case_globals)]
impl SHOW_HYPERLINK_POPUP {
  pub const NONE: Self = Self(10);
  pub const INFO: Self = Self(11);
  pub const EDITOR: Self = Self(12);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::INFO,
    Self::EDITOR,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::INFO => Some("INFO"),
      Self::EDITOR => Some("EDITOR"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SHOW_HYPERLINK_POPUP {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SHOW_HYPERLINK_POPUP {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for SHOW_HYPERLINK_POPUP {
    type Output = SHOW_HYPERLINK_POPUP;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SHOW_HYPERLINK_POPUP {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SHOW_HYPERLINK_POPUP {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SHOW_HYPERLINK_POPUP {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PRUNING_LEVEL: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PRUNING_LEVEL: u8 = 30;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PRUNING_LEVEL: [PRUNING_LEVEL; 3] = [
  PRUNING_LEVEL::CONSERVATIVE,
  PRUNING_LEVEL::BALANCED,
  PRUNING_LEVEL::AGGRESSIVE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct PRUNING_LEVEL(pub u8);
#[allow(non_upper_case_globals)]
impl PRUNING_LEVEL {
  pub const CONSERVATIVE: Self = Self(10);
  pub const BALANCED: Self = Self(20);
  pub const AGGRESSIVE: Self = Self(30);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 30;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::CONSERVATIVE,
    Self::BALANCED,
    Self::AGGRESSIVE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::CONSERVATIVE => Some("CONSERVATIVE"),
      Self::BALANCED => Some("BALANCED"),
      Self::AGGRESSIVE => Some("AGGRESSIVE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for PRUNING_LEVEL {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for PRUNING_LEVEL {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for PRUNING_LEVEL {
    type Output = PRUNING_LEVEL;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for PRUNING_LEVEL {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for PRUNING_LEVEL {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for PRUNING_LEVEL {}
pub enum DuconfigOffset {}
#[derive(Copy, Clone, PartialEq)]

/// User's personal application settings, applied across all projects
pub struct Duconfig<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Duconfig<'a> {
  type Inner = Duconfig<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Duconfig<'a> {
  pub const VT_THEME: flatbuffers::VOffsetT = 4;
  pub const VT_ANTI_ALIASING: flatbuffers::VOffsetT = 6;
  pub const VT_SHOW_HYPERLINK_POPUP: flatbuffers::VOffsetT = 8;
  pub const VT_ZOOM_STEP: flatbuffers::VOffsetT = 10;
  pub const VT_V_SYNC: flatbuffers::VOffsetT = 12;
  pub const VT_SCALE_RATIO_LOCKED: flatbuffers::VOffsetT = 14;
  pub const VT_DISPLAY_ALL_POINT_DISTANCES: flatbuffers::VOffsetT = 16;
  pub const VT_DISPLAY_DISTANCE_ON_DRAWING: flatbuffers::VOffsetT = 18;
  pub const VT_DISPLAY_ALL_POINT_COORDINATES: flatbuffers::VOffsetT = 20;
  pub const VT_DISPLAY_ALL_POINT_INFO_SELECTED: flatbuffers::VOffsetT = 22;
  pub const VT_DISPLAY_ROOT_AXIS: flatbuffers::VOffsetT = 24;
  pub const VT_DEBUG_RENDERING: flatbuffers::VOffsetT = 26;
  pub const VT_MANUAL_SAVE_MODE: flatbuffers::VOffsetT = 28;
  pub const VT_DEFAULT_VERSION_GRAPH_PRUNING_LEVEL: flatbuffers::VOffsetT = 30;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Duconfig { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DuconfigArgs
  ) -> flatbuffers::WIPOffset<Duconfig<'bldr>> {
    let mut builder = DuconfigBuilder::new(_fbb);
    builder.add_zoom_step(args.zoom_step);
    builder.add_default_version_graph_pruning_level(args.default_version_graph_pruning_level);
    builder.add_manual_save_mode(args.manual_save_mode);
    builder.add_debug_rendering(args.debug_rendering);
    builder.add_display_root_axis(args.display_root_axis);
    builder.add_display_all_point_info_selected(args.display_all_point_info_selected);
    builder.add_display_all_point_coordinates(args.display_all_point_coordinates);
    builder.add_display_distance_on_drawing(args.display_distance_on_drawing);
    builder.add_display_all_point_distances(args.display_all_point_distances);
    builder.add_scale_ratio_locked(args.scale_ratio_locked);
    builder.add_v_sync(args.v_sync);
    builder.add_show_hyperlink_popup(args.show_hyperlink_popup);
    builder.add_anti_aliasing(args.anti_aliasing);
    builder.add_theme(args.theme);
    builder.finish()
  }


  #[inline]
  pub fn theme(&self) -> THEME {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<THEME>(Duconfig::VT_THEME, Some(THEME::LIGHT)).unwrap()}
  }
  #[inline]
  pub fn anti_aliasing(&self) -> ANTI_ALIASING {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ANTI_ALIASING>(Duconfig::VT_ANTI_ALIASING, Some(ANTI_ALIASING::ANALYTIC)).unwrap()}
  }
  #[inline]
  pub fn show_hyperlink_popup(&self) -> SHOW_HYPERLINK_POPUP {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SHOW_HYPERLINK_POPUP>(Duconfig::VT_SHOW_HYPERLINK_POPUP, Some(SHOW_HYPERLINK_POPUP::INFO)).unwrap()}
  }
  #[inline]
  pub fn zoom_step(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Duconfig::VT_ZOOM_STEP, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn v_sync(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Duconfig::VT_V_SYNC, Some(false)).unwrap()}
  }
  #[inline]
  pub fn scale_ratio_locked(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Duconfig::VT_SCALE_RATIO_LOCKED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn display_all_point_distances(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Duconfig::VT_DISPLAY_ALL_POINT_DISTANCES, Some(false)).unwrap()}
  }
  #[inline]
  pub fn display_distance_on_drawing(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Duconfig::VT_DISPLAY_DISTANCE_ON_DRAWING, Some(false)).unwrap()}
  }
  #[inline]
  pub fn display_all_point_coordinates(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Duconfig::VT_DISPLAY_ALL_POINT_COORDINATES, Some(false)).unwrap()}
  }
  #[inline]
  pub fn display_all_point_info_selected(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Duconfig::VT_DISPLAY_ALL_POINT_INFO_SELECTED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn display_root_axis(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Duconfig::VT_DISPLAY_ROOT_AXIS, Some(false)).unwrap()}
  }
  #[inline]
  pub fn debug_rendering(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Duconfig::VT_DEBUG_RENDERING, Some(false)).unwrap()}
  }
  #[inline]
  pub fn manual_save_mode(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Duconfig::VT_MANUAL_SAVE_MODE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn default_version_graph_pruning_level(&self) -> PRUNING_LEVEL {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<PRUNING_LEVEL>(Duconfig::VT_DEFAULT_VERSION_GRAPH_PRUNING_LEVEL, Some(PRUNING_LEVEL::BALANCED)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Duconfig<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<THEME>("theme", Self::VT_THEME, false)?
     .visit_field::<ANTI_ALIASING>("anti_aliasing", Self::VT_ANTI_ALIASING, false)?
     .visit_field::<SHOW_HYPERLINK_POPUP>("show_hyperlink_popup", Self::VT_SHOW_HYPERLINK_POPUP, false)?
     .visit_field::<f32>("zoom_step", Self::VT_ZOOM_STEP, false)?
     .visit_field::<bool>("v_sync", Self::VT_V_SYNC, false)?
     .visit_field::<bool>("scale_ratio_locked", Self::VT_SCALE_RATIO_LOCKED, false)?
     .visit_field::<bool>("display_all_point_distances", Self::VT_DISPLAY_ALL_POINT_DISTANCES, false)?
     .visit_field::<bool>("display_distance_on_drawing", Self::VT_DISPLAY_DISTANCE_ON_DRAWING, false)?
     .visit_field::<bool>("display_all_point_coordinates", Self::VT_DISPLAY_ALL_POINT_COORDINATES, false)?
     .visit_field::<bool>("display_all_point_info_selected", Self::VT_DISPLAY_ALL_POINT_INFO_SELECTED, false)?
     .visit_field::<bool>("display_root_axis", Self::VT_DISPLAY_ROOT_AXIS, false)?
     .visit_field::<bool>("debug_rendering", Self::VT_DEBUG_RENDERING, false)?
     .visit_field::<bool>("manual_save_mode", Self::VT_MANUAL_SAVE_MODE, false)?
     .visit_field::<PRUNING_LEVEL>("default_version_graph_pruning_level", Self::VT_DEFAULT_VERSION_GRAPH_PRUNING_LEVEL, false)?
     .finish();
    Ok(())
  }
}
pub struct DuconfigArgs {
    pub theme: THEME,
    pub anti_aliasing: ANTI_ALIASING,
    pub show_hyperlink_popup: SHOW_HYPERLINK_POPUP,
    pub zoom_step: f32,
    pub v_sync: bool,
    pub scale_ratio_locked: bool,
    pub display_all_point_distances: bool,
    pub display_distance_on_drawing: bool,
    pub display_all_point_coordinates: bool,
    pub display_all_point_info_selected: bool,
    pub display_root_axis: bool,
    pub debug_rendering: bool,
    pub manual_save_mode: bool,
    pub default_version_graph_pruning_level: PRUNING_LEVEL,
}
impl<'a> Default for DuconfigArgs {
  #[inline]
  fn default() -> Self {
    DuconfigArgs {
      theme: THEME::LIGHT,
      anti_aliasing: ANTI_ALIASING::ANALYTIC,
      show_hyperlink_popup: SHOW_HYPERLINK_POPUP::INFO,
      zoom_step: 0.0,
      v_sync: false,
      scale_ratio_locked: false,
      display_all_point_distances: false,
      display_distance_on_drawing: false,
      display_all_point_coordinates: false,
      display_all_point_info_selected: false,
      display_root_axis: false,
      debug_rendering: false,
      manual_save_mode: false,
      default_version_graph_pruning_level: PRUNING_LEVEL::BALANCED,
    }
  }
}

pub struct DuconfigBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DuconfigBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_theme(&mut self, theme: THEME) {
    self.fbb_.push_slot::<THEME>(Duconfig::VT_THEME, theme, THEME::LIGHT);
  }
  #[inline]
  pub fn add_anti_aliasing(&mut self, anti_aliasing: ANTI_ALIASING) {
    self.fbb_.push_slot::<ANTI_ALIASING>(Duconfig::VT_ANTI_ALIASING, anti_aliasing, ANTI_ALIASING::ANALYTIC);
  }
  #[inline]
  pub fn add_show_hyperlink_popup(&mut self, show_hyperlink_popup: SHOW_HYPERLINK_POPUP) {
    self.fbb_.push_slot::<SHOW_HYPERLINK_POPUP>(Duconfig::VT_SHOW_HYPERLINK_POPUP, show_hyperlink_popup, SHOW_HYPERLINK_POPUP::INFO);
  }
  #[inline]
  pub fn add_zoom_step(&mut self, zoom_step: f32) {
    self.fbb_.push_slot::<f32>(Duconfig::VT_ZOOM_STEP, zoom_step, 0.0);
  }
  #[inline]
  pub fn add_v_sync(&mut self, v_sync: bool) {
    self.fbb_.push_slot::<bool>(Duconfig::VT_V_SYNC, v_sync, false);
  }
  #[inline]
  pub fn add_scale_ratio_locked(&mut self, scale_ratio_locked: bool) {
    self.fbb_.push_slot::<bool>(Duconfig::VT_SCALE_RATIO_LOCKED, scale_ratio_locked, false);
  }
  #[inline]
  pub fn add_display_all_point_distances(&mut self, display_all_point_distances: bool) {
    self.fbb_.push_slot::<bool>(Duconfig::VT_DISPLAY_ALL_POINT_DISTANCES, display_all_point_distances, false);
  }
  #[inline]
  pub fn add_display_distance_on_drawing(&mut self, display_distance_on_drawing: bool) {
    self.fbb_.push_slot::<bool>(Duconfig::VT_DISPLAY_DISTANCE_ON_DRAWING, display_distance_on_drawing, false);
  }
  #[inline]
  pub fn add_display_all_point_coordinates(&mut self, display_all_point_coordinates: bool) {
    self.fbb_.push_slot::<bool>(Duconfig::VT_DISPLAY_ALL_POINT_COORDINATES, display_all_point_coordinates, false);
  }
  #[inline]
  pub fn add_display_all_point_info_selected(&mut self, display_all_point_info_selected: bool) {
    self.fbb_.push_slot::<bool>(Duconfig::VT_DISPLAY_ALL_POINT_INFO_SELECTED, display_all_point_info_selected, false);
  }
  #[inline]
  pub fn add_display_root_axis(&mut self, display_root_axis: bool) {
    self.fbb_.push_slot::<bool>(Duconfig::VT_DISPLAY_ROOT_AXIS, display_root_axis, false);
  }
  #[inline]
  pub fn add_debug_rendering(&mut self, debug_rendering: bool) {
    self.fbb_.push_slot::<bool>(Duconfig::VT_DEBUG_RENDERING, debug_rendering, false);
  }
  #[inline]
  pub fn add_manual_save_mode(&mut self, manual_save_mode: bool) {
    self.fbb_.push_slot::<bool>(Duconfig::VT_MANUAL_SAVE_MODE, manual_save_mode, false);
  }
  #[inline]
  pub fn add_default_version_graph_pruning_level(&mut self, default_version_graph_pruning_level: PRUNING_LEVEL) {
    self.fbb_.push_slot::<PRUNING_LEVEL>(Duconfig::VT_DEFAULT_VERSION_GRAPH_PRUNING_LEVEL, default_version_graph_pruning_level, PRUNING_LEVEL::BALANCED);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DuconfigBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DuconfigBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Duconfig<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Duconfig<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Duconfig");
      ds.field("theme", &self.theme());
      ds.field("anti_aliasing", &self.anti_aliasing());
      ds.field("show_hyperlink_popup", &self.show_hyperlink_popup());
      ds.field("zoom_step", &self.zoom_step());
      ds.field("v_sync", &self.v_sync());
      ds.field("scale_ratio_locked", &self.scale_ratio_locked());
      ds.field("display_all_point_distances", &self.display_all_point_distances());
      ds.field("display_distance_on_drawing", &self.display_distance_on_drawing());
      ds.field("display_all_point_coordinates", &self.display_all_point_coordinates());
      ds.field("display_all_point_info_selected", &self.display_all_point_info_selected());
      ds.field("display_root_axis", &self.display_root_axis());
      ds.field("debug_rendering", &self.debug_rendering());
      ds.field("manual_save_mode", &self.manual_save_mode());
      ds.field("default_version_graph_pruning_level", &self.default_version_graph_pruning_level());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Duconfig`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_duconfig_unchecked`.
pub fn root_as_duconfig(buf: &[u8]) -> Result<Duconfig, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Duconfig>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Duconfig` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_duconfig_unchecked`.
pub fn size_prefixed_root_as_duconfig(buf: &[u8]) -> Result<Duconfig, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Duconfig>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Duconfig` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_duconfig_unchecked`.
pub fn root_as_duconfig_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Duconfig<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Duconfig<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Duconfig` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_duconfig_unchecked`.
pub fn size_prefixed_root_as_duconfig_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Duconfig<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Duconfig<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Duconfig and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Duconfig`.
pub unsafe fn root_as_duconfig_unchecked(buf: &[u8]) -> Duconfig {
  flatbuffers::root_unchecked::<Duconfig>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Duconfig and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Duconfig`.
pub unsafe fn size_prefixed_root_as_duconfig_unchecked(buf: &[u8]) -> Duconfig {
  flatbuffers::size_prefixed_root_unchecked::<Duconfig>(buf)
}
pub const DUCONFIG_IDENTIFIER: &str = "DFIG";

#[inline]
pub fn duconfig_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, DUCONFIG_IDENTIFIER, false)
}

#[inline]
pub fn duconfig_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, DUCONFIG_IDENTIFIER, true)
}

#[inline]
pub fn finish_duconfig_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<Duconfig<'a>>) {
  fbb.finish(root, Some(DUCONFIG_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_duconfig_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<Duconfig<'a>>) {
  fbb.finish_size_prefixed(root, Some(DUCONFIG_IDENTIFIER));
}
}  // pub mod Duconfig

