// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod duc {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_VERTICAL_ALIGN: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_VERTICAL_ALIGN: u8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_VERTICAL_ALIGN: [VERTICAL_ALIGN; 3] = [
  VERTICAL_ALIGN::TOP,
  VERTICAL_ALIGN::MIDDLE,
  VERTICAL_ALIGN::BOTTOM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct VERTICAL_ALIGN(pub u8);
#[allow(non_upper_case_globals)]
impl VERTICAL_ALIGN {
  pub const TOP: Self = Self(10);
  pub const MIDDLE: Self = Self(11);
  pub const BOTTOM: Self = Self(12);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::TOP,
    Self::MIDDLE,
    Self::BOTTOM,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::TOP => Some("TOP"),
      Self::MIDDLE => Some("MIDDLE"),
      Self::BOTTOM => Some("BOTTOM"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for VERTICAL_ALIGN {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for VERTICAL_ALIGN {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for VERTICAL_ALIGN {
    type Output = VERTICAL_ALIGN;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for VERTICAL_ALIGN {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for VERTICAL_ALIGN {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for VERTICAL_ALIGN {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TEXT_ALIGN: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TEXT_ALIGN: u8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TEXT_ALIGN: [TEXT_ALIGN; 3] = [
  TEXT_ALIGN::LEFT,
  TEXT_ALIGN::CENTER,
  TEXT_ALIGN::RIGHT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TEXT_ALIGN(pub u8);
#[allow(non_upper_case_globals)]
impl TEXT_ALIGN {
  pub const LEFT: Self = Self(10);
  pub const CENTER: Self = Self(11);
  pub const RIGHT: Self = Self(12);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::LEFT,
    Self::CENTER,
    Self::RIGHT,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::LEFT => Some("LEFT"),
      Self::CENTER => Some("CENTER"),
      Self::RIGHT => Some("RIGHT"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for TEXT_ALIGN {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for TEXT_ALIGN {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for TEXT_ALIGN {
    type Output = TEXT_ALIGN;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for TEXT_ALIGN {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for TEXT_ALIGN {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TEXT_ALIGN {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_STROKE_PLACEMENT: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_STROKE_PLACEMENT: u8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_STROKE_PLACEMENT: [STROKE_PLACEMENT; 3] = [
  STROKE_PLACEMENT::INSIDE,
  STROKE_PLACEMENT::CENTER,
  STROKE_PLACEMENT::OUTSIDE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct STROKE_PLACEMENT(pub u8);
#[allow(non_upper_case_globals)]
impl STROKE_PLACEMENT {
  pub const INSIDE: Self = Self(10);
  pub const CENTER: Self = Self(11);
  pub const OUTSIDE: Self = Self(12);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::INSIDE,
    Self::CENTER,
    Self::OUTSIDE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::INSIDE => Some("INSIDE"),
      Self::CENTER => Some("CENTER"),
      Self::OUTSIDE => Some("OUTSIDE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for STROKE_PLACEMENT {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for STROKE_PLACEMENT {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for STROKE_PLACEMENT {
    type Output = STROKE_PLACEMENT;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for STROKE_PLACEMENT {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for STROKE_PLACEMENT {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for STROKE_PLACEMENT {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_STROKE_WIDTH: u8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_STROKE_WIDTH: u8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_STROKE_WIDTH: [STROKE_WIDTH; 3] = [
  STROKE_WIDTH::THIN,
  STROKE_WIDTH::BOLD,
  STROKE_WIDTH::EXTRA_BOLD,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct STROKE_WIDTH(pub u8);
#[allow(non_upper_case_globals)]
impl STROKE_WIDTH {
  pub const THIN: Self = Self(1);
  pub const BOLD: Self = Self(2);
  pub const EXTRA_BOLD: Self = Self(4);

  pub const ENUM_MIN: u8 = 1;
  pub const ENUM_MAX: u8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::THIN,
    Self::BOLD,
    Self::EXTRA_BOLD,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::THIN => Some("THIN"),
      Self::BOLD => Some("BOLD"),
      Self::EXTRA_BOLD => Some("EXTRA_BOLD"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for STROKE_WIDTH {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for STROKE_WIDTH {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for STROKE_WIDTH {
    type Output = STROKE_WIDTH;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for STROKE_WIDTH {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for STROKE_WIDTH {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for STROKE_WIDTH {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ELEMENT_CONTENT_PREFERENCE: u8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ELEMENT_CONTENT_PREFERENCE: u8 = 18;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ELEMENT_CONTENT_PREFERENCE: [ELEMENT_CONTENT_PREFERENCE; 6] = [
  ELEMENT_CONTENT_PREFERENCE::SOLID,
  ELEMENT_CONTENT_PREFERENCE::FILL,
  ELEMENT_CONTENT_PREFERENCE::FIT,
  ELEMENT_CONTENT_PREFERENCE::TILE,
  ELEMENT_CONTENT_PREFERENCE::STRETCH,
  ELEMENT_CONTENT_PREFERENCE::HATCH,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ELEMENT_CONTENT_PREFERENCE(pub u8);
#[allow(non_upper_case_globals)]
impl ELEMENT_CONTENT_PREFERENCE {
  pub const SOLID: Self = Self(12);
  pub const FILL: Self = Self(14);
  pub const FIT: Self = Self(15);
  pub const TILE: Self = Self(16);
  pub const STRETCH: Self = Self(17);
  pub const HATCH: Self = Self(18);

  pub const ENUM_MIN: u8 = 12;
  pub const ENUM_MAX: u8 = 18;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SOLID,
    Self::FILL,
    Self::FIT,
    Self::TILE,
    Self::STRETCH,
    Self::HATCH,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::SOLID => Some("SOLID"),
      Self::FILL => Some("FILL"),
      Self::FIT => Some("FIT"),
      Self::TILE => Some("TILE"),
      Self::STRETCH => Some("STRETCH"),
      Self::HATCH => Some("HATCH"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ELEMENT_CONTENT_PREFERENCE {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ELEMENT_CONTENT_PREFERENCE {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ELEMENT_CONTENT_PREFERENCE {
    type Output = ELEMENT_CONTENT_PREFERENCE;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ELEMENT_CONTENT_PREFERENCE {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ELEMENT_CONTENT_PREFERENCE {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ELEMENT_CONTENT_PREFERENCE {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_STROKE_PREFERENCE: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_STROKE_PREFERENCE: u8 = 13;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_STROKE_PREFERENCE: [STROKE_PREFERENCE; 4] = [
  STROKE_PREFERENCE::SOLID,
  STROKE_PREFERENCE::DASHED,
  STROKE_PREFERENCE::DOTTED,
  STROKE_PREFERENCE::CUSTOM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct STROKE_PREFERENCE(pub u8);
#[allow(non_upper_case_globals)]
impl STROKE_PREFERENCE {
  pub const SOLID: Self = Self(10);
  pub const DASHED: Self = Self(11);
  pub const DOTTED: Self = Self(12);
  pub const CUSTOM: Self = Self(13);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 13;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SOLID,
    Self::DASHED,
    Self::DOTTED,
    Self::CUSTOM,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::SOLID => Some("SOLID"),
      Self::DASHED => Some("DASHED"),
      Self::DOTTED => Some("DOTTED"),
      Self::CUSTOM => Some("CUSTOM"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for STROKE_PREFERENCE {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for STROKE_PREFERENCE {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for STROKE_PREFERENCE {
    type Output = STROKE_PREFERENCE;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for STROKE_PREFERENCE {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for STROKE_PREFERENCE {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for STROKE_PREFERENCE {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_STROKE_SIDE_PREFERENCE: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_STROKE_SIDE_PREFERENCE: u8 = 15;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_STROKE_SIDE_PREFERENCE: [STROKE_SIDE_PREFERENCE; 6] = [
  STROKE_SIDE_PREFERENCE::TOP,
  STROKE_SIDE_PREFERENCE::BOTTOM,
  STROKE_SIDE_PREFERENCE::LEFT,
  STROKE_SIDE_PREFERENCE::RIGHT,
  STROKE_SIDE_PREFERENCE::CUSTOM,
  STROKE_SIDE_PREFERENCE::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct STROKE_SIDE_PREFERENCE(pub u8);
#[allow(non_upper_case_globals)]
impl STROKE_SIDE_PREFERENCE {
  pub const TOP: Self = Self(10);
  pub const BOTTOM: Self = Self(11);
  pub const LEFT: Self = Self(12);
  pub const RIGHT: Self = Self(13);
  pub const CUSTOM: Self = Self(14);
  pub const ALL: Self = Self(15);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 15;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::TOP,
    Self::BOTTOM,
    Self::LEFT,
    Self::RIGHT,
    Self::CUSTOM,
    Self::ALL,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::TOP => Some("TOP"),
      Self::BOTTOM => Some("BOTTOM"),
      Self::LEFT => Some("LEFT"),
      Self::RIGHT => Some("RIGHT"),
      Self::CUSTOM => Some("CUSTOM"),
      Self::ALL => Some("ALL"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for STROKE_SIDE_PREFERENCE {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for STROKE_SIDE_PREFERENCE {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for STROKE_SIDE_PREFERENCE {
    type Output = STROKE_SIDE_PREFERENCE;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for STROKE_SIDE_PREFERENCE {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for STROKE_SIDE_PREFERENCE {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for STROKE_SIDE_PREFERENCE {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_STROKE_CAP: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_STROKE_CAP: u8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_STROKE_CAP: [STROKE_CAP; 3] = [
  STROKE_CAP::BUTT,
  STROKE_CAP::ROUND,
  STROKE_CAP::SQUARE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct STROKE_CAP(pub u8);
#[allow(non_upper_case_globals)]
impl STROKE_CAP {
  pub const BUTT: Self = Self(10);
  pub const ROUND: Self = Self(11);
  pub const SQUARE: Self = Self(12);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::BUTT,
    Self::ROUND,
    Self::SQUARE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::BUTT => Some("BUTT"),
      Self::ROUND => Some("ROUND"),
      Self::SQUARE => Some("SQUARE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for STROKE_CAP {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for STROKE_CAP {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for STROKE_CAP {
    type Output = STROKE_CAP;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for STROKE_CAP {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for STROKE_CAP {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for STROKE_CAP {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_STROKE_JOIN: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_STROKE_JOIN: u8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_STROKE_JOIN: [STROKE_JOIN; 3] = [
  STROKE_JOIN::MITER,
  STROKE_JOIN::ROUND,
  STROKE_JOIN::BEVEL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct STROKE_JOIN(pub u8);
#[allow(non_upper_case_globals)]
impl STROKE_JOIN {
  pub const MITER: Self = Self(10);
  pub const ROUND: Self = Self(11);
  pub const BEVEL: Self = Self(12);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::MITER,
    Self::ROUND,
    Self::BEVEL,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::MITER => Some("MITER"),
      Self::ROUND => Some("ROUND"),
      Self::BEVEL => Some("BEVEL"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for STROKE_JOIN {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for STROKE_JOIN {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for STROKE_JOIN {
    type Output = STROKE_JOIN;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for STROKE_JOIN {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for STROKE_JOIN {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for STROKE_JOIN {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_LINE_HEAD: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_LINE_HEAD: u8 = 24;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_LINE_HEAD: [LINE_HEAD; 15] = [
  LINE_HEAD::ARROW,
  LINE_HEAD::BAR,
  LINE_HEAD::CIRCLE,
  LINE_HEAD::CIRCLE_OUTLINED,
  LINE_HEAD::TRIANGLE,
  LINE_HEAD::TRIANGLE_OUTLINED,
  LINE_HEAD::DIAMOND,
  LINE_HEAD::DIAMOND_OUTLINED,
  LINE_HEAD::CROSS,
  LINE_HEAD::OPEN_ARROW,
  LINE_HEAD::REVERSED_ARROW,
  LINE_HEAD::REVERSED_TRIANGLE,
  LINE_HEAD::REVERSED_TRIANGLE_OUTLINED,
  LINE_HEAD::CONE,
  LINE_HEAD::HALF_CONE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct LINE_HEAD(pub u8);
#[allow(non_upper_case_globals)]
impl LINE_HEAD {
  pub const ARROW: Self = Self(10);
  pub const BAR: Self = Self(11);
  pub const CIRCLE: Self = Self(12);
  pub const CIRCLE_OUTLINED: Self = Self(13);
  pub const TRIANGLE: Self = Self(14);
  pub const TRIANGLE_OUTLINED: Self = Self(15);
  pub const DIAMOND: Self = Self(16);
  pub const DIAMOND_OUTLINED: Self = Self(17);
  pub const CROSS: Self = Self(18);
  pub const OPEN_ARROW: Self = Self(19);
  pub const REVERSED_ARROW: Self = Self(20);
  pub const REVERSED_TRIANGLE: Self = Self(21);
  pub const REVERSED_TRIANGLE_OUTLINED: Self = Self(22);
  pub const CONE: Self = Self(23);
  pub const HALF_CONE: Self = Self(24);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 24;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ARROW,
    Self::BAR,
    Self::CIRCLE,
    Self::CIRCLE_OUTLINED,
    Self::TRIANGLE,
    Self::TRIANGLE_OUTLINED,
    Self::DIAMOND,
    Self::DIAMOND_OUTLINED,
    Self::CROSS,
    Self::OPEN_ARROW,
    Self::REVERSED_ARROW,
    Self::REVERSED_TRIANGLE,
    Self::REVERSED_TRIANGLE_OUTLINED,
    Self::CONE,
    Self::HALF_CONE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::ARROW => Some("ARROW"),
      Self::BAR => Some("BAR"),
      Self::CIRCLE => Some("CIRCLE"),
      Self::CIRCLE_OUTLINED => Some("CIRCLE_OUTLINED"),
      Self::TRIANGLE => Some("TRIANGLE"),
      Self::TRIANGLE_OUTLINED => Some("TRIANGLE_OUTLINED"),
      Self::DIAMOND => Some("DIAMOND"),
      Self::DIAMOND_OUTLINED => Some("DIAMOND_OUTLINED"),
      Self::CROSS => Some("CROSS"),
      Self::OPEN_ARROW => Some("OPEN_ARROW"),
      Self::REVERSED_ARROW => Some("REVERSED_ARROW"),
      Self::REVERSED_TRIANGLE => Some("REVERSED_TRIANGLE"),
      Self::REVERSED_TRIANGLE_OUTLINED => Some("REVERSED_TRIANGLE_OUTLINED"),
      Self::CONE => Some("CONE"),
      Self::HALF_CONE => Some("HALF_CONE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for LINE_HEAD {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for LINE_HEAD {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for LINE_HEAD {
    type Output = LINE_HEAD;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for LINE_HEAD {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for LINE_HEAD {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for LINE_HEAD {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_BEZIER_MIRRORING: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_BEZIER_MIRRORING: u8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_BEZIER_MIRRORING: [BEZIER_MIRRORING; 3] = [
  BEZIER_MIRRORING::NONE,
  BEZIER_MIRRORING::ANGLE,
  BEZIER_MIRRORING::ANGLE_LENGTH,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct BEZIER_MIRRORING(pub u8);
#[allow(non_upper_case_globals)]
impl BEZIER_MIRRORING {
  pub const NONE: Self = Self(10);
  pub const ANGLE: Self = Self(11);
  pub const ANGLE_LENGTH: Self = Self(12);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::ANGLE,
    Self::ANGLE_LENGTH,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::ANGLE => Some("ANGLE"),
      Self::ANGLE_LENGTH => Some("ANGLE_LENGTH"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for BEZIER_MIRRORING {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for BEZIER_MIRRORING {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for BEZIER_MIRRORING {
    type Output = BEZIER_MIRRORING;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for BEZIER_MIRRORING {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for BEZIER_MIRRORING {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for BEZIER_MIRRORING {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_HANDLE_TYPE: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_HANDLE_TYPE: u8 = 11;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_HANDLE_TYPE: [HANDLE_TYPE; 2] = [
  HANDLE_TYPE::HANDLE_IN,
  HANDLE_TYPE::HANDLE_OUT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct HANDLE_TYPE(pub u8);
#[allow(non_upper_case_globals)]
impl HANDLE_TYPE {
  pub const HANDLE_IN: Self = Self(10);
  pub const HANDLE_OUT: Self = Self(11);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 11;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::HANDLE_IN,
    Self::HANDLE_OUT,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::HANDLE_IN => Some("HANDLE_IN"),
      Self::HANDLE_OUT => Some("HANDLE_OUT"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for HANDLE_TYPE {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for HANDLE_TYPE {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for HANDLE_TYPE {
    type Output = HANDLE_TYPE;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for HANDLE_TYPE {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for HANDLE_TYPE {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for HANDLE_TYPE {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ANTI_ALIASING: u8 = 8;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ANTI_ALIASING: u8 = 16;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ANTI_ALIASING: [ANTI_ALIASING; 4] = [
  ANTI_ALIASING::MSAA_8,
  ANTI_ALIASING::NONE,
  ANTI_ALIASING::ANALYTIC,
  ANTI_ALIASING::MSAA_16,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ANTI_ALIASING(pub u8);
#[allow(non_upper_case_globals)]
impl ANTI_ALIASING {
  pub const MSAA_8: Self = Self(8);
  pub const NONE: Self = Self(10);
  pub const ANALYTIC: Self = Self(11);
  pub const MSAA_16: Self = Self(16);

  pub const ENUM_MIN: u8 = 8;
  pub const ENUM_MAX: u8 = 16;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::MSAA_8,
    Self::NONE,
    Self::ANALYTIC,
    Self::MSAA_16,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::MSAA_8 => Some("MSAA_8"),
      Self::NONE => Some("NONE"),
      Self::ANALYTIC => Some("ANALYTIC"),
      Self::MSAA_16 => Some("MSAA_16"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ANTI_ALIASING {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ANTI_ALIASING {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ANTI_ALIASING {
    type Output = ANTI_ALIASING;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ANTI_ALIASING {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ANTI_ALIASING {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ANTI_ALIASING {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_YOUTUBE_STATES: i8 = -1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_YOUTUBE_STATES: i8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_YOUTUBE_STATES: [YOUTUBE_STATES; 6] = [
  YOUTUBE_STATES::UNSTARTED,
  YOUTUBE_STATES::ENDED,
  YOUTUBE_STATES::PLAYING,
  YOUTUBE_STATES::PAUSED,
  YOUTUBE_STATES::BUFFERING,
  YOUTUBE_STATES::CUED,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct YOUTUBE_STATES(pub i8);
#[allow(non_upper_case_globals)]
impl YOUTUBE_STATES {
  pub const UNSTARTED: Self = Self(-1);
  pub const ENDED: Self = Self(0);
  pub const PLAYING: Self = Self(1);
  pub const PAUSED: Self = Self(2);
  pub const BUFFERING: Self = Self(3);
  pub const CUED: Self = Self(5);

  pub const ENUM_MIN: i8 = -1;
  pub const ENUM_MAX: i8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::UNSTARTED,
    Self::ENDED,
    Self::PLAYING,
    Self::PAUSED,
    Self::BUFFERING,
    Self::CUED,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::UNSTARTED => Some("UNSTARTED"),
      Self::ENDED => Some("ENDED"),
      Self::PLAYING => Some("PLAYING"),
      Self::PAUSED => Some("PAUSED"),
      Self::BUFFERING => Some("BUFFERING"),
      Self::CUED => Some("CUED"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for YOUTUBE_STATES {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for YOUTUBE_STATES {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for YOUTUBE_STATES {
    type Output = YOUTUBE_STATES;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for YOUTUBE_STATES {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for YOUTUBE_STATES {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for YOUTUBE_STATES {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_BLENDING: u8 = 11;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_BLENDING: u8 = 17;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_BLENDING: [BLENDING; 7] = [
  BLENDING::MULTIPLY,
  BLENDING::SCREEN,
  BLENDING::OVERLAY,
  BLENDING::DARKEN,
  BLENDING::LIGHTEN,
  BLENDING::DIFFERENCE,
  BLENDING::EXCLUSION,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct BLENDING(pub u8);
#[allow(non_upper_case_globals)]
impl BLENDING {
  pub const MULTIPLY: Self = Self(11);
  pub const SCREEN: Self = Self(12);
  pub const OVERLAY: Self = Self(13);
  pub const DARKEN: Self = Self(14);
  pub const LIGHTEN: Self = Self(15);
  pub const DIFFERENCE: Self = Self(16);
  pub const EXCLUSION: Self = Self(17);

  pub const ENUM_MIN: u8 = 11;
  pub const ENUM_MAX: u8 = 17;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::MULTIPLY,
    Self::SCREEN,
    Self::OVERLAY,
    Self::DARKEN,
    Self::LIGHTEN,
    Self::DIFFERENCE,
    Self::EXCLUSION,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::MULTIPLY => Some("MULTIPLY"),
      Self::SCREEN => Some("SCREEN"),
      Self::OVERLAY => Some("OVERLAY"),
      Self::DARKEN => Some("DARKEN"),
      Self::LIGHTEN => Some("LIGHTEN"),
      Self::DIFFERENCE => Some("DIFFERENCE"),
      Self::EXCLUSION => Some("EXCLUSION"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for BLENDING {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for BLENDING {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for BLENDING {
    type Output = BLENDING;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for BLENDING {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for BLENDING {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for BLENDING {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_GRID_DISPLAY_TYPE: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_GRID_DISPLAY_TYPE: u8 = 13;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_GRID_DISPLAY_TYPE: [GRID_DISPLAY_TYPE; 4] = [
  GRID_DISPLAY_TYPE::LINES,
  GRID_DISPLAY_TYPE::DOTS,
  GRID_DISPLAY_TYPE::CROSSES,
  GRID_DISPLAY_TYPE::ADAPTIVE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct GRID_DISPLAY_TYPE(pub u8);
#[allow(non_upper_case_globals)]
impl GRID_DISPLAY_TYPE {
  pub const LINES: Self = Self(10);
  pub const DOTS: Self = Self(11);
  pub const CROSSES: Self = Self(12);
  pub const ADAPTIVE: Self = Self(13);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 13;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::LINES,
    Self::DOTS,
    Self::CROSSES,
    Self::ADAPTIVE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::LINES => Some("LINES"),
      Self::DOTS => Some("DOTS"),
      Self::CROSSES => Some("CROSSES"),
      Self::ADAPTIVE => Some("ADAPTIVE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for GRID_DISPLAY_TYPE {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for GRID_DISPLAY_TYPE {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for GRID_DISPLAY_TYPE {
    type Output = GRID_DISPLAY_TYPE;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for GRID_DISPLAY_TYPE {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for GRID_DISPLAY_TYPE {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for GRID_DISPLAY_TYPE {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_GRID_TYPE: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_GRID_TYPE: u8 = 14;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_GRID_TYPE: [GRID_TYPE; 5] = [
  GRID_TYPE::RECTANGULAR,
  GRID_TYPE::ISOMETRIC,
  GRID_TYPE::POLAR,
  GRID_TYPE::TRIANGULAR,
  GRID_TYPE::CUSTOM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct GRID_TYPE(pub u8);
#[allow(non_upper_case_globals)]
impl GRID_TYPE {
  pub const RECTANGULAR: Self = Self(10);
  pub const ISOMETRIC: Self = Self(11);
  pub const POLAR: Self = Self(12);
  pub const TRIANGULAR: Self = Self(13);
  pub const CUSTOM: Self = Self(14);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 14;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::RECTANGULAR,
    Self::ISOMETRIC,
    Self::POLAR,
    Self::TRIANGULAR,
    Self::CUSTOM,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::RECTANGULAR => Some("RECTANGULAR"),
      Self::ISOMETRIC => Some("ISOMETRIC"),
      Self::POLAR => Some("POLAR"),
      Self::TRIANGULAR => Some("TRIANGULAR"),
      Self::CUSTOM => Some("CUSTOM"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for GRID_TYPE {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for GRID_TYPE {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for GRID_TYPE {
    type Output = GRID_TYPE;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for GRID_TYPE {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for GRID_TYPE {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for GRID_TYPE {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_OBJECT_SNAP_MODE: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_OBJECT_SNAP_MODE: u8 = 28;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_OBJECT_SNAP_MODE: [OBJECT_SNAP_MODE; 19] = [
  OBJECT_SNAP_MODE::ENDPOINT,
  OBJECT_SNAP_MODE::MIDPOINT,
  OBJECT_SNAP_MODE::CENTER,
  OBJECT_SNAP_MODE::QUADRANT,
  OBJECT_SNAP_MODE::INTERSECTION,
  OBJECT_SNAP_MODE::EXTENSION,
  OBJECT_SNAP_MODE::PERPENDICULAR,
  OBJECT_SNAP_MODE::TANGENT,
  OBJECT_SNAP_MODE::NEAREST,
  OBJECT_SNAP_MODE::NODE,
  OBJECT_SNAP_MODE::INSERT,
  OBJECT_SNAP_MODE::PARALLEL,
  OBJECT_SNAP_MODE::APPARENT,
  OBJECT_SNAP_MODE::FROM,
  OBJECT_SNAP_MODE::POINT_FILTER,
  OBJECT_SNAP_MODE::TEMPORARY,
  OBJECT_SNAP_MODE::BETWEEN_TWO_POINTS,
  OBJECT_SNAP_MODE::POINT_ON_CURVE,
  OBJECT_SNAP_MODE::GEOMETRIC,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct OBJECT_SNAP_MODE(pub u8);
#[allow(non_upper_case_globals)]
impl OBJECT_SNAP_MODE {
  pub const ENDPOINT: Self = Self(10);
  pub const MIDPOINT: Self = Self(11);
  pub const CENTER: Self = Self(12);
  pub const QUADRANT: Self = Self(13);
  pub const INTERSECTION: Self = Self(14);
  pub const EXTENSION: Self = Self(15);
  pub const PERPENDICULAR: Self = Self(16);
  pub const TANGENT: Self = Self(17);
  pub const NEAREST: Self = Self(18);
  pub const NODE: Self = Self(19);
  pub const INSERT: Self = Self(20);
  pub const PARALLEL: Self = Self(21);
  pub const APPARENT: Self = Self(22);
  pub const FROM: Self = Self(23);
  pub const POINT_FILTER: Self = Self(24);
  pub const TEMPORARY: Self = Self(25);
  pub const BETWEEN_TWO_POINTS: Self = Self(26);
  pub const POINT_ON_CURVE: Self = Self(27);
  pub const GEOMETRIC: Self = Self(28);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 28;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ENDPOINT,
    Self::MIDPOINT,
    Self::CENTER,
    Self::QUADRANT,
    Self::INTERSECTION,
    Self::EXTENSION,
    Self::PERPENDICULAR,
    Self::TANGENT,
    Self::NEAREST,
    Self::NODE,
    Self::INSERT,
    Self::PARALLEL,
    Self::APPARENT,
    Self::FROM,
    Self::POINT_FILTER,
    Self::TEMPORARY,
    Self::BETWEEN_TWO_POINTS,
    Self::POINT_ON_CURVE,
    Self::GEOMETRIC,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::ENDPOINT => Some("ENDPOINT"),
      Self::MIDPOINT => Some("MIDPOINT"),
      Self::CENTER => Some("CENTER"),
      Self::QUADRANT => Some("QUADRANT"),
      Self::INTERSECTION => Some("INTERSECTION"),
      Self::EXTENSION => Some("EXTENSION"),
      Self::PERPENDICULAR => Some("PERPENDICULAR"),
      Self::TANGENT => Some("TANGENT"),
      Self::NEAREST => Some("NEAREST"),
      Self::NODE => Some("NODE"),
      Self::INSERT => Some("INSERT"),
      Self::PARALLEL => Some("PARALLEL"),
      Self::APPARENT => Some("APPARENT"),
      Self::FROM => Some("FROM"),
      Self::POINT_FILTER => Some("POINT_FILTER"),
      Self::TEMPORARY => Some("TEMPORARY"),
      Self::BETWEEN_TWO_POINTS => Some("BETWEEN_TWO_POINTS"),
      Self::POINT_ON_CURVE => Some("POINT_ON_CURVE"),
      Self::GEOMETRIC => Some("GEOMETRIC"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for OBJECT_SNAP_MODE {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for OBJECT_SNAP_MODE {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for OBJECT_SNAP_MODE {
    type Output = OBJECT_SNAP_MODE;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for OBJECT_SNAP_MODE {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for OBJECT_SNAP_MODE {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for OBJECT_SNAP_MODE {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SNAP_MODE: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SNAP_MODE: u8 = 11;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SNAP_MODE: [SNAP_MODE; 2] = [
  SNAP_MODE::RUNNING,
  SNAP_MODE::SINGLE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SNAP_MODE(pub u8);
#[allow(non_upper_case_globals)]
impl SNAP_MODE {
  pub const RUNNING: Self = Self(10);
  pub const SINGLE: Self = Self(11);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 11;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::RUNNING,
    Self::SINGLE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::RUNNING => Some("RUNNING"),
      Self::SINGLE => Some("SINGLE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SNAP_MODE {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SNAP_MODE {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for SNAP_MODE {
    type Output = SNAP_MODE;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SNAP_MODE {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SNAP_MODE {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SNAP_MODE {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SNAP_OVERRIDE_BEHAVIOR: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SNAP_OVERRIDE_BEHAVIOR: u8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SNAP_OVERRIDE_BEHAVIOR: [SNAP_OVERRIDE_BEHAVIOR; 3] = [
  SNAP_OVERRIDE_BEHAVIOR::DISABLE,
  SNAP_OVERRIDE_BEHAVIOR::FORCE_GRID,
  SNAP_OVERRIDE_BEHAVIOR::FORCE_OBJECT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SNAP_OVERRIDE_BEHAVIOR(pub u8);
#[allow(non_upper_case_globals)]
impl SNAP_OVERRIDE_BEHAVIOR {
  pub const DISABLE: Self = Self(10);
  pub const FORCE_GRID: Self = Self(11);
  pub const FORCE_OBJECT: Self = Self(12);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::DISABLE,
    Self::FORCE_GRID,
    Self::FORCE_OBJECT,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::DISABLE => Some("DISABLE"),
      Self::FORCE_GRID => Some("FORCE_GRID"),
      Self::FORCE_OBJECT => Some("FORCE_OBJECT"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SNAP_OVERRIDE_BEHAVIOR {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SNAP_OVERRIDE_BEHAVIOR {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for SNAP_OVERRIDE_BEHAVIOR {
    type Output = SNAP_OVERRIDE_BEHAVIOR;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SNAP_OVERRIDE_BEHAVIOR {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SNAP_OVERRIDE_BEHAVIOR {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SNAP_OVERRIDE_BEHAVIOR {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SNAP_MARKER_SHAPE: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SNAP_MARKER_SHAPE: u8 = 13;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SNAP_MARKER_SHAPE: [SNAP_MARKER_SHAPE; 4] = [
  SNAP_MARKER_SHAPE::SQUARE,
  SNAP_MARKER_SHAPE::CIRCLE,
  SNAP_MARKER_SHAPE::TRIANGLE,
  SNAP_MARKER_SHAPE::X,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SNAP_MARKER_SHAPE(pub u8);
#[allow(non_upper_case_globals)]
impl SNAP_MARKER_SHAPE {
  pub const SQUARE: Self = Self(10);
  pub const CIRCLE: Self = Self(11);
  pub const TRIANGLE: Self = Self(12);
  pub const X: Self = Self(13);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 13;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SQUARE,
    Self::CIRCLE,
    Self::TRIANGLE,
    Self::X,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::SQUARE => Some("SQUARE"),
      Self::CIRCLE => Some("CIRCLE"),
      Self::TRIANGLE => Some("TRIANGLE"),
      Self::X => Some("X"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SNAP_MARKER_SHAPE {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SNAP_MARKER_SHAPE {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for SNAP_MARKER_SHAPE {
    type Output = SNAP_MARKER_SHAPE;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SNAP_MARKER_SHAPE {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SNAP_MARKER_SHAPE {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SNAP_MARKER_SHAPE {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TABLE_CELL_ALIGNMENT: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TABLE_CELL_ALIGNMENT: u8 = 18;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TABLE_CELL_ALIGNMENT: [TABLE_CELL_ALIGNMENT; 9] = [
  TABLE_CELL_ALIGNMENT::TOP_LEFT,
  TABLE_CELL_ALIGNMENT::TOP_CENTER,
  TABLE_CELL_ALIGNMENT::TOP_RIGHT,
  TABLE_CELL_ALIGNMENT::MIDDLE_LEFT,
  TABLE_CELL_ALIGNMENT::MIDDLE_CENTER,
  TABLE_CELL_ALIGNMENT::MIDDLE_RIGHT,
  TABLE_CELL_ALIGNMENT::BOTTOM_LEFT,
  TABLE_CELL_ALIGNMENT::BOTTOM_CENTER,
  TABLE_CELL_ALIGNMENT::BOTTOM_RIGHT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TABLE_CELL_ALIGNMENT(pub u8);
#[allow(non_upper_case_globals)]
impl TABLE_CELL_ALIGNMENT {
  pub const TOP_LEFT: Self = Self(10);
  pub const TOP_CENTER: Self = Self(11);
  pub const TOP_RIGHT: Self = Self(12);
  pub const MIDDLE_LEFT: Self = Self(13);
  pub const MIDDLE_CENTER: Self = Self(14);
  pub const MIDDLE_RIGHT: Self = Self(15);
  pub const BOTTOM_LEFT: Self = Self(16);
  pub const BOTTOM_CENTER: Self = Self(17);
  pub const BOTTOM_RIGHT: Self = Self(18);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 18;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::TOP_LEFT,
    Self::TOP_CENTER,
    Self::TOP_RIGHT,
    Self::MIDDLE_LEFT,
    Self::MIDDLE_CENTER,
    Self::MIDDLE_RIGHT,
    Self::BOTTOM_LEFT,
    Self::BOTTOM_CENTER,
    Self::BOTTOM_RIGHT,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::TOP_LEFT => Some("TOP_LEFT"),
      Self::TOP_CENTER => Some("TOP_CENTER"),
      Self::TOP_RIGHT => Some("TOP_RIGHT"),
      Self::MIDDLE_LEFT => Some("MIDDLE_LEFT"),
      Self::MIDDLE_CENTER => Some("MIDDLE_CENTER"),
      Self::MIDDLE_RIGHT => Some("MIDDLE_RIGHT"),
      Self::BOTTOM_LEFT => Some("BOTTOM_LEFT"),
      Self::BOTTOM_CENTER => Some("BOTTOM_CENTER"),
      Self::BOTTOM_RIGHT => Some("BOTTOM_RIGHT"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for TABLE_CELL_ALIGNMENT {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for TABLE_CELL_ALIGNMENT {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for TABLE_CELL_ALIGNMENT {
    type Output = TABLE_CELL_ALIGNMENT;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for TABLE_CELL_ALIGNMENT {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for TABLE_CELL_ALIGNMENT {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TABLE_CELL_ALIGNMENT {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TABLE_FLOW_DIRECTION: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TABLE_FLOW_DIRECTION: u8 = 11;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TABLE_FLOW_DIRECTION: [TABLE_FLOW_DIRECTION; 2] = [
  TABLE_FLOW_DIRECTION::DOWN,
  TABLE_FLOW_DIRECTION::UP,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TABLE_FLOW_DIRECTION(pub u8);
#[allow(non_upper_case_globals)]
impl TABLE_FLOW_DIRECTION {
  pub const DOWN: Self = Self(10);
  pub const UP: Self = Self(11);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 11;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::DOWN,
    Self::UP,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::DOWN => Some("DOWN"),
      Self::UP => Some("UP"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for TABLE_FLOW_DIRECTION {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for TABLE_FLOW_DIRECTION {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for TABLE_FLOW_DIRECTION {
    type Output = TABLE_FLOW_DIRECTION;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for TABLE_FLOW_DIRECTION {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for TABLE_FLOW_DIRECTION {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TABLE_FLOW_DIRECTION {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TOLERANCE_DISPLAY: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TOLERANCE_DISPLAY: u8 = 14;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TOLERANCE_DISPLAY: [TOLERANCE_DISPLAY; 5] = [
  TOLERANCE_DISPLAY::NONE,
  TOLERANCE_DISPLAY::SYMMETRICAL,
  TOLERANCE_DISPLAY::DEVIATION,
  TOLERANCE_DISPLAY::LIMITS,
  TOLERANCE_DISPLAY::BASIC,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TOLERANCE_DISPLAY(pub u8);
#[allow(non_upper_case_globals)]
impl TOLERANCE_DISPLAY {
  pub const NONE: Self = Self(10);
  pub const SYMMETRICAL: Self = Self(11);
  pub const DEVIATION: Self = Self(12);
  pub const LIMITS: Self = Self(13);
  pub const BASIC: Self = Self(14);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 14;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::SYMMETRICAL,
    Self::DEVIATION,
    Self::LIMITS,
    Self::BASIC,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::SYMMETRICAL => Some("SYMMETRICAL"),
      Self::DEVIATION => Some("DEVIATION"),
      Self::LIMITS => Some("LIMITS"),
      Self::BASIC => Some("BASIC"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for TOLERANCE_DISPLAY {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for TOLERANCE_DISPLAY {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for TOLERANCE_DISPLAY {
    type Output = TOLERANCE_DISPLAY;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for TOLERANCE_DISPLAY {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for TOLERANCE_DISPLAY {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TOLERANCE_DISPLAY {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DIMENSION_TYPE: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DIMENSION_TYPE: u8 = 22;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DIMENSION_TYPE: [DIMENSION_TYPE; 13] = [
  DIMENSION_TYPE::LINEAR,
  DIMENSION_TYPE::ALIGNED,
  DIMENSION_TYPE::ANGULAR,
  DIMENSION_TYPE::ARC_LENGTH,
  DIMENSION_TYPE::RADIUS,
  DIMENSION_TYPE::DIAMETER,
  DIMENSION_TYPE::CENTER_MARK,
  DIMENSION_TYPE::ROTATED,
  DIMENSION_TYPE::SPACING,
  DIMENSION_TYPE::CONTINUE,
  DIMENSION_TYPE::BASELINE,
  DIMENSION_TYPE::JOGGED_LINEAR,
  DIMENSION_TYPE::ORDINATE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DIMENSION_TYPE(pub u8);
#[allow(non_upper_case_globals)]
impl DIMENSION_TYPE {
  pub const LINEAR: Self = Self(10);
  pub const ALIGNED: Self = Self(11);
  pub const ANGULAR: Self = Self(12);
  pub const ARC_LENGTH: Self = Self(13);
  pub const RADIUS: Self = Self(14);
  pub const DIAMETER: Self = Self(15);
  pub const CENTER_MARK: Self = Self(16);
  pub const ROTATED: Self = Self(17);
  pub const SPACING: Self = Self(18);
  pub const CONTINUE: Self = Self(19);
  pub const BASELINE: Self = Self(20);
  pub const JOGGED_LINEAR: Self = Self(21);
  pub const ORDINATE: Self = Self(22);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 22;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::LINEAR,
    Self::ALIGNED,
    Self::ANGULAR,
    Self::ARC_LENGTH,
    Self::RADIUS,
    Self::DIAMETER,
    Self::CENTER_MARK,
    Self::ROTATED,
    Self::SPACING,
    Self::CONTINUE,
    Self::BASELINE,
    Self::JOGGED_LINEAR,
    Self::ORDINATE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::LINEAR => Some("LINEAR"),
      Self::ALIGNED => Some("ALIGNED"),
      Self::ANGULAR => Some("ANGULAR"),
      Self::ARC_LENGTH => Some("ARC_LENGTH"),
      Self::RADIUS => Some("RADIUS"),
      Self::DIAMETER => Some("DIAMETER"),
      Self::CENTER_MARK => Some("CENTER_MARK"),
      Self::ROTATED => Some("ROTATED"),
      Self::SPACING => Some("SPACING"),
      Self::CONTINUE => Some("CONTINUE"),
      Self::BASELINE => Some("BASELINE"),
      Self::JOGGED_LINEAR => Some("JOGGED_LINEAR"),
      Self::ORDINATE => Some("ORDINATE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DIMENSION_TYPE {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DIMENSION_TYPE {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for DIMENSION_TYPE {
    type Output = DIMENSION_TYPE;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DIMENSION_TYPE {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DIMENSION_TYPE {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DIMENSION_TYPE {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MARK_ELLIPSE_CENTER: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MARK_ELLIPSE_CENTER: u8 = 11;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MARK_ELLIPSE_CENTER: [MARK_ELLIPSE_CENTER; 2] = [
  MARK_ELLIPSE_CENTER::MARK,
  MARK_ELLIPSE_CENTER::LINE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MARK_ELLIPSE_CENTER(pub u8);
#[allow(non_upper_case_globals)]
impl MARK_ELLIPSE_CENTER {
  pub const MARK: Self = Self(10);
  pub const LINE: Self = Self(11);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 11;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::MARK,
    Self::LINE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::MARK => Some("MARK"),
      Self::LINE => Some("LINE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for MARK_ELLIPSE_CENTER {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for MARK_ELLIPSE_CENTER {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for MARK_ELLIPSE_CENTER {
    type Output = MARK_ELLIPSE_CENTER;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for MARK_ELLIPSE_CENTER {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for MARK_ELLIPSE_CENTER {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for MARK_ELLIPSE_CENTER {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TEXT_FLOW_DIRECTION: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TEXT_FLOW_DIRECTION: u8 = 13;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TEXT_FLOW_DIRECTION: [TEXT_FLOW_DIRECTION; 4] = [
  TEXT_FLOW_DIRECTION::LEFT_TO_RIGHT,
  TEXT_FLOW_DIRECTION::RIGHT_TO_LEFT,
  TEXT_FLOW_DIRECTION::TOP_TO_BOTTOM,
  TEXT_FLOW_DIRECTION::BOTTOM_TO_TOP,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TEXT_FLOW_DIRECTION(pub u8);
#[allow(non_upper_case_globals)]
impl TEXT_FLOW_DIRECTION {
  pub const LEFT_TO_RIGHT: Self = Self(10);
  pub const RIGHT_TO_LEFT: Self = Self(11);
  pub const TOP_TO_BOTTOM: Self = Self(12);
  pub const BOTTOM_TO_TOP: Self = Self(13);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 13;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::LEFT_TO_RIGHT,
    Self::RIGHT_TO_LEFT,
    Self::TOP_TO_BOTTOM,
    Self::BOTTOM_TO_TOP,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::LEFT_TO_RIGHT => Some("LEFT_TO_RIGHT"),
      Self::RIGHT_TO_LEFT => Some("RIGHT_TO_LEFT"),
      Self::TOP_TO_BOTTOM => Some("TOP_TO_BOTTOM"),
      Self::BOTTOM_TO_TOP => Some("BOTTOM_TO_TOP"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for TEXT_FLOW_DIRECTION {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for TEXT_FLOW_DIRECTION {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for TEXT_FLOW_DIRECTION {
    type Output = TEXT_FLOW_DIRECTION;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for TEXT_FLOW_DIRECTION {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for TEXT_FLOW_DIRECTION {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TEXT_FLOW_DIRECTION {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_COLUMN_TYPE: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_COLUMN_TYPE: u8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_COLUMN_TYPE: [COLUMN_TYPE; 3] = [
  COLUMN_TYPE::NO_COLUMNS,
  COLUMN_TYPE::STATIC_COLUMNS,
  COLUMN_TYPE::DYNAMIC_COLUMNS,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct COLUMN_TYPE(pub u8);
#[allow(non_upper_case_globals)]
impl COLUMN_TYPE {
  pub const NO_COLUMNS: Self = Self(10);
  pub const STATIC_COLUMNS: Self = Self(11);
  pub const DYNAMIC_COLUMNS: Self = Self(12);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NO_COLUMNS,
    Self::STATIC_COLUMNS,
    Self::DYNAMIC_COLUMNS,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NO_COLUMNS => Some("NO_COLUMNS"),
      Self::STATIC_COLUMNS => Some("STATIC_COLUMNS"),
      Self::DYNAMIC_COLUMNS => Some("DYNAMIC_COLUMNS"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for COLUMN_TYPE {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for COLUMN_TYPE {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for COLUMN_TYPE {
    type Output = COLUMN_TYPE;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for COLUMN_TYPE {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for COLUMN_TYPE {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for COLUMN_TYPE {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_GDT_SYMBOL: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_GDT_SYMBOL: u8 = 29;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_GDT_SYMBOL: [GDT_SYMBOL; 20] = [
  GDT_SYMBOL::STRAIGHTNESS,
  GDT_SYMBOL::FLATNESS,
  GDT_SYMBOL::CIRCULARITY,
  GDT_SYMBOL::CYLINDRICITY,
  GDT_SYMBOL::PERPENDICULARITY,
  GDT_SYMBOL::ANGULARITY,
  GDT_SYMBOL::PARALLELISM,
  GDT_SYMBOL::POSITION,
  GDT_SYMBOL::TRUE_POSITION,
  GDT_SYMBOL::CONCENTRICITY,
  GDT_SYMBOL::COAXIALITY,
  GDT_SYMBOL::SYMMETRY,
  GDT_SYMBOL::CIRCULAR_RUNOUT,
  GDT_SYMBOL::TOTAL_RUNOUT,
  GDT_SYMBOL::PROFILE_OF_LINE,
  GDT_SYMBOL::PROFILE_OF_SURFACE,
  GDT_SYMBOL::STATISTICAL,
  GDT_SYMBOL::ALL_AROUND,
  GDT_SYMBOL::ALL_OVER,
  GDT_SYMBOL::BETWEEN,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct GDT_SYMBOL(pub u8);
#[allow(non_upper_case_globals)]
impl GDT_SYMBOL {
  pub const STRAIGHTNESS: Self = Self(10);
  pub const FLATNESS: Self = Self(11);
  pub const CIRCULARITY: Self = Self(12);
  pub const CYLINDRICITY: Self = Self(13);
  pub const PERPENDICULARITY: Self = Self(14);
  pub const ANGULARITY: Self = Self(15);
  pub const PARALLELISM: Self = Self(16);
  pub const POSITION: Self = Self(17);
  pub const TRUE_POSITION: Self = Self(18);
  pub const CONCENTRICITY: Self = Self(19);
  pub const COAXIALITY: Self = Self(20);
  pub const SYMMETRY: Self = Self(21);
  pub const CIRCULAR_RUNOUT: Self = Self(22);
  pub const TOTAL_RUNOUT: Self = Self(23);
  pub const PROFILE_OF_LINE: Self = Self(24);
  pub const PROFILE_OF_SURFACE: Self = Self(25);
  pub const STATISTICAL: Self = Self(26);
  pub const ALL_AROUND: Self = Self(27);
  pub const ALL_OVER: Self = Self(28);
  pub const BETWEEN: Self = Self(29);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 29;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::STRAIGHTNESS,
    Self::FLATNESS,
    Self::CIRCULARITY,
    Self::CYLINDRICITY,
    Self::PERPENDICULARITY,
    Self::ANGULARITY,
    Self::PARALLELISM,
    Self::POSITION,
    Self::TRUE_POSITION,
    Self::CONCENTRICITY,
    Self::COAXIALITY,
    Self::SYMMETRY,
    Self::CIRCULAR_RUNOUT,
    Self::TOTAL_RUNOUT,
    Self::PROFILE_OF_LINE,
    Self::PROFILE_OF_SURFACE,
    Self::STATISTICAL,
    Self::ALL_AROUND,
    Self::ALL_OVER,
    Self::BETWEEN,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::STRAIGHTNESS => Some("STRAIGHTNESS"),
      Self::FLATNESS => Some("FLATNESS"),
      Self::CIRCULARITY => Some("CIRCULARITY"),
      Self::CYLINDRICITY => Some("CYLINDRICITY"),
      Self::PERPENDICULARITY => Some("PERPENDICULARITY"),
      Self::ANGULARITY => Some("ANGULARITY"),
      Self::PARALLELISM => Some("PARALLELISM"),
      Self::POSITION => Some("POSITION"),
      Self::TRUE_POSITION => Some("TRUE_POSITION"),
      Self::CONCENTRICITY => Some("CONCENTRICITY"),
      Self::COAXIALITY => Some("COAXIALITY"),
      Self::SYMMETRY => Some("SYMMETRY"),
      Self::CIRCULAR_RUNOUT => Some("CIRCULAR_RUNOUT"),
      Self::TOTAL_RUNOUT => Some("TOTAL_RUNOUT"),
      Self::PROFILE_OF_LINE => Some("PROFILE_OF_LINE"),
      Self::PROFILE_OF_SURFACE => Some("PROFILE_OF_SURFACE"),
      Self::STATISTICAL => Some("STATISTICAL"),
      Self::ALL_AROUND => Some("ALL_AROUND"),
      Self::ALL_OVER => Some("ALL_OVER"),
      Self::BETWEEN => Some("BETWEEN"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for GDT_SYMBOL {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for GDT_SYMBOL {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for GDT_SYMBOL {
    type Output = GDT_SYMBOL;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for GDT_SYMBOL {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for GDT_SYMBOL {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for GDT_SYMBOL {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MATERIAL_CONDITION: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MATERIAL_CONDITION: u8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MATERIAL_CONDITION: [MATERIAL_CONDITION; 3] = [
  MATERIAL_CONDITION::MAXIMUM,
  MATERIAL_CONDITION::LEAST,
  MATERIAL_CONDITION::REGARDLESS,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MATERIAL_CONDITION(pub u8);
#[allow(non_upper_case_globals)]
impl MATERIAL_CONDITION {
  pub const MAXIMUM: Self = Self(10);
  pub const LEAST: Self = Self(11);
  pub const REGARDLESS: Self = Self(12);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::MAXIMUM,
    Self::LEAST,
    Self::REGARDLESS,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::MAXIMUM => Some("MAXIMUM"),
      Self::LEAST => Some("LEAST"),
      Self::REGARDLESS => Some("REGARDLESS"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for MATERIAL_CONDITION {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for MATERIAL_CONDITION {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for MATERIAL_CONDITION {
    type Output = MATERIAL_CONDITION;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for MATERIAL_CONDITION {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for MATERIAL_CONDITION {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for MATERIAL_CONDITION {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_FEATURE_MODIFIER: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_FEATURE_MODIFIER: u8 = 24;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FEATURE_MODIFIER: [FEATURE_MODIFIER; 15] = [
  FEATURE_MODIFIER::FREE_STATE,
  FEATURE_MODIFIER::TANGENT_PLANE,
  FEATURE_MODIFIER::PROJECTED_TOLERANCE_ZONE,
  FEATURE_MODIFIER::DIAMETER,
  FEATURE_MODIFIER::SPHERICAL_DIAMETER,
  FEATURE_MODIFIER::RADIUS,
  FEATURE_MODIFIER::SPHERICAL_RADIUS,
  FEATURE_MODIFIER::CONTROLLED_RADIUS,
  FEATURE_MODIFIER::SQUARE,
  FEATURE_MODIFIER::TRANSLATION,
  FEATURE_MODIFIER::ALL_AROUND,
  FEATURE_MODIFIER::ALL_OVER,
  FEATURE_MODIFIER::STATISTICAL,
  FEATURE_MODIFIER::CONTINUOUS_FEATURE,
  FEATURE_MODIFIER::UNEQUALLY_DISPOSED,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct FEATURE_MODIFIER(pub u8);
#[allow(non_upper_case_globals)]
impl FEATURE_MODIFIER {
  pub const FREE_STATE: Self = Self(10);
  pub const TANGENT_PLANE: Self = Self(11);
  pub const PROJECTED_TOLERANCE_ZONE: Self = Self(12);
  pub const DIAMETER: Self = Self(13);
  pub const SPHERICAL_DIAMETER: Self = Self(14);
  pub const RADIUS: Self = Self(15);
  pub const SPHERICAL_RADIUS: Self = Self(16);
  pub const CONTROLLED_RADIUS: Self = Self(17);
  pub const SQUARE: Self = Self(18);
  pub const TRANSLATION: Self = Self(19);
  pub const ALL_AROUND: Self = Self(20);
  pub const ALL_OVER: Self = Self(21);
  pub const STATISTICAL: Self = Self(22);
  pub const CONTINUOUS_FEATURE: Self = Self(23);
  pub const UNEQUALLY_DISPOSED: Self = Self(24);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 24;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::FREE_STATE,
    Self::TANGENT_PLANE,
    Self::PROJECTED_TOLERANCE_ZONE,
    Self::DIAMETER,
    Self::SPHERICAL_DIAMETER,
    Self::RADIUS,
    Self::SPHERICAL_RADIUS,
    Self::CONTROLLED_RADIUS,
    Self::SQUARE,
    Self::TRANSLATION,
    Self::ALL_AROUND,
    Self::ALL_OVER,
    Self::STATISTICAL,
    Self::CONTINUOUS_FEATURE,
    Self::UNEQUALLY_DISPOSED,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::FREE_STATE => Some("FREE_STATE"),
      Self::TANGENT_PLANE => Some("TANGENT_PLANE"),
      Self::PROJECTED_TOLERANCE_ZONE => Some("PROJECTED_TOLERANCE_ZONE"),
      Self::DIAMETER => Some("DIAMETER"),
      Self::SPHERICAL_DIAMETER => Some("SPHERICAL_DIAMETER"),
      Self::RADIUS => Some("RADIUS"),
      Self::SPHERICAL_RADIUS => Some("SPHERICAL_RADIUS"),
      Self::CONTROLLED_RADIUS => Some("CONTROLLED_RADIUS"),
      Self::SQUARE => Some("SQUARE"),
      Self::TRANSLATION => Some("TRANSLATION"),
      Self::ALL_AROUND => Some("ALL_AROUND"),
      Self::ALL_OVER => Some("ALL_OVER"),
      Self::STATISTICAL => Some("STATISTICAL"),
      Self::CONTINUOUS_FEATURE => Some("CONTINUOUS_FEATURE"),
      Self::UNEQUALLY_DISPOSED => Some("UNEQUALLY_DISPOSED"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for FEATURE_MODIFIER {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for FEATURE_MODIFIER {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for FEATURE_MODIFIER {
    type Output = FEATURE_MODIFIER;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for FEATURE_MODIFIER {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for FEATURE_MODIFIER {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for FEATURE_MODIFIER {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TOLERANCE_ZONE_TYPE: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TOLERANCE_ZONE_TYPE: u8 = 14;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TOLERANCE_ZONE_TYPE: [TOLERANCE_ZONE_TYPE; 5] = [
  TOLERANCE_ZONE_TYPE::CYLINDRICAL,
  TOLERANCE_ZONE_TYPE::SPHERICAL,
  TOLERANCE_ZONE_TYPE::RECTANGULAR,
  TOLERANCE_ZONE_TYPE::LINEAR,
  TOLERANCE_ZONE_TYPE::CIRCULAR,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TOLERANCE_ZONE_TYPE(pub u8);
#[allow(non_upper_case_globals)]
impl TOLERANCE_ZONE_TYPE {
  pub const CYLINDRICAL: Self = Self(10);
  pub const SPHERICAL: Self = Self(11);
  pub const RECTANGULAR: Self = Self(12);
  pub const LINEAR: Self = Self(13);
  pub const CIRCULAR: Self = Self(14);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 14;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::CYLINDRICAL,
    Self::SPHERICAL,
    Self::RECTANGULAR,
    Self::LINEAR,
    Self::CIRCULAR,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::CYLINDRICAL => Some("CYLINDRICAL"),
      Self::SPHERICAL => Some("SPHERICAL"),
      Self::RECTANGULAR => Some("RECTANGULAR"),
      Self::LINEAR => Some("LINEAR"),
      Self::CIRCULAR => Some("CIRCULAR"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for TOLERANCE_ZONE_TYPE {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for TOLERANCE_ZONE_TYPE {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for TOLERANCE_ZONE_TYPE {
    type Output = TOLERANCE_ZONE_TYPE;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for TOLERANCE_ZONE_TYPE {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for TOLERANCE_ZONE_TYPE {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TOLERANCE_ZONE_TYPE {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DATUM_TARGET_TYPE: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DATUM_TARGET_TYPE: u8 = 13;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DATUM_TARGET_TYPE: [DATUM_TARGET_TYPE; 4] = [
  DATUM_TARGET_TYPE::POINT,
  DATUM_TARGET_TYPE::LINE,
  DATUM_TARGET_TYPE::AREA,
  DATUM_TARGET_TYPE::MOVABLE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DATUM_TARGET_TYPE(pub u8);
#[allow(non_upper_case_globals)]
impl DATUM_TARGET_TYPE {
  pub const POINT: Self = Self(10);
  pub const LINE: Self = Self(11);
  pub const AREA: Self = Self(12);
  pub const MOVABLE: Self = Self(13);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 13;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::POINT,
    Self::LINE,
    Self::AREA,
    Self::MOVABLE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::POINT => Some("POINT"),
      Self::LINE => Some("LINE"),
      Self::AREA => Some("AREA"),
      Self::MOVABLE => Some("MOVABLE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DATUM_TARGET_TYPE {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DATUM_TARGET_TYPE {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for DATUM_TARGET_TYPE {
    type Output = DATUM_TARGET_TYPE;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DATUM_TARGET_TYPE {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DATUM_TARGET_TYPE {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DATUM_TARGET_TYPE {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TOLERANCE_TYPE: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TOLERANCE_TYPE: u8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TOLERANCE_TYPE: [TOLERANCE_TYPE; 3] = [
  TOLERANCE_TYPE::SINGLE,
  TOLERANCE_TYPE::COMPOSITE,
  TOLERANCE_TYPE::MULTIPLE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TOLERANCE_TYPE(pub u8);
#[allow(non_upper_case_globals)]
impl TOLERANCE_TYPE {
  pub const SINGLE: Self = Self(10);
  pub const COMPOSITE: Self = Self(11);
  pub const MULTIPLE: Self = Self(12);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SINGLE,
    Self::COMPOSITE,
    Self::MULTIPLE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::SINGLE => Some("SINGLE"),
      Self::COMPOSITE => Some("COMPOSITE"),
      Self::MULTIPLE => Some("MULTIPLE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for TOLERANCE_TYPE {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for TOLERANCE_TYPE {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for TOLERANCE_TYPE {
    type Output = TOLERANCE_TYPE;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for TOLERANCE_TYPE {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for TOLERANCE_TYPE {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TOLERANCE_TYPE {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DATUM_BRACKET_STYLE: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DATUM_BRACKET_STYLE: u8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DATUM_BRACKET_STYLE: [DATUM_BRACKET_STYLE; 3] = [
  DATUM_BRACKET_STYLE::SQUARE,
  DATUM_BRACKET_STYLE::ROUND,
  DATUM_BRACKET_STYLE::NONE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DATUM_BRACKET_STYLE(pub u8);
#[allow(non_upper_case_globals)]
impl DATUM_BRACKET_STYLE {
  pub const SQUARE: Self = Self(10);
  pub const ROUND: Self = Self(11);
  pub const NONE: Self = Self(12);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SQUARE,
    Self::ROUND,
    Self::NONE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::SQUARE => Some("SQUARE"),
      Self::ROUND => Some("ROUND"),
      Self::NONE => Some("NONE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DATUM_BRACKET_STYLE {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DATUM_BRACKET_STYLE {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for DATUM_BRACKET_STYLE {
    type Output = DATUM_BRACKET_STYLE;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DATUM_BRACKET_STYLE {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DATUM_BRACKET_STYLE {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DATUM_BRACKET_STYLE {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DIMENSION_UNITS_FORMAT: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DIMENSION_UNITS_FORMAT: u8 = 14;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DIMENSION_UNITS_FORMAT: [DIMENSION_UNITS_FORMAT; 5] = [
  DIMENSION_UNITS_FORMAT::DECIMAL,
  DIMENSION_UNITS_FORMAT::ENGINEERING,
  DIMENSION_UNITS_FORMAT::ARCHITECTURAL,
  DIMENSION_UNITS_FORMAT::FRACTIONAL,
  DIMENSION_UNITS_FORMAT::SCIENTIFIC,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DIMENSION_UNITS_FORMAT(pub u8);
#[allow(non_upper_case_globals)]
impl DIMENSION_UNITS_FORMAT {
  pub const DECIMAL: Self = Self(10);
  pub const ENGINEERING: Self = Self(11);
  pub const ARCHITECTURAL: Self = Self(12);
  pub const FRACTIONAL: Self = Self(13);
  pub const SCIENTIFIC: Self = Self(14);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 14;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::DECIMAL,
    Self::ENGINEERING,
    Self::ARCHITECTURAL,
    Self::FRACTIONAL,
    Self::SCIENTIFIC,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::DECIMAL => Some("DECIMAL"),
      Self::ENGINEERING => Some("ENGINEERING"),
      Self::ARCHITECTURAL => Some("ARCHITECTURAL"),
      Self::FRACTIONAL => Some("FRACTIONAL"),
      Self::SCIENTIFIC => Some("SCIENTIFIC"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DIMENSION_UNITS_FORMAT {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DIMENSION_UNITS_FORMAT {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for DIMENSION_UNITS_FORMAT {
    type Output = DIMENSION_UNITS_FORMAT;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DIMENSION_UNITS_FORMAT {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DIMENSION_UNITS_FORMAT {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DIMENSION_UNITS_FORMAT {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ANGULAR_UNITS_FORMAT: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ANGULAR_UNITS_FORMAT: u8 = 14;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ANGULAR_UNITS_FORMAT: [ANGULAR_UNITS_FORMAT; 5] = [
  ANGULAR_UNITS_FORMAT::DECIMAL_DEGREES,
  ANGULAR_UNITS_FORMAT::DEGREES_MINUTES_SECONDS,
  ANGULAR_UNITS_FORMAT::GRADS,
  ANGULAR_UNITS_FORMAT::RADIANS,
  ANGULAR_UNITS_FORMAT::SURVEYOR,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ANGULAR_UNITS_FORMAT(pub u8);
#[allow(non_upper_case_globals)]
impl ANGULAR_UNITS_FORMAT {
  pub const DECIMAL_DEGREES: Self = Self(10);
  pub const DEGREES_MINUTES_SECONDS: Self = Self(11);
  pub const GRADS: Self = Self(12);
  pub const RADIANS: Self = Self(13);
  pub const SURVEYOR: Self = Self(14);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 14;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::DECIMAL_DEGREES,
    Self::DEGREES_MINUTES_SECONDS,
    Self::GRADS,
    Self::RADIANS,
    Self::SURVEYOR,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::DECIMAL_DEGREES => Some("DECIMAL_DEGREES"),
      Self::DEGREES_MINUTES_SECONDS => Some("DEGREES_MINUTES_SECONDS"),
      Self::GRADS => Some("GRADS"),
      Self::RADIANS => Some("RADIANS"),
      Self::SURVEYOR => Some("SURVEYOR"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ANGULAR_UNITS_FORMAT {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ANGULAR_UNITS_FORMAT {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ANGULAR_UNITS_FORMAT {
    type Output = ANGULAR_UNITS_FORMAT;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ANGULAR_UNITS_FORMAT {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ANGULAR_UNITS_FORMAT {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ANGULAR_UNITS_FORMAT {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DECIMAL_SEPARATOR: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DECIMAL_SEPARATOR: u8 = 11;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DECIMAL_SEPARATOR: [DECIMAL_SEPARATOR; 2] = [
  DECIMAL_SEPARATOR::DOT,
  DECIMAL_SEPARATOR::COMMA,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DECIMAL_SEPARATOR(pub u8);
#[allow(non_upper_case_globals)]
impl DECIMAL_SEPARATOR {
  pub const DOT: Self = Self(10);
  pub const COMMA: Self = Self(11);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 11;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::DOT,
    Self::COMMA,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::DOT => Some("DOT"),
      Self::COMMA => Some("COMMA"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DECIMAL_SEPARATOR {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DECIMAL_SEPARATOR {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for DECIMAL_SEPARATOR {
    type Output = DECIMAL_SEPARATOR;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DECIMAL_SEPARATOR {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DECIMAL_SEPARATOR {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DECIMAL_SEPARATOR {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_VIEWPORT_SHADE_PLOT: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_VIEWPORT_SHADE_PLOT: u8 = 13;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_VIEWPORT_SHADE_PLOT: [VIEWPORT_SHADE_PLOT; 4] = [
  VIEWPORT_SHADE_PLOT::AS_DISPLAYED,
  VIEWPORT_SHADE_PLOT::WIREFRAME,
  VIEWPORT_SHADE_PLOT::HIDDEN,
  VIEWPORT_SHADE_PLOT::RENDERED,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct VIEWPORT_SHADE_PLOT(pub u8);
#[allow(non_upper_case_globals)]
impl VIEWPORT_SHADE_PLOT {
  pub const AS_DISPLAYED: Self = Self(10);
  pub const WIREFRAME: Self = Self(11);
  pub const HIDDEN: Self = Self(12);
  pub const RENDERED: Self = Self(13);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 13;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::AS_DISPLAYED,
    Self::WIREFRAME,
    Self::HIDDEN,
    Self::RENDERED,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::AS_DISPLAYED => Some("AS_DISPLAYED"),
      Self::WIREFRAME => Some("WIREFRAME"),
      Self::HIDDEN => Some("HIDDEN"),
      Self::RENDERED => Some("RENDERED"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for VIEWPORT_SHADE_PLOT {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for VIEWPORT_SHADE_PLOT {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for VIEWPORT_SHADE_PLOT {
    type Output = VIEWPORT_SHADE_PLOT;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for VIEWPORT_SHADE_PLOT {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for VIEWPORT_SHADE_PLOT {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for VIEWPORT_SHADE_PLOT {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_HATCH_STYLE: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_HATCH_STYLE: u8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_HATCH_STYLE: [HATCH_STYLE; 3] = [
  HATCH_STYLE::NORMAL,
  HATCH_STYLE::OUTER,
  HATCH_STYLE::IGNORE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct HATCH_STYLE(pub u8);
#[allow(non_upper_case_globals)]
impl HATCH_STYLE {
  pub const NORMAL: Self = Self(10);
  pub const OUTER: Self = Self(11);
  pub const IGNORE: Self = Self(12);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NORMAL,
    Self::OUTER,
    Self::IGNORE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NORMAL => Some("NORMAL"),
      Self::OUTER => Some("OUTER"),
      Self::IGNORE => Some("IGNORE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for HATCH_STYLE {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for HATCH_STYLE {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for HATCH_STYLE {
    type Output = HATCH_STYLE;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for HATCH_STYLE {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for HATCH_STYLE {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for HATCH_STYLE {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_IMAGE_STATUS: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_IMAGE_STATUS: u8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_IMAGE_STATUS: [IMAGE_STATUS; 3] = [
  IMAGE_STATUS::PENDING,
  IMAGE_STATUS::SAVED,
  IMAGE_STATUS::ERROR,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct IMAGE_STATUS(pub u8);
#[allow(non_upper_case_globals)]
impl IMAGE_STATUS {
  pub const PENDING: Self = Self(10);
  pub const SAVED: Self = Self(11);
  pub const ERROR: Self = Self(12);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::PENDING,
    Self::SAVED,
    Self::ERROR,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::PENDING => Some("PENDING"),
      Self::SAVED => Some("SAVED"),
      Self::ERROR => Some("ERROR"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for IMAGE_STATUS {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for IMAGE_STATUS {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for IMAGE_STATUS {
    type Output = IMAGE_STATUS;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for IMAGE_STATUS {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for IMAGE_STATUS {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for IMAGE_STATUS {}
pub enum PointOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Point<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Point<'a> {
  type Inner = Point<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Point<'a> {
  pub const VT_X_V2: flatbuffers::VOffsetT = 4;
  pub const VT_Y_V2: flatbuffers::VOffsetT = 6;
  pub const VT_MIRRORING: flatbuffers::VOffsetT = 10;
  pub const VT_X_V3: flatbuffers::VOffsetT = 18;
  pub const VT_Y_V3: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Point { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PointArgs
  ) -> flatbuffers::WIPOffset<Point<'bldr>> {
    let mut builder = PointBuilder::new(_fbb);
    builder.add_y_v3(args.y_v3);
    builder.add_x_v3(args.x_v3);
    if let Some(x) = args.y_v2 { builder.add_y_v2(x); }
    if let Some(x) = args.x_v2 { builder.add_x_v2(x); }
    if let Some(x) = args.mirroring { builder.add_mirroring(x); }
    builder.finish()
  }


  #[inline]
  pub fn x_v2(&self) -> Option<f32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Point::VT_X_V2, None)}
  }
  #[inline]
  pub fn y_v2(&self) -> Option<f32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Point::VT_Y_V2, None)}
  }
  #[inline]
  pub fn mirroring(&self) -> Option<i8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(Point::VT_MIRRORING, None)}
  }
  #[inline]
  pub fn x_v3(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Point::VT_X_V3, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn y_v3(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Point::VT_Y_V3, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Point<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("x_v2", Self::VT_X_V2, false)?
     .visit_field::<f32>("y_v2", Self::VT_Y_V2, false)?
     .visit_field::<i8>("mirroring", Self::VT_MIRRORING, false)?
     .visit_field::<f64>("x_v3", Self::VT_X_V3, false)?
     .visit_field::<f64>("y_v3", Self::VT_Y_V3, false)?
     .finish();
    Ok(())
  }
}
pub struct PointArgs {
    pub x_v2: Option<f32>,
    pub y_v2: Option<f32>,
    pub mirroring: Option<i8>,
    pub x_v3: f64,
    pub y_v3: f64,
}
impl<'a> Default for PointArgs {
  #[inline]
  fn default() -> Self {
    PointArgs {
      x_v2: None,
      y_v2: None,
      mirroring: None,
      x_v3: 0.0,
      y_v3: 0.0,
    }
  }
}

pub struct PointBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PointBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_x_v2(&mut self, x_v2: f32) {
    self.fbb_.push_slot_always::<f32>(Point::VT_X_V2, x_v2);
  }
  #[inline]
  pub fn add_y_v2(&mut self, y_v2: f32) {
    self.fbb_.push_slot_always::<f32>(Point::VT_Y_V2, y_v2);
  }
  #[inline]
  pub fn add_mirroring(&mut self, mirroring: i8) {
    self.fbb_.push_slot_always::<i8>(Point::VT_MIRRORING, mirroring);
  }
  #[inline]
  pub fn add_x_v3(&mut self, x_v3: f64) {
    self.fbb_.push_slot::<f64>(Point::VT_X_V3, x_v3, 0.0);
  }
  #[inline]
  pub fn add_y_v3(&mut self, y_v3: f64) {
    self.fbb_.push_slot::<f64>(Point::VT_Y_V3, y_v3, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PointBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PointBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Point<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Point<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Point");
      ds.field("x_v2", &self.x_v2());
      ds.field("y_v2", &self.y_v2());
      ds.field("mirroring", &self.mirroring());
      ds.field("x_v3", &self.x_v3());
      ds.field("y_v3", &self.y_v3());
      ds.finish()
  }
}
pub enum DucLineReferenceOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucLineReference<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucLineReference<'a> {
  type Inner = DucLineReference<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucLineReference<'a> {
  pub const VT_INDEX: flatbuffers::VOffsetT = 4;
  pub const VT_HANDLE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucLineReference { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucLineReferenceArgs<'args>
  ) -> flatbuffers::WIPOffset<DucLineReference<'bldr>> {
    let mut builder = DucLineReferenceBuilder::new(_fbb);
    if let Some(x) = args.handle { builder.add_handle(x); }
    builder.add_index(args.index);
    builder.finish()
  }


  #[inline]
  pub fn index(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DucLineReference::VT_INDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn handle(&self) -> Option<SimplePoint<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SimplePoint>>(DucLineReference::VT_HANDLE, None)}
  }
}

impl flatbuffers::Verifiable for DucLineReference<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("index", Self::VT_INDEX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SimplePoint>>("handle", Self::VT_HANDLE, false)?
     .finish();
    Ok(())
  }
}
pub struct DucLineReferenceArgs<'a> {
    pub index: i32,
    pub handle: Option<flatbuffers::WIPOffset<SimplePoint<'a>>>,
}
impl<'a> Default for DucLineReferenceArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucLineReferenceArgs {
      index: 0,
      handle: None,
    }
  }
}

pub struct DucLineReferenceBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucLineReferenceBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_index(&mut self, index: i32) {
    self.fbb_.push_slot::<i32>(DucLineReference::VT_INDEX, index, 0);
  }
  #[inline]
  pub fn add_handle(&mut self, handle: flatbuffers::WIPOffset<SimplePoint<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SimplePoint>>(DucLineReference::VT_HANDLE, handle);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucLineReferenceBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucLineReferenceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucLineReference<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucLineReference<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucLineReference");
      ds.field("index", &self.index());
      ds.field("handle", &self.handle());
      ds.finish()
  }
}
pub enum DucLineOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucLine<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucLine<'a> {
  type Inner = DucLine<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucLine<'a> {
  pub const VT_START: flatbuffers::VOffsetT = 4;
  pub const VT_END: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucLine { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucLineArgs<'args>
  ) -> flatbuffers::WIPOffset<DucLine<'bldr>> {
    let mut builder = DucLineBuilder::new(_fbb);
    if let Some(x) = args.end { builder.add_end(x); }
    if let Some(x) = args.start { builder.add_start(x); }
    builder.finish()
  }


  #[inline]
  pub fn start(&self) -> Option<DucLineReference<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucLineReference>>(DucLine::VT_START, None)}
  }
  #[inline]
  pub fn end(&self) -> Option<DucLineReference<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucLineReference>>(DucLine::VT_END, None)}
  }
}

impl flatbuffers::Verifiable for DucLine<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucLineReference>>("start", Self::VT_START, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucLineReference>>("end", Self::VT_END, false)?
     .finish();
    Ok(())
  }
}
pub struct DucLineArgs<'a> {
    pub start: Option<flatbuffers::WIPOffset<DucLineReference<'a>>>,
    pub end: Option<flatbuffers::WIPOffset<DucLineReference<'a>>>,
}
impl<'a> Default for DucLineArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucLineArgs {
      start: None,
      end: None,
    }
  }
}

pub struct DucLineBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucLineBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_start(&mut self, start: flatbuffers::WIPOffset<DucLineReference<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucLineReference>>(DucLine::VT_START, start);
  }
  #[inline]
  pub fn add_end(&mut self, end: flatbuffers::WIPOffset<DucLineReference<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucLineReference>>(DucLine::VT_END, end);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucLineBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucLineBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucLine<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucLine<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucLine");
      ds.field("start", &self.start());
      ds.field("end", &self.end());
      ds.finish()
  }
}
pub enum PointBindingOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PointBinding<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PointBinding<'a> {
  type Inner = PointBinding<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PointBinding<'a> {
  pub const VT_ELEMENT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_FOCUS: flatbuffers::VOffsetT = 6;
  pub const VT_GAP: flatbuffers::VOffsetT = 8;
  pub const VT_POINT: flatbuffers::VOffsetT = 12;
  pub const VT_HEAD: flatbuffers::VOffsetT = 14;
  pub const VT_FIXED_POINT: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PointBinding { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PointBindingArgs<'args>
  ) -> flatbuffers::WIPOffset<PointBinding<'bldr>> {
    let mut builder = PointBindingBuilder::new(_fbb);
    if let Some(x) = args.fixed_point { builder.add_fixed_point(x); }
    if let Some(x) = args.point { builder.add_point(x); }
    builder.add_gap(args.gap);
    builder.add_focus(args.focus);
    if let Some(x) = args.element_id { builder.add_element_id(x); }
    builder.add_head(args.head);
    builder.finish()
  }


  #[inline]
  pub fn element_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PointBinding::VT_ELEMENT_ID, None)}
  }
  #[inline]
  pub fn focus(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(PointBinding::VT_FOCUS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn gap(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(PointBinding::VT_GAP, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn point(&self) -> Option<BindingPoint<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<BindingPoint>>(PointBinding::VT_POINT, None)}
  }
  #[inline]
  pub fn head(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(PointBinding::VT_HEAD, Some(0)).unwrap()}
  }
  #[inline]
  pub fn fixed_point(&self) -> Option<SimplePoint<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SimplePoint>>(PointBinding::VT_FIXED_POINT, None)}
  }
}

impl flatbuffers::Verifiable for PointBinding<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("element_id", Self::VT_ELEMENT_ID, false)?
     .visit_field::<f32>("focus", Self::VT_FOCUS, false)?
     .visit_field::<f32>("gap", Self::VT_GAP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<BindingPoint>>("point", Self::VT_POINT, false)?
     .visit_field::<i8>("head", Self::VT_HEAD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SimplePoint>>("fixed_point", Self::VT_FIXED_POINT, false)?
     .finish();
    Ok(())
  }
}
pub struct PointBindingArgs<'a> {
    pub element_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub focus: f32,
    pub gap: f32,
    pub point: Option<flatbuffers::WIPOffset<BindingPoint<'a>>>,
    pub head: i8,
    pub fixed_point: Option<flatbuffers::WIPOffset<SimplePoint<'a>>>,
}
impl<'a> Default for PointBindingArgs<'a> {
  #[inline]
  fn default() -> Self {
    PointBindingArgs {
      element_id: None,
      focus: 0.0,
      gap: 0.0,
      point: None,
      head: 0,
      fixed_point: None,
    }
  }
}

pub struct PointBindingBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PointBindingBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_element_id(&mut self, element_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PointBinding::VT_ELEMENT_ID, element_id);
  }
  #[inline]
  pub fn add_focus(&mut self, focus: f32) {
    self.fbb_.push_slot::<f32>(PointBinding::VT_FOCUS, focus, 0.0);
  }
  #[inline]
  pub fn add_gap(&mut self, gap: f32) {
    self.fbb_.push_slot::<f32>(PointBinding::VT_GAP, gap, 0.0);
  }
  #[inline]
  pub fn add_point(&mut self, point: flatbuffers::WIPOffset<BindingPoint<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<BindingPoint>>(PointBinding::VT_POINT, point);
  }
  #[inline]
  pub fn add_head(&mut self, head: i8) {
    self.fbb_.push_slot::<i8>(PointBinding::VT_HEAD, head, 0);
  }
  #[inline]
  pub fn add_fixed_point(&mut self, fixed_point: flatbuffers::WIPOffset<SimplePoint<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SimplePoint>>(PointBinding::VT_FIXED_POINT, fixed_point);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PointBindingBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PointBindingBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PointBinding<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PointBinding<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PointBinding");
      ds.field("element_id", &self.element_id());
      ds.field("focus", &self.focus());
      ds.field("gap", &self.gap());
      ds.field("point", &self.point());
      ds.field("head", &self.head());
      ds.field("fixed_point", &self.fixed_point());
      ds.finish()
  }
}
pub enum BindingPointOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BindingPoint<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BindingPoint<'a> {
  type Inner = BindingPoint<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BindingPoint<'a> {
  pub const VT_INDEX: flatbuffers::VOffsetT = 4;
  pub const VT_OFFSET: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BindingPoint { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BindingPointArgs
  ) -> flatbuffers::WIPOffset<BindingPoint<'bldr>> {
    let mut builder = BindingPointBuilder::new(_fbb);
    builder.add_offset(args.offset);
    builder.add_index(args.index);
    builder.finish()
  }


  #[inline]
  pub fn index(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(BindingPoint::VT_INDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn offset(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(BindingPoint::VT_OFFSET, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for BindingPoint<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("index", Self::VT_INDEX, false)?
     .visit_field::<f32>("offset", Self::VT_OFFSET, false)?
     .finish();
    Ok(())
  }
}
pub struct BindingPointArgs {
    pub index: i32,
    pub offset: f32,
}
impl<'a> Default for BindingPointArgs {
  #[inline]
  fn default() -> Self {
    BindingPointArgs {
      index: 0,
      offset: 0.0,
    }
  }
}

pub struct BindingPointBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BindingPointBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_index(&mut self, index: i32) {
    self.fbb_.push_slot::<i32>(BindingPoint::VT_INDEX, index, 0);
  }
  #[inline]
  pub fn add_offset(&mut self, offset: f32) {
    self.fbb_.push_slot::<f32>(BindingPoint::VT_OFFSET, offset, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BindingPointBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BindingPointBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BindingPoint<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BindingPoint<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BindingPoint");
      ds.field("index", &self.index());
      ds.field("offset", &self.offset());
      ds.finish()
  }
}
pub enum SimplePointOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SimplePoint<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SimplePoint<'a> {
  type Inner = SimplePoint<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SimplePoint<'a> {
  pub const VT_X: flatbuffers::VOffsetT = 4;
  pub const VT_Y: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SimplePoint { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SimplePointArgs
  ) -> flatbuffers::WIPOffset<SimplePoint<'bldr>> {
    let mut builder = SimplePointBuilder::new(_fbb);
    builder.add_y(args.y);
    builder.add_x(args.x);
    builder.finish()
  }


  #[inline]
  pub fn x(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SimplePoint::VT_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SimplePoint::VT_Y, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for SimplePoint<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("x", Self::VT_X, false)?
     .visit_field::<f64>("y", Self::VT_Y, false)?
     .finish();
    Ok(())
  }
}
pub struct SimplePointArgs {
    pub x: f64,
    pub y: f64,
}
impl<'a> Default for SimplePointArgs {
  #[inline]
  fn default() -> Self {
    SimplePointArgs {
      x: 0.0,
      y: 0.0,
    }
  }
}

pub struct SimplePointBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SimplePointBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_x(&mut self, x: f64) {
    self.fbb_.push_slot::<f64>(SimplePoint::VT_X, x, 0.0);
  }
  #[inline]
  pub fn add_y(&mut self, y: f64) {
    self.fbb_.push_slot::<f64>(SimplePoint::VT_Y, y, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SimplePointBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SimplePointBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SimplePoint<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SimplePoint<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SimplePoint");
      ds.field("x", &self.x());
      ds.field("y", &self.y());
      ds.finish()
  }
}
pub enum TilingPropertiesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TilingProperties<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TilingProperties<'a> {
  type Inner = TilingProperties<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TilingProperties<'a> {
  pub const VT_SIZE_IN_PERCENT: flatbuffers::VOffsetT = 4;
  pub const VT_ANGLE: flatbuffers::VOffsetT = 6;
  pub const VT_SPACING: flatbuffers::VOffsetT = 8;
  pub const VT_OFFSET_X: flatbuffers::VOffsetT = 10;
  pub const VT_OFFSET_Y: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TilingProperties { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TilingPropertiesArgs
  ) -> flatbuffers::WIPOffset<TilingProperties<'bldr>> {
    let mut builder = TilingPropertiesBuilder::new(_fbb);
    if let Some(x) = args.offset_y { builder.add_offset_y(x); }
    if let Some(x) = args.offset_x { builder.add_offset_x(x); }
    if let Some(x) = args.spacing { builder.add_spacing(x); }
    builder.add_angle(args.angle);
    builder.add_size_in_percent(args.size_in_percent);
    builder.finish()
  }


  #[inline]
  pub fn size_in_percent(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TilingProperties::VT_SIZE_IN_PERCENT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn angle(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TilingProperties::VT_ANGLE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn spacing(&self) -> Option<f64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TilingProperties::VT_SPACING, None)}
  }
  #[inline]
  pub fn offset_x(&self) -> Option<f64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TilingProperties::VT_OFFSET_X, None)}
  }
  #[inline]
  pub fn offset_y(&self) -> Option<f64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TilingProperties::VT_OFFSET_Y, None)}
  }
}

impl flatbuffers::Verifiable for TilingProperties<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("size_in_percent", Self::VT_SIZE_IN_PERCENT, false)?
     .visit_field::<f64>("angle", Self::VT_ANGLE, false)?
     .visit_field::<f64>("spacing", Self::VT_SPACING, false)?
     .visit_field::<f64>("offset_x", Self::VT_OFFSET_X, false)?
     .visit_field::<f64>("offset_y", Self::VT_OFFSET_Y, false)?
     .finish();
    Ok(())
  }
}
pub struct TilingPropertiesArgs {
    pub size_in_percent: f64,
    pub angle: f64,
    pub spacing: Option<f64>,
    pub offset_x: Option<f64>,
    pub offset_y: Option<f64>,
}
impl<'a> Default for TilingPropertiesArgs {
  #[inline]
  fn default() -> Self {
    TilingPropertiesArgs {
      size_in_percent: 0.0,
      angle: 0.0,
      spacing: None,
      offset_x: None,
      offset_y: None,
    }
  }
}

pub struct TilingPropertiesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TilingPropertiesBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_size_in_percent(&mut self, size_in_percent: f64) {
    self.fbb_.push_slot::<f64>(TilingProperties::VT_SIZE_IN_PERCENT, size_in_percent, 0.0);
  }
  #[inline]
  pub fn add_angle(&mut self, angle: f64) {
    self.fbb_.push_slot::<f64>(TilingProperties::VT_ANGLE, angle, 0.0);
  }
  #[inline]
  pub fn add_spacing(&mut self, spacing: f64) {
    self.fbb_.push_slot_always::<f64>(TilingProperties::VT_SPACING, spacing);
  }
  #[inline]
  pub fn add_offset_x(&mut self, offset_x: f64) {
    self.fbb_.push_slot_always::<f64>(TilingProperties::VT_OFFSET_X, offset_x);
  }
  #[inline]
  pub fn add_offset_y(&mut self, offset_y: f64) {
    self.fbb_.push_slot_always::<f64>(TilingProperties::VT_OFFSET_Y, offset_y);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TilingPropertiesBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TilingPropertiesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TilingProperties<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TilingProperties<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TilingProperties");
      ds.field("size_in_percent", &self.size_in_percent());
      ds.field("angle", &self.angle());
      ds.field("spacing", &self.spacing());
      ds.field("offset_x", &self.offset_x());
      ds.field("offset_y", &self.offset_y());
      ds.finish()
  }
}
pub enum ElementContentBaseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ElementContentBase<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ElementContentBase<'a> {
  type Inner = ElementContentBase<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ElementContentBase<'a> {
  pub const VT_PREFERENCE: flatbuffers::VOffsetT = 4;
  pub const VT_SRC: flatbuffers::VOffsetT = 6;
  pub const VT_VISIBLE: flatbuffers::VOffsetT = 8;
  pub const VT_OPACITY: flatbuffers::VOffsetT = 10;
  pub const VT_TILING: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ElementContentBase { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ElementContentBaseArgs<'args>
  ) -> flatbuffers::WIPOffset<ElementContentBase<'bldr>> {
    let mut builder = ElementContentBaseBuilder::new(_fbb);
    builder.add_opacity(args.opacity);
    if let Some(x) = args.tiling { builder.add_tiling(x); }
    if let Some(x) = args.src { builder.add_src(x); }
    builder.add_visible(args.visible);
    builder.add_preference(args.preference);
    builder.finish()
  }


  #[inline]
  pub fn preference(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(ElementContentBase::VT_PREFERENCE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn src(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ElementContentBase::VT_SRC, None)}
  }
  #[inline]
  pub fn visible(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ElementContentBase::VT_VISIBLE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn opacity(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ElementContentBase::VT_OPACITY, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn tiling(&self) -> Option<TilingProperties<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<TilingProperties>>(ElementContentBase::VT_TILING, None)}
  }
}

impl flatbuffers::Verifiable for ElementContentBase<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i8>("preference", Self::VT_PREFERENCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("src", Self::VT_SRC, false)?
     .visit_field::<bool>("visible", Self::VT_VISIBLE, false)?
     .visit_field::<f64>("opacity", Self::VT_OPACITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<TilingProperties>>("tiling", Self::VT_TILING, false)?
     .finish();
    Ok(())
  }
}
pub struct ElementContentBaseArgs<'a> {
    pub preference: i8,
    pub src: Option<flatbuffers::WIPOffset<&'a str>>,
    pub visible: bool,
    pub opacity: f64,
    pub tiling: Option<flatbuffers::WIPOffset<TilingProperties<'a>>>,
}
impl<'a> Default for ElementContentBaseArgs<'a> {
  #[inline]
  fn default() -> Self {
    ElementContentBaseArgs {
      preference: 0,
      src: None,
      visible: false,
      opacity: 0.0,
      tiling: None,
    }
  }
}

pub struct ElementContentBaseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ElementContentBaseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_preference(&mut self, preference: i8) {
    self.fbb_.push_slot::<i8>(ElementContentBase::VT_PREFERENCE, preference, 0);
  }
  #[inline]
  pub fn add_src(&mut self, src: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ElementContentBase::VT_SRC, src);
  }
  #[inline]
  pub fn add_visible(&mut self, visible: bool) {
    self.fbb_.push_slot::<bool>(ElementContentBase::VT_VISIBLE, visible, false);
  }
  #[inline]
  pub fn add_opacity(&mut self, opacity: f64) {
    self.fbb_.push_slot::<f64>(ElementContentBase::VT_OPACITY, opacity, 0.0);
  }
  #[inline]
  pub fn add_tiling(&mut self, tiling: flatbuffers::WIPOffset<TilingProperties<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<TilingProperties>>(ElementContentBase::VT_TILING, tiling);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ElementContentBaseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ElementContentBaseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ElementContentBase<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ElementContentBase<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ElementContentBase");
      ds.field("preference", &self.preference());
      ds.field("src", &self.src());
      ds.field("visible", &self.visible());
      ds.field("opacity", &self.opacity());
      ds.field("tiling", &self.tiling());
      ds.finish()
  }
}
pub enum StrokeStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct StrokeStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StrokeStyle<'a> {
  type Inner = StrokeStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> StrokeStyle<'a> {
  pub const VT_PREFERENCE: flatbuffers::VOffsetT = 4;
  pub const VT_CAP: flatbuffers::VOffsetT = 6;
  pub const VT_JOIN: flatbuffers::VOffsetT = 8;
  pub const VT_DASH: flatbuffers::VOffsetT = 10;
  pub const VT_DASH_CAP: flatbuffers::VOffsetT = 12;
  pub const VT_MITER_LIMIT: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StrokeStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StrokeStyleArgs<'args>
  ) -> flatbuffers::WIPOffset<StrokeStyle<'bldr>> {
    let mut builder = StrokeStyleBuilder::new(_fbb);
    if let Some(x) = args.miter_limit { builder.add_miter_limit(x); }
    if let Some(x) = args.dash { builder.add_dash(x); }
    if let Some(x) = args.dash_cap { builder.add_dash_cap(x); }
    if let Some(x) = args.join { builder.add_join(x); }
    if let Some(x) = args.cap { builder.add_cap(x); }
    builder.add_preference(args.preference);
    builder.finish()
  }


  #[inline]
  pub fn preference(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(StrokeStyle::VT_PREFERENCE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn cap(&self) -> Option<i8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(StrokeStyle::VT_CAP, None)}
  }
  #[inline]
  pub fn join(&self) -> Option<i8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(StrokeStyle::VT_JOIN, None)}
  }
  #[inline]
  pub fn dash(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(StrokeStyle::VT_DASH, None)}
  }
  #[inline]
  pub fn dash_cap(&self) -> Option<i8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(StrokeStyle::VT_DASH_CAP, None)}
  }
  #[inline]
  pub fn miter_limit(&self) -> Option<f64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StrokeStyle::VT_MITER_LIMIT, None)}
  }
}

impl flatbuffers::Verifiable for StrokeStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i8>("preference", Self::VT_PREFERENCE, false)?
     .visit_field::<i8>("cap", Self::VT_CAP, false)?
     .visit_field::<i8>("join", Self::VT_JOIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("dash", Self::VT_DASH, false)?
     .visit_field::<i8>("dash_cap", Self::VT_DASH_CAP, false)?
     .visit_field::<f64>("miter_limit", Self::VT_MITER_LIMIT, false)?
     .finish();
    Ok(())
  }
}
pub struct StrokeStyleArgs<'a> {
    pub preference: i8,
    pub cap: Option<i8>,
    pub join: Option<i8>,
    pub dash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub dash_cap: Option<i8>,
    pub miter_limit: Option<f64>,
}
impl<'a> Default for StrokeStyleArgs<'a> {
  #[inline]
  fn default() -> Self {
    StrokeStyleArgs {
      preference: 0,
      cap: None,
      join: None,
      dash: None,
      dash_cap: None,
      miter_limit: None,
    }
  }
}

pub struct StrokeStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StrokeStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_preference(&mut self, preference: i8) {
    self.fbb_.push_slot::<i8>(StrokeStyle::VT_PREFERENCE, preference, 0);
  }
  #[inline]
  pub fn add_cap(&mut self, cap: i8) {
    self.fbb_.push_slot_always::<i8>(StrokeStyle::VT_CAP, cap);
  }
  #[inline]
  pub fn add_join(&mut self, join: i8) {
    self.fbb_.push_slot_always::<i8>(StrokeStyle::VT_JOIN, join);
  }
  #[inline]
  pub fn add_dash(&mut self, dash: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StrokeStyle::VT_DASH, dash);
  }
  #[inline]
  pub fn add_dash_cap(&mut self, dash_cap: i8) {
    self.fbb_.push_slot_always::<i8>(StrokeStyle::VT_DASH_CAP, dash_cap);
  }
  #[inline]
  pub fn add_miter_limit(&mut self, miter_limit: f64) {
    self.fbb_.push_slot_always::<f64>(StrokeStyle::VT_MITER_LIMIT, miter_limit);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StrokeStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StrokeStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StrokeStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StrokeStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StrokeStyle");
      ds.field("preference", &self.preference());
      ds.field("cap", &self.cap());
      ds.field("join", &self.join());
      ds.field("dash", &self.dash());
      ds.field("dash_cap", &self.dash_cap());
      ds.field("miter_limit", &self.miter_limit());
      ds.finish()
  }
}
pub enum StrokeSidesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct StrokeSides<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StrokeSides<'a> {
  type Inner = StrokeSides<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> StrokeSides<'a> {
  pub const VT_PREFERENCE: flatbuffers::VOffsetT = 4;
  pub const VT_VALUES: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StrokeSides { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StrokeSidesArgs<'args>
  ) -> flatbuffers::WIPOffset<StrokeSides<'bldr>> {
    let mut builder = StrokeSidesBuilder::new(_fbb);
    if let Some(x) = args.values { builder.add_values(x); }
    builder.add_preference(args.preference);
    builder.finish()
  }


  #[inline]
  pub fn preference(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(StrokeSides::VT_PREFERENCE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn values(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(StrokeSides::VT_VALUES, None)}
  }
}

impl flatbuffers::Verifiable for StrokeSides<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i8>("preference", Self::VT_PREFERENCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("values", Self::VT_VALUES, false)?
     .finish();
    Ok(())
  }
}
pub struct StrokeSidesArgs<'a> {
    pub preference: i8,
    pub values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
}
impl<'a> Default for StrokeSidesArgs<'a> {
  #[inline]
  fn default() -> Self {
    StrokeSidesArgs {
      preference: 0,
      values: None,
    }
  }
}

pub struct StrokeSidesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StrokeSidesBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_preference(&mut self, preference: i8) {
    self.fbb_.push_slot::<i8>(StrokeSides::VT_PREFERENCE, preference, 0);
  }
  #[inline]
  pub fn add_values(&mut self, values: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StrokeSides::VT_VALUES, values);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StrokeSidesBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StrokeSidesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StrokeSides<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StrokeSides<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StrokeSides");
      ds.field("preference", &self.preference());
      ds.field("values", &self.values());
      ds.finish()
  }
}
pub enum ElementStrokeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ElementStroke<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ElementStroke<'a> {
  type Inner = ElementStroke<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ElementStroke<'a> {
  pub const VT_CONTENT: flatbuffers::VOffsetT = 4;
  pub const VT_WIDTH: flatbuffers::VOffsetT = 6;
  pub const VT_STYLE: flatbuffers::VOffsetT = 8;
  pub const VT_PLACEMENT: flatbuffers::VOffsetT = 10;
  pub const VT_STROKE_SIDES: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ElementStroke { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ElementStrokeArgs<'args>
  ) -> flatbuffers::WIPOffset<ElementStroke<'bldr>> {
    let mut builder = ElementStrokeBuilder::new(_fbb);
    builder.add_width(args.width);
    if let Some(x) = args.stroke_sides { builder.add_stroke_sides(x); }
    if let Some(x) = args.style { builder.add_style(x); }
    if let Some(x) = args.content { builder.add_content(x); }
    builder.add_placement(args.placement);
    builder.finish()
  }


  #[inline]
  pub fn content(&self) -> Option<ElementContentBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ElementContentBase>>(ElementStroke::VT_CONTENT, None)}
  }
  #[inline]
  pub fn width(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ElementStroke::VT_WIDTH, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn style(&self) -> Option<StrokeStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<StrokeStyle>>(ElementStroke::VT_STYLE, None)}
  }
  #[inline]
  pub fn placement(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(ElementStroke::VT_PLACEMENT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn stroke_sides(&self) -> Option<StrokeSides<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<StrokeSides>>(ElementStroke::VT_STROKE_SIDES, None)}
  }
}

impl flatbuffers::Verifiable for ElementStroke<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<ElementContentBase>>("content", Self::VT_CONTENT, false)?
     .visit_field::<f64>("width", Self::VT_WIDTH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<StrokeStyle>>("style", Self::VT_STYLE, false)?
     .visit_field::<i8>("placement", Self::VT_PLACEMENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<StrokeSides>>("stroke_sides", Self::VT_STROKE_SIDES, false)?
     .finish();
    Ok(())
  }
}
pub struct ElementStrokeArgs<'a> {
    pub content: Option<flatbuffers::WIPOffset<ElementContentBase<'a>>>,
    pub width: f64,
    pub style: Option<flatbuffers::WIPOffset<StrokeStyle<'a>>>,
    pub placement: i8,
    pub stroke_sides: Option<flatbuffers::WIPOffset<StrokeSides<'a>>>,
}
impl<'a> Default for ElementStrokeArgs<'a> {
  #[inline]
  fn default() -> Self {
    ElementStrokeArgs {
      content: None,
      width: 0.0,
      style: None,
      placement: 0,
      stroke_sides: None,
    }
  }
}

pub struct ElementStrokeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ElementStrokeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_content(&mut self, content: flatbuffers::WIPOffset<ElementContentBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ElementContentBase>>(ElementStroke::VT_CONTENT, content);
  }
  #[inline]
  pub fn add_width(&mut self, width: f64) {
    self.fbb_.push_slot::<f64>(ElementStroke::VT_WIDTH, width, 0.0);
  }
  #[inline]
  pub fn add_style(&mut self, style: flatbuffers::WIPOffset<StrokeStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<StrokeStyle>>(ElementStroke::VT_STYLE, style);
  }
  #[inline]
  pub fn add_placement(&mut self, placement: i8) {
    self.fbb_.push_slot::<i8>(ElementStroke::VT_PLACEMENT, placement, 0);
  }
  #[inline]
  pub fn add_stroke_sides(&mut self, stroke_sides: flatbuffers::WIPOffset<StrokeSides<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<StrokeSides>>(ElementStroke::VT_STROKE_SIDES, stroke_sides);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ElementStrokeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ElementStrokeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ElementStroke<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ElementStroke<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ElementStroke");
      ds.field("content", &self.content());
      ds.field("width", &self.width());
      ds.field("style", &self.style());
      ds.field("placement", &self.placement());
      ds.field("stroke_sides", &self.stroke_sides());
      ds.finish()
  }
}
pub enum ElementBackgroundOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ElementBackground<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ElementBackground<'a> {
  type Inner = ElementBackground<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ElementBackground<'a> {
  pub const VT_CONTENT: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ElementBackground { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ElementBackgroundArgs<'args>
  ) -> flatbuffers::WIPOffset<ElementBackground<'bldr>> {
    let mut builder = ElementBackgroundBuilder::new(_fbb);
    if let Some(x) = args.content { builder.add_content(x); }
    builder.finish()
  }


  #[inline]
  pub fn content(&self) -> Option<ElementContentBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ElementContentBase>>(ElementBackground::VT_CONTENT, None)}
  }
}

impl flatbuffers::Verifiable for ElementBackground<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<ElementContentBase>>("content", Self::VT_CONTENT, false)?
     .finish();
    Ok(())
  }
}
pub struct ElementBackgroundArgs<'a> {
    pub content: Option<flatbuffers::WIPOffset<ElementContentBase<'a>>>,
}
impl<'a> Default for ElementBackgroundArgs<'a> {
  #[inline]
  fn default() -> Self {
    ElementBackgroundArgs {
      content: None,
    }
  }
}

pub struct ElementBackgroundBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ElementBackgroundBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_content(&mut self, content: flatbuffers::WIPOffset<ElementContentBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ElementContentBase>>(ElementBackground::VT_CONTENT, content);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ElementBackgroundBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ElementBackgroundBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ElementBackground<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ElementBackground<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ElementBackground");
      ds.field("content", &self.content());
      ds.finish()
  }
}
pub enum DucPathOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucPath<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucPath<'a> {
  type Inner = DucPath<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucPath<'a> {
  pub const VT_LINE_INDICES: flatbuffers::VOffsetT = 4;
  pub const VT_BACKGROUND: flatbuffers::VOffsetT = 6;
  pub const VT_STROKE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucPath { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucPathArgs<'args>
  ) -> flatbuffers::WIPOffset<DucPath<'bldr>> {
    let mut builder = DucPathBuilder::new(_fbb);
    if let Some(x) = args.stroke { builder.add_stroke(x); }
    if let Some(x) = args.background { builder.add_background(x); }
    if let Some(x) = args.line_indices { builder.add_line_indices(x); }
    builder.finish()
  }


  #[inline]
  pub fn line_indices(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(DucPath::VT_LINE_INDICES, None)}
  }
  #[inline]
  pub fn background(&self) -> Option<ElementBackground<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ElementBackground>>(DucPath::VT_BACKGROUND, None)}
  }
  #[inline]
  pub fn stroke(&self) -> Option<ElementStroke<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ElementStroke>>(DucPath::VT_STROKE, None)}
  }
}

impl flatbuffers::Verifiable for DucPath<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("line_indices", Self::VT_LINE_INDICES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ElementBackground>>("background", Self::VT_BACKGROUND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ElementStroke>>("stroke", Self::VT_STROKE, false)?
     .finish();
    Ok(())
  }
}
pub struct DucPathArgs<'a> {
    pub line_indices: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub background: Option<flatbuffers::WIPOffset<ElementBackground<'a>>>,
    pub stroke: Option<flatbuffers::WIPOffset<ElementStroke<'a>>>,
}
impl<'a> Default for DucPathArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucPathArgs {
      line_indices: None,
      background: None,
      stroke: None,
    }
  }
}

pub struct DucPathBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucPathBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_line_indices(&mut self, line_indices: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucPath::VT_LINE_INDICES, line_indices);
  }
  #[inline]
  pub fn add_background(&mut self, background: flatbuffers::WIPOffset<ElementBackground<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ElementBackground>>(DucPath::VT_BACKGROUND, background);
  }
  #[inline]
  pub fn add_stroke(&mut self, stroke: flatbuffers::WIPOffset<ElementStroke<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ElementStroke>>(DucPath::VT_STROKE, stroke);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucPathBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucPathBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucPath<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucPath<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucPath");
      ds.field("line_indices", &self.line_indices());
      ds.field("background", &self.background());
      ds.field("stroke", &self.stroke());
      ds.finish()
  }
}
pub enum ImageCropOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ImageCrop<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ImageCrop<'a> {
  type Inner = ImageCrop<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ImageCrop<'a> {
  pub const VT_X: flatbuffers::VOffsetT = 4;
  pub const VT_Y: flatbuffers::VOffsetT = 6;
  pub const VT_WIDTH: flatbuffers::VOffsetT = 8;
  pub const VT_HEIGHT: flatbuffers::VOffsetT = 10;
  pub const VT_NATURAL_WIDTH: flatbuffers::VOffsetT = 12;
  pub const VT_NATURAL_HEIGHT: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ImageCrop { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ImageCropArgs
  ) -> flatbuffers::WIPOffset<ImageCrop<'bldr>> {
    let mut builder = ImageCropBuilder::new(_fbb);
    builder.add_natural_height(args.natural_height);
    builder.add_natural_width(args.natural_width);
    builder.add_height(args.height);
    builder.add_width(args.width);
    builder.add_y(args.y);
    builder.add_x(args.x);
    builder.finish()
  }


  #[inline]
  pub fn x(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ImageCrop::VT_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ImageCrop::VT_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn width(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ImageCrop::VT_WIDTH, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn height(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ImageCrop::VT_HEIGHT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn natural_width(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ImageCrop::VT_NATURAL_WIDTH, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn natural_height(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ImageCrop::VT_NATURAL_HEIGHT, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ImageCrop<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("x", Self::VT_X, false)?
     .visit_field::<f64>("y", Self::VT_Y, false)?
     .visit_field::<f64>("width", Self::VT_WIDTH, false)?
     .visit_field::<f64>("height", Self::VT_HEIGHT, false)?
     .visit_field::<f64>("natural_width", Self::VT_NATURAL_WIDTH, false)?
     .visit_field::<f64>("natural_height", Self::VT_NATURAL_HEIGHT, false)?
     .finish();
    Ok(())
  }
}
pub struct ImageCropArgs {
    pub x: f64,
    pub y: f64,
    pub width: f64,
    pub height: f64,
    pub natural_width: f64,
    pub natural_height: f64,
}
impl<'a> Default for ImageCropArgs {
  #[inline]
  fn default() -> Self {
    ImageCropArgs {
      x: 0.0,
      y: 0.0,
      width: 0.0,
      height: 0.0,
      natural_width: 0.0,
      natural_height: 0.0,
    }
  }
}

pub struct ImageCropBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ImageCropBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_x(&mut self, x: f64) {
    self.fbb_.push_slot::<f64>(ImageCrop::VT_X, x, 0.0);
  }
  #[inline]
  pub fn add_y(&mut self, y: f64) {
    self.fbb_.push_slot::<f64>(ImageCrop::VT_Y, y, 0.0);
  }
  #[inline]
  pub fn add_width(&mut self, width: f64) {
    self.fbb_.push_slot::<f64>(ImageCrop::VT_WIDTH, width, 0.0);
  }
  #[inline]
  pub fn add_height(&mut self, height: f64) {
    self.fbb_.push_slot::<f64>(ImageCrop::VT_HEIGHT, height, 0.0);
  }
  #[inline]
  pub fn add_natural_width(&mut self, natural_width: f64) {
    self.fbb_.push_slot::<f64>(ImageCrop::VT_NATURAL_WIDTH, natural_width, 0.0);
  }
  #[inline]
  pub fn add_natural_height(&mut self, natural_height: f64) {
    self.fbb_.push_slot::<f64>(ImageCrop::VT_NATURAL_HEIGHT, natural_height, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ImageCropBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ImageCropBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ImageCrop<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ImageCrop<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ImageCrop");
      ds.field("x", &self.x());
      ds.field("y", &self.y());
      ds.field("width", &self.width());
      ds.field("height", &self.height());
      ds.field("natural_width", &self.natural_width());
      ds.field("natural_height", &self.natural_height());
      ds.finish()
  }
}
pub enum DucTableStylePropsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucTableStyleProps<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucTableStyleProps<'a> {
  type Inner = DucTableStyleProps<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucTableStyleProps<'a> {
  pub const VT_BACKGROUND_COLOR: flatbuffers::VOffsetT = 4;
  pub const VT_BORDER_WIDTH: flatbuffers::VOffsetT = 6;
  pub const VT_BORDER_DASHES: flatbuffers::VOffsetT = 8;
  pub const VT_BORDER_COLOR: flatbuffers::VOffsetT = 10;
  pub const VT_TEXT_COLOR: flatbuffers::VOffsetT = 12;
  pub const VT_TEXT_SIZE: flatbuffers::VOffsetT = 14;
  pub const VT_TEXT_FONT: flatbuffers::VOffsetT = 16;
  pub const VT_TEXT_ALIGN: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucTableStyleProps { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucTableStylePropsArgs<'args>
  ) -> flatbuffers::WIPOffset<DucTableStyleProps<'bldr>> {
    let mut builder = DucTableStylePropsBuilder::new(_fbb);
    builder.add_text_size(args.text_size);
    builder.add_border_width(args.border_width);
    if let Some(x) = args.text_font { builder.add_text_font(x); }
    if let Some(x) = args.text_color { builder.add_text_color(x); }
    if let Some(x) = args.border_color { builder.add_border_color(x); }
    if let Some(x) = args.border_dashes { builder.add_border_dashes(x); }
    if let Some(x) = args.background_color { builder.add_background_color(x); }
    builder.add_text_align(args.text_align);
    builder.finish()
  }


  #[inline]
  pub fn background_color(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucTableStyleProps::VT_BACKGROUND_COLOR, None)}
  }
  #[inline]
  pub fn border_width(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucTableStyleProps::VT_BORDER_WIDTH, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn border_dashes(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(DucTableStyleProps::VT_BORDER_DASHES, None)}
  }
  #[inline]
  pub fn border_color(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucTableStyleProps::VT_BORDER_COLOR, None)}
  }
  #[inline]
  pub fn text_color(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucTableStyleProps::VT_TEXT_COLOR, None)}
  }
  #[inline]
  pub fn text_size(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucTableStyleProps::VT_TEXT_SIZE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn text_font(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucTableStyleProps::VT_TEXT_FONT, None)}
  }
  #[inline]
  pub fn text_align(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(DucTableStyleProps::VT_TEXT_ALIGN, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DucTableStyleProps<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("background_color", Self::VT_BACKGROUND_COLOR, false)?
     .visit_field::<f64>("border_width", Self::VT_BORDER_WIDTH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("border_dashes", Self::VT_BORDER_DASHES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("border_color", Self::VT_BORDER_COLOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("text_color", Self::VT_TEXT_COLOR, false)?
     .visit_field::<f64>("text_size", Self::VT_TEXT_SIZE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("text_font", Self::VT_TEXT_FONT, false)?
     .visit_field::<i8>("text_align", Self::VT_TEXT_ALIGN, false)?
     .finish();
    Ok(())
  }
}
pub struct DucTableStylePropsArgs<'a> {
    pub background_color: Option<flatbuffers::WIPOffset<&'a str>>,
    pub border_width: f64,
    pub border_dashes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub border_color: Option<flatbuffers::WIPOffset<&'a str>>,
    pub text_color: Option<flatbuffers::WIPOffset<&'a str>>,
    pub text_size: f64,
    pub text_font: Option<flatbuffers::WIPOffset<&'a str>>,
    pub text_align: i8,
}
impl<'a> Default for DucTableStylePropsArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucTableStylePropsArgs {
      background_color: None,
      border_width: 0.0,
      border_dashes: None,
      border_color: None,
      text_color: None,
      text_size: 0.0,
      text_font: None,
      text_align: 0,
    }
  }
}

pub struct DucTableStylePropsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucTableStylePropsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_background_color(&mut self, background_color: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucTableStyleProps::VT_BACKGROUND_COLOR, background_color);
  }
  #[inline]
  pub fn add_border_width(&mut self, border_width: f64) {
    self.fbb_.push_slot::<f64>(DucTableStyleProps::VT_BORDER_WIDTH, border_width, 0.0);
  }
  #[inline]
  pub fn add_border_dashes(&mut self, border_dashes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucTableStyleProps::VT_BORDER_DASHES, border_dashes);
  }
  #[inline]
  pub fn add_border_color(&mut self, border_color: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucTableStyleProps::VT_BORDER_COLOR, border_color);
  }
  #[inline]
  pub fn add_text_color(&mut self, text_color: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucTableStyleProps::VT_TEXT_COLOR, text_color);
  }
  #[inline]
  pub fn add_text_size(&mut self, text_size: f64) {
    self.fbb_.push_slot::<f64>(DucTableStyleProps::VT_TEXT_SIZE, text_size, 0.0);
  }
  #[inline]
  pub fn add_text_font(&mut self, text_font: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucTableStyleProps::VT_TEXT_FONT, text_font);
  }
  #[inline]
  pub fn add_text_align(&mut self, text_align: i8) {
    self.fbb_.push_slot::<i8>(DucTableStyleProps::VT_TEXT_ALIGN, text_align, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucTableStylePropsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucTableStylePropsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucTableStyleProps<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucTableStyleProps<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucTableStyleProps");
      ds.field("background_color", &self.background_color());
      ds.field("border_width", &self.border_width());
      ds.field("border_dashes", &self.border_dashes());
      ds.field("border_color", &self.border_color());
      ds.field("text_color", &self.text_color());
      ds.field("text_size", &self.text_size());
      ds.field("text_font", &self.text_font());
      ds.field("text_align", &self.text_align());
      ds.finish()
  }
}
pub enum DucTableColumnOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucTableColumn<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucTableColumn<'a> {
  type Inner = DucTableColumn<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucTableColumn<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_WIDTH: flatbuffers::VOffsetT = 6;
  pub const VT_STYLE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucTableColumn { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucTableColumnArgs<'args>
  ) -> flatbuffers::WIPOffset<DucTableColumn<'bldr>> {
    let mut builder = DucTableColumnBuilder::new(_fbb);
    builder.add_width(args.width);
    if let Some(x) = args.style { builder.add_style(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucTableColumn::VT_ID, None)}
  }
  #[inline]
  pub fn width(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucTableColumn::VT_WIDTH, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn style(&self) -> Option<DucTableStyleProps<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucTableStyleProps>>(DucTableColumn::VT_STYLE, None)}
  }
}

impl flatbuffers::Verifiable for DucTableColumn<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<f64>("width", Self::VT_WIDTH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucTableStyleProps>>("style", Self::VT_STYLE, false)?
     .finish();
    Ok(())
  }
}
pub struct DucTableColumnArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub width: f64,
    pub style: Option<flatbuffers::WIPOffset<DucTableStyleProps<'a>>>,
}
impl<'a> Default for DucTableColumnArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucTableColumnArgs {
      id: None,
      width: 0.0,
      style: None,
    }
  }
}

pub struct DucTableColumnBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucTableColumnBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucTableColumn::VT_ID, id);
  }
  #[inline]
  pub fn add_width(&mut self, width: f64) {
    self.fbb_.push_slot::<f64>(DucTableColumn::VT_WIDTH, width, 0.0);
  }
  #[inline]
  pub fn add_style(&mut self, style: flatbuffers::WIPOffset<DucTableStyleProps<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucTableStyleProps>>(DucTableColumn::VT_STYLE, style);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucTableColumnBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucTableColumnBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucTableColumn<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucTableColumn<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucTableColumn");
      ds.field("id", &self.id());
      ds.field("width", &self.width());
      ds.field("style", &self.style());
      ds.finish()
  }
}
pub enum DucTableRowOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucTableRow<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucTableRow<'a> {
  type Inner = DucTableRow<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucTableRow<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_HEIGHT: flatbuffers::VOffsetT = 6;
  pub const VT_STYLE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucTableRow { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucTableRowArgs<'args>
  ) -> flatbuffers::WIPOffset<DucTableRow<'bldr>> {
    let mut builder = DucTableRowBuilder::new(_fbb);
    builder.add_height(args.height);
    if let Some(x) = args.style { builder.add_style(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucTableRow::VT_ID, None)}
  }
  #[inline]
  pub fn height(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucTableRow::VT_HEIGHT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn style(&self) -> Option<DucTableStyleProps<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucTableStyleProps>>(DucTableRow::VT_STYLE, None)}
  }
}

impl flatbuffers::Verifiable for DucTableRow<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<f64>("height", Self::VT_HEIGHT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucTableStyleProps>>("style", Self::VT_STYLE, false)?
     .finish();
    Ok(())
  }
}
pub struct DucTableRowArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub height: f64,
    pub style: Option<flatbuffers::WIPOffset<DucTableStyleProps<'a>>>,
}
impl<'a> Default for DucTableRowArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucTableRowArgs {
      id: None,
      height: 0.0,
      style: None,
    }
  }
}

pub struct DucTableRowBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucTableRowBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucTableRow::VT_ID, id);
  }
  #[inline]
  pub fn add_height(&mut self, height: f64) {
    self.fbb_.push_slot::<f64>(DucTableRow::VT_HEIGHT, height, 0.0);
  }
  #[inline]
  pub fn add_style(&mut self, style: flatbuffers::WIPOffset<DucTableStyleProps<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucTableStyleProps>>(DucTableRow::VT_STYLE, style);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucTableRowBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucTableRowBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucTableRow<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucTableRow<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucTableRow");
      ds.field("id", &self.id());
      ds.field("height", &self.height());
      ds.field("style", &self.style());
      ds.finish()
  }
}
pub enum DucTableCellOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucTableCell<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucTableCell<'a> {
  type Inner = DucTableCell<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucTableCell<'a> {
  pub const VT_ROW_ID: flatbuffers::VOffsetT = 4;
  pub const VT_COLUMN_ID: flatbuffers::VOffsetT = 6;
  pub const VT_DATA: flatbuffers::VOffsetT = 8;
  pub const VT_STYLE: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucTableCell { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucTableCellArgs<'args>
  ) -> flatbuffers::WIPOffset<DucTableCell<'bldr>> {
    let mut builder = DucTableCellBuilder::new(_fbb);
    if let Some(x) = args.style { builder.add_style(x); }
    if let Some(x) = args.data { builder.add_data(x); }
    if let Some(x) = args.column_id { builder.add_column_id(x); }
    if let Some(x) = args.row_id { builder.add_row_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn row_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucTableCell::VT_ROW_ID, None)}
  }
  #[inline]
  pub fn column_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucTableCell::VT_COLUMN_ID, None)}
  }
  #[inline]
  pub fn data(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucTableCell::VT_DATA, None)}
  }
  #[inline]
  pub fn style(&self) -> Option<DucTableStyleProps<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucTableStyleProps>>(DucTableCell::VT_STYLE, None)}
  }
}

impl flatbuffers::Verifiable for DucTableCell<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("row_id", Self::VT_ROW_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("column_id", Self::VT_COLUMN_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("data", Self::VT_DATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucTableStyleProps>>("style", Self::VT_STYLE, false)?
     .finish();
    Ok(())
  }
}
pub struct DucTableCellArgs<'a> {
    pub row_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub column_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub data: Option<flatbuffers::WIPOffset<&'a str>>,
    pub style: Option<flatbuffers::WIPOffset<DucTableStyleProps<'a>>>,
}
impl<'a> Default for DucTableCellArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucTableCellArgs {
      row_id: None,
      column_id: None,
      data: None,
      style: None,
    }
  }
}

pub struct DucTableCellBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucTableCellBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_row_id(&mut self, row_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucTableCell::VT_ROW_ID, row_id);
  }
  #[inline]
  pub fn add_column_id(&mut self, column_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucTableCell::VT_COLUMN_ID, column_id);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucTableCell::VT_DATA, data);
  }
  #[inline]
  pub fn add_style(&mut self, style: flatbuffers::WIPOffset<DucTableStyleProps<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucTableStyleProps>>(DucTableCell::VT_STYLE, style);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucTableCellBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucTableCellBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucTableCell<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucTableCell<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucTableCell");
      ds.field("row_id", &self.row_id());
      ds.field("column_id", &self.column_id());
      ds.field("data", &self.data());
      ds.field("style", &self.style());
      ds.finish()
  }
}
pub enum DucTableStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucTableStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucTableStyle<'a> {
  type Inner = DucTableStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucTableStyle<'a> {
  pub const VT_DEFAULT_PROPS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucTableStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucTableStyleArgs<'args>
  ) -> flatbuffers::WIPOffset<DucTableStyle<'bldr>> {
    let mut builder = DucTableStyleBuilder::new(_fbb);
    if let Some(x) = args.default_props { builder.add_default_props(x); }
    builder.finish()
  }


  #[inline]
  pub fn default_props(&self) -> Option<DucTableStyleProps<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucTableStyleProps>>(DucTableStyle::VT_DEFAULT_PROPS, None)}
  }
}

impl flatbuffers::Verifiable for DucTableStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucTableStyleProps>>("default_props", Self::VT_DEFAULT_PROPS, false)?
     .finish();
    Ok(())
  }
}
pub struct DucTableStyleArgs<'a> {
    pub default_props: Option<flatbuffers::WIPOffset<DucTableStyleProps<'a>>>,
}
impl<'a> Default for DucTableStyleArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucTableStyleArgs {
      default_props: None,
    }
  }
}

pub struct DucTableStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucTableStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_default_props(&mut self, default_props: flatbuffers::WIPOffset<DucTableStyleProps<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucTableStyleProps>>(DucTableStyle::VT_DEFAULT_PROPS, default_props);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucTableStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucTableStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucTableStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucTableStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucTableStyle");
      ds.field("default_props", &self.default_props());
      ds.finish()
  }
}
pub enum DucBlockInstanceElementOverrideOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucBlockInstanceElementOverride<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucBlockInstanceElementOverride<'a> {
  type Inner = DucBlockInstanceElementOverride<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucBlockInstanceElementOverride<'a> {
  pub const VT_ELEMENT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_OVERRIDES: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucBlockInstanceElementOverride { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucBlockInstanceElementOverrideArgs<'args>
  ) -> flatbuffers::WIPOffset<DucBlockInstanceElementOverride<'bldr>> {
    let mut builder = DucBlockInstanceElementOverrideBuilder::new(_fbb);
    if let Some(x) = args.overrides { builder.add_overrides(x); }
    if let Some(x) = args.element_id { builder.add_element_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn element_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucBlockInstanceElementOverride::VT_ELEMENT_ID, None)}
  }
  #[inline]
  pub fn overrides(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucBlockInstanceElementOverride::VT_OVERRIDES, None)}
  }
}

impl flatbuffers::Verifiable for DucBlockInstanceElementOverride<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("element_id", Self::VT_ELEMENT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("overrides", Self::VT_OVERRIDES, false)?
     .finish();
    Ok(())
  }
}
pub struct DucBlockInstanceElementOverrideArgs<'a> {
    pub element_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub overrides: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DucBlockInstanceElementOverrideArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucBlockInstanceElementOverrideArgs {
      element_id: None,
      overrides: None,
    }
  }
}

pub struct DucBlockInstanceElementOverrideBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucBlockInstanceElementOverrideBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_element_id(&mut self, element_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucBlockInstanceElementOverride::VT_ELEMENT_ID, element_id);
  }
  #[inline]
  pub fn add_overrides(&mut self, overrides: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucBlockInstanceElementOverride::VT_OVERRIDES, overrides);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucBlockInstanceElementOverrideBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucBlockInstanceElementOverrideBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucBlockInstanceElementOverride<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucBlockInstanceElementOverride<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucBlockInstanceElementOverride");
      ds.field("element_id", &self.element_id());
      ds.field("overrides", &self.overrides());
      ds.finish()
  }
}
pub enum DucElementOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucElement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucElement<'a> {
  type Inner = DucElement<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucElement<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
  pub const VT_X_V2: flatbuffers::VOffsetT = 8;
  pub const VT_Y_V2: flatbuffers::VOffsetT = 10;
  pub const VT_SCOPE: flatbuffers::VOffsetT = 14;
  pub const VT_LABEL: flatbuffers::VOffsetT = 18;
  pub const VT_IS_VISIBLE: flatbuffers::VOffsetT = 20;
  pub const VT_BACKGROUND_COLOR_V3: flatbuffers::VOffsetT = 26;
  pub const VT_STROKE_COLOR_V3: flatbuffers::VOffsetT = 28;
  pub const VT_OPACITY: flatbuffers::VOffsetT = 38;
  pub const VT_WIDTH_V2: flatbuffers::VOffsetT = 40;
  pub const VT_HEIGHT_V2: flatbuffers::VOffsetT = 42;
  pub const VT_ANGLE_V2: flatbuffers::VOffsetT = 44;
  pub const VT_IS_DELETED: flatbuffers::VOffsetT = 46;
  pub const VT_GROUP_IDS: flatbuffers::VOffsetT = 48;
  pub const VT_FRAME_ID: flatbuffers::VOffsetT = 50;
  pub const VT_BOUND_ELEMENTS: flatbuffers::VOffsetT = 52;
  pub const VT_LINK: flatbuffers::VOffsetT = 54;
  pub const VT_LOCKED: flatbuffers::VOffsetT = 56;
  pub const VT_TEXT_FONT_SIZE_V2: flatbuffers::VOffsetT = 64;
  pub const VT_TEXT_FONT_FAMILY: flatbuffers::VOffsetT = 66;
  pub const VT_TEXT_TEXT: flatbuffers::VOffsetT = 68;
  pub const VT_TEXT_CONTAINER_ID: flatbuffers::VOffsetT = 74;
  pub const VT_TEXT_LINE_HEIGHT_V2: flatbuffers::VOffsetT = 78;
  pub const VT_TEXT_AUTO_RESIZE: flatbuffers::VOffsetT = 80;
  pub const VT_LINEAR_ELEMENT_POINTS: flatbuffers::VOffsetT = 82;
  pub const VT_LINEAR_ELEMENT_LAST_COMMITTED_POINT: flatbuffers::VOffsetT = 84;
  pub const VT_LINEAR_ELEMENT_START_BINDING: flatbuffers::VOffsetT = 86;
  pub const VT_LINEAR_ELEMENT_END_BINDING: flatbuffers::VOffsetT = 88;
  pub const VT_ARROW_ELBOWED: flatbuffers::VOffsetT = 94;
  pub const VT_FREE_DRAW_SIMULATE_PRESSURE: flatbuffers::VOffsetT = 98;
  pub const VT_FILE_ID: flatbuffers::VOffsetT = 100;
  pub const VT_IMAGE_STATUS: flatbuffers::VOffsetT = 102;
  pub const VT_STACK_LIKE_IS_COLLAPSED: flatbuffers::VOffsetT = 106;
  pub const VT_STROKE_STYLE_V3: flatbuffers::VOffsetT = 112;
  pub const VT_FILL_STYLE_V3: flatbuffers::VOffsetT = 114;
  pub const VT_TEXT_TEXT_ALIGN: flatbuffers::VOffsetT = 116;
  pub const VT_TEXT_VERTICAL_ALIGN: flatbuffers::VOffsetT = 118;
  pub const VT_X: flatbuffers::VOffsetT = 120;
  pub const VT_Y: flatbuffers::VOffsetT = 122;
  pub const VT_IMAGE_SCALE: flatbuffers::VOffsetT = 124;
  pub const VT_FREE_DRAW_PRESSURES: flatbuffers::VOffsetT = 126;
  pub const VT_STROKE_WIDTH_V3: flatbuffers::VOffsetT = 128;
  pub const VT_ANGLE: flatbuffers::VOffsetT = 130;
  pub const VT_ROUNDNESS: flatbuffers::VOffsetT = 132;
  pub const VT_WIDTH: flatbuffers::VOffsetT = 134;
  pub const VT_HEIGHT: flatbuffers::VOffsetT = 136;
  pub const VT_TEXT_FONT_SIZE: flatbuffers::VOffsetT = 138;
  pub const VT_TEXT_LINE_HEIGHT: flatbuffers::VOffsetT = 140;
  pub const VT_BLENDING: flatbuffers::VOffsetT = 142;
  pub const VT_BACKGROUND: flatbuffers::VOffsetT = 144;
  pub const VT_STROKE: flatbuffers::VOffsetT = 146;
  pub const VT_IMAGE_CROP: flatbuffers::VOffsetT = 148;
  pub const VT_STACK_LIKE_CLIP: flatbuffers::VOffsetT = 150;
  pub const VT_SUBSET: flatbuffers::VOffsetT = 152;
  pub const VT_Z_INDEX: flatbuffers::VOffsetT = 154;
  pub const VT_POLYGON_SIDES: flatbuffers::VOffsetT = 156;
  pub const VT_TABLE_COLUMN_ORDER: flatbuffers::VOffsetT = 158;
  pub const VT_TABLE_ROW_ORDER: flatbuffers::VOffsetT = 160;
  pub const VT_TABLE_COLUMNS: flatbuffers::VOffsetT = 162;
  pub const VT_TABLE_ROWS: flatbuffers::VOffsetT = 164;
  pub const VT_TABLE_CELLS: flatbuffers::VOffsetT = 166;
  pub const VT_TABLE_STYLE: flatbuffers::VOffsetT = 168;
  pub const VT_DOC_CONTENT: flatbuffers::VOffsetT = 170;
  pub const VT_LINEAR_ELEMENT_LINES: flatbuffers::VOffsetT = 172;
  pub const VT_ELLIPSE_RATIO: flatbuffers::VOffsetT = 174;
  pub const VT_ELLIPSE_START_ANGLE: flatbuffers::VOffsetT = 176;
  pub const VT_ELLIPSE_END_ANGLE: flatbuffers::VOffsetT = 178;
  pub const VT_ELLIPSE_SHOW_AUX_CROSSHAIR: flatbuffers::VOffsetT = 180;
  pub const VT_FREE_DRAW_THINNING: flatbuffers::VOffsetT = 182;
  pub const VT_FREE_DRAW_SMOOTHING: flatbuffers::VOffsetT = 184;
  pub const VT_FREE_DRAW_STREAMLINE: flatbuffers::VOffsetT = 186;
  pub const VT_FREE_DRAW_EASING: flatbuffers::VOffsetT = 188;
  pub const VT_FREE_DRAW_START_CAP: flatbuffers::VOffsetT = 190;
  pub const VT_FREE_DRAW_START_TAPER: flatbuffers::VOffsetT = 192;
  pub const VT_FREE_DRAW_START_EASING: flatbuffers::VOffsetT = 194;
  pub const VT_FREE_DRAW_END_CAP: flatbuffers::VOffsetT = 196;
  pub const VT_FREE_DRAW_END_TAPER: flatbuffers::VOffsetT = 198;
  pub const VT_FREE_DRAW_END_EASING: flatbuffers::VOffsetT = 200;
  pub const VT_FREE_DRAW_SVG_PATH: flatbuffers::VOffsetT = 202;
  pub const VT_FREE_DRAW_SIZE: flatbuffers::VOffsetT = 204;
  pub const VT_LINEAR_ELEMENT_PATH_OVERRIDES: flatbuffers::VOffsetT = 206;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 208;
  pub const VT_NO_PLOT: flatbuffers::VOffsetT = 210;
  pub const VT_STACK_LIKE_LABELING_COLOR: flatbuffers::VOffsetT = 212;
  pub const VT_STACK_LIKE_STROKE_OVERRIDE: flatbuffers::VOffsetT = 214;
  pub const VT_STACK_LIKE_BACKGROUND_OVERRIDE: flatbuffers::VOffsetT = 216;
  pub const VT_BLOCK_INSTANCE_BLOCK_ID: flatbuffers::VOffsetT = 218;
  pub const VT_BLOCK_INSTANCE_ELEMENT_OVERRIDES: flatbuffers::VOffsetT = 220;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucElement { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucElementArgs<'args>
  ) -> flatbuffers::WIPOffset<DucElement<'bldr>> {
    let mut builder = DucElementBuilder::new(_fbb);
    if let Some(x) = args.free_draw_size { builder.add_free_draw_size(x); }
    if let Some(x) = args.free_draw_end_taper { builder.add_free_draw_end_taper(x); }
    if let Some(x) = args.free_draw_start_taper { builder.add_free_draw_start_taper(x); }
    if let Some(x) = args.free_draw_streamline { builder.add_free_draw_streamline(x); }
    if let Some(x) = args.free_draw_smoothing { builder.add_free_draw_smoothing(x); }
    if let Some(x) = args.free_draw_thinning { builder.add_free_draw_thinning(x); }
    if let Some(x) = args.ellipse_end_angle { builder.add_ellipse_end_angle(x); }
    if let Some(x) = args.ellipse_start_angle { builder.add_ellipse_start_angle(x); }
    if let Some(x) = args.ellipse_ratio { builder.add_ellipse_ratio(x); }
    if let Some(x) = args.text_line_height { builder.add_text_line_height(x); }
    if let Some(x) = args.text_font_size { builder.add_text_font_size(x); }
    builder.add_height(args.height);
    builder.add_width(args.width);
    builder.add_roundness(args.roundness);
    builder.add_angle(args.angle);
    builder.add_stroke_width_v3(args.stroke_width_v3);
    builder.add_y(args.y);
    builder.add_x(args.x);
    if let Some(x) = args.block_instance_element_overrides { builder.add_block_instance_element_overrides(x); }
    if let Some(x) = args.block_instance_block_id { builder.add_block_instance_block_id(x); }
    if let Some(x) = args.stack_like_background_override { builder.add_stack_like_background_override(x); }
    if let Some(x) = args.stack_like_stroke_override { builder.add_stack_like_stroke_override(x); }
    if let Some(x) = args.stack_like_labeling_color { builder.add_stack_like_labeling_color(x); }
    if let Some(x) = args.description { builder.add_description(x); }
    if let Some(x) = args.linear_element_path_overrides { builder.add_linear_element_path_overrides(x); }
    if let Some(x) = args.free_draw_svg_path { builder.add_free_draw_svg_path(x); }
    if let Some(x) = args.free_draw_end_easing { builder.add_free_draw_end_easing(x); }
    if let Some(x) = args.free_draw_start_easing { builder.add_free_draw_start_easing(x); }
    if let Some(x) = args.free_draw_easing { builder.add_free_draw_easing(x); }
    if let Some(x) = args.linear_element_lines { builder.add_linear_element_lines(x); }
    if let Some(x) = args.doc_content { builder.add_doc_content(x); }
    if let Some(x) = args.table_style { builder.add_table_style(x); }
    if let Some(x) = args.table_cells { builder.add_table_cells(x); }
    if let Some(x) = args.table_rows { builder.add_table_rows(x); }
    if let Some(x) = args.table_columns { builder.add_table_columns(x); }
    if let Some(x) = args.table_row_order { builder.add_table_row_order(x); }
    if let Some(x) = args.table_column_order { builder.add_table_column_order(x); }
    if let Some(x) = args.polygon_sides { builder.add_polygon_sides(x); }
    builder.add_z_index(args.z_index);
    if let Some(x) = args.image_crop { builder.add_image_crop(x); }
    if let Some(x) = args.stroke { builder.add_stroke(x); }
    if let Some(x) = args.background { builder.add_background(x); }
    if let Some(x) = args.free_draw_pressures { builder.add_free_draw_pressures(x); }
    if let Some(x) = args.image_scale { builder.add_image_scale(x); }
    if let Some(x) = args.file_id { builder.add_file_id(x); }
    if let Some(x) = args.linear_element_end_binding { builder.add_linear_element_end_binding(x); }
    if let Some(x) = args.linear_element_start_binding { builder.add_linear_element_start_binding(x); }
    if let Some(x) = args.linear_element_last_committed_point { builder.add_linear_element_last_committed_point(x); }
    if let Some(x) = args.linear_element_points { builder.add_linear_element_points(x); }
    if let Some(x) = args.text_line_height_v2 { builder.add_text_line_height_v2(x); }
    if let Some(x) = args.text_container_id { builder.add_text_container_id(x); }
    if let Some(x) = args.text_text { builder.add_text_text(x); }
    if let Some(x) = args.text_font_family { builder.add_text_font_family(x); }
    if let Some(x) = args.text_font_size_v2 { builder.add_text_font_size_v2(x); }
    if let Some(x) = args.link { builder.add_link(x); }
    if let Some(x) = args.bound_elements { builder.add_bound_elements(x); }
    if let Some(x) = args.frame_id { builder.add_frame_id(x); }
    if let Some(x) = args.group_ids { builder.add_group_ids(x); }
    if let Some(x) = args.angle_v2 { builder.add_angle_v2(x); }
    if let Some(x) = args.height_v2 { builder.add_height_v2(x); }
    if let Some(x) = args.width_v2 { builder.add_width_v2(x); }
    builder.add_opacity(args.opacity);
    if let Some(x) = args.stroke_color_v3 { builder.add_stroke_color_v3(x); }
    if let Some(x) = args.background_color_v3 { builder.add_background_color_v3(x); }
    if let Some(x) = args.label { builder.add_label(x); }
    if let Some(x) = args.scope { builder.add_scope(x); }
    if let Some(x) = args.y_v2 { builder.add_y_v2(x); }
    if let Some(x) = args.x_v2 { builder.add_x_v2(x); }
    if let Some(x) = args.type_ { builder.add_type_(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    if let Some(x) = args.no_plot { builder.add_no_plot(x); }
    if let Some(x) = args.free_draw_end_cap { builder.add_free_draw_end_cap(x); }
    if let Some(x) = args.free_draw_start_cap { builder.add_free_draw_start_cap(x); }
    if let Some(x) = args.ellipse_show_aux_crosshair { builder.add_ellipse_show_aux_crosshair(x); }
    if let Some(x) = args.subset { builder.add_subset(x); }
    if let Some(x) = args.stack_like_clip { builder.add_stack_like_clip(x); }
    if let Some(x) = args.blending { builder.add_blending(x); }
    builder.add_text_vertical_align(args.text_vertical_align);
    if let Some(x) = args.text_text_align { builder.add_text_text_align(x); }
    builder.add_fill_style_v3(args.fill_style_v3);
    builder.add_stroke_style_v3(args.stroke_style_v3);
    if let Some(x) = args.stack_like_is_collapsed { builder.add_stack_like_is_collapsed(x); }
    if let Some(x) = args.image_status { builder.add_image_status(x); }
    if let Some(x) = args.free_draw_simulate_pressure { builder.add_free_draw_simulate_pressure(x); }
    if let Some(x) = args.arrow_elbowed { builder.add_arrow_elbowed(x); }
    if let Some(x) = args.text_auto_resize { builder.add_text_auto_resize(x); }
    builder.add_locked(args.locked);
    builder.add_is_deleted(args.is_deleted);
    builder.add_is_visible(args.is_visible);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_ID, None)}
  }
  #[inline]
  pub fn type_(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_TYPE_, None)}
  }
  #[inline]
  pub fn x_v2(&self) -> Option<f32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucElement::VT_X_V2, None)}
  }
  #[inline]
  pub fn y_v2(&self) -> Option<f32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucElement::VT_Y_V2, None)}
  }
  #[inline]
  pub fn scope(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_SCOPE, None)}
  }
  #[inline]
  pub fn label(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_LABEL, None)}
  }
  #[inline]
  pub fn is_visible(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucElement::VT_IS_VISIBLE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn background_color_v3(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_BACKGROUND_COLOR_V3, None)}
  }
  #[inline]
  pub fn stroke_color_v3(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_STROKE_COLOR_V3, None)}
  }
  #[inline]
  pub fn opacity(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucElement::VT_OPACITY, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn width_v2(&self) -> Option<f32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucElement::VT_WIDTH_V2, None)}
  }
  #[inline]
  pub fn height_v2(&self) -> Option<f32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucElement::VT_HEIGHT_V2, None)}
  }
  #[inline]
  pub fn angle_v2(&self) -> Option<f32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucElement::VT_ANGLE_V2, None)}
  }
  #[inline]
  pub fn is_deleted(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucElement::VT_IS_DELETED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn group_ids(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(DucElement::VT_GROUP_IDS, None)}
  }
  #[inline]
  pub fn frame_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_FRAME_ID, None)}
  }
  #[inline]
  pub fn bound_elements(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BoundElement<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BoundElement>>>>(DucElement::VT_BOUND_ELEMENTS, None)}
  }
  #[inline]
  pub fn link(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_LINK, None)}
  }
  #[inline]
  pub fn locked(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucElement::VT_LOCKED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn text_font_size_v2(&self) -> Option<i32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DucElement::VT_TEXT_FONT_SIZE_V2, None)}
  }
  #[inline]
  pub fn text_font_family(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_TEXT_FONT_FAMILY, None)}
  }
  #[inline]
  pub fn text_text(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_TEXT_TEXT, None)}
  }
  #[inline]
  pub fn text_container_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_TEXT_CONTAINER_ID, None)}
  }
  #[inline]
  pub fn text_line_height_v2(&self) -> Option<f32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucElement::VT_TEXT_LINE_HEIGHT_V2, None)}
  }
  #[inline]
  pub fn text_auto_resize(&self) -> Option<bool> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucElement::VT_TEXT_AUTO_RESIZE, None)}
  }
  #[inline]
  pub fn linear_element_points(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Point<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Point>>>>(DucElement::VT_LINEAR_ELEMENT_POINTS, None)}
  }
  #[inline]
  pub fn linear_element_last_committed_point(&self) -> Option<Point<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Point>>(DucElement::VT_LINEAR_ELEMENT_LAST_COMMITTED_POINT, None)}
  }
  #[inline]
  pub fn linear_element_start_binding(&self) -> Option<PointBinding<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<PointBinding>>(DucElement::VT_LINEAR_ELEMENT_START_BINDING, None)}
  }
  #[inline]
  pub fn linear_element_end_binding(&self) -> Option<PointBinding<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<PointBinding>>(DucElement::VT_LINEAR_ELEMENT_END_BINDING, None)}
  }
  #[inline]
  pub fn arrow_elbowed(&self) -> Option<bool> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucElement::VT_ARROW_ELBOWED, None)}
  }
  #[inline]
  pub fn free_draw_simulate_pressure(&self) -> Option<bool> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucElement::VT_FREE_DRAW_SIMULATE_PRESSURE, None)}
  }
  #[inline]
  pub fn file_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_FILE_ID, None)}
  }
  #[inline]
  pub fn image_status(&self) -> Option<IMAGE_STATUS> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<IMAGE_STATUS>(DucElement::VT_IMAGE_STATUS, None)}
  }
  #[inline]
  pub fn stack_like_is_collapsed(&self) -> Option<bool> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucElement::VT_STACK_LIKE_IS_COLLAPSED, None)}
  }
  #[inline]
  pub fn stroke_style_v3(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(DucElement::VT_STROKE_STYLE_V3, Some(0)).unwrap()}
  }
  #[inline]
  pub fn fill_style_v3(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(DucElement::VT_FILL_STYLE_V3, Some(0)).unwrap()}
  }
  #[inline]
  pub fn text_text_align(&self) -> Option<i8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(DucElement::VT_TEXT_TEXT_ALIGN, None)}
  }
  #[inline]
  pub fn text_vertical_align(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(DucElement::VT_TEXT_VERTICAL_ALIGN, Some(0)).unwrap()}
  }
  #[inline]
  pub fn x(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucElement::VT_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucElement::VT_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn image_scale(&self) -> Option<SimplePoint<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SimplePoint>>(DucElement::VT_IMAGE_SCALE, None)}
  }
  #[inline]
  pub fn free_draw_pressures(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(DucElement::VT_FREE_DRAW_PRESSURES, None)}
  }
  #[inline]
  pub fn stroke_width_v3(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucElement::VT_STROKE_WIDTH_V3, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn angle(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucElement::VT_ANGLE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn roundness(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucElement::VT_ROUNDNESS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn width(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucElement::VT_WIDTH, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn height(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucElement::VT_HEIGHT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn text_font_size(&self) -> Option<f64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucElement::VT_TEXT_FONT_SIZE, None)}
  }
  #[inline]
  pub fn text_line_height(&self) -> Option<f64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucElement::VT_TEXT_LINE_HEIGHT, None)}
  }
  #[inline]
  pub fn blending(&self) -> Option<i8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(DucElement::VT_BLENDING, None)}
  }
  #[inline]
  pub fn background(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ElementBackground<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ElementBackground>>>>(DucElement::VT_BACKGROUND, None)}
  }
  #[inline]
  pub fn stroke(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ElementStroke<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ElementStroke>>>>(DucElement::VT_STROKE, None)}
  }
  #[inline]
  pub fn image_crop(&self) -> Option<ImageCrop<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ImageCrop>>(DucElement::VT_IMAGE_CROP, None)}
  }
  #[inline]
  pub fn stack_like_clip(&self) -> Option<bool> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucElement::VT_STACK_LIKE_CLIP, None)}
  }
  #[inline]
  pub fn subset(&self) -> Option<i8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(DucElement::VT_SUBSET, None)}
  }
  #[inline]
  pub fn z_index(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DucElement::VT_Z_INDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn polygon_sides(&self) -> Option<i32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DucElement::VT_POLYGON_SIDES, None)}
  }
  #[inline]
  pub fn table_column_order(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(DucElement::VT_TABLE_COLUMN_ORDER, None)}
  }
  #[inline]
  pub fn table_row_order(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(DucElement::VT_TABLE_ROW_ORDER, None)}
  }
  #[inline]
  pub fn table_columns(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucTableColumn<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucTableColumn>>>>(DucElement::VT_TABLE_COLUMNS, None)}
  }
  #[inline]
  pub fn table_rows(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucTableRow<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucTableRow>>>>(DucElement::VT_TABLE_ROWS, None)}
  }
  #[inline]
  pub fn table_cells(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucTableCell<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucTableCell>>>>(DucElement::VT_TABLE_CELLS, None)}
  }
  #[inline]
  pub fn table_style(&self) -> Option<DucTableStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucTableStyle>>(DucElement::VT_TABLE_STYLE, None)}
  }
  #[inline]
  pub fn doc_content(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_DOC_CONTENT, None)}
  }
  #[inline]
  pub fn linear_element_lines(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucLine<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucLine>>>>(DucElement::VT_LINEAR_ELEMENT_LINES, None)}
  }
  #[inline]
  pub fn ellipse_ratio(&self) -> Option<f64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucElement::VT_ELLIPSE_RATIO, None)}
  }
  #[inline]
  pub fn ellipse_start_angle(&self) -> Option<f64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucElement::VT_ELLIPSE_START_ANGLE, None)}
  }
  #[inline]
  pub fn ellipse_end_angle(&self) -> Option<f64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucElement::VT_ELLIPSE_END_ANGLE, None)}
  }
  #[inline]
  pub fn ellipse_show_aux_crosshair(&self) -> Option<bool> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucElement::VT_ELLIPSE_SHOW_AUX_CROSSHAIR, None)}
  }
  #[inline]
  pub fn free_draw_thinning(&self) -> Option<f64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucElement::VT_FREE_DRAW_THINNING, None)}
  }
  #[inline]
  pub fn free_draw_smoothing(&self) -> Option<f64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucElement::VT_FREE_DRAW_SMOOTHING, None)}
  }
  #[inline]
  pub fn free_draw_streamline(&self) -> Option<f64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucElement::VT_FREE_DRAW_STREAMLINE, None)}
  }
  #[inline]
  pub fn free_draw_easing(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_FREE_DRAW_EASING, None)}
  }
  #[inline]
  pub fn free_draw_start_cap(&self) -> Option<bool> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucElement::VT_FREE_DRAW_START_CAP, None)}
  }
  #[inline]
  pub fn free_draw_start_taper(&self) -> Option<f64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucElement::VT_FREE_DRAW_START_TAPER, None)}
  }
  #[inline]
  pub fn free_draw_start_easing(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_FREE_DRAW_START_EASING, None)}
  }
  #[inline]
  pub fn free_draw_end_cap(&self) -> Option<bool> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucElement::VT_FREE_DRAW_END_CAP, None)}
  }
  #[inline]
  pub fn free_draw_end_taper(&self) -> Option<f64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucElement::VT_FREE_DRAW_END_TAPER, None)}
  }
  #[inline]
  pub fn free_draw_end_easing(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_FREE_DRAW_END_EASING, None)}
  }
  #[inline]
  pub fn free_draw_svg_path(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_FREE_DRAW_SVG_PATH, None)}
  }
  #[inline]
  pub fn free_draw_size(&self) -> Option<f64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucElement::VT_FREE_DRAW_SIZE, None)}
  }
  #[inline]
  pub fn linear_element_path_overrides(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucPath<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucPath>>>>(DucElement::VT_LINEAR_ELEMENT_PATH_OVERRIDES, None)}
  }
  #[inline]
  pub fn description(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_DESCRIPTION, None)}
  }
  #[inline]
  pub fn no_plot(&self) -> Option<bool> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucElement::VT_NO_PLOT, None)}
  }
  #[inline]
  pub fn stack_like_labeling_color(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_STACK_LIKE_LABELING_COLOR, None)}
  }
  #[inline]
  pub fn stack_like_stroke_override(&self) -> Option<ElementStroke<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ElementStroke>>(DucElement::VT_STACK_LIKE_STROKE_OVERRIDE, None)}
  }
  #[inline]
  pub fn stack_like_background_override(&self) -> Option<ElementBackground<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ElementBackground>>(DucElement::VT_STACK_LIKE_BACKGROUND_OVERRIDE, None)}
  }
  #[inline]
  pub fn block_instance_block_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_BLOCK_INSTANCE_BLOCK_ID, None)}
  }
  #[inline]
  pub fn block_instance_element_overrides(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucBlockInstanceElementOverride<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucBlockInstanceElementOverride>>>>(DucElement::VT_BLOCK_INSTANCE_ELEMENT_OVERRIDES, None)}
  }
}

impl flatbuffers::Verifiable for DucElement<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, false)?
     .visit_field::<f32>("x_v2", Self::VT_X_V2, false)?
     .visit_field::<f32>("y_v2", Self::VT_Y_V2, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("scope", Self::VT_SCOPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("label", Self::VT_LABEL, false)?
     .visit_field::<bool>("is_visible", Self::VT_IS_VISIBLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("background_color_v3", Self::VT_BACKGROUND_COLOR_V3, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stroke_color_v3", Self::VT_STROKE_COLOR_V3, false)?
     .visit_field::<f32>("opacity", Self::VT_OPACITY, false)?
     .visit_field::<f32>("width_v2", Self::VT_WIDTH_V2, false)?
     .visit_field::<f32>("height_v2", Self::VT_HEIGHT_V2, false)?
     .visit_field::<f32>("angle_v2", Self::VT_ANGLE_V2, false)?
     .visit_field::<bool>("is_deleted", Self::VT_IS_DELETED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("group_ids", Self::VT_GROUP_IDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("frame_id", Self::VT_FRAME_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BoundElement>>>>("bound_elements", Self::VT_BOUND_ELEMENTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("link", Self::VT_LINK, false)?
     .visit_field::<bool>("locked", Self::VT_LOCKED, false)?
     .visit_field::<i32>("text_font_size_v2", Self::VT_TEXT_FONT_SIZE_V2, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("text_font_family", Self::VT_TEXT_FONT_FAMILY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("text_text", Self::VT_TEXT_TEXT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("text_container_id", Self::VT_TEXT_CONTAINER_ID, false)?
     .visit_field::<f32>("text_line_height_v2", Self::VT_TEXT_LINE_HEIGHT_V2, false)?
     .visit_field::<bool>("text_auto_resize", Self::VT_TEXT_AUTO_RESIZE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Point>>>>("linear_element_points", Self::VT_LINEAR_ELEMENT_POINTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Point>>("linear_element_last_committed_point", Self::VT_LINEAR_ELEMENT_LAST_COMMITTED_POINT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<PointBinding>>("linear_element_start_binding", Self::VT_LINEAR_ELEMENT_START_BINDING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<PointBinding>>("linear_element_end_binding", Self::VT_LINEAR_ELEMENT_END_BINDING, false)?
     .visit_field::<bool>("arrow_elbowed", Self::VT_ARROW_ELBOWED, false)?
     .visit_field::<bool>("free_draw_simulate_pressure", Self::VT_FREE_DRAW_SIMULATE_PRESSURE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("file_id", Self::VT_FILE_ID, false)?
     .visit_field::<IMAGE_STATUS>("image_status", Self::VT_IMAGE_STATUS, false)?
     .visit_field::<bool>("stack_like_is_collapsed", Self::VT_STACK_LIKE_IS_COLLAPSED, false)?
     .visit_field::<i8>("stroke_style_v3", Self::VT_STROKE_STYLE_V3, false)?
     .visit_field::<i8>("fill_style_v3", Self::VT_FILL_STYLE_V3, false)?
     .visit_field::<i8>("text_text_align", Self::VT_TEXT_TEXT_ALIGN, false)?
     .visit_field::<i8>("text_vertical_align", Self::VT_TEXT_VERTICAL_ALIGN, false)?
     .visit_field::<f64>("x", Self::VT_X, false)?
     .visit_field::<f64>("y", Self::VT_Y, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SimplePoint>>("image_scale", Self::VT_IMAGE_SCALE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("free_draw_pressures", Self::VT_FREE_DRAW_PRESSURES, false)?
     .visit_field::<f64>("stroke_width_v3", Self::VT_STROKE_WIDTH_V3, false)?
     .visit_field::<f64>("angle", Self::VT_ANGLE, false)?
     .visit_field::<f64>("roundness", Self::VT_ROUNDNESS, false)?
     .visit_field::<f64>("width", Self::VT_WIDTH, false)?
     .visit_field::<f64>("height", Self::VT_HEIGHT, false)?
     .visit_field::<f64>("text_font_size", Self::VT_TEXT_FONT_SIZE, false)?
     .visit_field::<f64>("text_line_height", Self::VT_TEXT_LINE_HEIGHT, false)?
     .visit_field::<i8>("blending", Self::VT_BLENDING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ElementBackground>>>>("background", Self::VT_BACKGROUND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ElementStroke>>>>("stroke", Self::VT_STROKE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ImageCrop>>("image_crop", Self::VT_IMAGE_CROP, false)?
     .visit_field::<bool>("stack_like_clip", Self::VT_STACK_LIKE_CLIP, false)?
     .visit_field::<i8>("subset", Self::VT_SUBSET, false)?
     .visit_field::<i32>("z_index", Self::VT_Z_INDEX, false)?
     .visit_field::<i32>("polygon_sides", Self::VT_POLYGON_SIDES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("table_column_order", Self::VT_TABLE_COLUMN_ORDER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("table_row_order", Self::VT_TABLE_ROW_ORDER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DucTableColumn>>>>("table_columns", Self::VT_TABLE_COLUMNS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DucTableRow>>>>("table_rows", Self::VT_TABLE_ROWS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DucTableCell>>>>("table_cells", Self::VT_TABLE_CELLS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucTableStyle>>("table_style", Self::VT_TABLE_STYLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("doc_content", Self::VT_DOC_CONTENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DucLine>>>>("linear_element_lines", Self::VT_LINEAR_ELEMENT_LINES, false)?
     .visit_field::<f64>("ellipse_ratio", Self::VT_ELLIPSE_RATIO, false)?
     .visit_field::<f64>("ellipse_start_angle", Self::VT_ELLIPSE_START_ANGLE, false)?
     .visit_field::<f64>("ellipse_end_angle", Self::VT_ELLIPSE_END_ANGLE, false)?
     .visit_field::<bool>("ellipse_show_aux_crosshair", Self::VT_ELLIPSE_SHOW_AUX_CROSSHAIR, false)?
     .visit_field::<f64>("free_draw_thinning", Self::VT_FREE_DRAW_THINNING, false)?
     .visit_field::<f64>("free_draw_smoothing", Self::VT_FREE_DRAW_SMOOTHING, false)?
     .visit_field::<f64>("free_draw_streamline", Self::VT_FREE_DRAW_STREAMLINE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("free_draw_easing", Self::VT_FREE_DRAW_EASING, false)?
     .visit_field::<bool>("free_draw_start_cap", Self::VT_FREE_DRAW_START_CAP, false)?
     .visit_field::<f64>("free_draw_start_taper", Self::VT_FREE_DRAW_START_TAPER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("free_draw_start_easing", Self::VT_FREE_DRAW_START_EASING, false)?
     .visit_field::<bool>("free_draw_end_cap", Self::VT_FREE_DRAW_END_CAP, false)?
     .visit_field::<f64>("free_draw_end_taper", Self::VT_FREE_DRAW_END_TAPER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("free_draw_end_easing", Self::VT_FREE_DRAW_END_EASING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("free_draw_svg_path", Self::VT_FREE_DRAW_SVG_PATH, false)?
     .visit_field::<f64>("free_draw_size", Self::VT_FREE_DRAW_SIZE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DucPath>>>>("linear_element_path_overrides", Self::VT_LINEAR_ELEMENT_PATH_OVERRIDES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("description", Self::VT_DESCRIPTION, false)?
     .visit_field::<bool>("no_plot", Self::VT_NO_PLOT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stack_like_labeling_color", Self::VT_STACK_LIKE_LABELING_COLOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ElementStroke>>("stack_like_stroke_override", Self::VT_STACK_LIKE_STROKE_OVERRIDE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ElementBackground>>("stack_like_background_override", Self::VT_STACK_LIKE_BACKGROUND_OVERRIDE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("block_instance_block_id", Self::VT_BLOCK_INSTANCE_BLOCK_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DucBlockInstanceElementOverride>>>>("block_instance_element_overrides", Self::VT_BLOCK_INSTANCE_ELEMENT_OVERRIDES, false)?
     .finish();
    Ok(())
  }
}
pub struct DucElementArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
    pub x_v2: Option<f32>,
    pub y_v2: Option<f32>,
    pub scope: Option<flatbuffers::WIPOffset<&'a str>>,
    pub label: Option<flatbuffers::WIPOffset<&'a str>>,
    pub is_visible: bool,
    pub background_color_v3: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stroke_color_v3: Option<flatbuffers::WIPOffset<&'a str>>,
    pub opacity: f32,
    pub width_v2: Option<f32>,
    pub height_v2: Option<f32>,
    pub angle_v2: Option<f32>,
    pub is_deleted: bool,
    pub group_ids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub frame_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bound_elements: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BoundElement<'a>>>>>,
    pub link: Option<flatbuffers::WIPOffset<&'a str>>,
    pub locked: bool,
    pub text_font_size_v2: Option<i32>,
    pub text_font_family: Option<flatbuffers::WIPOffset<&'a str>>,
    pub text_text: Option<flatbuffers::WIPOffset<&'a str>>,
    pub text_container_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub text_line_height_v2: Option<f32>,
    pub text_auto_resize: Option<bool>,
    pub linear_element_points: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Point<'a>>>>>,
    pub linear_element_last_committed_point: Option<flatbuffers::WIPOffset<Point<'a>>>,
    pub linear_element_start_binding: Option<flatbuffers::WIPOffset<PointBinding<'a>>>,
    pub linear_element_end_binding: Option<flatbuffers::WIPOffset<PointBinding<'a>>>,
    pub arrow_elbowed: Option<bool>,
    pub free_draw_simulate_pressure: Option<bool>,
    pub file_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub image_status: Option<IMAGE_STATUS>,
    pub stack_like_is_collapsed: Option<bool>,
    pub stroke_style_v3: i8,
    pub fill_style_v3: i8,
    pub text_text_align: Option<i8>,
    pub text_vertical_align: i8,
    pub x: f64,
    pub y: f64,
    pub image_scale: Option<flatbuffers::WIPOffset<SimplePoint<'a>>>,
    pub free_draw_pressures: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub stroke_width_v3: f64,
    pub angle: f64,
    pub roundness: f64,
    pub width: f64,
    pub height: f64,
    pub text_font_size: Option<f64>,
    pub text_line_height: Option<f64>,
    pub blending: Option<i8>,
    pub background: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ElementBackground<'a>>>>>,
    pub stroke: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ElementStroke<'a>>>>>,
    pub image_crop: Option<flatbuffers::WIPOffset<ImageCrop<'a>>>,
    pub stack_like_clip: Option<bool>,
    pub subset: Option<i8>,
    pub z_index: i32,
    pub polygon_sides: Option<i32>,
    pub table_column_order: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub table_row_order: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub table_columns: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucTableColumn<'a>>>>>,
    pub table_rows: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucTableRow<'a>>>>>,
    pub table_cells: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucTableCell<'a>>>>>,
    pub table_style: Option<flatbuffers::WIPOffset<DucTableStyle<'a>>>,
    pub doc_content: Option<flatbuffers::WIPOffset<&'a str>>,
    pub linear_element_lines: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucLine<'a>>>>>,
    pub ellipse_ratio: Option<f64>,
    pub ellipse_start_angle: Option<f64>,
    pub ellipse_end_angle: Option<f64>,
    pub ellipse_show_aux_crosshair: Option<bool>,
    pub free_draw_thinning: Option<f64>,
    pub free_draw_smoothing: Option<f64>,
    pub free_draw_streamline: Option<f64>,
    pub free_draw_easing: Option<flatbuffers::WIPOffset<&'a str>>,
    pub free_draw_start_cap: Option<bool>,
    pub free_draw_start_taper: Option<f64>,
    pub free_draw_start_easing: Option<flatbuffers::WIPOffset<&'a str>>,
    pub free_draw_end_cap: Option<bool>,
    pub free_draw_end_taper: Option<f64>,
    pub free_draw_end_easing: Option<flatbuffers::WIPOffset<&'a str>>,
    pub free_draw_svg_path: Option<flatbuffers::WIPOffset<&'a str>>,
    pub free_draw_size: Option<f64>,
    pub linear_element_path_overrides: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucPath<'a>>>>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub no_plot: Option<bool>,
    pub stack_like_labeling_color: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stack_like_stroke_override: Option<flatbuffers::WIPOffset<ElementStroke<'a>>>,
    pub stack_like_background_override: Option<flatbuffers::WIPOffset<ElementBackground<'a>>>,
    pub block_instance_block_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub block_instance_element_overrides: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucBlockInstanceElementOverride<'a>>>>>,
}
impl<'a> Default for DucElementArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucElementArgs {
      id: None,
      type_: None,
      x_v2: None,
      y_v2: None,
      scope: None,
      label: None,
      is_visible: false,
      background_color_v3: None,
      stroke_color_v3: None,
      opacity: 0.0,
      width_v2: None,
      height_v2: None,
      angle_v2: None,
      is_deleted: false,
      group_ids: None,
      frame_id: None,
      bound_elements: None,
      link: None,
      locked: false,
      text_font_size_v2: None,
      text_font_family: None,
      text_text: None,
      text_container_id: None,
      text_line_height_v2: None,
      text_auto_resize: None,
      linear_element_points: None,
      linear_element_last_committed_point: None,
      linear_element_start_binding: None,
      linear_element_end_binding: None,
      arrow_elbowed: None,
      free_draw_simulate_pressure: None,
      file_id: None,
      image_status: None,
      stack_like_is_collapsed: None,
      stroke_style_v3: 0,
      fill_style_v3: 0,
      text_text_align: None,
      text_vertical_align: 0,
      x: 0.0,
      y: 0.0,
      image_scale: None,
      free_draw_pressures: None,
      stroke_width_v3: 0.0,
      angle: 0.0,
      roundness: 0.0,
      width: 0.0,
      height: 0.0,
      text_font_size: None,
      text_line_height: None,
      blending: None,
      background: None,
      stroke: None,
      image_crop: None,
      stack_like_clip: None,
      subset: None,
      z_index: 0,
      polygon_sides: None,
      table_column_order: None,
      table_row_order: None,
      table_columns: None,
      table_rows: None,
      table_cells: None,
      table_style: None,
      doc_content: None,
      linear_element_lines: None,
      ellipse_ratio: None,
      ellipse_start_angle: None,
      ellipse_end_angle: None,
      ellipse_show_aux_crosshair: None,
      free_draw_thinning: None,
      free_draw_smoothing: None,
      free_draw_streamline: None,
      free_draw_easing: None,
      free_draw_start_cap: None,
      free_draw_start_taper: None,
      free_draw_start_easing: None,
      free_draw_end_cap: None,
      free_draw_end_taper: None,
      free_draw_end_easing: None,
      free_draw_svg_path: None,
      free_draw_size: None,
      linear_element_path_overrides: None,
      description: None,
      no_plot: None,
      stack_like_labeling_color: None,
      stack_like_stroke_override: None,
      stack_like_background_override: None,
      block_instance_block_id: None,
      block_instance_element_overrides: None,
    }
  }
}

pub struct DucElementBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucElementBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_ID, id);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_x_v2(&mut self, x_v2: f32) {
    self.fbb_.push_slot_always::<f32>(DucElement::VT_X_V2, x_v2);
  }
  #[inline]
  pub fn add_y_v2(&mut self, y_v2: f32) {
    self.fbb_.push_slot_always::<f32>(DucElement::VT_Y_V2, y_v2);
  }
  #[inline]
  pub fn add_scope(&mut self, scope: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_SCOPE, scope);
  }
  #[inline]
  pub fn add_label(&mut self, label: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_LABEL, label);
  }
  #[inline]
  pub fn add_is_visible(&mut self, is_visible: bool) {
    self.fbb_.push_slot::<bool>(DucElement::VT_IS_VISIBLE, is_visible, false);
  }
  #[inline]
  pub fn add_background_color_v3(&mut self, background_color_v3: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_BACKGROUND_COLOR_V3, background_color_v3);
  }
  #[inline]
  pub fn add_stroke_color_v3(&mut self, stroke_color_v3: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_STROKE_COLOR_V3, stroke_color_v3);
  }
  #[inline]
  pub fn add_opacity(&mut self, opacity: f32) {
    self.fbb_.push_slot::<f32>(DucElement::VT_OPACITY, opacity, 0.0);
  }
  #[inline]
  pub fn add_width_v2(&mut self, width_v2: f32) {
    self.fbb_.push_slot_always::<f32>(DucElement::VT_WIDTH_V2, width_v2);
  }
  #[inline]
  pub fn add_height_v2(&mut self, height_v2: f32) {
    self.fbb_.push_slot_always::<f32>(DucElement::VT_HEIGHT_V2, height_v2);
  }
  #[inline]
  pub fn add_angle_v2(&mut self, angle_v2: f32) {
    self.fbb_.push_slot_always::<f32>(DucElement::VT_ANGLE_V2, angle_v2);
  }
  #[inline]
  pub fn add_is_deleted(&mut self, is_deleted: bool) {
    self.fbb_.push_slot::<bool>(DucElement::VT_IS_DELETED, is_deleted, false);
  }
  #[inline]
  pub fn add_group_ids(&mut self, group_ids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_GROUP_IDS, group_ids);
  }
  #[inline]
  pub fn add_frame_id(&mut self, frame_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_FRAME_ID, frame_id);
  }
  #[inline]
  pub fn add_bound_elements(&mut self, bound_elements: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BoundElement<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_BOUND_ELEMENTS, bound_elements);
  }
  #[inline]
  pub fn add_link(&mut self, link: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_LINK, link);
  }
  #[inline]
  pub fn add_locked(&mut self, locked: bool) {
    self.fbb_.push_slot::<bool>(DucElement::VT_LOCKED, locked, false);
  }
  #[inline]
  pub fn add_text_font_size_v2(&mut self, text_font_size_v2: i32) {
    self.fbb_.push_slot_always::<i32>(DucElement::VT_TEXT_FONT_SIZE_V2, text_font_size_v2);
  }
  #[inline]
  pub fn add_text_font_family(&mut self, text_font_family: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_TEXT_FONT_FAMILY, text_font_family);
  }
  #[inline]
  pub fn add_text_text(&mut self, text_text: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_TEXT_TEXT, text_text);
  }
  #[inline]
  pub fn add_text_container_id(&mut self, text_container_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_TEXT_CONTAINER_ID, text_container_id);
  }
  #[inline]
  pub fn add_text_line_height_v2(&mut self, text_line_height_v2: f32) {
    self.fbb_.push_slot_always::<f32>(DucElement::VT_TEXT_LINE_HEIGHT_V2, text_line_height_v2);
  }
  #[inline]
  pub fn add_text_auto_resize(&mut self, text_auto_resize: bool) {
    self.fbb_.push_slot_always::<bool>(DucElement::VT_TEXT_AUTO_RESIZE, text_auto_resize);
  }
  #[inline]
  pub fn add_linear_element_points(&mut self, linear_element_points: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Point<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_LINEAR_ELEMENT_POINTS, linear_element_points);
  }
  #[inline]
  pub fn add_linear_element_last_committed_point(&mut self, linear_element_last_committed_point: flatbuffers::WIPOffset<Point<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Point>>(DucElement::VT_LINEAR_ELEMENT_LAST_COMMITTED_POINT, linear_element_last_committed_point);
  }
  #[inline]
  pub fn add_linear_element_start_binding(&mut self, linear_element_start_binding: flatbuffers::WIPOffset<PointBinding<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PointBinding>>(DucElement::VT_LINEAR_ELEMENT_START_BINDING, linear_element_start_binding);
  }
  #[inline]
  pub fn add_linear_element_end_binding(&mut self, linear_element_end_binding: flatbuffers::WIPOffset<PointBinding<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PointBinding>>(DucElement::VT_LINEAR_ELEMENT_END_BINDING, linear_element_end_binding);
  }
  #[inline]
  pub fn add_arrow_elbowed(&mut self, arrow_elbowed: bool) {
    self.fbb_.push_slot_always::<bool>(DucElement::VT_ARROW_ELBOWED, arrow_elbowed);
  }
  #[inline]
  pub fn add_free_draw_simulate_pressure(&mut self, free_draw_simulate_pressure: bool) {
    self.fbb_.push_slot_always::<bool>(DucElement::VT_FREE_DRAW_SIMULATE_PRESSURE, free_draw_simulate_pressure);
  }
  #[inline]
  pub fn add_file_id(&mut self, file_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_FILE_ID, file_id);
  }
  #[inline]
  pub fn add_image_status(&mut self, image_status: IMAGE_STATUS) {
    self.fbb_.push_slot_always::<IMAGE_STATUS>(DucElement::VT_IMAGE_STATUS, image_status);
  }
  #[inline]
  pub fn add_stack_like_is_collapsed(&mut self, stack_like_is_collapsed: bool) {
    self.fbb_.push_slot_always::<bool>(DucElement::VT_STACK_LIKE_IS_COLLAPSED, stack_like_is_collapsed);
  }
  #[inline]
  pub fn add_stroke_style_v3(&mut self, stroke_style_v3: i8) {
    self.fbb_.push_slot::<i8>(DucElement::VT_STROKE_STYLE_V3, stroke_style_v3, 0);
  }
  #[inline]
  pub fn add_fill_style_v3(&mut self, fill_style_v3: i8) {
    self.fbb_.push_slot::<i8>(DucElement::VT_FILL_STYLE_V3, fill_style_v3, 0);
  }
  #[inline]
  pub fn add_text_text_align(&mut self, text_text_align: i8) {
    self.fbb_.push_slot_always::<i8>(DucElement::VT_TEXT_TEXT_ALIGN, text_text_align);
  }
  #[inline]
  pub fn add_text_vertical_align(&mut self, text_vertical_align: i8) {
    self.fbb_.push_slot::<i8>(DucElement::VT_TEXT_VERTICAL_ALIGN, text_vertical_align, 0);
  }
  #[inline]
  pub fn add_x(&mut self, x: f64) {
    self.fbb_.push_slot::<f64>(DucElement::VT_X, x, 0.0);
  }
  #[inline]
  pub fn add_y(&mut self, y: f64) {
    self.fbb_.push_slot::<f64>(DucElement::VT_Y, y, 0.0);
  }
  #[inline]
  pub fn add_image_scale(&mut self, image_scale: flatbuffers::WIPOffset<SimplePoint<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SimplePoint>>(DucElement::VT_IMAGE_SCALE, image_scale);
  }
  #[inline]
  pub fn add_free_draw_pressures(&mut self, free_draw_pressures: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_FREE_DRAW_PRESSURES, free_draw_pressures);
  }
  #[inline]
  pub fn add_stroke_width_v3(&mut self, stroke_width_v3: f64) {
    self.fbb_.push_slot::<f64>(DucElement::VT_STROKE_WIDTH_V3, stroke_width_v3, 0.0);
  }
  #[inline]
  pub fn add_angle(&mut self, angle: f64) {
    self.fbb_.push_slot::<f64>(DucElement::VT_ANGLE, angle, 0.0);
  }
  #[inline]
  pub fn add_roundness(&mut self, roundness: f64) {
    self.fbb_.push_slot::<f64>(DucElement::VT_ROUNDNESS, roundness, 0.0);
  }
  #[inline]
  pub fn add_width(&mut self, width: f64) {
    self.fbb_.push_slot::<f64>(DucElement::VT_WIDTH, width, 0.0);
  }
  #[inline]
  pub fn add_height(&mut self, height: f64) {
    self.fbb_.push_slot::<f64>(DucElement::VT_HEIGHT, height, 0.0);
  }
  #[inline]
  pub fn add_text_font_size(&mut self, text_font_size: f64) {
    self.fbb_.push_slot_always::<f64>(DucElement::VT_TEXT_FONT_SIZE, text_font_size);
  }
  #[inline]
  pub fn add_text_line_height(&mut self, text_line_height: f64) {
    self.fbb_.push_slot_always::<f64>(DucElement::VT_TEXT_LINE_HEIGHT, text_line_height);
  }
  #[inline]
  pub fn add_blending(&mut self, blending: i8) {
    self.fbb_.push_slot_always::<i8>(DucElement::VT_BLENDING, blending);
  }
  #[inline]
  pub fn add_background(&mut self, background: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ElementBackground<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_BACKGROUND, background);
  }
  #[inline]
  pub fn add_stroke(&mut self, stroke: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ElementStroke<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_STROKE, stroke);
  }
  #[inline]
  pub fn add_image_crop(&mut self, image_crop: flatbuffers::WIPOffset<ImageCrop<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ImageCrop>>(DucElement::VT_IMAGE_CROP, image_crop);
  }
  #[inline]
  pub fn add_stack_like_clip(&mut self, stack_like_clip: bool) {
    self.fbb_.push_slot_always::<bool>(DucElement::VT_STACK_LIKE_CLIP, stack_like_clip);
  }
  #[inline]
  pub fn add_subset(&mut self, subset: i8) {
    self.fbb_.push_slot_always::<i8>(DucElement::VT_SUBSET, subset);
  }
  #[inline]
  pub fn add_z_index(&mut self, z_index: i32) {
    self.fbb_.push_slot::<i32>(DucElement::VT_Z_INDEX, z_index, 0);
  }
  #[inline]
  pub fn add_polygon_sides(&mut self, polygon_sides: i32) {
    self.fbb_.push_slot_always::<i32>(DucElement::VT_POLYGON_SIDES, polygon_sides);
  }
  #[inline]
  pub fn add_table_column_order(&mut self, table_column_order: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_TABLE_COLUMN_ORDER, table_column_order);
  }
  #[inline]
  pub fn add_table_row_order(&mut self, table_row_order: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_TABLE_ROW_ORDER, table_row_order);
  }
  #[inline]
  pub fn add_table_columns(&mut self, table_columns: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DucTableColumn<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_TABLE_COLUMNS, table_columns);
  }
  #[inline]
  pub fn add_table_rows(&mut self, table_rows: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DucTableRow<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_TABLE_ROWS, table_rows);
  }
  #[inline]
  pub fn add_table_cells(&mut self, table_cells: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DucTableCell<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_TABLE_CELLS, table_cells);
  }
  #[inline]
  pub fn add_table_style(&mut self, table_style: flatbuffers::WIPOffset<DucTableStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucTableStyle>>(DucElement::VT_TABLE_STYLE, table_style);
  }
  #[inline]
  pub fn add_doc_content(&mut self, doc_content: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_DOC_CONTENT, doc_content);
  }
  #[inline]
  pub fn add_linear_element_lines(&mut self, linear_element_lines: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DucLine<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_LINEAR_ELEMENT_LINES, linear_element_lines);
  }
  #[inline]
  pub fn add_ellipse_ratio(&mut self, ellipse_ratio: f64) {
    self.fbb_.push_slot_always::<f64>(DucElement::VT_ELLIPSE_RATIO, ellipse_ratio);
  }
  #[inline]
  pub fn add_ellipse_start_angle(&mut self, ellipse_start_angle: f64) {
    self.fbb_.push_slot_always::<f64>(DucElement::VT_ELLIPSE_START_ANGLE, ellipse_start_angle);
  }
  #[inline]
  pub fn add_ellipse_end_angle(&mut self, ellipse_end_angle: f64) {
    self.fbb_.push_slot_always::<f64>(DucElement::VT_ELLIPSE_END_ANGLE, ellipse_end_angle);
  }
  #[inline]
  pub fn add_ellipse_show_aux_crosshair(&mut self, ellipse_show_aux_crosshair: bool) {
    self.fbb_.push_slot_always::<bool>(DucElement::VT_ELLIPSE_SHOW_AUX_CROSSHAIR, ellipse_show_aux_crosshair);
  }
  #[inline]
  pub fn add_free_draw_thinning(&mut self, free_draw_thinning: f64) {
    self.fbb_.push_slot_always::<f64>(DucElement::VT_FREE_DRAW_THINNING, free_draw_thinning);
  }
  #[inline]
  pub fn add_free_draw_smoothing(&mut self, free_draw_smoothing: f64) {
    self.fbb_.push_slot_always::<f64>(DucElement::VT_FREE_DRAW_SMOOTHING, free_draw_smoothing);
  }
  #[inline]
  pub fn add_free_draw_streamline(&mut self, free_draw_streamline: f64) {
    self.fbb_.push_slot_always::<f64>(DucElement::VT_FREE_DRAW_STREAMLINE, free_draw_streamline);
  }
  #[inline]
  pub fn add_free_draw_easing(&mut self, free_draw_easing: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_FREE_DRAW_EASING, free_draw_easing);
  }
  #[inline]
  pub fn add_free_draw_start_cap(&mut self, free_draw_start_cap: bool) {
    self.fbb_.push_slot_always::<bool>(DucElement::VT_FREE_DRAW_START_CAP, free_draw_start_cap);
  }
  #[inline]
  pub fn add_free_draw_start_taper(&mut self, free_draw_start_taper: f64) {
    self.fbb_.push_slot_always::<f64>(DucElement::VT_FREE_DRAW_START_TAPER, free_draw_start_taper);
  }
  #[inline]
  pub fn add_free_draw_start_easing(&mut self, free_draw_start_easing: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_FREE_DRAW_START_EASING, free_draw_start_easing);
  }
  #[inline]
  pub fn add_free_draw_end_cap(&mut self, free_draw_end_cap: bool) {
    self.fbb_.push_slot_always::<bool>(DucElement::VT_FREE_DRAW_END_CAP, free_draw_end_cap);
  }
  #[inline]
  pub fn add_free_draw_end_taper(&mut self, free_draw_end_taper: f64) {
    self.fbb_.push_slot_always::<f64>(DucElement::VT_FREE_DRAW_END_TAPER, free_draw_end_taper);
  }
  #[inline]
  pub fn add_free_draw_end_easing(&mut self, free_draw_end_easing: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_FREE_DRAW_END_EASING, free_draw_end_easing);
  }
  #[inline]
  pub fn add_free_draw_svg_path(&mut self, free_draw_svg_path: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_FREE_DRAW_SVG_PATH, free_draw_svg_path);
  }
  #[inline]
  pub fn add_free_draw_size(&mut self, free_draw_size: f64) {
    self.fbb_.push_slot_always::<f64>(DucElement::VT_FREE_DRAW_SIZE, free_draw_size);
  }
  #[inline]
  pub fn add_linear_element_path_overrides(&mut self, linear_element_path_overrides: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DucPath<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_LINEAR_ELEMENT_PATH_OVERRIDES, linear_element_path_overrides);
  }
  #[inline]
  pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_DESCRIPTION, description);
  }
  #[inline]
  pub fn add_no_plot(&mut self, no_plot: bool) {
    self.fbb_.push_slot_always::<bool>(DucElement::VT_NO_PLOT, no_plot);
  }
  #[inline]
  pub fn add_stack_like_labeling_color(&mut self, stack_like_labeling_color: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_STACK_LIKE_LABELING_COLOR, stack_like_labeling_color);
  }
  #[inline]
  pub fn add_stack_like_stroke_override(&mut self, stack_like_stroke_override: flatbuffers::WIPOffset<ElementStroke<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ElementStroke>>(DucElement::VT_STACK_LIKE_STROKE_OVERRIDE, stack_like_stroke_override);
  }
  #[inline]
  pub fn add_stack_like_background_override(&mut self, stack_like_background_override: flatbuffers::WIPOffset<ElementBackground<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ElementBackground>>(DucElement::VT_STACK_LIKE_BACKGROUND_OVERRIDE, stack_like_background_override);
  }
  #[inline]
  pub fn add_block_instance_block_id(&mut self, block_instance_block_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_BLOCK_INSTANCE_BLOCK_ID, block_instance_block_id);
  }
  #[inline]
  pub fn add_block_instance_element_overrides(&mut self, block_instance_element_overrides: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DucBlockInstanceElementOverride<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_BLOCK_INSTANCE_ELEMENT_OVERRIDES, block_instance_element_overrides);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucElementBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucElementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucElement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucElement<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucElement");
      ds.field("id", &self.id());
      ds.field("type_", &self.type_());
      ds.field("x_v2", &self.x_v2());
      ds.field("y_v2", &self.y_v2());
      ds.field("scope", &self.scope());
      ds.field("label", &self.label());
      ds.field("is_visible", &self.is_visible());
      ds.field("background_color_v3", &self.background_color_v3());
      ds.field("stroke_color_v3", &self.stroke_color_v3());
      ds.field("opacity", &self.opacity());
      ds.field("width_v2", &self.width_v2());
      ds.field("height_v2", &self.height_v2());
      ds.field("angle_v2", &self.angle_v2());
      ds.field("is_deleted", &self.is_deleted());
      ds.field("group_ids", &self.group_ids());
      ds.field("frame_id", &self.frame_id());
      ds.field("bound_elements", &self.bound_elements());
      ds.field("link", &self.link());
      ds.field("locked", &self.locked());
      ds.field("text_font_size_v2", &self.text_font_size_v2());
      ds.field("text_font_family", &self.text_font_family());
      ds.field("text_text", &self.text_text());
      ds.field("text_container_id", &self.text_container_id());
      ds.field("text_line_height_v2", &self.text_line_height_v2());
      ds.field("text_auto_resize", &self.text_auto_resize());
      ds.field("linear_element_points", &self.linear_element_points());
      ds.field("linear_element_last_committed_point", &self.linear_element_last_committed_point());
      ds.field("linear_element_start_binding", &self.linear_element_start_binding());
      ds.field("linear_element_end_binding", &self.linear_element_end_binding());
      ds.field("arrow_elbowed", &self.arrow_elbowed());
      ds.field("free_draw_simulate_pressure", &self.free_draw_simulate_pressure());
      ds.field("file_id", &self.file_id());
      ds.field("image_status", &self.image_status());
      ds.field("stack_like_is_collapsed", &self.stack_like_is_collapsed());
      ds.field("stroke_style_v3", &self.stroke_style_v3());
      ds.field("fill_style_v3", &self.fill_style_v3());
      ds.field("text_text_align", &self.text_text_align());
      ds.field("text_vertical_align", &self.text_vertical_align());
      ds.field("x", &self.x());
      ds.field("y", &self.y());
      ds.field("image_scale", &self.image_scale());
      ds.field("free_draw_pressures", &self.free_draw_pressures());
      ds.field("stroke_width_v3", &self.stroke_width_v3());
      ds.field("angle", &self.angle());
      ds.field("roundness", &self.roundness());
      ds.field("width", &self.width());
      ds.field("height", &self.height());
      ds.field("text_font_size", &self.text_font_size());
      ds.field("text_line_height", &self.text_line_height());
      ds.field("blending", &self.blending());
      ds.field("background", &self.background());
      ds.field("stroke", &self.stroke());
      ds.field("image_crop", &self.image_crop());
      ds.field("stack_like_clip", &self.stack_like_clip());
      ds.field("subset", &self.subset());
      ds.field("z_index", &self.z_index());
      ds.field("polygon_sides", &self.polygon_sides());
      ds.field("table_column_order", &self.table_column_order());
      ds.field("table_row_order", &self.table_row_order());
      ds.field("table_columns", &self.table_columns());
      ds.field("table_rows", &self.table_rows());
      ds.field("table_cells", &self.table_cells());
      ds.field("table_style", &self.table_style());
      ds.field("doc_content", &self.doc_content());
      ds.field("linear_element_lines", &self.linear_element_lines());
      ds.field("ellipse_ratio", &self.ellipse_ratio());
      ds.field("ellipse_start_angle", &self.ellipse_start_angle());
      ds.field("ellipse_end_angle", &self.ellipse_end_angle());
      ds.field("ellipse_show_aux_crosshair", &self.ellipse_show_aux_crosshair());
      ds.field("free_draw_thinning", &self.free_draw_thinning());
      ds.field("free_draw_smoothing", &self.free_draw_smoothing());
      ds.field("free_draw_streamline", &self.free_draw_streamline());
      ds.field("free_draw_easing", &self.free_draw_easing());
      ds.field("free_draw_start_cap", &self.free_draw_start_cap());
      ds.field("free_draw_start_taper", &self.free_draw_start_taper());
      ds.field("free_draw_start_easing", &self.free_draw_start_easing());
      ds.field("free_draw_end_cap", &self.free_draw_end_cap());
      ds.field("free_draw_end_taper", &self.free_draw_end_taper());
      ds.field("free_draw_end_easing", &self.free_draw_end_easing());
      ds.field("free_draw_svg_path", &self.free_draw_svg_path());
      ds.field("free_draw_size", &self.free_draw_size());
      ds.field("linear_element_path_overrides", &self.linear_element_path_overrides());
      ds.field("description", &self.description());
      ds.field("no_plot", &self.no_plot());
      ds.field("stack_like_labeling_color", &self.stack_like_labeling_color());
      ds.field("stack_like_stroke_override", &self.stack_like_stroke_override());
      ds.field("stack_like_background_override", &self.stack_like_background_override());
      ds.field("block_instance_block_id", &self.block_instance_block_id());
      ds.field("block_instance_element_overrides", &self.block_instance_element_overrides());
      ds.finish()
  }
}
pub enum BoundElementOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BoundElement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BoundElement<'a> {
  type Inner = BoundElement<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BoundElement<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BoundElement { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BoundElementArgs<'args>
  ) -> flatbuffers::WIPOffset<BoundElement<'bldr>> {
    let mut builder = BoundElementBuilder::new(_fbb);
    if let Some(x) = args.type_ { builder.add_type_(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BoundElement::VT_ID, None)}
  }
  #[inline]
  pub fn type_(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BoundElement::VT_TYPE_, None)}
  }
}

impl flatbuffers::Verifiable for BoundElement<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, false)?
     .finish();
    Ok(())
  }
}
pub struct BoundElementArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for BoundElementArgs<'a> {
  #[inline]
  fn default() -> Self {
    BoundElementArgs {
      id: None,
      type_: None,
    }
  }
}

pub struct BoundElementBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BoundElementBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BoundElement::VT_ID, id);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BoundElement::VT_TYPE_, type_);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BoundElementBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BoundElementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BoundElement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BoundElement<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BoundElement");
      ds.field("id", &self.id());
      ds.field("type_", &self.type_());
      ds.finish()
  }
}
pub enum SegmentMidpointStateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SegmentMidpointState<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SegmentMidpointState<'a> {
  type Inner = SegmentMidpointState<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SegmentMidpointState<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;
  pub const VT_INDEX: flatbuffers::VOffsetT = 6;
  pub const VT_ADDED: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SegmentMidpointState { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SegmentMidpointStateArgs<'args>
  ) -> flatbuffers::WIPOffset<SegmentMidpointState<'bldr>> {
    let mut builder = SegmentMidpointStateBuilder::new(_fbb);
    builder.add_index(args.index);
    if let Some(x) = args.value { builder.add_value(x); }
    builder.add_added(args.added);
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> Option<Point<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Point>>(SegmentMidpointState::VT_VALUE, None)}
  }
  #[inline]
  pub fn index(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SegmentMidpointState::VT_INDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn added(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SegmentMidpointState::VT_ADDED, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for SegmentMidpointState<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Point>>("value", Self::VT_VALUE, false)?
     .visit_field::<i32>("index", Self::VT_INDEX, false)?
     .visit_field::<bool>("added", Self::VT_ADDED, false)?
     .finish();
    Ok(())
  }
}
pub struct SegmentMidpointStateArgs<'a> {
    pub value: Option<flatbuffers::WIPOffset<Point<'a>>>,
    pub index: i32,
    pub added: bool,
}
impl<'a> Default for SegmentMidpointStateArgs<'a> {
  #[inline]
  fn default() -> Self {
    SegmentMidpointStateArgs {
      value: None,
      index: 0,
      added: false,
    }
  }
}

pub struct SegmentMidpointStateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SegmentMidpointStateBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<Point<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Point>>(SegmentMidpointState::VT_VALUE, value);
  }
  #[inline]
  pub fn add_index(&mut self, index: i32) {
    self.fbb_.push_slot::<i32>(SegmentMidpointState::VT_INDEX, index, 0);
  }
  #[inline]
  pub fn add_added(&mut self, added: bool) {
    self.fbb_.push_slot::<bool>(SegmentMidpointState::VT_ADDED, added, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SegmentMidpointStateBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SegmentMidpointStateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SegmentMidpointState<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SegmentMidpointState<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SegmentMidpointState");
      ds.field("value", &self.value());
      ds.field("index", &self.index());
      ds.field("added", &self.added());
      ds.finish()
  }
}
pub enum PointerDownStateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PointerDownState<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PointerDownState<'a> {
  type Inner = PointerDownState<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PointerDownState<'a> {
  pub const VT_PREV_SELECTED_POINTS_INDICES: flatbuffers::VOffsetT = 4;
  pub const VT_LAST_CLICKED_POINT: flatbuffers::VOffsetT = 6;
  pub const VT_LAST_CLICKED_IS_END_POINT: flatbuffers::VOffsetT = 8;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 10;
  pub const VT_SEGMENT_MIDPOINT: flatbuffers::VOffsetT = 12;
  pub const VT_HANDLE_TYPE: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PointerDownState { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PointerDownStateArgs<'args>
  ) -> flatbuffers::WIPOffset<PointerDownState<'bldr>> {
    let mut builder = PointerDownStateBuilder::new(_fbb);
    if let Some(x) = args.segment_midpoint { builder.add_segment_midpoint(x); }
    if let Some(x) = args.origin { builder.add_origin(x); }
    builder.add_last_clicked_point(args.last_clicked_point);
    if let Some(x) = args.prev_selected_points_indices { builder.add_prev_selected_points_indices(x); }
    if let Some(x) = args.handle_type { builder.add_handle_type(x); }
    builder.add_last_clicked_is_end_point(args.last_clicked_is_end_point);
    builder.finish()
  }


  #[inline]
  pub fn prev_selected_points_indices(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(PointerDownState::VT_PREV_SELECTED_POINTS_INDICES, None)}
  }
  #[inline]
  pub fn last_clicked_point(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PointerDownState::VT_LAST_CLICKED_POINT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn last_clicked_is_end_point(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(PointerDownState::VT_LAST_CLICKED_IS_END_POINT, Some(false)).unwrap()}
  }
  #[inline]
  pub fn origin(&self) -> Option<SimplePoint<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SimplePoint>>(PointerDownState::VT_ORIGIN, None)}
  }
  #[inline]
  pub fn segment_midpoint(&self) -> Option<SegmentMidpointState<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SegmentMidpointState>>(PointerDownState::VT_SEGMENT_MIDPOINT, None)}
  }
  #[inline]
  pub fn handle_type(&self) -> Option<i8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(PointerDownState::VT_HANDLE_TYPE, None)}
  }
}

impl flatbuffers::Verifiable for PointerDownState<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("prev_selected_points_indices", Self::VT_PREV_SELECTED_POINTS_INDICES, false)?
     .visit_field::<i32>("last_clicked_point", Self::VT_LAST_CLICKED_POINT, false)?
     .visit_field::<bool>("last_clicked_is_end_point", Self::VT_LAST_CLICKED_IS_END_POINT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SimplePoint>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SegmentMidpointState>>("segment_midpoint", Self::VT_SEGMENT_MIDPOINT, false)?
     .visit_field::<i8>("handle_type", Self::VT_HANDLE_TYPE, false)?
     .finish();
    Ok(())
  }
}
pub struct PointerDownStateArgs<'a> {
    pub prev_selected_points_indices: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub last_clicked_point: i32,
    pub last_clicked_is_end_point: bool,
    pub origin: Option<flatbuffers::WIPOffset<SimplePoint<'a>>>,
    pub segment_midpoint: Option<flatbuffers::WIPOffset<SegmentMidpointState<'a>>>,
    pub handle_type: Option<i8>,
}
impl<'a> Default for PointerDownStateArgs<'a> {
  #[inline]
  fn default() -> Self {
    PointerDownStateArgs {
      prev_selected_points_indices: None,
      last_clicked_point: 0,
      last_clicked_is_end_point: false,
      origin: None,
      segment_midpoint: None,
      handle_type: None,
    }
  }
}

pub struct PointerDownStateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PointerDownStateBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_prev_selected_points_indices(&mut self, prev_selected_points_indices: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PointerDownState::VT_PREV_SELECTED_POINTS_INDICES, prev_selected_points_indices);
  }
  #[inline]
  pub fn add_last_clicked_point(&mut self, last_clicked_point: i32) {
    self.fbb_.push_slot::<i32>(PointerDownState::VT_LAST_CLICKED_POINT, last_clicked_point, 0);
  }
  #[inline]
  pub fn add_last_clicked_is_end_point(&mut self, last_clicked_is_end_point: bool) {
    self.fbb_.push_slot::<bool>(PointerDownState::VT_LAST_CLICKED_IS_END_POINT, last_clicked_is_end_point, false);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<SimplePoint<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SimplePoint>>(PointerDownState::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_segment_midpoint(&mut self, segment_midpoint: flatbuffers::WIPOffset<SegmentMidpointState<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SegmentMidpointState>>(PointerDownState::VT_SEGMENT_MIDPOINT, segment_midpoint);
  }
  #[inline]
  pub fn add_handle_type(&mut self, handle_type: i8) {
    self.fbb_.push_slot_always::<i8>(PointerDownState::VT_HANDLE_TYPE, handle_type);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PointerDownStateBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PointerDownStateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PointerDownState<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PointerDownState<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PointerDownState");
      ds.field("prev_selected_points_indices", &self.prev_selected_points_indices());
      ds.field("last_clicked_point", &self.last_clicked_point());
      ds.field("last_clicked_is_end_point", &self.last_clicked_is_end_point());
      ds.field("origin", &self.origin());
      ds.field("segment_midpoint", &self.segment_midpoint());
      ds.field("handle_type", &self.handle_type());
      ds.finish()
  }
}
pub enum LinearElementEditorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LinearElementEditor<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LinearElementEditor<'a> {
  type Inner = LinearElementEditor<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LinearElementEditor<'a> {
  pub const VT_ELEMENT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_SELECTED_POINTS_INDICES: flatbuffers::VOffsetT = 6;
  pub const VT_POINTER_DOWN_STATE: flatbuffers::VOffsetT = 8;
  pub const VT_IS_DRAGGING: flatbuffers::VOffsetT = 10;
  pub const VT_LAST_UNCOMMITTED_POINT: flatbuffers::VOffsetT = 12;
  pub const VT_POINTER_OFFSET: flatbuffers::VOffsetT = 14;
  pub const VT_START_BINDING_ELEMENT: flatbuffers::VOffsetT = 16;
  pub const VT_END_BINDING_ELEMENT: flatbuffers::VOffsetT = 18;
  pub const VT_HOVER_POINT_INDEX: flatbuffers::VOffsetT = 20;
  pub const VT_SEGMENT_MID_POINT_HOVERED_COORDS: flatbuffers::VOffsetT = 22;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LinearElementEditor { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LinearElementEditorArgs<'args>
  ) -> flatbuffers::WIPOffset<LinearElementEditor<'bldr>> {
    let mut builder = LinearElementEditorBuilder::new(_fbb);
    if let Some(x) = args.segment_mid_point_hovered_coords { builder.add_segment_mid_point_hovered_coords(x); }
    builder.add_hover_point_index(args.hover_point_index);
    if let Some(x) = args.end_binding_element { builder.add_end_binding_element(x); }
    if let Some(x) = args.start_binding_element { builder.add_start_binding_element(x); }
    if let Some(x) = args.pointer_offset { builder.add_pointer_offset(x); }
    if let Some(x) = args.last_uncommitted_point { builder.add_last_uncommitted_point(x); }
    if let Some(x) = args.pointer_down_state { builder.add_pointer_down_state(x); }
    if let Some(x) = args.selected_points_indices { builder.add_selected_points_indices(x); }
    if let Some(x) = args.element_id { builder.add_element_id(x); }
    builder.add_is_dragging(args.is_dragging);
    builder.finish()
  }


  #[inline]
  pub fn element_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LinearElementEditor::VT_ELEMENT_ID, None)}
  }
  #[inline]
  pub fn selected_points_indices(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(LinearElementEditor::VT_SELECTED_POINTS_INDICES, None)}
  }
  #[inline]
  pub fn pointer_down_state(&self) -> Option<PointerDownState<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<PointerDownState>>(LinearElementEditor::VT_POINTER_DOWN_STATE, None)}
  }
  #[inline]
  pub fn is_dragging(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(LinearElementEditor::VT_IS_DRAGGING, Some(false)).unwrap()}
  }
  #[inline]
  pub fn last_uncommitted_point(&self) -> Option<Point<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Point>>(LinearElementEditor::VT_LAST_UNCOMMITTED_POINT, None)}
  }
  #[inline]
  pub fn pointer_offset(&self) -> Option<SimplePoint<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SimplePoint>>(LinearElementEditor::VT_POINTER_OFFSET, None)}
  }
  #[inline]
  pub fn start_binding_element(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LinearElementEditor::VT_START_BINDING_ELEMENT, None)}
  }
  #[inline]
  pub fn end_binding_element(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LinearElementEditor::VT_END_BINDING_ELEMENT, None)}
  }
  #[inline]
  pub fn hover_point_index(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(LinearElementEditor::VT_HOVER_POINT_INDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn segment_mid_point_hovered_coords(&self) -> Option<Point<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Point>>(LinearElementEditor::VT_SEGMENT_MID_POINT_HOVERED_COORDS, None)}
  }
}

impl flatbuffers::Verifiable for LinearElementEditor<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("element_id", Self::VT_ELEMENT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("selected_points_indices", Self::VT_SELECTED_POINTS_INDICES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<PointerDownState>>("pointer_down_state", Self::VT_POINTER_DOWN_STATE, false)?
     .visit_field::<bool>("is_dragging", Self::VT_IS_DRAGGING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Point>>("last_uncommitted_point", Self::VT_LAST_UNCOMMITTED_POINT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SimplePoint>>("pointer_offset", Self::VT_POINTER_OFFSET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("start_binding_element", Self::VT_START_BINDING_ELEMENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("end_binding_element", Self::VT_END_BINDING_ELEMENT, false)?
     .visit_field::<i32>("hover_point_index", Self::VT_HOVER_POINT_INDEX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Point>>("segment_mid_point_hovered_coords", Self::VT_SEGMENT_MID_POINT_HOVERED_COORDS, false)?
     .finish();
    Ok(())
  }
}
pub struct LinearElementEditorArgs<'a> {
    pub element_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub selected_points_indices: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub pointer_down_state: Option<flatbuffers::WIPOffset<PointerDownState<'a>>>,
    pub is_dragging: bool,
    pub last_uncommitted_point: Option<flatbuffers::WIPOffset<Point<'a>>>,
    pub pointer_offset: Option<flatbuffers::WIPOffset<SimplePoint<'a>>>,
    pub start_binding_element: Option<flatbuffers::WIPOffset<&'a str>>,
    pub end_binding_element: Option<flatbuffers::WIPOffset<&'a str>>,
    pub hover_point_index: i32,
    pub segment_mid_point_hovered_coords: Option<flatbuffers::WIPOffset<Point<'a>>>,
}
impl<'a> Default for LinearElementEditorArgs<'a> {
  #[inline]
  fn default() -> Self {
    LinearElementEditorArgs {
      element_id: None,
      selected_points_indices: None,
      pointer_down_state: None,
      is_dragging: false,
      last_uncommitted_point: None,
      pointer_offset: None,
      start_binding_element: None,
      end_binding_element: None,
      hover_point_index: 0,
      segment_mid_point_hovered_coords: None,
    }
  }
}

pub struct LinearElementEditorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LinearElementEditorBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_element_id(&mut self, element_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinearElementEditor::VT_ELEMENT_ID, element_id);
  }
  #[inline]
  pub fn add_selected_points_indices(&mut self, selected_points_indices: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinearElementEditor::VT_SELECTED_POINTS_INDICES, selected_points_indices);
  }
  #[inline]
  pub fn add_pointer_down_state(&mut self, pointer_down_state: flatbuffers::WIPOffset<PointerDownState<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PointerDownState>>(LinearElementEditor::VT_POINTER_DOWN_STATE, pointer_down_state);
  }
  #[inline]
  pub fn add_is_dragging(&mut self, is_dragging: bool) {
    self.fbb_.push_slot::<bool>(LinearElementEditor::VT_IS_DRAGGING, is_dragging, false);
  }
  #[inline]
  pub fn add_last_uncommitted_point(&mut self, last_uncommitted_point: flatbuffers::WIPOffset<Point<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Point>>(LinearElementEditor::VT_LAST_UNCOMMITTED_POINT, last_uncommitted_point);
  }
  #[inline]
  pub fn add_pointer_offset(&mut self, pointer_offset: flatbuffers::WIPOffset<SimplePoint<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SimplePoint>>(LinearElementEditor::VT_POINTER_OFFSET, pointer_offset);
  }
  #[inline]
  pub fn add_start_binding_element(&mut self, start_binding_element: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinearElementEditor::VT_START_BINDING_ELEMENT, start_binding_element);
  }
  #[inline]
  pub fn add_end_binding_element(&mut self, end_binding_element: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinearElementEditor::VT_END_BINDING_ELEMENT, end_binding_element);
  }
  #[inline]
  pub fn add_hover_point_index(&mut self, hover_point_index: i32) {
    self.fbb_.push_slot::<i32>(LinearElementEditor::VT_HOVER_POINT_INDEX, hover_point_index, 0);
  }
  #[inline]
  pub fn add_segment_mid_point_hovered_coords(&mut self, segment_mid_point_hovered_coords: flatbuffers::WIPOffset<Point<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Point>>(LinearElementEditor::VT_SEGMENT_MID_POINT_HOVERED_COORDS, segment_mid_point_hovered_coords);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LinearElementEditorBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LinearElementEditorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LinearElementEditor<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LinearElementEditor<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LinearElementEditor");
      ds.field("element_id", &self.element_id());
      ds.field("selected_points_indices", &self.selected_points_indices());
      ds.field("pointer_down_state", &self.pointer_down_state());
      ds.field("is_dragging", &self.is_dragging());
      ds.field("last_uncommitted_point", &self.last_uncommitted_point());
      ds.field("pointer_offset", &self.pointer_offset());
      ds.field("start_binding_element", &self.start_binding_element());
      ds.field("end_binding_element", &self.end_binding_element());
      ds.field("hover_point_index", &self.hover_point_index());
      ds.field("segment_mid_point_hovered_coords", &self.segment_mid_point_hovered_coords());
      ds.finish()
  }
}
pub enum DucGroupOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucGroup<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucGroup<'a> {
  type Inner = DucGroup<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucGroup<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_IS_COLLAPSED: flatbuffers::VOffsetT = 8;
  pub const VT_LABEL: flatbuffers::VOffsetT = 10;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 16;
  pub const VT_NO_PLOT: flatbuffers::VOffsetT = 18;
  pub const VT_LOCKED: flatbuffers::VOffsetT = 20;
  pub const VT_IS_VISIBLE: flatbuffers::VOffsetT = 22;
  pub const VT_OPACITY: flatbuffers::VOffsetT = 24;
  pub const VT_LABELING_COLOR: flatbuffers::VOffsetT = 26;
  pub const VT_STROKE_OVERRIDE: flatbuffers::VOffsetT = 28;
  pub const VT_BACKGROUND_OVERRIDE: flatbuffers::VOffsetT = 30;
  pub const VT_CLIP: flatbuffers::VOffsetT = 32;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucGroup { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucGroupArgs<'args>
  ) -> flatbuffers::WIPOffset<DucGroup<'bldr>> {
    let mut builder = DucGroupBuilder::new(_fbb);
    if let Some(x) = args.background_override { builder.add_background_override(x); }
    if let Some(x) = args.stroke_override { builder.add_stroke_override(x); }
    if let Some(x) = args.labeling_color { builder.add_labeling_color(x); }
    builder.add_opacity(args.opacity);
    if let Some(x) = args.description { builder.add_description(x); }
    if let Some(x) = args.label { builder.add_label(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    if let Some(x) = args.clip { builder.add_clip(x); }
    builder.add_is_visible(args.is_visible);
    builder.add_locked(args.locked);
    if let Some(x) = args.no_plot { builder.add_no_plot(x); }
    builder.add_is_collapsed(args.is_collapsed);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucGroup::VT_ID, None)}
  }
  #[inline]
  pub fn is_collapsed(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucGroup::VT_IS_COLLAPSED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn label(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucGroup::VT_LABEL, None)}
  }
  #[inline]
  pub fn description(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucGroup::VT_DESCRIPTION, None)}
  }
  #[inline]
  pub fn no_plot(&self) -> Option<bool> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucGroup::VT_NO_PLOT, None)}
  }
  #[inline]
  pub fn locked(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucGroup::VT_LOCKED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn is_visible(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucGroup::VT_IS_VISIBLE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn opacity(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucGroup::VT_OPACITY, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn labeling_color(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucGroup::VT_LABELING_COLOR, None)}
  }
  #[inline]
  pub fn stroke_override(&self) -> Option<ElementStroke<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ElementStroke>>(DucGroup::VT_STROKE_OVERRIDE, None)}
  }
  #[inline]
  pub fn background_override(&self) -> Option<ElementBackground<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ElementBackground>>(DucGroup::VT_BACKGROUND_OVERRIDE, None)}
  }
  #[inline]
  pub fn clip(&self) -> Option<bool> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucGroup::VT_CLIP, None)}
  }
}

impl flatbuffers::Verifiable for DucGroup<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<bool>("is_collapsed", Self::VT_IS_COLLAPSED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("label", Self::VT_LABEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("description", Self::VT_DESCRIPTION, false)?
     .visit_field::<bool>("no_plot", Self::VT_NO_PLOT, false)?
     .visit_field::<bool>("locked", Self::VT_LOCKED, false)?
     .visit_field::<bool>("is_visible", Self::VT_IS_VISIBLE, false)?
     .visit_field::<f32>("opacity", Self::VT_OPACITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("labeling_color", Self::VT_LABELING_COLOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ElementStroke>>("stroke_override", Self::VT_STROKE_OVERRIDE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ElementBackground>>("background_override", Self::VT_BACKGROUND_OVERRIDE, false)?
     .visit_field::<bool>("clip", Self::VT_CLIP, false)?
     .finish();
    Ok(())
  }
}
pub struct DucGroupArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub is_collapsed: bool,
    pub label: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub no_plot: Option<bool>,
    pub locked: bool,
    pub is_visible: bool,
    pub opacity: f32,
    pub labeling_color: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stroke_override: Option<flatbuffers::WIPOffset<ElementStroke<'a>>>,
    pub background_override: Option<flatbuffers::WIPOffset<ElementBackground<'a>>>,
    pub clip: Option<bool>,
}
impl<'a> Default for DucGroupArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucGroupArgs {
      id: None,
      is_collapsed: false,
      label: None,
      description: None,
      no_plot: None,
      locked: false,
      is_visible: false,
      opacity: 0.0,
      labeling_color: None,
      stroke_override: None,
      background_override: None,
      clip: None,
    }
  }
}

pub struct DucGroupBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucGroupBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucGroup::VT_ID, id);
  }
  #[inline]
  pub fn add_is_collapsed(&mut self, is_collapsed: bool) {
    self.fbb_.push_slot::<bool>(DucGroup::VT_IS_COLLAPSED, is_collapsed, false);
  }
  #[inline]
  pub fn add_label(&mut self, label: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucGroup::VT_LABEL, label);
  }
  #[inline]
  pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucGroup::VT_DESCRIPTION, description);
  }
  #[inline]
  pub fn add_no_plot(&mut self, no_plot: bool) {
    self.fbb_.push_slot_always::<bool>(DucGroup::VT_NO_PLOT, no_plot);
  }
  #[inline]
  pub fn add_locked(&mut self, locked: bool) {
    self.fbb_.push_slot::<bool>(DucGroup::VT_LOCKED, locked, false);
  }
  #[inline]
  pub fn add_is_visible(&mut self, is_visible: bool) {
    self.fbb_.push_slot::<bool>(DucGroup::VT_IS_VISIBLE, is_visible, false);
  }
  #[inline]
  pub fn add_opacity(&mut self, opacity: f32) {
    self.fbb_.push_slot::<f32>(DucGroup::VT_OPACITY, opacity, 0.0);
  }
  #[inline]
  pub fn add_labeling_color(&mut self, labeling_color: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucGroup::VT_LABELING_COLOR, labeling_color);
  }
  #[inline]
  pub fn add_stroke_override(&mut self, stroke_override: flatbuffers::WIPOffset<ElementStroke<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ElementStroke>>(DucGroup::VT_STROKE_OVERRIDE, stroke_override);
  }
  #[inline]
  pub fn add_background_override(&mut self, background_override: flatbuffers::WIPOffset<ElementBackground<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ElementBackground>>(DucGroup::VT_BACKGROUND_OVERRIDE, background_override);
  }
  #[inline]
  pub fn add_clip(&mut self, clip: bool) {
    self.fbb_.push_slot_always::<bool>(DucGroup::VT_CLIP, clip);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucGroupBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucGroupBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucGroup<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucGroup<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucGroup");
      ds.field("id", &self.id());
      ds.field("is_collapsed", &self.is_collapsed());
      ds.field("label", &self.label());
      ds.field("description", &self.description());
      ds.field("no_plot", &self.no_plot());
      ds.field("locked", &self.locked());
      ds.field("is_visible", &self.is_visible());
      ds.field("opacity", &self.opacity());
      ds.field("labeling_color", &self.labeling_color());
      ds.field("stroke_override", &self.stroke_override());
      ds.field("background_override", &self.background_override());
      ds.field("clip", &self.clip());
      ds.finish()
  }
}
pub enum DucBlockOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucBlock<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucBlock<'a> {
  type Inner = DucBlock<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucBlock<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_LABEL: flatbuffers::VOffsetT = 6;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 8;
  pub const VT_VERSION: flatbuffers::VOffsetT = 10;
  pub const VT_ELEMENTS: flatbuffers::VOffsetT = 12;
  pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucBlock { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucBlockArgs<'args>
  ) -> flatbuffers::WIPOffset<DucBlock<'bldr>> {
    let mut builder = DucBlockBuilder::new(_fbb);
    if let Some(x) = args.attributes { builder.add_attributes(x); }
    if let Some(x) = args.elements { builder.add_elements(x); }
    builder.add_version(args.version);
    if let Some(x) = args.description { builder.add_description(x); }
    if let Some(x) = args.label { builder.add_label(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucBlock::VT_ID, None)}
  }
  #[inline]
  pub fn label(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucBlock::VT_LABEL, None)}
  }
  #[inline]
  pub fn description(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucBlock::VT_DESCRIPTION, None)}
  }
  #[inline]
  pub fn version(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DucBlock::VT_VERSION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn elements(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucElement<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucElement>>>>(DucBlock::VT_ELEMENTS, None)}
  }
  #[inline]
  pub fn attributes(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucBlockAttribute<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucBlockAttribute>>>>(DucBlock::VT_ATTRIBUTES, None)}
  }
}

impl flatbuffers::Verifiable for DucBlock<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("label", Self::VT_LABEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("description", Self::VT_DESCRIPTION, false)?
     .visit_field::<i32>("version", Self::VT_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DucElement>>>>("elements", Self::VT_ELEMENTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DucBlockAttribute>>>>("attributes", Self::VT_ATTRIBUTES, false)?
     .finish();
    Ok(())
  }
}
pub struct DucBlockArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub label: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub version: i32,
    pub elements: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucElement<'a>>>>>,
    pub attributes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucBlockAttribute<'a>>>>>,
}
impl<'a> Default for DucBlockArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucBlockArgs {
      id: None,
      label: None,
      description: None,
      version: 0,
      elements: None,
      attributes: None,
    }
  }
}

pub struct DucBlockBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucBlockBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucBlock::VT_ID, id);
  }
  #[inline]
  pub fn add_label(&mut self, label: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucBlock::VT_LABEL, label);
  }
  #[inline]
  pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucBlock::VT_DESCRIPTION, description);
  }
  #[inline]
  pub fn add_version(&mut self, version: i32) {
    self.fbb_.push_slot::<i32>(DucBlock::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_elements(&mut self, elements: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DucElement<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucBlock::VT_ELEMENTS, elements);
  }
  #[inline]
  pub fn add_attributes(&mut self, attributes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DucBlockAttribute<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucBlock::VT_ATTRIBUTES, attributes);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucBlockBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucBlockBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucBlock<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucBlock<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucBlock");
      ds.field("id", &self.id());
      ds.field("label", &self.label());
      ds.field("description", &self.description());
      ds.field("version", &self.version());
      ds.field("elements", &self.elements());
      ds.field("attributes", &self.attributes());
      ds.finish()
  }
}
pub enum DucBlockAttributeDetailsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucBlockAttributeDetails<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucBlockAttributeDetails<'a> {
  type Inner = DucBlockAttributeDetails<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucBlockAttributeDetails<'a> {
  pub const VT_TAG: flatbuffers::VOffsetT = 4;
  pub const VT_DEFAULT_VALUE: flatbuffers::VOffsetT = 6;
  pub const VT_PROMPT: flatbuffers::VOffsetT = 8;
  pub const VT_POSITION: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucBlockAttributeDetails { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucBlockAttributeDetailsArgs<'args>
  ) -> flatbuffers::WIPOffset<DucBlockAttributeDetails<'bldr>> {
    let mut builder = DucBlockAttributeDetailsBuilder::new(_fbb);
    if let Some(x) = args.position { builder.add_position(x); }
    if let Some(x) = args.prompt { builder.add_prompt(x); }
    if let Some(x) = args.default_value { builder.add_default_value(x); }
    if let Some(x) = args.tag { builder.add_tag(x); }
    builder.finish()
  }


  #[inline]
  pub fn tag(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucBlockAttributeDetails::VT_TAG, None)}
  }
  #[inline]
  pub fn default_value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucBlockAttributeDetails::VT_DEFAULT_VALUE, None)}
  }
  #[inline]
  pub fn prompt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucBlockAttributeDetails::VT_PROMPT, None)}
  }
  #[inline]
  pub fn position(&self) -> Option<SimplePoint<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SimplePoint>>(DucBlockAttributeDetails::VT_POSITION, None)}
  }
}

impl flatbuffers::Verifiable for DucBlockAttributeDetails<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tag", Self::VT_TAG, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("default_value", Self::VT_DEFAULT_VALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("prompt", Self::VT_PROMPT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SimplePoint>>("position", Self::VT_POSITION, false)?
     .finish();
    Ok(())
  }
}
pub struct DucBlockAttributeDetailsArgs<'a> {
    pub tag: Option<flatbuffers::WIPOffset<&'a str>>,
    pub default_value: Option<flatbuffers::WIPOffset<&'a str>>,
    pub prompt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub position: Option<flatbuffers::WIPOffset<SimplePoint<'a>>>,
}
impl<'a> Default for DucBlockAttributeDetailsArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucBlockAttributeDetailsArgs {
      tag: None,
      default_value: None,
      prompt: None,
      position: None,
    }
  }
}

pub struct DucBlockAttributeDetailsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucBlockAttributeDetailsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_tag(&mut self, tag: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucBlockAttributeDetails::VT_TAG, tag);
  }
  #[inline]
  pub fn add_default_value(&mut self, default_value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucBlockAttributeDetails::VT_DEFAULT_VALUE, default_value);
  }
  #[inline]
  pub fn add_prompt(&mut self, prompt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucBlockAttributeDetails::VT_PROMPT, prompt);
  }
  #[inline]
  pub fn add_position(&mut self, position: flatbuffers::WIPOffset<SimplePoint<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SimplePoint>>(DucBlockAttributeDetails::VT_POSITION, position);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucBlockAttributeDetailsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucBlockAttributeDetailsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucBlockAttributeDetails<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucBlockAttributeDetails<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucBlockAttributeDetails");
      ds.field("tag", &self.tag());
      ds.field("default_value", &self.default_value());
      ds.field("prompt", &self.prompt());
      ds.field("position", &self.position());
      ds.finish()
  }
}
pub enum DucBlockAttributeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucBlockAttribute<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucBlockAttribute<'a> {
  type Inner = DucBlockAttribute<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucBlockAttribute<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_DETAILS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucBlockAttribute { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucBlockAttributeArgs<'args>
  ) -> flatbuffers::WIPOffset<DucBlockAttribute<'bldr>> {
    let mut builder = DucBlockAttributeBuilder::new(_fbb);
    if let Some(x) = args.details { builder.add_details(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucBlockAttribute::VT_NAME, None)}
  }
  #[inline]
  pub fn details(&self) -> Option<DucBlockAttributeDetails<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucBlockAttributeDetails>>(DucBlockAttribute::VT_DETAILS, None)}
  }
}

impl flatbuffers::Verifiable for DucBlockAttribute<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucBlockAttributeDetails>>("details", Self::VT_DETAILS, false)?
     .finish();
    Ok(())
  }
}
pub struct DucBlockAttributeArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub details: Option<flatbuffers::WIPOffset<DucBlockAttributeDetails<'a>>>,
}
impl<'a> Default for DucBlockAttributeArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucBlockAttributeArgs {
      name: None,
      details: None,
    }
  }
}

pub struct DucBlockAttributeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucBlockAttributeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucBlockAttribute::VT_NAME, name);
  }
  #[inline]
  pub fn add_details(&mut self, details: flatbuffers::WIPOffset<DucBlockAttributeDetails<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucBlockAttributeDetails>>(DucBlockAttribute::VT_DETAILS, details);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucBlockAttributeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucBlockAttributeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucBlockAttribute<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucBlockAttribute<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucBlockAttribute");
      ds.field("name", &self.name());
      ds.field("details", &self.details());
      ds.finish()
  }
}
pub enum AppStateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AppState<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AppState<'a> {
  type Inner = AppState<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AppState<'a> {
  pub const VT_FRAME_RENDERING_ENABLED: flatbuffers::VOffsetT = 18;
  pub const VT_FRAME_RENDERING_NAME: flatbuffers::VOffsetT = 20;
  pub const VT_FRAME_RENDERING_OUTLINE: flatbuffers::VOffsetT = 22;
  pub const VT_FRAME_RENDERING_CLIP: flatbuffers::VOffsetT = 24;
  pub const VT_CURRENT_ITEM_OPACITY: flatbuffers::VOffsetT = 46;
  pub const VT_VIEW_BACKGROUND_COLOR: flatbuffers::VOffsetT = 60;
  pub const VT_SCOPE: flatbuffers::VOffsetT = 62;
  pub const VT_SCROLL_X: flatbuffers::VOffsetT = 68;
  pub const VT_SCROLL_Y: flatbuffers::VOffsetT = 70;
  pub const VT_CURSOR_BUTTON: flatbuffers::VOffsetT = 72;
  pub const VT_SCROLLED_OUTSIDE: flatbuffers::VOffsetT = 74;
  pub const VT_NAME: flatbuffers::VOffsetT = 76;
  pub const VT_ZOOM: flatbuffers::VOffsetT = 78;
  pub const VT_LAST_POINTER_DOWN_WITH: flatbuffers::VOffsetT = 80;
  pub const VT_SELECTED_ELEMENT_IDS: flatbuffers::VOffsetT = 82;
  pub const VT_GRID_SIZE: flatbuffers::VOffsetT = 90;
  pub const VT_SCALE_RATIO_LOCKED: flatbuffers::VOffsetT = 100;
  pub const VT_DISPLAY_ALL_POINT_DISTANCES: flatbuffers::VOffsetT = 102;
  pub const VT_DISPLAY_DISTANCE_ON_DRAWING: flatbuffers::VOffsetT = 104;
  pub const VT_DISPLAY_ALL_POINT_COORDINATES: flatbuffers::VOffsetT = 106;
  pub const VT_DISPLAY_ALL_POINT_INFO_SELECTED: flatbuffers::VOffsetT = 108;
  pub const VT_DISPLAY_ROOT_AXIS: flatbuffers::VOffsetT = 110;
  pub const VT_CURRENT_ITEM_TEXT_ALIGN_V3: flatbuffers::VOffsetT = 122;
  pub const VT_LINE_BENDING_MODE: flatbuffers::VOffsetT = 124;
  pub const VT_CURRENT_ITEM_FONT_SIZE_V3: flatbuffers::VOffsetT = 130;
  pub const VT_COORD_DECIMAL_PLACES_V3: flatbuffers::VOffsetT = 132;
  pub const VT_CURRENT_ITEM_STROKE: flatbuffers::VOffsetT = 134;
  pub const VT_CURRENT_ITEM_BACKGROUND: flatbuffers::VOffsetT = 136;
  pub const VT_MAIN_SCOPE: flatbuffers::VOffsetT = 138;
  pub const VT_STANDARD: flatbuffers::VOffsetT = 140;
  pub const VT_CURRENT_ITEM_START_LINE_HEAD: flatbuffers::VOffsetT = 142;
  pub const VT_CURRENT_ITEM_END_LINE_HEAD: flatbuffers::VOffsetT = 144;
  pub const VT_CURRENT_ITEM_ROUNDNESS_V3: flatbuffers::VOffsetT = 146;
  pub const VT_ANTI_ALIASING: flatbuffers::VOffsetT = 148;
  pub const VT_V_SYNC: flatbuffers::VOffsetT = 150;
  pub const VT_CURRENT_ITEM_FONT_FAMILY_V2: flatbuffers::VOffsetT = 152;
  pub const VT_DEBUG_RENDERING: flatbuffers::VOffsetT = 154;
  pub const VT_CURRENT_ITEM_SUBSET: flatbuffers::VOffsetT = 156;
  pub const VT_EDITING_LINEAR_ELEMENT: flatbuffers::VOffsetT = 158;
  pub const VT_GRID_MODE_ENABLED: flatbuffers::VOffsetT = 160;
  pub const VT_GRID_STEP: flatbuffers::VOffsetT = 162;
  pub const VT_SCOPE_EXPONENT_THRESHOLD: flatbuffers::VOffsetT = 164;
  pub const VT_ZOOM_STEP: flatbuffers::VOffsetT = 166;
  pub const VT_HOVERED_ELEMENT_ID: flatbuffers::VOffsetT = 168;
  pub const VT_ELEMENTS_PENDING_ERASURE: flatbuffers::VOffsetT = 170;
  pub const VT_SUGGESTED_BINDING_ELEMENT_ID: flatbuffers::VOffsetT = 172;
  pub const VT_IS_BINDING_ENABLED: flatbuffers::VOffsetT = 174;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AppState { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AppStateArgs<'args>
  ) -> flatbuffers::WIPOffset<AppState<'bldr>> {
    let mut builder = AppStateBuilder::new(_fbb);
    builder.add_current_item_roundness_v3(args.current_item_roundness_v3);
    builder.add_current_item_font_size_v3(args.current_item_font_size_v3);
    if let Some(x) = args.suggested_binding_element_id { builder.add_suggested_binding_element_id(x); }
    if let Some(x) = args.elements_pending_erasure { builder.add_elements_pending_erasure(x); }
    if let Some(x) = args.hovered_element_id { builder.add_hovered_element_id(x); }
    builder.add_zoom_step(args.zoom_step);
    builder.add_grid_step(args.grid_step);
    if let Some(x) = args.editing_linear_element { builder.add_editing_linear_element(x); }
    if let Some(x) = args.current_item_font_family_v2 { builder.add_current_item_font_family_v2(x); }
    if let Some(x) = args.main_scope { builder.add_main_scope(x); }
    if let Some(x) = args.current_item_background { builder.add_current_item_background(x); }
    if let Some(x) = args.current_item_stroke { builder.add_current_item_stroke(x); }
    builder.add_grid_size(args.grid_size);
    if let Some(x) = args.selected_element_ids { builder.add_selected_element_ids(x); }
    if let Some(x) = args.last_pointer_down_with { builder.add_last_pointer_down_with(x); }
    builder.add_zoom(args.zoom);
    if let Some(x) = args.name { builder.add_name(x); }
    if let Some(x) = args.cursor_button { builder.add_cursor_button(x); }
    builder.add_scroll_y(args.scroll_y);
    builder.add_scroll_x(args.scroll_x);
    if let Some(x) = args.scope { builder.add_scope(x); }
    if let Some(x) = args.view_background_color { builder.add_view_background_color(x); }
    builder.add_current_item_opacity(args.current_item_opacity);
    builder.add_is_binding_enabled(args.is_binding_enabled);
    builder.add_scope_exponent_threshold(args.scope_exponent_threshold);
    builder.add_grid_mode_enabled(args.grid_mode_enabled);
    if let Some(x) = args.current_item_subset { builder.add_current_item_subset(x); }
    builder.add_debug_rendering(args.debug_rendering);
    builder.add_v_sync(args.v_sync);
    builder.add_anti_aliasing(args.anti_aliasing);
    if let Some(x) = args.current_item_end_line_head { builder.add_current_item_end_line_head(x); }
    if let Some(x) = args.current_item_start_line_head { builder.add_current_item_start_line_head(x); }
    builder.add_standard(args.standard);
    builder.add_coord_decimal_places_v3(args.coord_decimal_places_v3);
    builder.add_line_bending_mode(args.line_bending_mode);
    builder.add_current_item_text_align_v3(args.current_item_text_align_v3);
    builder.add_display_root_axis(args.display_root_axis);
    builder.add_display_all_point_info_selected(args.display_all_point_info_selected);
    builder.add_display_all_point_coordinates(args.display_all_point_coordinates);
    builder.add_display_distance_on_drawing(args.display_distance_on_drawing);
    builder.add_display_all_point_distances(args.display_all_point_distances);
    builder.add_scale_ratio_locked(args.scale_ratio_locked);
    builder.add_scrolled_outside(args.scrolled_outside);
    builder.add_frame_rendering_clip(args.frame_rendering_clip);
    builder.add_frame_rendering_outline(args.frame_rendering_outline);
    builder.add_frame_rendering_name(args.frame_rendering_name);
    builder.add_frame_rendering_enabled(args.frame_rendering_enabled);
    builder.finish()
  }


  #[inline]
  pub fn frame_rendering_enabled(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_FRAME_RENDERING_ENABLED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn frame_rendering_name(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_FRAME_RENDERING_NAME, Some(false)).unwrap()}
  }
  #[inline]
  pub fn frame_rendering_outline(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_FRAME_RENDERING_OUTLINE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn frame_rendering_clip(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_FRAME_RENDERING_CLIP, Some(false)).unwrap()}
  }
  #[inline]
  pub fn current_item_opacity(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(AppState::VT_CURRENT_ITEM_OPACITY, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn view_background_color(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_VIEW_BACKGROUND_COLOR, None)}
  }
  #[inline]
  pub fn scope(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_SCOPE, None)}
  }
  #[inline]
  pub fn scroll_x(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(AppState::VT_SCROLL_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn scroll_y(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(AppState::VT_SCROLL_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn cursor_button(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_CURSOR_BUTTON, None)}
  }
  #[inline]
  pub fn scrolled_outside(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_SCROLLED_OUTSIDE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_NAME, None)}
  }
  #[inline]
  pub fn zoom(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(AppState::VT_ZOOM, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn last_pointer_down_with(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_LAST_POINTER_DOWN_WITH, None)}
  }
  #[inline]
  pub fn selected_element_ids(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(AppState::VT_SELECTED_ELEMENT_IDS, None)}
  }
  #[inline]
  pub fn grid_size(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AppState::VT_GRID_SIZE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn scale_ratio_locked(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_SCALE_RATIO_LOCKED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn display_all_point_distances(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_DISPLAY_ALL_POINT_DISTANCES, Some(false)).unwrap()}
  }
  #[inline]
  pub fn display_distance_on_drawing(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_DISPLAY_DISTANCE_ON_DRAWING, Some(false)).unwrap()}
  }
  #[inline]
  pub fn display_all_point_coordinates(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_DISPLAY_ALL_POINT_COORDINATES, Some(false)).unwrap()}
  }
  #[inline]
  pub fn display_all_point_info_selected(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_DISPLAY_ALL_POINT_INFO_SELECTED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn display_root_axis(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_DISPLAY_ROOT_AXIS, Some(false)).unwrap()}
  }
  #[inline]
  pub fn current_item_text_align_v3(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(AppState::VT_CURRENT_ITEM_TEXT_ALIGN_V3, Some(0)).unwrap()}
  }
  #[inline]
  pub fn line_bending_mode(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_LINE_BENDING_MODE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn current_item_font_size_v3(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AppState::VT_CURRENT_ITEM_FONT_SIZE_V3, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn coord_decimal_places_v3(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(AppState::VT_COORD_DECIMAL_PLACES_V3, Some(0)).unwrap()}
  }
  #[inline]
  pub fn current_item_stroke(&self) -> Option<ElementStroke<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ElementStroke>>(AppState::VT_CURRENT_ITEM_STROKE, None)}
  }
  #[inline]
  pub fn current_item_background(&self) -> Option<ElementBackground<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ElementBackground>>(AppState::VT_CURRENT_ITEM_BACKGROUND, None)}
  }
  #[inline]
  pub fn main_scope(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_MAIN_SCOPE, None)}
  }
  #[inline]
  pub fn standard(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(AppState::VT_STANDARD, Some(0)).unwrap()}
  }
  #[inline]
  pub fn current_item_start_line_head(&self) -> Option<i8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(AppState::VT_CURRENT_ITEM_START_LINE_HEAD, None)}
  }
  #[inline]
  pub fn current_item_end_line_head(&self) -> Option<i8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(AppState::VT_CURRENT_ITEM_END_LINE_HEAD, None)}
  }
  #[inline]
  pub fn current_item_roundness_v3(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AppState::VT_CURRENT_ITEM_ROUNDNESS_V3, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn anti_aliasing(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(AppState::VT_ANTI_ALIASING, Some(0)).unwrap()}
  }
  #[inline]
  pub fn v_sync(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_V_SYNC, Some(false)).unwrap()}
  }
  #[inline]
  pub fn current_item_font_family_v2(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_CURRENT_ITEM_FONT_FAMILY_V2, None)}
  }
  #[inline]
  pub fn debug_rendering(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_DEBUG_RENDERING, Some(false)).unwrap()}
  }
  #[inline]
  pub fn current_item_subset(&self) -> Option<i8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(AppState::VT_CURRENT_ITEM_SUBSET, None)}
  }
  #[inline]
  pub fn editing_linear_element(&self) -> Option<LinearElementEditor<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<LinearElementEditor>>(AppState::VT_EDITING_LINEAR_ELEMENT, None)}
  }
  #[inline]
  pub fn grid_mode_enabled(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_GRID_MODE_ENABLED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn grid_step(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AppState::VT_GRID_STEP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn scope_exponent_threshold(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(AppState::VT_SCOPE_EXPONENT_THRESHOLD, Some(0)).unwrap()}
  }
  #[inline]
  pub fn zoom_step(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(AppState::VT_ZOOM_STEP, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn hovered_element_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_HOVERED_ELEMENT_ID, None)}
  }
  #[inline]
  pub fn elements_pending_erasure(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(AppState::VT_ELEMENTS_PENDING_ERASURE, None)}
  }
  #[inline]
  pub fn suggested_binding_element_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_SUGGESTED_BINDING_ELEMENT_ID, None)}
  }
  #[inline]
  pub fn is_binding_enabled(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_IS_BINDING_ENABLED, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for AppState<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("frame_rendering_enabled", Self::VT_FRAME_RENDERING_ENABLED, false)?
     .visit_field::<bool>("frame_rendering_name", Self::VT_FRAME_RENDERING_NAME, false)?
     .visit_field::<bool>("frame_rendering_outline", Self::VT_FRAME_RENDERING_OUTLINE, false)?
     .visit_field::<bool>("frame_rendering_clip", Self::VT_FRAME_RENDERING_CLIP, false)?
     .visit_field::<f32>("current_item_opacity", Self::VT_CURRENT_ITEM_OPACITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("view_background_color", Self::VT_VIEW_BACKGROUND_COLOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("scope", Self::VT_SCOPE, false)?
     .visit_field::<f32>("scroll_x", Self::VT_SCROLL_X, false)?
     .visit_field::<f32>("scroll_y", Self::VT_SCROLL_Y, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("cursor_button", Self::VT_CURSOR_BUTTON, false)?
     .visit_field::<bool>("scrolled_outside", Self::VT_SCROLLED_OUTSIDE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<f32>("zoom", Self::VT_ZOOM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("last_pointer_down_with", Self::VT_LAST_POINTER_DOWN_WITH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("selected_element_ids", Self::VT_SELECTED_ELEMENT_IDS, false)?
     .visit_field::<i32>("grid_size", Self::VT_GRID_SIZE, false)?
     .visit_field::<bool>("scale_ratio_locked", Self::VT_SCALE_RATIO_LOCKED, false)?
     .visit_field::<bool>("display_all_point_distances", Self::VT_DISPLAY_ALL_POINT_DISTANCES, false)?
     .visit_field::<bool>("display_distance_on_drawing", Self::VT_DISPLAY_DISTANCE_ON_DRAWING, false)?
     .visit_field::<bool>("display_all_point_coordinates", Self::VT_DISPLAY_ALL_POINT_COORDINATES, false)?
     .visit_field::<bool>("display_all_point_info_selected", Self::VT_DISPLAY_ALL_POINT_INFO_SELECTED, false)?
     .visit_field::<bool>("display_root_axis", Self::VT_DISPLAY_ROOT_AXIS, false)?
     .visit_field::<i8>("current_item_text_align_v3", Self::VT_CURRENT_ITEM_TEXT_ALIGN_V3, false)?
     .visit_field::<bool>("line_bending_mode", Self::VT_LINE_BENDING_MODE, false)?
     .visit_field::<f64>("current_item_font_size_v3", Self::VT_CURRENT_ITEM_FONT_SIZE_V3, false)?
     .visit_field::<i8>("coord_decimal_places_v3", Self::VT_COORD_DECIMAL_PLACES_V3, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ElementStroke>>("current_item_stroke", Self::VT_CURRENT_ITEM_STROKE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ElementBackground>>("current_item_background", Self::VT_CURRENT_ITEM_BACKGROUND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("main_scope", Self::VT_MAIN_SCOPE, false)?
     .visit_field::<i8>("standard", Self::VT_STANDARD, false)?
     .visit_field::<i8>("current_item_start_line_head", Self::VT_CURRENT_ITEM_START_LINE_HEAD, false)?
     .visit_field::<i8>("current_item_end_line_head", Self::VT_CURRENT_ITEM_END_LINE_HEAD, false)?
     .visit_field::<f64>("current_item_roundness_v3", Self::VT_CURRENT_ITEM_ROUNDNESS_V3, false)?
     .visit_field::<i8>("anti_aliasing", Self::VT_ANTI_ALIASING, false)?
     .visit_field::<bool>("v_sync", Self::VT_V_SYNC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("current_item_font_family_v2", Self::VT_CURRENT_ITEM_FONT_FAMILY_V2, false)?
     .visit_field::<bool>("debug_rendering", Self::VT_DEBUG_RENDERING, false)?
     .visit_field::<i8>("current_item_subset", Self::VT_CURRENT_ITEM_SUBSET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<LinearElementEditor>>("editing_linear_element", Self::VT_EDITING_LINEAR_ELEMENT, false)?
     .visit_field::<bool>("grid_mode_enabled", Self::VT_GRID_MODE_ENABLED, false)?
     .visit_field::<i32>("grid_step", Self::VT_GRID_STEP, false)?
     .visit_field::<i8>("scope_exponent_threshold", Self::VT_SCOPE_EXPONENT_THRESHOLD, false)?
     .visit_field::<f32>("zoom_step", Self::VT_ZOOM_STEP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("hovered_element_id", Self::VT_HOVERED_ELEMENT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("elements_pending_erasure", Self::VT_ELEMENTS_PENDING_ERASURE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("suggested_binding_element_id", Self::VT_SUGGESTED_BINDING_ELEMENT_ID, false)?
     .visit_field::<bool>("is_binding_enabled", Self::VT_IS_BINDING_ENABLED, false)?
     .finish();
    Ok(())
  }
}
pub struct AppStateArgs<'a> {
    pub frame_rendering_enabled: bool,
    pub frame_rendering_name: bool,
    pub frame_rendering_outline: bool,
    pub frame_rendering_clip: bool,
    pub current_item_opacity: f32,
    pub view_background_color: Option<flatbuffers::WIPOffset<&'a str>>,
    pub scope: Option<flatbuffers::WIPOffset<&'a str>>,
    pub scroll_x: f32,
    pub scroll_y: f32,
    pub cursor_button: Option<flatbuffers::WIPOffset<&'a str>>,
    pub scrolled_outside: bool,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub zoom: f32,
    pub last_pointer_down_with: Option<flatbuffers::WIPOffset<&'a str>>,
    pub selected_element_ids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub grid_size: i32,
    pub scale_ratio_locked: bool,
    pub display_all_point_distances: bool,
    pub display_distance_on_drawing: bool,
    pub display_all_point_coordinates: bool,
    pub display_all_point_info_selected: bool,
    pub display_root_axis: bool,
    pub current_item_text_align_v3: i8,
    pub line_bending_mode: bool,
    pub current_item_font_size_v3: f64,
    pub coord_decimal_places_v3: i8,
    pub current_item_stroke: Option<flatbuffers::WIPOffset<ElementStroke<'a>>>,
    pub current_item_background: Option<flatbuffers::WIPOffset<ElementBackground<'a>>>,
    pub main_scope: Option<flatbuffers::WIPOffset<&'a str>>,
    pub standard: i8,
    pub current_item_start_line_head: Option<i8>,
    pub current_item_end_line_head: Option<i8>,
    pub current_item_roundness_v3: f64,
    pub anti_aliasing: i8,
    pub v_sync: bool,
    pub current_item_font_family_v2: Option<flatbuffers::WIPOffset<&'a str>>,
    pub debug_rendering: bool,
    pub current_item_subset: Option<i8>,
    pub editing_linear_element: Option<flatbuffers::WIPOffset<LinearElementEditor<'a>>>,
    pub grid_mode_enabled: bool,
    pub grid_step: i32,
    pub scope_exponent_threshold: i8,
    pub zoom_step: f32,
    pub hovered_element_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub elements_pending_erasure: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub suggested_binding_element_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub is_binding_enabled: bool,
}
impl<'a> Default for AppStateArgs<'a> {
  #[inline]
  fn default() -> Self {
    AppStateArgs {
      frame_rendering_enabled: false,
      frame_rendering_name: false,
      frame_rendering_outline: false,
      frame_rendering_clip: false,
      current_item_opacity: 0.0,
      view_background_color: None,
      scope: None,
      scroll_x: 0.0,
      scroll_y: 0.0,
      cursor_button: None,
      scrolled_outside: false,
      name: None,
      zoom: 0.0,
      last_pointer_down_with: None,
      selected_element_ids: None,
      grid_size: 0,
      scale_ratio_locked: false,
      display_all_point_distances: false,
      display_distance_on_drawing: false,
      display_all_point_coordinates: false,
      display_all_point_info_selected: false,
      display_root_axis: false,
      current_item_text_align_v3: 0,
      line_bending_mode: false,
      current_item_font_size_v3: 0.0,
      coord_decimal_places_v3: 0,
      current_item_stroke: None,
      current_item_background: None,
      main_scope: None,
      standard: 0,
      current_item_start_line_head: None,
      current_item_end_line_head: None,
      current_item_roundness_v3: 0.0,
      anti_aliasing: 0,
      v_sync: false,
      current_item_font_family_v2: None,
      debug_rendering: false,
      current_item_subset: None,
      editing_linear_element: None,
      grid_mode_enabled: false,
      grid_step: 0,
      scope_exponent_threshold: 0,
      zoom_step: 0.0,
      hovered_element_id: None,
      elements_pending_erasure: None,
      suggested_binding_element_id: None,
      is_binding_enabled: false,
    }
  }
}

pub struct AppStateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AppStateBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_frame_rendering_enabled(&mut self, frame_rendering_enabled: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_FRAME_RENDERING_ENABLED, frame_rendering_enabled, false);
  }
  #[inline]
  pub fn add_frame_rendering_name(&mut self, frame_rendering_name: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_FRAME_RENDERING_NAME, frame_rendering_name, false);
  }
  #[inline]
  pub fn add_frame_rendering_outline(&mut self, frame_rendering_outline: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_FRAME_RENDERING_OUTLINE, frame_rendering_outline, false);
  }
  #[inline]
  pub fn add_frame_rendering_clip(&mut self, frame_rendering_clip: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_FRAME_RENDERING_CLIP, frame_rendering_clip, false);
  }
  #[inline]
  pub fn add_current_item_opacity(&mut self, current_item_opacity: f32) {
    self.fbb_.push_slot::<f32>(AppState::VT_CURRENT_ITEM_OPACITY, current_item_opacity, 0.0);
  }
  #[inline]
  pub fn add_view_background_color(&mut self, view_background_color: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_VIEW_BACKGROUND_COLOR, view_background_color);
  }
  #[inline]
  pub fn add_scope(&mut self, scope: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_SCOPE, scope);
  }
  #[inline]
  pub fn add_scroll_x(&mut self, scroll_x: f32) {
    self.fbb_.push_slot::<f32>(AppState::VT_SCROLL_X, scroll_x, 0.0);
  }
  #[inline]
  pub fn add_scroll_y(&mut self, scroll_y: f32) {
    self.fbb_.push_slot::<f32>(AppState::VT_SCROLL_Y, scroll_y, 0.0);
  }
  #[inline]
  pub fn add_cursor_button(&mut self, cursor_button: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_CURSOR_BUTTON, cursor_button);
  }
  #[inline]
  pub fn add_scrolled_outside(&mut self, scrolled_outside: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_SCROLLED_OUTSIDE, scrolled_outside, false);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_NAME, name);
  }
  #[inline]
  pub fn add_zoom(&mut self, zoom: f32) {
    self.fbb_.push_slot::<f32>(AppState::VT_ZOOM, zoom, 0.0);
  }
  #[inline]
  pub fn add_last_pointer_down_with(&mut self, last_pointer_down_with: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_LAST_POINTER_DOWN_WITH, last_pointer_down_with);
  }
  #[inline]
  pub fn add_selected_element_ids(&mut self, selected_element_ids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_SELECTED_ELEMENT_IDS, selected_element_ids);
  }
  #[inline]
  pub fn add_grid_size(&mut self, grid_size: i32) {
    self.fbb_.push_slot::<i32>(AppState::VT_GRID_SIZE, grid_size, 0);
  }
  #[inline]
  pub fn add_scale_ratio_locked(&mut self, scale_ratio_locked: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_SCALE_RATIO_LOCKED, scale_ratio_locked, false);
  }
  #[inline]
  pub fn add_display_all_point_distances(&mut self, display_all_point_distances: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_DISPLAY_ALL_POINT_DISTANCES, display_all_point_distances, false);
  }
  #[inline]
  pub fn add_display_distance_on_drawing(&mut self, display_distance_on_drawing: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_DISPLAY_DISTANCE_ON_DRAWING, display_distance_on_drawing, false);
  }
  #[inline]
  pub fn add_display_all_point_coordinates(&mut self, display_all_point_coordinates: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_DISPLAY_ALL_POINT_COORDINATES, display_all_point_coordinates, false);
  }
  #[inline]
  pub fn add_display_all_point_info_selected(&mut self, display_all_point_info_selected: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_DISPLAY_ALL_POINT_INFO_SELECTED, display_all_point_info_selected, false);
  }
  #[inline]
  pub fn add_display_root_axis(&mut self, display_root_axis: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_DISPLAY_ROOT_AXIS, display_root_axis, false);
  }
  #[inline]
  pub fn add_current_item_text_align_v3(&mut self, current_item_text_align_v3: i8) {
    self.fbb_.push_slot::<i8>(AppState::VT_CURRENT_ITEM_TEXT_ALIGN_V3, current_item_text_align_v3, 0);
  }
  #[inline]
  pub fn add_line_bending_mode(&mut self, line_bending_mode: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_LINE_BENDING_MODE, line_bending_mode, false);
  }
  #[inline]
  pub fn add_current_item_font_size_v3(&mut self, current_item_font_size_v3: f64) {
    self.fbb_.push_slot::<f64>(AppState::VT_CURRENT_ITEM_FONT_SIZE_V3, current_item_font_size_v3, 0.0);
  }
  #[inline]
  pub fn add_coord_decimal_places_v3(&mut self, coord_decimal_places_v3: i8) {
    self.fbb_.push_slot::<i8>(AppState::VT_COORD_DECIMAL_PLACES_V3, coord_decimal_places_v3, 0);
  }
  #[inline]
  pub fn add_current_item_stroke(&mut self, current_item_stroke: flatbuffers::WIPOffset<ElementStroke<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ElementStroke>>(AppState::VT_CURRENT_ITEM_STROKE, current_item_stroke);
  }
  #[inline]
  pub fn add_current_item_background(&mut self, current_item_background: flatbuffers::WIPOffset<ElementBackground<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ElementBackground>>(AppState::VT_CURRENT_ITEM_BACKGROUND, current_item_background);
  }
  #[inline]
  pub fn add_main_scope(&mut self, main_scope: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_MAIN_SCOPE, main_scope);
  }
  #[inline]
  pub fn add_standard(&mut self, standard: i8) {
    self.fbb_.push_slot::<i8>(AppState::VT_STANDARD, standard, 0);
  }
  #[inline]
  pub fn add_current_item_start_line_head(&mut self, current_item_start_line_head: i8) {
    self.fbb_.push_slot_always::<i8>(AppState::VT_CURRENT_ITEM_START_LINE_HEAD, current_item_start_line_head);
  }
  #[inline]
  pub fn add_current_item_end_line_head(&mut self, current_item_end_line_head: i8) {
    self.fbb_.push_slot_always::<i8>(AppState::VT_CURRENT_ITEM_END_LINE_HEAD, current_item_end_line_head);
  }
  #[inline]
  pub fn add_current_item_roundness_v3(&mut self, current_item_roundness_v3: f64) {
    self.fbb_.push_slot::<f64>(AppState::VT_CURRENT_ITEM_ROUNDNESS_V3, current_item_roundness_v3, 0.0);
  }
  #[inline]
  pub fn add_anti_aliasing(&mut self, anti_aliasing: i8) {
    self.fbb_.push_slot::<i8>(AppState::VT_ANTI_ALIASING, anti_aliasing, 0);
  }
  #[inline]
  pub fn add_v_sync(&mut self, v_sync: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_V_SYNC, v_sync, false);
  }
  #[inline]
  pub fn add_current_item_font_family_v2(&mut self, current_item_font_family_v2: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_CURRENT_ITEM_FONT_FAMILY_V2, current_item_font_family_v2);
  }
  #[inline]
  pub fn add_debug_rendering(&mut self, debug_rendering: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_DEBUG_RENDERING, debug_rendering, false);
  }
  #[inline]
  pub fn add_current_item_subset(&mut self, current_item_subset: i8) {
    self.fbb_.push_slot_always::<i8>(AppState::VT_CURRENT_ITEM_SUBSET, current_item_subset);
  }
  #[inline]
  pub fn add_editing_linear_element(&mut self, editing_linear_element: flatbuffers::WIPOffset<LinearElementEditor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<LinearElementEditor>>(AppState::VT_EDITING_LINEAR_ELEMENT, editing_linear_element);
  }
  #[inline]
  pub fn add_grid_mode_enabled(&mut self, grid_mode_enabled: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_GRID_MODE_ENABLED, grid_mode_enabled, false);
  }
  #[inline]
  pub fn add_grid_step(&mut self, grid_step: i32) {
    self.fbb_.push_slot::<i32>(AppState::VT_GRID_STEP, grid_step, 0);
  }
  #[inline]
  pub fn add_scope_exponent_threshold(&mut self, scope_exponent_threshold: i8) {
    self.fbb_.push_slot::<i8>(AppState::VT_SCOPE_EXPONENT_THRESHOLD, scope_exponent_threshold, 0);
  }
  #[inline]
  pub fn add_zoom_step(&mut self, zoom_step: f32) {
    self.fbb_.push_slot::<f32>(AppState::VT_ZOOM_STEP, zoom_step, 0.0);
  }
  #[inline]
  pub fn add_hovered_element_id(&mut self, hovered_element_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_HOVERED_ELEMENT_ID, hovered_element_id);
  }
  #[inline]
  pub fn add_elements_pending_erasure(&mut self, elements_pending_erasure: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_ELEMENTS_PENDING_ERASURE, elements_pending_erasure);
  }
  #[inline]
  pub fn add_suggested_binding_element_id(&mut self, suggested_binding_element_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_SUGGESTED_BINDING_ELEMENT_ID, suggested_binding_element_id);
  }
  #[inline]
  pub fn add_is_binding_enabled(&mut self, is_binding_enabled: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_IS_BINDING_ENABLED, is_binding_enabled, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AppStateBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AppStateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AppState<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AppState<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AppState");
      ds.field("frame_rendering_enabled", &self.frame_rendering_enabled());
      ds.field("frame_rendering_name", &self.frame_rendering_name());
      ds.field("frame_rendering_outline", &self.frame_rendering_outline());
      ds.field("frame_rendering_clip", &self.frame_rendering_clip());
      ds.field("current_item_opacity", &self.current_item_opacity());
      ds.field("view_background_color", &self.view_background_color());
      ds.field("scope", &self.scope());
      ds.field("scroll_x", &self.scroll_x());
      ds.field("scroll_y", &self.scroll_y());
      ds.field("cursor_button", &self.cursor_button());
      ds.field("scrolled_outside", &self.scrolled_outside());
      ds.field("name", &self.name());
      ds.field("zoom", &self.zoom());
      ds.field("last_pointer_down_with", &self.last_pointer_down_with());
      ds.field("selected_element_ids", &self.selected_element_ids());
      ds.field("grid_size", &self.grid_size());
      ds.field("scale_ratio_locked", &self.scale_ratio_locked());
      ds.field("display_all_point_distances", &self.display_all_point_distances());
      ds.field("display_distance_on_drawing", &self.display_distance_on_drawing());
      ds.field("display_all_point_coordinates", &self.display_all_point_coordinates());
      ds.field("display_all_point_info_selected", &self.display_all_point_info_selected());
      ds.field("display_root_axis", &self.display_root_axis());
      ds.field("current_item_text_align_v3", &self.current_item_text_align_v3());
      ds.field("line_bending_mode", &self.line_bending_mode());
      ds.field("current_item_font_size_v3", &self.current_item_font_size_v3());
      ds.field("coord_decimal_places_v3", &self.coord_decimal_places_v3());
      ds.field("current_item_stroke", &self.current_item_stroke());
      ds.field("current_item_background", &self.current_item_background());
      ds.field("main_scope", &self.main_scope());
      ds.field("standard", &self.standard());
      ds.field("current_item_start_line_head", &self.current_item_start_line_head());
      ds.field("current_item_end_line_head", &self.current_item_end_line_head());
      ds.field("current_item_roundness_v3", &self.current_item_roundness_v3());
      ds.field("anti_aliasing", &self.anti_aliasing());
      ds.field("v_sync", &self.v_sync());
      ds.field("current_item_font_family_v2", &self.current_item_font_family_v2());
      ds.field("debug_rendering", &self.debug_rendering());
      ds.field("current_item_subset", &self.current_item_subset());
      ds.field("editing_linear_element", &self.editing_linear_element());
      ds.field("grid_mode_enabled", &self.grid_mode_enabled());
      ds.field("grid_step", &self.grid_step());
      ds.field("scope_exponent_threshold", &self.scope_exponent_threshold());
      ds.field("zoom_step", &self.zoom_step());
      ds.field("hovered_element_id", &self.hovered_element_id());
      ds.field("elements_pending_erasure", &self.elements_pending_erasure());
      ds.field("suggested_binding_element_id", &self.suggested_binding_element_id());
      ds.field("is_binding_enabled", &self.is_binding_enabled());
      ds.finish()
  }
}
pub enum BinaryFileDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BinaryFileData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BinaryFileData<'a> {
  type Inner = BinaryFileData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BinaryFileData<'a> {
  pub const VT_MIME_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_ID: flatbuffers::VOffsetT = 6;
  pub const VT_DATA: flatbuffers::VOffsetT = 8;
  pub const VT_CREATED: flatbuffers::VOffsetT = 10;
  pub const VT_LAST_RETRIEVED: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BinaryFileData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BinaryFileDataArgs<'args>
  ) -> flatbuffers::WIPOffset<BinaryFileData<'bldr>> {
    let mut builder = BinaryFileDataBuilder::new(_fbb);
    builder.add_last_retrieved(args.last_retrieved);
    builder.add_created(args.created);
    if let Some(x) = args.data { builder.add_data(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    if let Some(x) = args.mime_type { builder.add_mime_type(x); }
    builder.finish()
  }


  #[inline]
  pub fn mime_type(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BinaryFileData::VT_MIME_TYPE, None)}
  }
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BinaryFileData::VT_ID, None)}
  }
  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(BinaryFileData::VT_DATA, None)}
  }
  #[inline]
  pub fn created(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(BinaryFileData::VT_CREATED, Some(0)).unwrap()}
  }
  #[inline]
  pub fn last_retrieved(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(BinaryFileData::VT_LAST_RETRIEVED, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for BinaryFileData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("mime_type", Self::VT_MIME_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("data", Self::VT_DATA, false)?
     .visit_field::<i64>("created", Self::VT_CREATED, false)?
     .visit_field::<i64>("last_retrieved", Self::VT_LAST_RETRIEVED, false)?
     .finish();
    Ok(())
  }
}
pub struct BinaryFileDataArgs<'a> {
    pub mime_type: Option<flatbuffers::WIPOffset<&'a str>>,
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub created: i64,
    pub last_retrieved: i64,
}
impl<'a> Default for BinaryFileDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    BinaryFileDataArgs {
      mime_type: None,
      id: None,
      data: None,
      created: 0,
      last_retrieved: 0,
    }
  }
}

pub struct BinaryFileDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BinaryFileDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_mime_type(&mut self, mime_type: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryFileData::VT_MIME_TYPE, mime_type);
  }
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryFileData::VT_ID, id);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryFileData::VT_DATA, data);
  }
  #[inline]
  pub fn add_created(&mut self, created: i64) {
    self.fbb_.push_slot::<i64>(BinaryFileData::VT_CREATED, created, 0);
  }
  #[inline]
  pub fn add_last_retrieved(&mut self, last_retrieved: i64) {
    self.fbb_.push_slot::<i64>(BinaryFileData::VT_LAST_RETRIEVED, last_retrieved, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BinaryFileDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BinaryFileDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BinaryFileData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BinaryFileData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BinaryFileData");
      ds.field("mime_type", &self.mime_type());
      ds.field("id", &self.id());
      ds.field("data", &self.data());
      ds.field("created", &self.created());
      ds.field("last_retrieved", &self.last_retrieved());
      ds.finish()
  }
}
pub enum BinaryFilesEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BinaryFilesEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BinaryFilesEntry<'a> {
  type Inner = BinaryFilesEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BinaryFilesEntry<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BinaryFilesEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BinaryFilesEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<BinaryFilesEntry<'bldr>> {
    let mut builder = BinaryFilesEntryBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BinaryFilesEntry::VT_KEY, None)}
  }
  #[inline]
  pub fn value(&self) -> Option<BinaryFileData<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<BinaryFileData>>(BinaryFilesEntry::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for BinaryFilesEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<BinaryFileData>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct BinaryFilesEntryArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<BinaryFileData<'a>>>,
}
impl<'a> Default for BinaryFilesEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    BinaryFilesEntryArgs {
      key: None,
      value: None,
    }
  }
}

pub struct BinaryFilesEntryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BinaryFilesEntryBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryFilesEntry::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<BinaryFileData<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<BinaryFileData>>(BinaryFilesEntry::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BinaryFilesEntryBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BinaryFilesEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BinaryFilesEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BinaryFilesEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BinaryFilesEntry");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum BinaryFilesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BinaryFiles<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BinaryFiles<'a> {
  type Inner = BinaryFiles<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BinaryFiles<'a> {
  pub const VT_ENTRIES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BinaryFiles { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BinaryFilesArgs<'args>
  ) -> flatbuffers::WIPOffset<BinaryFiles<'bldr>> {
    let mut builder = BinaryFilesBuilder::new(_fbb);
    if let Some(x) = args.entries { builder.add_entries(x); }
    builder.finish()
  }


  #[inline]
  pub fn entries(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinaryFilesEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinaryFilesEntry>>>>(BinaryFiles::VT_ENTRIES, None)}
  }
}

impl flatbuffers::Verifiable for BinaryFiles<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BinaryFilesEntry>>>>("entries", Self::VT_ENTRIES, false)?
     .finish();
    Ok(())
  }
}
pub struct BinaryFilesArgs<'a> {
    pub entries: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinaryFilesEntry<'a>>>>>,
}
impl<'a> Default for BinaryFilesArgs<'a> {
  #[inline]
  fn default() -> Self {
    BinaryFilesArgs {
      entries: None,
    }
  }
}

pub struct BinaryFilesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BinaryFilesBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_entries(&mut self, entries: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinaryFilesEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryFiles::VT_ENTRIES, entries);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BinaryFilesBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BinaryFilesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BinaryFiles<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BinaryFiles<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BinaryFiles");
      ds.field("entries", &self.entries());
      ds.finish()
  }
}
pub enum RendererStateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RendererState<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RendererState<'a> {
  type Inner = RendererState<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> RendererState<'a> {
  pub const VT_DELETED_ELEMENT_IDS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    RendererState { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RendererStateArgs<'args>
  ) -> flatbuffers::WIPOffset<RendererState<'bldr>> {
    let mut builder = RendererStateBuilder::new(_fbb);
    if let Some(x) = args.deleted_element_ids { builder.add_deleted_element_ids(x); }
    builder.finish()
  }


  #[inline]
  pub fn deleted_element_ids(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(RendererState::VT_DELETED_ELEMENT_IDS, None)}
  }
}

impl flatbuffers::Verifiable for RendererState<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("deleted_element_ids", Self::VT_DELETED_ELEMENT_IDS, false)?
     .finish();
    Ok(())
  }
}
pub struct RendererStateArgs<'a> {
    pub deleted_element_ids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for RendererStateArgs<'a> {
  #[inline]
  fn default() -> Self {
    RendererStateArgs {
      deleted_element_ids: None,
    }
  }
}

pub struct RendererStateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> RendererStateBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_deleted_element_ids(&mut self, deleted_element_ids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RendererState::VT_DELETED_ELEMENT_IDS, deleted_element_ids);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> RendererStateBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RendererStateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<RendererState<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for RendererState<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("RendererState");
      ds.field("deleted_element_ids", &self.deleted_element_ids());
      ds.finish()
  }
}
pub enum ExportedDataStateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ExportedDataState<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExportedDataState<'a> {
  type Inner = ExportedDataState<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ExportedDataState<'a> {
  pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
  pub const VT_VERSION_LEGACY: flatbuffers::VOffsetT = 6;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 8;
  pub const VT_ELEMENTS: flatbuffers::VOffsetT = 10;
  pub const VT_APP_STATE: flatbuffers::VOffsetT = 12;
  pub const VT_FILES: flatbuffers::VOffsetT = 14;
  pub const VT_RENDERER_STATE: flatbuffers::VOffsetT = 16;
  pub const VT_BLOCKS: flatbuffers::VOffsetT = 18;
  pub const VT_GROUPS: flatbuffers::VOffsetT = 20;
  pub const VT_VERSION: flatbuffers::VOffsetT = 22;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ExportedDataState { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ExportedDataStateArgs<'args>
  ) -> flatbuffers::WIPOffset<ExportedDataState<'bldr>> {
    let mut builder = ExportedDataStateBuilder::new(_fbb);
    if let Some(x) = args.version { builder.add_version(x); }
    if let Some(x) = args.groups { builder.add_groups(x); }
    if let Some(x) = args.blocks { builder.add_blocks(x); }
    if let Some(x) = args.renderer_state { builder.add_renderer_state(x); }
    if let Some(x) = args.files { builder.add_files(x); }
    if let Some(x) = args.app_state { builder.add_app_state(x); }
    if let Some(x) = args.elements { builder.add_elements(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    builder.add_version_legacy(args.version_legacy);
    if let Some(x) = args.type_ { builder.add_type_(x); }
    builder.finish()
  }


  #[inline]
  pub fn type_(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ExportedDataState::VT_TYPE_, None)}
  }
  #[inline]
  pub fn version_legacy(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ExportedDataState::VT_VERSION_LEGACY, Some(0)).unwrap()}
  }
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ExportedDataState::VT_SOURCE, None)}
  }
  #[inline]
  pub fn elements(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucElement<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucElement>>>>(ExportedDataState::VT_ELEMENTS, None)}
  }
  #[inline]
  pub fn app_state(&self) -> Option<AppState<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<AppState>>(ExportedDataState::VT_APP_STATE, None)}
  }
  #[inline]
  pub fn files(&self) -> Option<BinaryFiles<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<BinaryFiles>>(ExportedDataState::VT_FILES, None)}
  }
  #[inline]
  pub fn renderer_state(&self) -> Option<RendererState<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<RendererState>>(ExportedDataState::VT_RENDERER_STATE, None)}
  }
  #[inline]
  pub fn blocks(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucBlock<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucBlock>>>>(ExportedDataState::VT_BLOCKS, None)}
  }
  #[inline]
  pub fn groups(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucGroup<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucGroup>>>>(ExportedDataState::VT_GROUPS, None)}
  }
  #[inline]
  pub fn version(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ExportedDataState::VT_VERSION, None)}
  }
}

impl flatbuffers::Verifiable for ExportedDataState<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, false)?
     .visit_field::<i32>("version_legacy", Self::VT_VERSION_LEGACY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DucElement>>>>("elements", Self::VT_ELEMENTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<AppState>>("app_state", Self::VT_APP_STATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<BinaryFiles>>("files", Self::VT_FILES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<RendererState>>("renderer_state", Self::VT_RENDERER_STATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DucBlock>>>>("blocks", Self::VT_BLOCKS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DucGroup>>>>("groups", Self::VT_GROUPS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("version", Self::VT_VERSION, false)?
     .finish();
    Ok(())
  }
}
pub struct ExportedDataStateArgs<'a> {
    pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
    pub version_legacy: i32,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub elements: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucElement<'a>>>>>,
    pub app_state: Option<flatbuffers::WIPOffset<AppState<'a>>>,
    pub files: Option<flatbuffers::WIPOffset<BinaryFiles<'a>>>,
    pub renderer_state: Option<flatbuffers::WIPOffset<RendererState<'a>>>,
    pub blocks: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucBlock<'a>>>>>,
    pub groups: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucGroup<'a>>>>>,
    pub version: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ExportedDataStateArgs<'a> {
  #[inline]
  fn default() -> Self {
    ExportedDataStateArgs {
      type_: None,
      version_legacy: 0,
      source: None,
      elements: None,
      app_state: None,
      files: None,
      renderer_state: None,
      blocks: None,
      groups: None,
      version: None,
    }
  }
}

pub struct ExportedDataStateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ExportedDataStateBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ExportedDataState::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_version_legacy(&mut self, version_legacy: i32) {
    self.fbb_.push_slot::<i32>(ExportedDataState::VT_VERSION_LEGACY, version_legacy, 0);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ExportedDataState::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_elements(&mut self, elements: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DucElement<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ExportedDataState::VT_ELEMENTS, elements);
  }
  #[inline]
  pub fn add_app_state(&mut self, app_state: flatbuffers::WIPOffset<AppState<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<AppState>>(ExportedDataState::VT_APP_STATE, app_state);
  }
  #[inline]
  pub fn add_files(&mut self, files: flatbuffers::WIPOffset<BinaryFiles<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<BinaryFiles>>(ExportedDataState::VT_FILES, files);
  }
  #[inline]
  pub fn add_renderer_state(&mut self, renderer_state: flatbuffers::WIPOffset<RendererState<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RendererState>>(ExportedDataState::VT_RENDERER_STATE, renderer_state);
  }
  #[inline]
  pub fn add_blocks(&mut self, blocks: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DucBlock<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ExportedDataState::VT_BLOCKS, blocks);
  }
  #[inline]
  pub fn add_groups(&mut self, groups: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DucGroup<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ExportedDataState::VT_GROUPS, groups);
  }
  #[inline]
  pub fn add_version(&mut self, version: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ExportedDataState::VT_VERSION, version);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ExportedDataStateBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ExportedDataStateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ExportedDataState<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ExportedDataState<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ExportedDataState");
      ds.field("type_", &self.type_());
      ds.field("version_legacy", &self.version_legacy());
      ds.field("source", &self.source());
      ds.field("elements", &self.elements());
      ds.field("app_state", &self.app_state());
      ds.field("files", &self.files());
      ds.field("renderer_state", &self.renderer_state());
      ds.field("blocks", &self.blocks());
      ds.field("groups", &self.groups());
      ds.field("version", &self.version());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `ExportedDataState`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_exported_data_state_unchecked`.
pub fn root_as_exported_data_state(buf: &[u8]) -> Result<ExportedDataState, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<ExportedDataState>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `ExportedDataState` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_exported_data_state_unchecked`.
pub fn size_prefixed_root_as_exported_data_state(buf: &[u8]) -> Result<ExportedDataState, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<ExportedDataState>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `ExportedDataState` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_exported_data_state_unchecked`.
pub fn root_as_exported_data_state_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ExportedDataState<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<ExportedDataState<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `ExportedDataState` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_exported_data_state_unchecked`.
pub fn size_prefixed_root_as_exported_data_state_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ExportedDataState<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<ExportedDataState<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a ExportedDataState and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `ExportedDataState`.
pub unsafe fn root_as_exported_data_state_unchecked(buf: &[u8]) -> ExportedDataState {
  flatbuffers::root_unchecked::<ExportedDataState>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed ExportedDataState and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `ExportedDataState`.
pub unsafe fn size_prefixed_root_as_exported_data_state_unchecked(buf: &[u8]) -> ExportedDataState {
  flatbuffers::size_prefixed_root_unchecked::<ExportedDataState>(buf)
}
pub const EXPORTED_DATA_STATE_IDENTIFIER: &str = "DUC_";

#[inline]
pub fn exported_data_state_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, EXPORTED_DATA_STATE_IDENTIFIER, false)
}

#[inline]
pub fn exported_data_state_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, EXPORTED_DATA_STATE_IDENTIFIER, true)
}

#[inline]
pub fn finish_exported_data_state_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<ExportedDataState<'a>>) {
  fbb.finish(root, Some(EXPORTED_DATA_STATE_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_exported_data_state_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<ExportedDataState<'a>>) {
  fbb.finish_size_prefixed(root, Some(EXPORTED_DATA_STATE_IDENTIFIER));
}
}  // pub mod Duc

