// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod duc {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_VERTICAL_ALIGN: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_VERTICAL_ALIGN: u8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_VERTICAL_ALIGN: [VERTICAL_ALIGN; 3] = [
  VERTICAL_ALIGN::TOP,
  VERTICAL_ALIGN::MIDDLE,
  VERTICAL_ALIGN::BOTTOM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct VERTICAL_ALIGN(pub u8);
#[allow(non_upper_case_globals)]
impl VERTICAL_ALIGN {
  pub const TOP: Self = Self(10);
  pub const MIDDLE: Self = Self(11);
  pub const BOTTOM: Self = Self(12);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::TOP,
    Self::MIDDLE,
    Self::BOTTOM,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::TOP => Some("TOP"),
      Self::MIDDLE => Some("MIDDLE"),
      Self::BOTTOM => Some("BOTTOM"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for VERTICAL_ALIGN {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for VERTICAL_ALIGN {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for VERTICAL_ALIGN {
    type Output = VERTICAL_ALIGN;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for VERTICAL_ALIGN {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for VERTICAL_ALIGN {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for VERTICAL_ALIGN {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TEXT_ALIGN: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TEXT_ALIGN: u8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TEXT_ALIGN: [TEXT_ALIGN; 3] = [
  TEXT_ALIGN::LEFT,
  TEXT_ALIGN::CENTER,
  TEXT_ALIGN::RIGHT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TEXT_ALIGN(pub u8);
#[allow(non_upper_case_globals)]
impl TEXT_ALIGN {
  pub const LEFT: Self = Self(10);
  pub const CENTER: Self = Self(11);
  pub const RIGHT: Self = Self(12);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::LEFT,
    Self::CENTER,
    Self::RIGHT,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::LEFT => Some("LEFT"),
      Self::CENTER => Some("CENTER"),
      Self::RIGHT => Some("RIGHT"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for TEXT_ALIGN {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for TEXT_ALIGN {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for TEXT_ALIGN {
    type Output = TEXT_ALIGN;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for TEXT_ALIGN {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for TEXT_ALIGN {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TEXT_ALIGN {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_LINE_SPACING_TYPE: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_LINE_SPACING_TYPE: u8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_LINE_SPACING_TYPE: [LINE_SPACING_TYPE; 3] = [
  LINE_SPACING_TYPE::AT_LEAST,
  LINE_SPACING_TYPE::EXACTLY,
  LINE_SPACING_TYPE::MULTIPLE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct LINE_SPACING_TYPE(pub u8);
#[allow(non_upper_case_globals)]
impl LINE_SPACING_TYPE {
  pub const AT_LEAST: Self = Self(10);
  pub const EXACTLY: Self = Self(11);
  pub const MULTIPLE: Self = Self(12);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::AT_LEAST,
    Self::EXACTLY,
    Self::MULTIPLE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::AT_LEAST => Some("AT_LEAST"),
      Self::EXACTLY => Some("EXACTLY"),
      Self::MULTIPLE => Some("MULTIPLE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for LINE_SPACING_TYPE {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for LINE_SPACING_TYPE {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for LINE_SPACING_TYPE {
    type Output = LINE_SPACING_TYPE;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for LINE_SPACING_TYPE {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for LINE_SPACING_TYPE {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for LINE_SPACING_TYPE {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_STACKED_TEXT_ALIGN: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_STACKED_TEXT_ALIGN: u8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_STACKED_TEXT_ALIGN: [STACKED_TEXT_ALIGN; 3] = [
  STACKED_TEXT_ALIGN::CENTER,
  STACKED_TEXT_ALIGN::DECIMAL,
  STACKED_TEXT_ALIGN::SLASH,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct STACKED_TEXT_ALIGN(pub u8);
#[allow(non_upper_case_globals)]
impl STACKED_TEXT_ALIGN {
  pub const CENTER: Self = Self(10);
  pub const DECIMAL: Self = Self(11);
  pub const SLASH: Self = Self(12);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::CENTER,
    Self::DECIMAL,
    Self::SLASH,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::CENTER => Some("CENTER"),
      Self::DECIMAL => Some("DECIMAL"),
      Self::SLASH => Some("SLASH"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for STACKED_TEXT_ALIGN {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for STACKED_TEXT_ALIGN {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for STACKED_TEXT_ALIGN {
    type Output = STACKED_TEXT_ALIGN;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for STACKED_TEXT_ALIGN {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for STACKED_TEXT_ALIGN {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for STACKED_TEXT_ALIGN {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TEXT_FIELD_SOURCE_TYPE: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TEXT_FIELD_SOURCE_TYPE: u8 = 20;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TEXT_FIELD_SOURCE_TYPE: [TEXT_FIELD_SOURCE_TYPE; 2] = [
  TEXT_FIELD_SOURCE_TYPE::ELEMENT,
  TEXT_FIELD_SOURCE_TYPE::DICTIONARY,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TEXT_FIELD_SOURCE_TYPE(pub u8);
#[allow(non_upper_case_globals)]
impl TEXT_FIELD_SOURCE_TYPE {
  pub const ELEMENT: Self = Self(10);
  pub const DICTIONARY: Self = Self(20);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 20;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ELEMENT,
    Self::DICTIONARY,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::ELEMENT => Some("ELEMENT"),
      Self::DICTIONARY => Some("DICTIONARY"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for TEXT_FIELD_SOURCE_TYPE {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for TEXT_FIELD_SOURCE_TYPE {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for TEXT_FIELD_SOURCE_TYPE {
    type Output = TEXT_FIELD_SOURCE_TYPE;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for TEXT_FIELD_SOURCE_TYPE {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for TEXT_FIELD_SOURCE_TYPE {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TEXT_FIELD_SOURCE_TYPE {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TEXT_FIELD_SOURCE_PROPERTY: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TEXT_FIELD_SOURCE_PROPERTY: u8 = 20;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TEXT_FIELD_SOURCE_PROPERTY: [TEXT_FIELD_SOURCE_PROPERTY; 11] = [
  TEXT_FIELD_SOURCE_PROPERTY::AREA,
  TEXT_FIELD_SOURCE_PROPERTY::PERIMETER,
  TEXT_FIELD_SOURCE_PROPERTY::VOLUME,
  TEXT_FIELD_SOURCE_PROPERTY::LENGTH,
  TEXT_FIELD_SOURCE_PROPERTY::WIDTH,
  TEXT_FIELD_SOURCE_PROPERTY::HEIGHT,
  TEXT_FIELD_SOURCE_PROPERTY::RADIUS,
  TEXT_FIELD_SOURCE_PROPERTY::DIAMETER,
  TEXT_FIELD_SOURCE_PROPERTY::X_COORDINATE,
  TEXT_FIELD_SOURCE_PROPERTY::Y_COORDINATE,
  TEXT_FIELD_SOURCE_PROPERTY::LABEL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TEXT_FIELD_SOURCE_PROPERTY(pub u8);
#[allow(non_upper_case_globals)]
impl TEXT_FIELD_SOURCE_PROPERTY {
  pub const AREA: Self = Self(10);
  pub const PERIMETER: Self = Self(11);
  pub const VOLUME: Self = Self(12);
  pub const LENGTH: Self = Self(13);
  pub const WIDTH: Self = Self(14);
  pub const HEIGHT: Self = Self(15);
  pub const RADIUS: Self = Self(16);
  pub const DIAMETER: Self = Self(17);
  pub const X_COORDINATE: Self = Self(18);
  pub const Y_COORDINATE: Self = Self(19);
  pub const LABEL: Self = Self(20);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 20;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::AREA,
    Self::PERIMETER,
    Self::VOLUME,
    Self::LENGTH,
    Self::WIDTH,
    Self::HEIGHT,
    Self::RADIUS,
    Self::DIAMETER,
    Self::X_COORDINATE,
    Self::Y_COORDINATE,
    Self::LABEL,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::AREA => Some("AREA"),
      Self::PERIMETER => Some("PERIMETER"),
      Self::VOLUME => Some("VOLUME"),
      Self::LENGTH => Some("LENGTH"),
      Self::WIDTH => Some("WIDTH"),
      Self::HEIGHT => Some("HEIGHT"),
      Self::RADIUS => Some("RADIUS"),
      Self::DIAMETER => Some("DIAMETER"),
      Self::X_COORDINATE => Some("X_COORDINATE"),
      Self::Y_COORDINATE => Some("Y_COORDINATE"),
      Self::LABEL => Some("LABEL"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for TEXT_FIELD_SOURCE_PROPERTY {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for TEXT_FIELD_SOURCE_PROPERTY {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for TEXT_FIELD_SOURCE_PROPERTY {
    type Output = TEXT_FIELD_SOURCE_PROPERTY;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for TEXT_FIELD_SOURCE_PROPERTY {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for TEXT_FIELD_SOURCE_PROPERTY {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TEXT_FIELD_SOURCE_PROPERTY {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_STROKE_PLACEMENT: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_STROKE_PLACEMENT: u8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_STROKE_PLACEMENT: [STROKE_PLACEMENT; 3] = [
  STROKE_PLACEMENT::INSIDE,
  STROKE_PLACEMENT::CENTER,
  STROKE_PLACEMENT::OUTSIDE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct STROKE_PLACEMENT(pub u8);
#[allow(non_upper_case_globals)]
impl STROKE_PLACEMENT {
  pub const INSIDE: Self = Self(10);
  pub const CENTER: Self = Self(11);
  pub const OUTSIDE: Self = Self(12);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::INSIDE,
    Self::CENTER,
    Self::OUTSIDE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::INSIDE => Some("INSIDE"),
      Self::CENTER => Some("CENTER"),
      Self::OUTSIDE => Some("OUTSIDE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for STROKE_PLACEMENT {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for STROKE_PLACEMENT {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for STROKE_PLACEMENT {
    type Output = STROKE_PLACEMENT;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for STROKE_PLACEMENT {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for STROKE_PLACEMENT {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for STROKE_PLACEMENT {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_STROKE_WIDTH: u8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_STROKE_WIDTH: u8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_STROKE_WIDTH: [STROKE_WIDTH; 3] = [
  STROKE_WIDTH::THIN,
  STROKE_WIDTH::BOLD,
  STROKE_WIDTH::EXTRA_BOLD,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct STROKE_WIDTH(pub u8);
#[allow(non_upper_case_globals)]
impl STROKE_WIDTH {
  pub const THIN: Self = Self(1);
  pub const BOLD: Self = Self(2);
  pub const EXTRA_BOLD: Self = Self(4);

  pub const ENUM_MIN: u8 = 1;
  pub const ENUM_MAX: u8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::THIN,
    Self::BOLD,
    Self::EXTRA_BOLD,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::THIN => Some("THIN"),
      Self::BOLD => Some("BOLD"),
      Self::EXTRA_BOLD => Some("EXTRA_BOLD"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for STROKE_WIDTH {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for STROKE_WIDTH {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for STROKE_WIDTH {
    type Output = STROKE_WIDTH;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for STROKE_WIDTH {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for STROKE_WIDTH {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for STROKE_WIDTH {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ELEMENT_CONTENT_PREFERENCE: u8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ELEMENT_CONTENT_PREFERENCE: u8 = 18;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ELEMENT_CONTENT_PREFERENCE: [ELEMENT_CONTENT_PREFERENCE; 6] = [
  ELEMENT_CONTENT_PREFERENCE::SOLID,
  ELEMENT_CONTENT_PREFERENCE::FILL,
  ELEMENT_CONTENT_PREFERENCE::FIT,
  ELEMENT_CONTENT_PREFERENCE::TILE,
  ELEMENT_CONTENT_PREFERENCE::STRETCH,
  ELEMENT_CONTENT_PREFERENCE::HATCH,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ELEMENT_CONTENT_PREFERENCE(pub u8);
#[allow(non_upper_case_globals)]
impl ELEMENT_CONTENT_PREFERENCE {
  pub const SOLID: Self = Self(12);
  pub const FILL: Self = Self(14);
  pub const FIT: Self = Self(15);
  pub const TILE: Self = Self(16);
  pub const STRETCH: Self = Self(17);
  pub const HATCH: Self = Self(18);

  pub const ENUM_MIN: u8 = 12;
  pub const ENUM_MAX: u8 = 18;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SOLID,
    Self::FILL,
    Self::FIT,
    Self::TILE,
    Self::STRETCH,
    Self::HATCH,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::SOLID => Some("SOLID"),
      Self::FILL => Some("FILL"),
      Self::FIT => Some("FIT"),
      Self::TILE => Some("TILE"),
      Self::STRETCH => Some("STRETCH"),
      Self::HATCH => Some("HATCH"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ELEMENT_CONTENT_PREFERENCE {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ELEMENT_CONTENT_PREFERENCE {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ELEMENT_CONTENT_PREFERENCE {
    type Output = ELEMENT_CONTENT_PREFERENCE;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ELEMENT_CONTENT_PREFERENCE {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ELEMENT_CONTENT_PREFERENCE {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ELEMENT_CONTENT_PREFERENCE {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_STROKE_PREFERENCE: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_STROKE_PREFERENCE: u8 = 13;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_STROKE_PREFERENCE: [STROKE_PREFERENCE; 4] = [
  STROKE_PREFERENCE::SOLID,
  STROKE_PREFERENCE::DASHED,
  STROKE_PREFERENCE::DOTTED,
  STROKE_PREFERENCE::CUSTOM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct STROKE_PREFERENCE(pub u8);
#[allow(non_upper_case_globals)]
impl STROKE_PREFERENCE {
  pub const SOLID: Self = Self(10);
  pub const DASHED: Self = Self(11);
  pub const DOTTED: Self = Self(12);
  pub const CUSTOM: Self = Self(13);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 13;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SOLID,
    Self::DASHED,
    Self::DOTTED,
    Self::CUSTOM,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::SOLID => Some("SOLID"),
      Self::DASHED => Some("DASHED"),
      Self::DOTTED => Some("DOTTED"),
      Self::CUSTOM => Some("CUSTOM"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for STROKE_PREFERENCE {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for STROKE_PREFERENCE {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for STROKE_PREFERENCE {
    type Output = STROKE_PREFERENCE;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for STROKE_PREFERENCE {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for STROKE_PREFERENCE {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for STROKE_PREFERENCE {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_STROKE_SIDE_PREFERENCE: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_STROKE_SIDE_PREFERENCE: u8 = 15;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_STROKE_SIDE_PREFERENCE: [STROKE_SIDE_PREFERENCE; 6] = [
  STROKE_SIDE_PREFERENCE::TOP,
  STROKE_SIDE_PREFERENCE::BOTTOM,
  STROKE_SIDE_PREFERENCE::LEFT,
  STROKE_SIDE_PREFERENCE::RIGHT,
  STROKE_SIDE_PREFERENCE::CUSTOM,
  STROKE_SIDE_PREFERENCE::ALL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct STROKE_SIDE_PREFERENCE(pub u8);
#[allow(non_upper_case_globals)]
impl STROKE_SIDE_PREFERENCE {
  pub const TOP: Self = Self(10);
  pub const BOTTOM: Self = Self(11);
  pub const LEFT: Self = Self(12);
  pub const RIGHT: Self = Self(13);
  pub const CUSTOM: Self = Self(14);
  pub const ALL: Self = Self(15);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 15;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::TOP,
    Self::BOTTOM,
    Self::LEFT,
    Self::RIGHT,
    Self::CUSTOM,
    Self::ALL,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::TOP => Some("TOP"),
      Self::BOTTOM => Some("BOTTOM"),
      Self::LEFT => Some("LEFT"),
      Self::RIGHT => Some("RIGHT"),
      Self::CUSTOM => Some("CUSTOM"),
      Self::ALL => Some("ALL"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for STROKE_SIDE_PREFERENCE {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for STROKE_SIDE_PREFERENCE {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for STROKE_SIDE_PREFERENCE {
    type Output = STROKE_SIDE_PREFERENCE;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for STROKE_SIDE_PREFERENCE {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for STROKE_SIDE_PREFERENCE {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for STROKE_SIDE_PREFERENCE {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_STROKE_CAP: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_STROKE_CAP: u8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_STROKE_CAP: [STROKE_CAP; 3] = [
  STROKE_CAP::BUTT,
  STROKE_CAP::ROUND,
  STROKE_CAP::SQUARE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct STROKE_CAP(pub u8);
#[allow(non_upper_case_globals)]
impl STROKE_CAP {
  pub const BUTT: Self = Self(10);
  pub const ROUND: Self = Self(11);
  pub const SQUARE: Self = Self(12);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::BUTT,
    Self::ROUND,
    Self::SQUARE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::BUTT => Some("BUTT"),
      Self::ROUND => Some("ROUND"),
      Self::SQUARE => Some("SQUARE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for STROKE_CAP {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for STROKE_CAP {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for STROKE_CAP {
    type Output = STROKE_CAP;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for STROKE_CAP {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for STROKE_CAP {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for STROKE_CAP {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_STROKE_JOIN: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_STROKE_JOIN: u8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_STROKE_JOIN: [STROKE_JOIN; 3] = [
  STROKE_JOIN::MITER,
  STROKE_JOIN::ROUND,
  STROKE_JOIN::BEVEL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct STROKE_JOIN(pub u8);
#[allow(non_upper_case_globals)]
impl STROKE_JOIN {
  pub const MITER: Self = Self(10);
  pub const ROUND: Self = Self(11);
  pub const BEVEL: Self = Self(12);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::MITER,
    Self::ROUND,
    Self::BEVEL,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::MITER => Some("MITER"),
      Self::ROUND => Some("ROUND"),
      Self::BEVEL => Some("BEVEL"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for STROKE_JOIN {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for STROKE_JOIN {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for STROKE_JOIN {
    type Output = STROKE_JOIN;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for STROKE_JOIN {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for STROKE_JOIN {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for STROKE_JOIN {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_LINE_HEAD: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_LINE_HEAD: u8 = 24;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_LINE_HEAD: [LINE_HEAD; 15] = [
  LINE_HEAD::ARROW,
  LINE_HEAD::BAR,
  LINE_HEAD::CIRCLE,
  LINE_HEAD::CIRCLE_OUTLINED,
  LINE_HEAD::TRIANGLE,
  LINE_HEAD::TRIANGLE_OUTLINED,
  LINE_HEAD::DIAMOND,
  LINE_HEAD::DIAMOND_OUTLINED,
  LINE_HEAD::CROSS,
  LINE_HEAD::OPEN_ARROW,
  LINE_HEAD::REVERSED_ARROW,
  LINE_HEAD::REVERSED_TRIANGLE,
  LINE_HEAD::REVERSED_TRIANGLE_OUTLINED,
  LINE_HEAD::CONE,
  LINE_HEAD::HALF_CONE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct LINE_HEAD(pub u8);
#[allow(non_upper_case_globals)]
impl LINE_HEAD {
  pub const ARROW: Self = Self(10);
  pub const BAR: Self = Self(11);
  pub const CIRCLE: Self = Self(12);
  pub const CIRCLE_OUTLINED: Self = Self(13);
  pub const TRIANGLE: Self = Self(14);
  pub const TRIANGLE_OUTLINED: Self = Self(15);
  pub const DIAMOND: Self = Self(16);
  pub const DIAMOND_OUTLINED: Self = Self(17);
  pub const CROSS: Self = Self(18);
  pub const OPEN_ARROW: Self = Self(19);
  pub const REVERSED_ARROW: Self = Self(20);
  pub const REVERSED_TRIANGLE: Self = Self(21);
  pub const REVERSED_TRIANGLE_OUTLINED: Self = Self(22);
  pub const CONE: Self = Self(23);
  pub const HALF_CONE: Self = Self(24);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 24;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::ARROW,
    Self::BAR,
    Self::CIRCLE,
    Self::CIRCLE_OUTLINED,
    Self::TRIANGLE,
    Self::TRIANGLE_OUTLINED,
    Self::DIAMOND,
    Self::DIAMOND_OUTLINED,
    Self::CROSS,
    Self::OPEN_ARROW,
    Self::REVERSED_ARROW,
    Self::REVERSED_TRIANGLE,
    Self::REVERSED_TRIANGLE_OUTLINED,
    Self::CONE,
    Self::HALF_CONE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::ARROW => Some("ARROW"),
      Self::BAR => Some("BAR"),
      Self::CIRCLE => Some("CIRCLE"),
      Self::CIRCLE_OUTLINED => Some("CIRCLE_OUTLINED"),
      Self::TRIANGLE => Some("TRIANGLE"),
      Self::TRIANGLE_OUTLINED => Some("TRIANGLE_OUTLINED"),
      Self::DIAMOND => Some("DIAMOND"),
      Self::DIAMOND_OUTLINED => Some("DIAMOND_OUTLINED"),
      Self::CROSS => Some("CROSS"),
      Self::OPEN_ARROW => Some("OPEN_ARROW"),
      Self::REVERSED_ARROW => Some("REVERSED_ARROW"),
      Self::REVERSED_TRIANGLE => Some("REVERSED_TRIANGLE"),
      Self::REVERSED_TRIANGLE_OUTLINED => Some("REVERSED_TRIANGLE_OUTLINED"),
      Self::CONE => Some("CONE"),
      Self::HALF_CONE => Some("HALF_CONE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for LINE_HEAD {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for LINE_HEAD {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for LINE_HEAD {
    type Output = LINE_HEAD;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for LINE_HEAD {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for LINE_HEAD {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for LINE_HEAD {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_BEZIER_MIRRORING: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_BEZIER_MIRRORING: u8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_BEZIER_MIRRORING: [BEZIER_MIRRORING; 3] = [
  BEZIER_MIRRORING::NONE,
  BEZIER_MIRRORING::ANGLE,
  BEZIER_MIRRORING::ANGLE_LENGTH,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct BEZIER_MIRRORING(pub u8);
#[allow(non_upper_case_globals)]
impl BEZIER_MIRRORING {
  pub const NONE: Self = Self(10);
  pub const ANGLE: Self = Self(11);
  pub const ANGLE_LENGTH: Self = Self(12);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::ANGLE,
    Self::ANGLE_LENGTH,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::ANGLE => Some("ANGLE"),
      Self::ANGLE_LENGTH => Some("ANGLE_LENGTH"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for BEZIER_MIRRORING {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for BEZIER_MIRRORING {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for BEZIER_MIRRORING {
    type Output = BEZIER_MIRRORING;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for BEZIER_MIRRORING {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for BEZIER_MIRRORING {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for BEZIER_MIRRORING {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_HANDLE_TYPE: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_HANDLE_TYPE: u8 = 11;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_HANDLE_TYPE: [HANDLE_TYPE; 2] = [
  HANDLE_TYPE::HANDLE_IN,
  HANDLE_TYPE::HANDLE_OUT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct HANDLE_TYPE(pub u8);
#[allow(non_upper_case_globals)]
impl HANDLE_TYPE {
  pub const HANDLE_IN: Self = Self(10);
  pub const HANDLE_OUT: Self = Self(11);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 11;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::HANDLE_IN,
    Self::HANDLE_OUT,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::HANDLE_IN => Some("HANDLE_IN"),
      Self::HANDLE_OUT => Some("HANDLE_OUT"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for HANDLE_TYPE {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for HANDLE_TYPE {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for HANDLE_TYPE {
    type Output = HANDLE_TYPE;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for HANDLE_TYPE {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for HANDLE_TYPE {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for HANDLE_TYPE {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_YOUTUBE_STATES: i8 = -1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_YOUTUBE_STATES: i8 = 5;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_YOUTUBE_STATES: [YOUTUBE_STATES; 6] = [
  YOUTUBE_STATES::UNSTARTED,
  YOUTUBE_STATES::ENDED,
  YOUTUBE_STATES::PLAYING,
  YOUTUBE_STATES::PAUSED,
  YOUTUBE_STATES::BUFFERING,
  YOUTUBE_STATES::CUED,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct YOUTUBE_STATES(pub i8);
#[allow(non_upper_case_globals)]
impl YOUTUBE_STATES {
  pub const UNSTARTED: Self = Self(-1);
  pub const ENDED: Self = Self(0);
  pub const PLAYING: Self = Self(1);
  pub const PAUSED: Self = Self(2);
  pub const BUFFERING: Self = Self(3);
  pub const CUED: Self = Self(5);

  pub const ENUM_MIN: i8 = -1;
  pub const ENUM_MAX: i8 = 5;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::UNSTARTED,
    Self::ENDED,
    Self::PLAYING,
    Self::PAUSED,
    Self::BUFFERING,
    Self::CUED,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::UNSTARTED => Some("UNSTARTED"),
      Self::ENDED => Some("ENDED"),
      Self::PLAYING => Some("PLAYING"),
      Self::PAUSED => Some("PAUSED"),
      Self::BUFFERING => Some("BUFFERING"),
      Self::CUED => Some("CUED"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for YOUTUBE_STATES {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for YOUTUBE_STATES {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for YOUTUBE_STATES {
    type Output = YOUTUBE_STATES;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for YOUTUBE_STATES {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for YOUTUBE_STATES {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for YOUTUBE_STATES {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_BLENDING: u8 = 11;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_BLENDING: u8 = 17;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_BLENDING: [BLENDING; 7] = [
  BLENDING::MULTIPLY,
  BLENDING::SCREEN,
  BLENDING::OVERLAY,
  BLENDING::DARKEN,
  BLENDING::LIGHTEN,
  BLENDING::DIFFERENCE,
  BLENDING::EXCLUSION,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct BLENDING(pub u8);
#[allow(non_upper_case_globals)]
impl BLENDING {
  pub const MULTIPLY: Self = Self(11);
  pub const SCREEN: Self = Self(12);
  pub const OVERLAY: Self = Self(13);
  pub const DARKEN: Self = Self(14);
  pub const LIGHTEN: Self = Self(15);
  pub const DIFFERENCE: Self = Self(16);
  pub const EXCLUSION: Self = Self(17);

  pub const ENUM_MIN: u8 = 11;
  pub const ENUM_MAX: u8 = 17;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::MULTIPLY,
    Self::SCREEN,
    Self::OVERLAY,
    Self::DARKEN,
    Self::LIGHTEN,
    Self::DIFFERENCE,
    Self::EXCLUSION,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::MULTIPLY => Some("MULTIPLY"),
      Self::SCREEN => Some("SCREEN"),
      Self::OVERLAY => Some("OVERLAY"),
      Self::DARKEN => Some("DARKEN"),
      Self::LIGHTEN => Some("LIGHTEN"),
      Self::DIFFERENCE => Some("DIFFERENCE"),
      Self::EXCLUSION => Some("EXCLUSION"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for BLENDING {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for BLENDING {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for BLENDING {
    type Output = BLENDING;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for BLENDING {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for BLENDING {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for BLENDING {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_GRID_DISPLAY_TYPE: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_GRID_DISPLAY_TYPE: u8 = 13;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_GRID_DISPLAY_TYPE: [GRID_DISPLAY_TYPE; 4] = [
  GRID_DISPLAY_TYPE::LINES,
  GRID_DISPLAY_TYPE::DOTS,
  GRID_DISPLAY_TYPE::CROSSES,
  GRID_DISPLAY_TYPE::ADAPTIVE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct GRID_DISPLAY_TYPE(pub u8);
#[allow(non_upper_case_globals)]
impl GRID_DISPLAY_TYPE {
  pub const LINES: Self = Self(10);
  pub const DOTS: Self = Self(11);
  pub const CROSSES: Self = Self(12);
  pub const ADAPTIVE: Self = Self(13);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 13;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::LINES,
    Self::DOTS,
    Self::CROSSES,
    Self::ADAPTIVE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::LINES => Some("LINES"),
      Self::DOTS => Some("DOTS"),
      Self::CROSSES => Some("CROSSES"),
      Self::ADAPTIVE => Some("ADAPTIVE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for GRID_DISPLAY_TYPE {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for GRID_DISPLAY_TYPE {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for GRID_DISPLAY_TYPE {
    type Output = GRID_DISPLAY_TYPE;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for GRID_DISPLAY_TYPE {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for GRID_DISPLAY_TYPE {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for GRID_DISPLAY_TYPE {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_GRID_TYPE: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_GRID_TYPE: u8 = 14;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_GRID_TYPE: [GRID_TYPE; 5] = [
  GRID_TYPE::RECTANGULAR,
  GRID_TYPE::ISOMETRIC,
  GRID_TYPE::POLAR,
  GRID_TYPE::TRIANGULAR,
  GRID_TYPE::CUSTOM,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct GRID_TYPE(pub u8);
#[allow(non_upper_case_globals)]
impl GRID_TYPE {
  pub const RECTANGULAR: Self = Self(10);
  pub const ISOMETRIC: Self = Self(11);
  pub const POLAR: Self = Self(12);
  pub const TRIANGULAR: Self = Self(13);
  pub const CUSTOM: Self = Self(14);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 14;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::RECTANGULAR,
    Self::ISOMETRIC,
    Self::POLAR,
    Self::TRIANGULAR,
    Self::CUSTOM,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::RECTANGULAR => Some("RECTANGULAR"),
      Self::ISOMETRIC => Some("ISOMETRIC"),
      Self::POLAR => Some("POLAR"),
      Self::TRIANGULAR => Some("TRIANGULAR"),
      Self::CUSTOM => Some("CUSTOM"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for GRID_TYPE {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for GRID_TYPE {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for GRID_TYPE {
    type Output = GRID_TYPE;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for GRID_TYPE {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for GRID_TYPE {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for GRID_TYPE {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_OBJECT_SNAP_MODE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_OBJECT_SNAP_MODE: u8 = 28;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_OBJECT_SNAP_MODE: [OBJECT_SNAP_MODE; 20] = [
  OBJECT_SNAP_MODE::NONE,
  OBJECT_SNAP_MODE::ENDPOINT,
  OBJECT_SNAP_MODE::MIDPOINT,
  OBJECT_SNAP_MODE::CENTER,
  OBJECT_SNAP_MODE::QUADRANT,
  OBJECT_SNAP_MODE::INTERSECTION,
  OBJECT_SNAP_MODE::EXTENSION,
  OBJECT_SNAP_MODE::PERPENDICULAR,
  OBJECT_SNAP_MODE::TANGENT,
  OBJECT_SNAP_MODE::NEAREST,
  OBJECT_SNAP_MODE::NODE,
  OBJECT_SNAP_MODE::INSERT,
  OBJECT_SNAP_MODE::PARALLEL,
  OBJECT_SNAP_MODE::APPARENT,
  OBJECT_SNAP_MODE::FROM,
  OBJECT_SNAP_MODE::POINT_FILTER,
  OBJECT_SNAP_MODE::TEMPORARY,
  OBJECT_SNAP_MODE::BETWEEN_TWO_POINTS,
  OBJECT_SNAP_MODE::POINT_ON_CURVE,
  OBJECT_SNAP_MODE::GEOMETRIC,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct OBJECT_SNAP_MODE(pub u8);
#[allow(non_upper_case_globals)]
impl OBJECT_SNAP_MODE {
  pub const NONE: Self = Self(0);
  pub const ENDPOINT: Self = Self(10);
  pub const MIDPOINT: Self = Self(11);
  pub const CENTER: Self = Self(12);
  pub const QUADRANT: Self = Self(13);
  pub const INTERSECTION: Self = Self(14);
  pub const EXTENSION: Self = Self(15);
  pub const PERPENDICULAR: Self = Self(16);
  pub const TANGENT: Self = Self(17);
  pub const NEAREST: Self = Self(18);
  pub const NODE: Self = Self(19);
  pub const INSERT: Self = Self(20);
  pub const PARALLEL: Self = Self(21);
  pub const APPARENT: Self = Self(22);
  pub const FROM: Self = Self(23);
  pub const POINT_FILTER: Self = Self(24);
  pub const TEMPORARY: Self = Self(25);
  pub const BETWEEN_TWO_POINTS: Self = Self(26);
  pub const POINT_ON_CURVE: Self = Self(27);
  pub const GEOMETRIC: Self = Self(28);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 28;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::ENDPOINT,
    Self::MIDPOINT,
    Self::CENTER,
    Self::QUADRANT,
    Self::INTERSECTION,
    Self::EXTENSION,
    Self::PERPENDICULAR,
    Self::TANGENT,
    Self::NEAREST,
    Self::NODE,
    Self::INSERT,
    Self::PARALLEL,
    Self::APPARENT,
    Self::FROM,
    Self::POINT_FILTER,
    Self::TEMPORARY,
    Self::BETWEEN_TWO_POINTS,
    Self::POINT_ON_CURVE,
    Self::GEOMETRIC,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::ENDPOINT => Some("ENDPOINT"),
      Self::MIDPOINT => Some("MIDPOINT"),
      Self::CENTER => Some("CENTER"),
      Self::QUADRANT => Some("QUADRANT"),
      Self::INTERSECTION => Some("INTERSECTION"),
      Self::EXTENSION => Some("EXTENSION"),
      Self::PERPENDICULAR => Some("PERPENDICULAR"),
      Self::TANGENT => Some("TANGENT"),
      Self::NEAREST => Some("NEAREST"),
      Self::NODE => Some("NODE"),
      Self::INSERT => Some("INSERT"),
      Self::PARALLEL => Some("PARALLEL"),
      Self::APPARENT => Some("APPARENT"),
      Self::FROM => Some("FROM"),
      Self::POINT_FILTER => Some("POINT_FILTER"),
      Self::TEMPORARY => Some("TEMPORARY"),
      Self::BETWEEN_TWO_POINTS => Some("BETWEEN_TWO_POINTS"),
      Self::POINT_ON_CURVE => Some("POINT_ON_CURVE"),
      Self::GEOMETRIC => Some("GEOMETRIC"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for OBJECT_SNAP_MODE {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for OBJECT_SNAP_MODE {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for OBJECT_SNAP_MODE {
    type Output = OBJECT_SNAP_MODE;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for OBJECT_SNAP_MODE {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for OBJECT_SNAP_MODE {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for OBJECT_SNAP_MODE {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SNAP_MODE: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SNAP_MODE: u8 = 11;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SNAP_MODE: [SNAP_MODE; 2] = [
  SNAP_MODE::RUNNING,
  SNAP_MODE::SINGLE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SNAP_MODE(pub u8);
#[allow(non_upper_case_globals)]
impl SNAP_MODE {
  pub const RUNNING: Self = Self(10);
  pub const SINGLE: Self = Self(11);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 11;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::RUNNING,
    Self::SINGLE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::RUNNING => Some("RUNNING"),
      Self::SINGLE => Some("SINGLE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SNAP_MODE {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SNAP_MODE {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for SNAP_MODE {
    type Output = SNAP_MODE;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SNAP_MODE {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SNAP_MODE {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SNAP_MODE {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SNAP_OVERRIDE_BEHAVIOR: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SNAP_OVERRIDE_BEHAVIOR: u8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SNAP_OVERRIDE_BEHAVIOR: [SNAP_OVERRIDE_BEHAVIOR; 3] = [
  SNAP_OVERRIDE_BEHAVIOR::DISABLE,
  SNAP_OVERRIDE_BEHAVIOR::FORCE_GRID,
  SNAP_OVERRIDE_BEHAVIOR::FORCE_OBJECT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SNAP_OVERRIDE_BEHAVIOR(pub u8);
#[allow(non_upper_case_globals)]
impl SNAP_OVERRIDE_BEHAVIOR {
  pub const DISABLE: Self = Self(10);
  pub const FORCE_GRID: Self = Self(11);
  pub const FORCE_OBJECT: Self = Self(12);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::DISABLE,
    Self::FORCE_GRID,
    Self::FORCE_OBJECT,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::DISABLE => Some("DISABLE"),
      Self::FORCE_GRID => Some("FORCE_GRID"),
      Self::FORCE_OBJECT => Some("FORCE_OBJECT"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SNAP_OVERRIDE_BEHAVIOR {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SNAP_OVERRIDE_BEHAVIOR {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for SNAP_OVERRIDE_BEHAVIOR {
    type Output = SNAP_OVERRIDE_BEHAVIOR;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SNAP_OVERRIDE_BEHAVIOR {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SNAP_OVERRIDE_BEHAVIOR {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SNAP_OVERRIDE_BEHAVIOR {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SNAP_MARKER_SHAPE: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SNAP_MARKER_SHAPE: u8 = 13;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SNAP_MARKER_SHAPE: [SNAP_MARKER_SHAPE; 4] = [
  SNAP_MARKER_SHAPE::SQUARE,
  SNAP_MARKER_SHAPE::CIRCLE,
  SNAP_MARKER_SHAPE::TRIANGLE,
  SNAP_MARKER_SHAPE::X,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SNAP_MARKER_SHAPE(pub u8);
#[allow(non_upper_case_globals)]
impl SNAP_MARKER_SHAPE {
  pub const SQUARE: Self = Self(10);
  pub const CIRCLE: Self = Self(11);
  pub const TRIANGLE: Self = Self(12);
  pub const X: Self = Self(13);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 13;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SQUARE,
    Self::CIRCLE,
    Self::TRIANGLE,
    Self::X,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::SQUARE => Some("SQUARE"),
      Self::CIRCLE => Some("CIRCLE"),
      Self::TRIANGLE => Some("TRIANGLE"),
      Self::X => Some("X"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for SNAP_MARKER_SHAPE {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for SNAP_MARKER_SHAPE {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for SNAP_MARKER_SHAPE {
    type Output = SNAP_MARKER_SHAPE;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SNAP_MARKER_SHAPE {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for SNAP_MARKER_SHAPE {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for SNAP_MARKER_SHAPE {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TABLE_CELL_ALIGNMENT: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TABLE_CELL_ALIGNMENT: u8 = 18;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TABLE_CELL_ALIGNMENT: [TABLE_CELL_ALIGNMENT; 9] = [
  TABLE_CELL_ALIGNMENT::TOP_LEFT,
  TABLE_CELL_ALIGNMENT::TOP_CENTER,
  TABLE_CELL_ALIGNMENT::TOP_RIGHT,
  TABLE_CELL_ALIGNMENT::MIDDLE_LEFT,
  TABLE_CELL_ALIGNMENT::MIDDLE_CENTER,
  TABLE_CELL_ALIGNMENT::MIDDLE_RIGHT,
  TABLE_CELL_ALIGNMENT::BOTTOM_LEFT,
  TABLE_CELL_ALIGNMENT::BOTTOM_CENTER,
  TABLE_CELL_ALIGNMENT::BOTTOM_RIGHT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TABLE_CELL_ALIGNMENT(pub u8);
#[allow(non_upper_case_globals)]
impl TABLE_CELL_ALIGNMENT {
  pub const TOP_LEFT: Self = Self(10);
  pub const TOP_CENTER: Self = Self(11);
  pub const TOP_RIGHT: Self = Self(12);
  pub const MIDDLE_LEFT: Self = Self(13);
  pub const MIDDLE_CENTER: Self = Self(14);
  pub const MIDDLE_RIGHT: Self = Self(15);
  pub const BOTTOM_LEFT: Self = Self(16);
  pub const BOTTOM_CENTER: Self = Self(17);
  pub const BOTTOM_RIGHT: Self = Self(18);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 18;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::TOP_LEFT,
    Self::TOP_CENTER,
    Self::TOP_RIGHT,
    Self::MIDDLE_LEFT,
    Self::MIDDLE_CENTER,
    Self::MIDDLE_RIGHT,
    Self::BOTTOM_LEFT,
    Self::BOTTOM_CENTER,
    Self::BOTTOM_RIGHT,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::TOP_LEFT => Some("TOP_LEFT"),
      Self::TOP_CENTER => Some("TOP_CENTER"),
      Self::TOP_RIGHT => Some("TOP_RIGHT"),
      Self::MIDDLE_LEFT => Some("MIDDLE_LEFT"),
      Self::MIDDLE_CENTER => Some("MIDDLE_CENTER"),
      Self::MIDDLE_RIGHT => Some("MIDDLE_RIGHT"),
      Self::BOTTOM_LEFT => Some("BOTTOM_LEFT"),
      Self::BOTTOM_CENTER => Some("BOTTOM_CENTER"),
      Self::BOTTOM_RIGHT => Some("BOTTOM_RIGHT"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for TABLE_CELL_ALIGNMENT {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for TABLE_CELL_ALIGNMENT {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for TABLE_CELL_ALIGNMENT {
    type Output = TABLE_CELL_ALIGNMENT;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for TABLE_CELL_ALIGNMENT {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for TABLE_CELL_ALIGNMENT {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TABLE_CELL_ALIGNMENT {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TABLE_FLOW_DIRECTION: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TABLE_FLOW_DIRECTION: u8 = 11;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TABLE_FLOW_DIRECTION: [TABLE_FLOW_DIRECTION; 2] = [
  TABLE_FLOW_DIRECTION::DOWN,
  TABLE_FLOW_DIRECTION::UP,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TABLE_FLOW_DIRECTION(pub u8);
#[allow(non_upper_case_globals)]
impl TABLE_FLOW_DIRECTION {
  pub const DOWN: Self = Self(10);
  pub const UP: Self = Self(11);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 11;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::DOWN,
    Self::UP,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::DOWN => Some("DOWN"),
      Self::UP => Some("UP"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for TABLE_FLOW_DIRECTION {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for TABLE_FLOW_DIRECTION {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for TABLE_FLOW_DIRECTION {
    type Output = TABLE_FLOW_DIRECTION;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for TABLE_FLOW_DIRECTION {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for TABLE_FLOW_DIRECTION {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TABLE_FLOW_DIRECTION {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TOLERANCE_DISPLAY: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TOLERANCE_DISPLAY: u8 = 14;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TOLERANCE_DISPLAY: [TOLERANCE_DISPLAY; 5] = [
  TOLERANCE_DISPLAY::NONE,
  TOLERANCE_DISPLAY::SYMMETRICAL,
  TOLERANCE_DISPLAY::DEVIATION,
  TOLERANCE_DISPLAY::LIMITS,
  TOLERANCE_DISPLAY::BASIC,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TOLERANCE_DISPLAY(pub u8);
#[allow(non_upper_case_globals)]
impl TOLERANCE_DISPLAY {
  pub const NONE: Self = Self(10);
  pub const SYMMETRICAL: Self = Self(11);
  pub const DEVIATION: Self = Self(12);
  pub const LIMITS: Self = Self(13);
  pub const BASIC: Self = Self(14);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 14;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::SYMMETRICAL,
    Self::DEVIATION,
    Self::LIMITS,
    Self::BASIC,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::SYMMETRICAL => Some("SYMMETRICAL"),
      Self::DEVIATION => Some("DEVIATION"),
      Self::LIMITS => Some("LIMITS"),
      Self::BASIC => Some("BASIC"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for TOLERANCE_DISPLAY {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for TOLERANCE_DISPLAY {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for TOLERANCE_DISPLAY {
    type Output = TOLERANCE_DISPLAY;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for TOLERANCE_DISPLAY {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for TOLERANCE_DISPLAY {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TOLERANCE_DISPLAY {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DIMENSION_TYPE: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DIMENSION_TYPE: u8 = 22;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DIMENSION_TYPE: [DIMENSION_TYPE; 13] = [
  DIMENSION_TYPE::LINEAR,
  DIMENSION_TYPE::ALIGNED,
  DIMENSION_TYPE::ANGULAR,
  DIMENSION_TYPE::ARC_LENGTH,
  DIMENSION_TYPE::RADIUS,
  DIMENSION_TYPE::DIAMETER,
  DIMENSION_TYPE::CENTER_MARK,
  DIMENSION_TYPE::ROTATED,
  DIMENSION_TYPE::SPACING,
  DIMENSION_TYPE::CONTINUE,
  DIMENSION_TYPE::BASELINE,
  DIMENSION_TYPE::JOGGED_LINEAR,
  DIMENSION_TYPE::ORDINATE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DIMENSION_TYPE(pub u8);
#[allow(non_upper_case_globals)]
impl DIMENSION_TYPE {
  pub const LINEAR: Self = Self(10);
  pub const ALIGNED: Self = Self(11);
  pub const ANGULAR: Self = Self(12);
  pub const ARC_LENGTH: Self = Self(13);
  pub const RADIUS: Self = Self(14);
  pub const DIAMETER: Self = Self(15);
  pub const CENTER_MARK: Self = Self(16);
  pub const ROTATED: Self = Self(17);
  pub const SPACING: Self = Self(18);
  pub const CONTINUE: Self = Self(19);
  pub const BASELINE: Self = Self(20);
  pub const JOGGED_LINEAR: Self = Self(21);
  pub const ORDINATE: Self = Self(22);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 22;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::LINEAR,
    Self::ALIGNED,
    Self::ANGULAR,
    Self::ARC_LENGTH,
    Self::RADIUS,
    Self::DIAMETER,
    Self::CENTER_MARK,
    Self::ROTATED,
    Self::SPACING,
    Self::CONTINUE,
    Self::BASELINE,
    Self::JOGGED_LINEAR,
    Self::ORDINATE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::LINEAR => Some("LINEAR"),
      Self::ALIGNED => Some("ALIGNED"),
      Self::ANGULAR => Some("ANGULAR"),
      Self::ARC_LENGTH => Some("ARC_LENGTH"),
      Self::RADIUS => Some("RADIUS"),
      Self::DIAMETER => Some("DIAMETER"),
      Self::CENTER_MARK => Some("CENTER_MARK"),
      Self::ROTATED => Some("ROTATED"),
      Self::SPACING => Some("SPACING"),
      Self::CONTINUE => Some("CONTINUE"),
      Self::BASELINE => Some("BASELINE"),
      Self::JOGGED_LINEAR => Some("JOGGED_LINEAR"),
      Self::ORDINATE => Some("ORDINATE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DIMENSION_TYPE {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DIMENSION_TYPE {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for DIMENSION_TYPE {
    type Output = DIMENSION_TYPE;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DIMENSION_TYPE {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DIMENSION_TYPE {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DIMENSION_TYPE {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MARK_ELLIPSE_CENTER: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MARK_ELLIPSE_CENTER: u8 = 11;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MARK_ELLIPSE_CENTER: [MARK_ELLIPSE_CENTER; 2] = [
  MARK_ELLIPSE_CENTER::MARK,
  MARK_ELLIPSE_CENTER::LINE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MARK_ELLIPSE_CENTER(pub u8);
#[allow(non_upper_case_globals)]
impl MARK_ELLIPSE_CENTER {
  pub const MARK: Self = Self(10);
  pub const LINE: Self = Self(11);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 11;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::MARK,
    Self::LINE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::MARK => Some("MARK"),
      Self::LINE => Some("LINE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for MARK_ELLIPSE_CENTER {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for MARK_ELLIPSE_CENTER {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for MARK_ELLIPSE_CENTER {
    type Output = MARK_ELLIPSE_CENTER;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for MARK_ELLIPSE_CENTER {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for MARK_ELLIPSE_CENTER {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for MARK_ELLIPSE_CENTER {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TEXT_FLOW_DIRECTION: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TEXT_FLOW_DIRECTION: u8 = 13;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TEXT_FLOW_DIRECTION: [TEXT_FLOW_DIRECTION; 4] = [
  TEXT_FLOW_DIRECTION::LEFT_TO_RIGHT,
  TEXT_FLOW_DIRECTION::RIGHT_TO_LEFT,
  TEXT_FLOW_DIRECTION::TOP_TO_BOTTOM,
  TEXT_FLOW_DIRECTION::BOTTOM_TO_TOP,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TEXT_FLOW_DIRECTION(pub u8);
#[allow(non_upper_case_globals)]
impl TEXT_FLOW_DIRECTION {
  pub const LEFT_TO_RIGHT: Self = Self(10);
  pub const RIGHT_TO_LEFT: Self = Self(11);
  pub const TOP_TO_BOTTOM: Self = Self(12);
  pub const BOTTOM_TO_TOP: Self = Self(13);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 13;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::LEFT_TO_RIGHT,
    Self::RIGHT_TO_LEFT,
    Self::TOP_TO_BOTTOM,
    Self::BOTTOM_TO_TOP,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::LEFT_TO_RIGHT => Some("LEFT_TO_RIGHT"),
      Self::RIGHT_TO_LEFT => Some("RIGHT_TO_LEFT"),
      Self::TOP_TO_BOTTOM => Some("TOP_TO_BOTTOM"),
      Self::BOTTOM_TO_TOP => Some("BOTTOM_TO_TOP"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for TEXT_FLOW_DIRECTION {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for TEXT_FLOW_DIRECTION {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for TEXT_FLOW_DIRECTION {
    type Output = TEXT_FLOW_DIRECTION;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for TEXT_FLOW_DIRECTION {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for TEXT_FLOW_DIRECTION {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TEXT_FLOW_DIRECTION {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_COLUMN_TYPE: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_COLUMN_TYPE: u8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_COLUMN_TYPE: [COLUMN_TYPE; 3] = [
  COLUMN_TYPE::NO_COLUMNS,
  COLUMN_TYPE::STATIC_COLUMNS,
  COLUMN_TYPE::DYNAMIC_COLUMNS,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct COLUMN_TYPE(pub u8);
#[allow(non_upper_case_globals)]
impl COLUMN_TYPE {
  pub const NO_COLUMNS: Self = Self(10);
  pub const STATIC_COLUMNS: Self = Self(11);
  pub const DYNAMIC_COLUMNS: Self = Self(12);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NO_COLUMNS,
    Self::STATIC_COLUMNS,
    Self::DYNAMIC_COLUMNS,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NO_COLUMNS => Some("NO_COLUMNS"),
      Self::STATIC_COLUMNS => Some("STATIC_COLUMNS"),
      Self::DYNAMIC_COLUMNS => Some("DYNAMIC_COLUMNS"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for COLUMN_TYPE {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for COLUMN_TYPE {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for COLUMN_TYPE {
    type Output = COLUMN_TYPE;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for COLUMN_TYPE {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for COLUMN_TYPE {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for COLUMN_TYPE {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_GDT_SYMBOL: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_GDT_SYMBOL: u8 = 29;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_GDT_SYMBOL: [GDT_SYMBOL; 20] = [
  GDT_SYMBOL::STRAIGHTNESS,
  GDT_SYMBOL::FLATNESS,
  GDT_SYMBOL::CIRCULARITY,
  GDT_SYMBOL::CYLINDRICITY,
  GDT_SYMBOL::PERPENDICULARITY,
  GDT_SYMBOL::ANGULARITY,
  GDT_SYMBOL::PARALLELISM,
  GDT_SYMBOL::POSITION,
  GDT_SYMBOL::TRUE_POSITION,
  GDT_SYMBOL::CONCENTRICITY,
  GDT_SYMBOL::COAXIALITY,
  GDT_SYMBOL::SYMMETRY,
  GDT_SYMBOL::CIRCULAR_RUNOUT,
  GDT_SYMBOL::TOTAL_RUNOUT,
  GDT_SYMBOL::PROFILE_OF_LINE,
  GDT_SYMBOL::PROFILE_OF_SURFACE,
  GDT_SYMBOL::STATISTICAL,
  GDT_SYMBOL::ALL_AROUND,
  GDT_SYMBOL::ALL_OVER,
  GDT_SYMBOL::BETWEEN,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct GDT_SYMBOL(pub u8);
#[allow(non_upper_case_globals)]
impl GDT_SYMBOL {
  pub const STRAIGHTNESS: Self = Self(10);
  pub const FLATNESS: Self = Self(11);
  pub const CIRCULARITY: Self = Self(12);
  pub const CYLINDRICITY: Self = Self(13);
  pub const PERPENDICULARITY: Self = Self(14);
  pub const ANGULARITY: Self = Self(15);
  pub const PARALLELISM: Self = Self(16);
  pub const POSITION: Self = Self(17);
  pub const TRUE_POSITION: Self = Self(18);
  pub const CONCENTRICITY: Self = Self(19);
  pub const COAXIALITY: Self = Self(20);
  pub const SYMMETRY: Self = Self(21);
  pub const CIRCULAR_RUNOUT: Self = Self(22);
  pub const TOTAL_RUNOUT: Self = Self(23);
  pub const PROFILE_OF_LINE: Self = Self(24);
  pub const PROFILE_OF_SURFACE: Self = Self(25);
  pub const STATISTICAL: Self = Self(26);
  pub const ALL_AROUND: Self = Self(27);
  pub const ALL_OVER: Self = Self(28);
  pub const BETWEEN: Self = Self(29);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 29;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::STRAIGHTNESS,
    Self::FLATNESS,
    Self::CIRCULARITY,
    Self::CYLINDRICITY,
    Self::PERPENDICULARITY,
    Self::ANGULARITY,
    Self::PARALLELISM,
    Self::POSITION,
    Self::TRUE_POSITION,
    Self::CONCENTRICITY,
    Self::COAXIALITY,
    Self::SYMMETRY,
    Self::CIRCULAR_RUNOUT,
    Self::TOTAL_RUNOUT,
    Self::PROFILE_OF_LINE,
    Self::PROFILE_OF_SURFACE,
    Self::STATISTICAL,
    Self::ALL_AROUND,
    Self::ALL_OVER,
    Self::BETWEEN,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::STRAIGHTNESS => Some("STRAIGHTNESS"),
      Self::FLATNESS => Some("FLATNESS"),
      Self::CIRCULARITY => Some("CIRCULARITY"),
      Self::CYLINDRICITY => Some("CYLINDRICITY"),
      Self::PERPENDICULARITY => Some("PERPENDICULARITY"),
      Self::ANGULARITY => Some("ANGULARITY"),
      Self::PARALLELISM => Some("PARALLELISM"),
      Self::POSITION => Some("POSITION"),
      Self::TRUE_POSITION => Some("TRUE_POSITION"),
      Self::CONCENTRICITY => Some("CONCENTRICITY"),
      Self::COAXIALITY => Some("COAXIALITY"),
      Self::SYMMETRY => Some("SYMMETRY"),
      Self::CIRCULAR_RUNOUT => Some("CIRCULAR_RUNOUT"),
      Self::TOTAL_RUNOUT => Some("TOTAL_RUNOUT"),
      Self::PROFILE_OF_LINE => Some("PROFILE_OF_LINE"),
      Self::PROFILE_OF_SURFACE => Some("PROFILE_OF_SURFACE"),
      Self::STATISTICAL => Some("STATISTICAL"),
      Self::ALL_AROUND => Some("ALL_AROUND"),
      Self::ALL_OVER => Some("ALL_OVER"),
      Self::BETWEEN => Some("BETWEEN"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for GDT_SYMBOL {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for GDT_SYMBOL {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for GDT_SYMBOL {
    type Output = GDT_SYMBOL;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for GDT_SYMBOL {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for GDT_SYMBOL {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for GDT_SYMBOL {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MATERIAL_CONDITION: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MATERIAL_CONDITION: u8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MATERIAL_CONDITION: [MATERIAL_CONDITION; 3] = [
  MATERIAL_CONDITION::MAXIMUM,
  MATERIAL_CONDITION::LEAST,
  MATERIAL_CONDITION::REGARDLESS,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MATERIAL_CONDITION(pub u8);
#[allow(non_upper_case_globals)]
impl MATERIAL_CONDITION {
  pub const MAXIMUM: Self = Self(10);
  pub const LEAST: Self = Self(11);
  pub const REGARDLESS: Self = Self(12);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::MAXIMUM,
    Self::LEAST,
    Self::REGARDLESS,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::MAXIMUM => Some("MAXIMUM"),
      Self::LEAST => Some("LEAST"),
      Self::REGARDLESS => Some("REGARDLESS"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for MATERIAL_CONDITION {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for MATERIAL_CONDITION {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for MATERIAL_CONDITION {
    type Output = MATERIAL_CONDITION;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for MATERIAL_CONDITION {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for MATERIAL_CONDITION {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for MATERIAL_CONDITION {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_FEATURE_MODIFIER: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_FEATURE_MODIFIER: u8 = 24;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_FEATURE_MODIFIER: [FEATURE_MODIFIER; 16] = [
  FEATURE_MODIFIER::NONE,
  FEATURE_MODIFIER::FREE_STATE,
  FEATURE_MODIFIER::TANGENT_PLANE,
  FEATURE_MODIFIER::PROJECTED_TOLERANCE_ZONE,
  FEATURE_MODIFIER::DIAMETER,
  FEATURE_MODIFIER::SPHERICAL_DIAMETER,
  FEATURE_MODIFIER::RADIUS,
  FEATURE_MODIFIER::SPHERICAL_RADIUS,
  FEATURE_MODIFIER::CONTROLLED_RADIUS,
  FEATURE_MODIFIER::SQUARE,
  FEATURE_MODIFIER::TRANSLATION,
  FEATURE_MODIFIER::ALL_AROUND,
  FEATURE_MODIFIER::ALL_OVER,
  FEATURE_MODIFIER::STATISTICAL,
  FEATURE_MODIFIER::CONTINUOUS_FEATURE,
  FEATURE_MODIFIER::UNEQUALLY_DISPOSED,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct FEATURE_MODIFIER(pub u8);
#[allow(non_upper_case_globals)]
impl FEATURE_MODIFIER {
  pub const NONE: Self = Self(0);
  pub const FREE_STATE: Self = Self(10);
  pub const TANGENT_PLANE: Self = Self(11);
  pub const PROJECTED_TOLERANCE_ZONE: Self = Self(12);
  pub const DIAMETER: Self = Self(13);
  pub const SPHERICAL_DIAMETER: Self = Self(14);
  pub const RADIUS: Self = Self(15);
  pub const SPHERICAL_RADIUS: Self = Self(16);
  pub const CONTROLLED_RADIUS: Self = Self(17);
  pub const SQUARE: Self = Self(18);
  pub const TRANSLATION: Self = Self(19);
  pub const ALL_AROUND: Self = Self(20);
  pub const ALL_OVER: Self = Self(21);
  pub const STATISTICAL: Self = Self(22);
  pub const CONTINUOUS_FEATURE: Self = Self(23);
  pub const UNEQUALLY_DISPOSED: Self = Self(24);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 24;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::FREE_STATE,
    Self::TANGENT_PLANE,
    Self::PROJECTED_TOLERANCE_ZONE,
    Self::DIAMETER,
    Self::SPHERICAL_DIAMETER,
    Self::RADIUS,
    Self::SPHERICAL_RADIUS,
    Self::CONTROLLED_RADIUS,
    Self::SQUARE,
    Self::TRANSLATION,
    Self::ALL_AROUND,
    Self::ALL_OVER,
    Self::STATISTICAL,
    Self::CONTINUOUS_FEATURE,
    Self::UNEQUALLY_DISPOSED,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::FREE_STATE => Some("FREE_STATE"),
      Self::TANGENT_PLANE => Some("TANGENT_PLANE"),
      Self::PROJECTED_TOLERANCE_ZONE => Some("PROJECTED_TOLERANCE_ZONE"),
      Self::DIAMETER => Some("DIAMETER"),
      Self::SPHERICAL_DIAMETER => Some("SPHERICAL_DIAMETER"),
      Self::RADIUS => Some("RADIUS"),
      Self::SPHERICAL_RADIUS => Some("SPHERICAL_RADIUS"),
      Self::CONTROLLED_RADIUS => Some("CONTROLLED_RADIUS"),
      Self::SQUARE => Some("SQUARE"),
      Self::TRANSLATION => Some("TRANSLATION"),
      Self::ALL_AROUND => Some("ALL_AROUND"),
      Self::ALL_OVER => Some("ALL_OVER"),
      Self::STATISTICAL => Some("STATISTICAL"),
      Self::CONTINUOUS_FEATURE => Some("CONTINUOUS_FEATURE"),
      Self::UNEQUALLY_DISPOSED => Some("UNEQUALLY_DISPOSED"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for FEATURE_MODIFIER {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for FEATURE_MODIFIER {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for FEATURE_MODIFIER {
    type Output = FEATURE_MODIFIER;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for FEATURE_MODIFIER {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for FEATURE_MODIFIER {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for FEATURE_MODIFIER {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TOLERANCE_ZONE_TYPE: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TOLERANCE_ZONE_TYPE: u8 = 14;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TOLERANCE_ZONE_TYPE: [TOLERANCE_ZONE_TYPE; 5] = [
  TOLERANCE_ZONE_TYPE::CYLINDRICAL,
  TOLERANCE_ZONE_TYPE::SPHERICAL,
  TOLERANCE_ZONE_TYPE::RECTANGULAR,
  TOLERANCE_ZONE_TYPE::LINEAR,
  TOLERANCE_ZONE_TYPE::CIRCULAR,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TOLERANCE_ZONE_TYPE(pub u8);
#[allow(non_upper_case_globals)]
impl TOLERANCE_ZONE_TYPE {
  pub const CYLINDRICAL: Self = Self(10);
  pub const SPHERICAL: Self = Self(11);
  pub const RECTANGULAR: Self = Self(12);
  pub const LINEAR: Self = Self(13);
  pub const CIRCULAR: Self = Self(14);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 14;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::CYLINDRICAL,
    Self::SPHERICAL,
    Self::RECTANGULAR,
    Self::LINEAR,
    Self::CIRCULAR,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::CYLINDRICAL => Some("CYLINDRICAL"),
      Self::SPHERICAL => Some("SPHERICAL"),
      Self::RECTANGULAR => Some("RECTANGULAR"),
      Self::LINEAR => Some("LINEAR"),
      Self::CIRCULAR => Some("CIRCULAR"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for TOLERANCE_ZONE_TYPE {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for TOLERANCE_ZONE_TYPE {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for TOLERANCE_ZONE_TYPE {
    type Output = TOLERANCE_ZONE_TYPE;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for TOLERANCE_ZONE_TYPE {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for TOLERANCE_ZONE_TYPE {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TOLERANCE_ZONE_TYPE {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DATUM_TARGET_TYPE: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DATUM_TARGET_TYPE: u8 = 13;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DATUM_TARGET_TYPE: [DATUM_TARGET_TYPE; 4] = [
  DATUM_TARGET_TYPE::POINT,
  DATUM_TARGET_TYPE::LINE,
  DATUM_TARGET_TYPE::AREA,
  DATUM_TARGET_TYPE::MOVABLE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DATUM_TARGET_TYPE(pub u8);
#[allow(non_upper_case_globals)]
impl DATUM_TARGET_TYPE {
  pub const POINT: Self = Self(10);
  pub const LINE: Self = Self(11);
  pub const AREA: Self = Self(12);
  pub const MOVABLE: Self = Self(13);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 13;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::POINT,
    Self::LINE,
    Self::AREA,
    Self::MOVABLE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::POINT => Some("POINT"),
      Self::LINE => Some("LINE"),
      Self::AREA => Some("AREA"),
      Self::MOVABLE => Some("MOVABLE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DATUM_TARGET_TYPE {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DATUM_TARGET_TYPE {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for DATUM_TARGET_TYPE {
    type Output = DATUM_TARGET_TYPE;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DATUM_TARGET_TYPE {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DATUM_TARGET_TYPE {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DATUM_TARGET_TYPE {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_TOLERANCE_TYPE: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_TOLERANCE_TYPE: u8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_TOLERANCE_TYPE: [TOLERANCE_TYPE; 3] = [
  TOLERANCE_TYPE::SINGLE,
  TOLERANCE_TYPE::COMPOSITE,
  TOLERANCE_TYPE::MULTIPLE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct TOLERANCE_TYPE(pub u8);
#[allow(non_upper_case_globals)]
impl TOLERANCE_TYPE {
  pub const SINGLE: Self = Self(10);
  pub const COMPOSITE: Self = Self(11);
  pub const MULTIPLE: Self = Self(12);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SINGLE,
    Self::COMPOSITE,
    Self::MULTIPLE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::SINGLE => Some("SINGLE"),
      Self::COMPOSITE => Some("COMPOSITE"),
      Self::MULTIPLE => Some("MULTIPLE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for TOLERANCE_TYPE {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for TOLERANCE_TYPE {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for TOLERANCE_TYPE {
    type Output = TOLERANCE_TYPE;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for TOLERANCE_TYPE {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for TOLERANCE_TYPE {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for TOLERANCE_TYPE {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DATUM_BRACKET_STYLE: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DATUM_BRACKET_STYLE: u8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DATUM_BRACKET_STYLE: [DATUM_BRACKET_STYLE; 3] = [
  DATUM_BRACKET_STYLE::SQUARE,
  DATUM_BRACKET_STYLE::ROUND,
  DATUM_BRACKET_STYLE::NONE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DATUM_BRACKET_STYLE(pub u8);
#[allow(non_upper_case_globals)]
impl DATUM_BRACKET_STYLE {
  pub const SQUARE: Self = Self(10);
  pub const ROUND: Self = Self(11);
  pub const NONE: Self = Self(12);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SQUARE,
    Self::ROUND,
    Self::NONE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::SQUARE => Some("SQUARE"),
      Self::ROUND => Some("ROUND"),
      Self::NONE => Some("NONE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DATUM_BRACKET_STYLE {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DATUM_BRACKET_STYLE {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for DATUM_BRACKET_STYLE {
    type Output = DATUM_BRACKET_STYLE;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DATUM_BRACKET_STYLE {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DATUM_BRACKET_STYLE {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DATUM_BRACKET_STYLE {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DIMENSION_UNITS_FORMAT: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DIMENSION_UNITS_FORMAT: u8 = 14;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DIMENSION_UNITS_FORMAT: [DIMENSION_UNITS_FORMAT; 5] = [
  DIMENSION_UNITS_FORMAT::DECIMAL,
  DIMENSION_UNITS_FORMAT::ENGINEERING,
  DIMENSION_UNITS_FORMAT::ARCHITECTURAL,
  DIMENSION_UNITS_FORMAT::FRACTIONAL,
  DIMENSION_UNITS_FORMAT::SCIENTIFIC,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DIMENSION_UNITS_FORMAT(pub u8);
#[allow(non_upper_case_globals)]
impl DIMENSION_UNITS_FORMAT {
  pub const DECIMAL: Self = Self(10);
  pub const ENGINEERING: Self = Self(11);
  pub const ARCHITECTURAL: Self = Self(12);
  pub const FRACTIONAL: Self = Self(13);
  pub const SCIENTIFIC: Self = Self(14);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 14;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::DECIMAL,
    Self::ENGINEERING,
    Self::ARCHITECTURAL,
    Self::FRACTIONAL,
    Self::SCIENTIFIC,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::DECIMAL => Some("DECIMAL"),
      Self::ENGINEERING => Some("ENGINEERING"),
      Self::ARCHITECTURAL => Some("ARCHITECTURAL"),
      Self::FRACTIONAL => Some("FRACTIONAL"),
      Self::SCIENTIFIC => Some("SCIENTIFIC"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DIMENSION_UNITS_FORMAT {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DIMENSION_UNITS_FORMAT {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for DIMENSION_UNITS_FORMAT {
    type Output = DIMENSION_UNITS_FORMAT;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DIMENSION_UNITS_FORMAT {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DIMENSION_UNITS_FORMAT {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DIMENSION_UNITS_FORMAT {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DIMENSION_FIT_RULE: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DIMENSION_FIT_RULE: u8 = 13;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DIMENSION_FIT_RULE: [DIMENSION_FIT_RULE; 4] = [
  DIMENSION_FIT_RULE::TEXT_AND_ARROWS,
  DIMENSION_FIT_RULE::ARROWS_ONLY,
  DIMENSION_FIT_RULE::TEXT_ONLY,
  DIMENSION_FIT_RULE::BEST_FIT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DIMENSION_FIT_RULE(pub u8);
#[allow(non_upper_case_globals)]
impl DIMENSION_FIT_RULE {
  pub const TEXT_AND_ARROWS: Self = Self(10);
  pub const ARROWS_ONLY: Self = Self(11);
  pub const TEXT_ONLY: Self = Self(12);
  pub const BEST_FIT: Self = Self(13);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 13;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::TEXT_AND_ARROWS,
    Self::ARROWS_ONLY,
    Self::TEXT_ONLY,
    Self::BEST_FIT,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::TEXT_AND_ARROWS => Some("TEXT_AND_ARROWS"),
      Self::ARROWS_ONLY => Some("ARROWS_ONLY"),
      Self::TEXT_ONLY => Some("TEXT_ONLY"),
      Self::BEST_FIT => Some("BEST_FIT"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DIMENSION_FIT_RULE {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DIMENSION_FIT_RULE {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for DIMENSION_FIT_RULE {
    type Output = DIMENSION_FIT_RULE;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DIMENSION_FIT_RULE {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DIMENSION_FIT_RULE {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DIMENSION_FIT_RULE {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DIMENSION_TEXT_PLACEMENT: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DIMENSION_TEXT_PLACEMENT: u8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DIMENSION_TEXT_PLACEMENT: [DIMENSION_TEXT_PLACEMENT; 3] = [
  DIMENSION_TEXT_PLACEMENT::BESIDE_LINE,
  DIMENSION_TEXT_PLACEMENT::OVER_LINE,
  DIMENSION_TEXT_PLACEMENT::OVER_LINE_WITH_LEADER,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DIMENSION_TEXT_PLACEMENT(pub u8);
#[allow(non_upper_case_globals)]
impl DIMENSION_TEXT_PLACEMENT {
  pub const BESIDE_LINE: Self = Self(10);
  pub const OVER_LINE: Self = Self(11);
  pub const OVER_LINE_WITH_LEADER: Self = Self(12);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::BESIDE_LINE,
    Self::OVER_LINE,
    Self::OVER_LINE_WITH_LEADER,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::BESIDE_LINE => Some("BESIDE_LINE"),
      Self::OVER_LINE => Some("OVER_LINE"),
      Self::OVER_LINE_WITH_LEADER => Some("OVER_LINE_WITH_LEADER"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DIMENSION_TEXT_PLACEMENT {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DIMENSION_TEXT_PLACEMENT {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for DIMENSION_TEXT_PLACEMENT {
    type Output = DIMENSION_TEXT_PLACEMENT;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DIMENSION_TEXT_PLACEMENT {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DIMENSION_TEXT_PLACEMENT {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DIMENSION_TEXT_PLACEMENT {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ANGULAR_UNITS_FORMAT: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ANGULAR_UNITS_FORMAT: u8 = 14;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ANGULAR_UNITS_FORMAT: [ANGULAR_UNITS_FORMAT; 5] = [
  ANGULAR_UNITS_FORMAT::DECIMAL_DEGREES,
  ANGULAR_UNITS_FORMAT::DEGREES_MINUTES_SECONDS,
  ANGULAR_UNITS_FORMAT::GRADS,
  ANGULAR_UNITS_FORMAT::RADIANS,
  ANGULAR_UNITS_FORMAT::SURVEYOR,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ANGULAR_UNITS_FORMAT(pub u8);
#[allow(non_upper_case_globals)]
impl ANGULAR_UNITS_FORMAT {
  pub const DECIMAL_DEGREES: Self = Self(10);
  pub const DEGREES_MINUTES_SECONDS: Self = Self(11);
  pub const GRADS: Self = Self(12);
  pub const RADIANS: Self = Self(13);
  pub const SURVEYOR: Self = Self(14);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 14;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::DECIMAL_DEGREES,
    Self::DEGREES_MINUTES_SECONDS,
    Self::GRADS,
    Self::RADIANS,
    Self::SURVEYOR,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::DECIMAL_DEGREES => Some("DECIMAL_DEGREES"),
      Self::DEGREES_MINUTES_SECONDS => Some("DEGREES_MINUTES_SECONDS"),
      Self::GRADS => Some("GRADS"),
      Self::RADIANS => Some("RADIANS"),
      Self::SURVEYOR => Some("SURVEYOR"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ANGULAR_UNITS_FORMAT {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ANGULAR_UNITS_FORMAT {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ANGULAR_UNITS_FORMAT {
    type Output = ANGULAR_UNITS_FORMAT;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ANGULAR_UNITS_FORMAT {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ANGULAR_UNITS_FORMAT {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ANGULAR_UNITS_FORMAT {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_UNIT_SYSTEM: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_UNIT_SYSTEM: u8 = 11;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_UNIT_SYSTEM: [UNIT_SYSTEM; 2] = [
  UNIT_SYSTEM::METRIC,
  UNIT_SYSTEM::IMPERIAL,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct UNIT_SYSTEM(pub u8);
#[allow(non_upper_case_globals)]
impl UNIT_SYSTEM {
  pub const METRIC: Self = Self(10);
  pub const IMPERIAL: Self = Self(11);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 11;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::METRIC,
    Self::IMPERIAL,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::METRIC => Some("METRIC"),
      Self::IMPERIAL => Some("IMPERIAL"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for UNIT_SYSTEM {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for UNIT_SYSTEM {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for UNIT_SYSTEM {
    type Output = UNIT_SYSTEM;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for UNIT_SYSTEM {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for UNIT_SYSTEM {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for UNIT_SYSTEM {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DECIMAL_SEPARATOR: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DECIMAL_SEPARATOR: u8 = 11;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DECIMAL_SEPARATOR: [DECIMAL_SEPARATOR; 2] = [
  DECIMAL_SEPARATOR::DOT,
  DECIMAL_SEPARATOR::COMMA,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DECIMAL_SEPARATOR(pub u8);
#[allow(non_upper_case_globals)]
impl DECIMAL_SEPARATOR {
  pub const DOT: Self = Self(10);
  pub const COMMA: Self = Self(11);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 11;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::DOT,
    Self::COMMA,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::DOT => Some("DOT"),
      Self::COMMA => Some("COMMA"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DECIMAL_SEPARATOR {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DECIMAL_SEPARATOR {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for DECIMAL_SEPARATOR {
    type Output = DECIMAL_SEPARATOR;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DECIMAL_SEPARATOR {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DECIMAL_SEPARATOR {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DECIMAL_SEPARATOR {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_VIEWPORT_SHADE_PLOT: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_VIEWPORT_SHADE_PLOT: u8 = 13;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_VIEWPORT_SHADE_PLOT: [VIEWPORT_SHADE_PLOT; 4] = [
  VIEWPORT_SHADE_PLOT::AS_DISPLAYED,
  VIEWPORT_SHADE_PLOT::WIREFRAME,
  VIEWPORT_SHADE_PLOT::HIDDEN,
  VIEWPORT_SHADE_PLOT::RENDERED,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct VIEWPORT_SHADE_PLOT(pub u8);
#[allow(non_upper_case_globals)]
impl VIEWPORT_SHADE_PLOT {
  pub const AS_DISPLAYED: Self = Self(10);
  pub const WIREFRAME: Self = Self(11);
  pub const HIDDEN: Self = Self(12);
  pub const RENDERED: Self = Self(13);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 13;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::AS_DISPLAYED,
    Self::WIREFRAME,
    Self::HIDDEN,
    Self::RENDERED,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::AS_DISPLAYED => Some("AS_DISPLAYED"),
      Self::WIREFRAME => Some("WIREFRAME"),
      Self::HIDDEN => Some("HIDDEN"),
      Self::RENDERED => Some("RENDERED"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for VIEWPORT_SHADE_PLOT {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for VIEWPORT_SHADE_PLOT {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for VIEWPORT_SHADE_PLOT {
    type Output = VIEWPORT_SHADE_PLOT;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for VIEWPORT_SHADE_PLOT {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for VIEWPORT_SHADE_PLOT {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for VIEWPORT_SHADE_PLOT {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_HATCH_STYLE: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_HATCH_STYLE: u8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_HATCH_STYLE: [HATCH_STYLE; 3] = [
  HATCH_STYLE::NORMAL,
  HATCH_STYLE::OUTER,
  HATCH_STYLE::IGNORE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct HATCH_STYLE(pub u8);
#[allow(non_upper_case_globals)]
impl HATCH_STYLE {
  pub const NORMAL: Self = Self(10);
  pub const OUTER: Self = Self(11);
  pub const IGNORE: Self = Self(12);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NORMAL,
    Self::OUTER,
    Self::IGNORE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NORMAL => Some("NORMAL"),
      Self::OUTER => Some("OUTER"),
      Self::IGNORE => Some("IGNORE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for HATCH_STYLE {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for HATCH_STYLE {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for HATCH_STYLE {
    type Output = HATCH_STYLE;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for HATCH_STYLE {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for HATCH_STYLE {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for HATCH_STYLE {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_IMAGE_STATUS: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_IMAGE_STATUS: u8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_IMAGE_STATUS: [IMAGE_STATUS; 3] = [
  IMAGE_STATUS::PENDING,
  IMAGE_STATUS::SAVED,
  IMAGE_STATUS::ERROR,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct IMAGE_STATUS(pub u8);
#[allow(non_upper_case_globals)]
impl IMAGE_STATUS {
  pub const PENDING: Self = Self(10);
  pub const SAVED: Self = Self(11);
  pub const ERROR: Self = Self(12);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::PENDING,
    Self::SAVED,
    Self::ERROR,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::PENDING => Some("PENDING"),
      Self::SAVED => Some("SAVED"),
      Self::ERROR => Some("ERROR"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for IMAGE_STATUS {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for IMAGE_STATUS {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for IMAGE_STATUS {
    type Output = IMAGE_STATUS;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for IMAGE_STATUS {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for IMAGE_STATUS {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for IMAGE_STATUS {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_BLOCK_ATTACHMENT: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_BLOCK_ATTACHMENT: u8 = 11;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_BLOCK_ATTACHMENT: [BLOCK_ATTACHMENT; 2] = [
  BLOCK_ATTACHMENT::CENTER_EXTENTS,
  BLOCK_ATTACHMENT::INSERTION_POINT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct BLOCK_ATTACHMENT(pub u8);
#[allow(non_upper_case_globals)]
impl BLOCK_ATTACHMENT {
  pub const CENTER_EXTENTS: Self = Self(10);
  pub const INSERTION_POINT: Self = Self(11);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 11;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::CENTER_EXTENTS,
    Self::INSERTION_POINT,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::CENTER_EXTENTS => Some("CENTER_EXTENTS"),
      Self::INSERTION_POINT => Some("INSERTION_POINT"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for BLOCK_ATTACHMENT {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for BLOCK_ATTACHMENT {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for BLOCK_ATTACHMENT {
    type Output = BLOCK_ATTACHMENT;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for BLOCK_ATTACHMENT {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for BLOCK_ATTACHMENT {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for BLOCK_ATTACHMENT {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_AXIS: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_AXIS: u8 = 30;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_AXIS: [AXIS; 3] = [
  AXIS::X,
  AXIS::Y,
  AXIS::Z,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct AXIS(pub u8);
#[allow(non_upper_case_globals)]
impl AXIS {
  pub const X: Self = Self(10);
  pub const Y: Self = Self(20);
  pub const Z: Self = Self(30);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 30;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::X,
    Self::Y,
    Self::Z,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::X => Some("X"),
      Self::Y => Some("Y"),
      Self::Z => Some("Z"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for AXIS {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for AXIS {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for AXIS {
    type Output = AXIS;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for AXIS {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for AXIS {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for AXIS {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PRUNING_LEVEL: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PRUNING_LEVEL: u8 = 30;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PRUNING_LEVEL: [PRUNING_LEVEL; 3] = [
  PRUNING_LEVEL::CONSERVATIVE,
  PRUNING_LEVEL::BALANCED,
  PRUNING_LEVEL::AGGRESSIVE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct PRUNING_LEVEL(pub u8);
#[allow(non_upper_case_globals)]
impl PRUNING_LEVEL {
  pub const CONSERVATIVE: Self = Self(10);
  pub const BALANCED: Self = Self(20);
  pub const AGGRESSIVE: Self = Self(30);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 30;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::CONSERVATIVE,
    Self::BALANCED,
    Self::AGGRESSIVE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::CONSERVATIVE => Some("CONSERVATIVE"),
      Self::BALANCED => Some("BALANCED"),
      Self::AGGRESSIVE => Some("AGGRESSIVE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for PRUNING_LEVEL {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for PRUNING_LEVEL {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for PRUNING_LEVEL {
    type Output = PRUNING_LEVEL;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for PRUNING_LEVEL {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for PRUNING_LEVEL {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for PRUNING_LEVEL {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PARAMETRIC_SOURCE_TYPE: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PARAMETRIC_SOURCE_TYPE: u8 = 11;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PARAMETRIC_SOURCE_TYPE: [PARAMETRIC_SOURCE_TYPE; 2] = [
  PARAMETRIC_SOURCE_TYPE::CODE,
  PARAMETRIC_SOURCE_TYPE::FILE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct PARAMETRIC_SOURCE_TYPE(pub u8);
#[allow(non_upper_case_globals)]
impl PARAMETRIC_SOURCE_TYPE {
  pub const CODE: Self = Self(10);
  pub const FILE: Self = Self(11);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 11;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::CODE,
    Self::FILE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::CODE => Some("CODE"),
      Self::FILE => Some("FILE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for PARAMETRIC_SOURCE_TYPE {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for PARAMETRIC_SOURCE_TYPE {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for PARAMETRIC_SOURCE_TYPE {
    type Output = PARAMETRIC_SOURCE_TYPE;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for PARAMETRIC_SOURCE_TYPE {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for PARAMETRIC_SOURCE_TYPE {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for PARAMETRIC_SOURCE_TYPE {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_LEADER_CONTENT_TYPE: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_LEADER_CONTENT_TYPE: u8 = 11;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_LEADER_CONTENT_TYPE: [LEADER_CONTENT_TYPE; 2] = [
  LEADER_CONTENT_TYPE::TEXT,
  LEADER_CONTENT_TYPE::BLOCK,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct LEADER_CONTENT_TYPE(pub u8);
#[allow(non_upper_case_globals)]
impl LEADER_CONTENT_TYPE {
  pub const TEXT: Self = Self(10);
  pub const BLOCK: Self = Self(11);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 11;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::TEXT,
    Self::BLOCK,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::TEXT => Some("TEXT"),
      Self::BLOCK => Some("BLOCK"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for LEADER_CONTENT_TYPE {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for LEADER_CONTENT_TYPE {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for LEADER_CONTENT_TYPE {
    type Output = LEADER_CONTENT_TYPE;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for LEADER_CONTENT_TYPE {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for LEADER_CONTENT_TYPE {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for LEADER_CONTENT_TYPE {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_BOOLEAN_OPERATION: u8 = 10;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_BOOLEAN_OPERATION: u8 = 13;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_BOOLEAN_OPERATION: [BOOLEAN_OPERATION; 4] = [
  BOOLEAN_OPERATION::UNION,
  BOOLEAN_OPERATION::SUBTRACT,
  BOOLEAN_OPERATION::INTERSECT,
  BOOLEAN_OPERATION::EXCLUDE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct BOOLEAN_OPERATION(pub u8);
#[allow(non_upper_case_globals)]
impl BOOLEAN_OPERATION {
  pub const UNION: Self = Self(10);
  pub const SUBTRACT: Self = Self(11);
  pub const INTERSECT: Self = Self(12);
  pub const EXCLUDE: Self = Self(13);

  pub const ENUM_MIN: u8 = 10;
  pub const ENUM_MAX: u8 = 13;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::UNION,
    Self::SUBTRACT,
    Self::INTERSECT,
    Self::EXCLUDE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::UNION => Some("UNION"),
      Self::SUBTRACT => Some("SUBTRACT"),
      Self::INTERSECT => Some("INTERSECT"),
      Self::EXCLUDE => Some("EXCLUDE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for BOOLEAN_OPERATION {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for BOOLEAN_OPERATION {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for BOOLEAN_OPERATION {
    type Output = BOOLEAN_OPERATION;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for BOOLEAN_OPERATION {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for BOOLEAN_OPERATION {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for BOOLEAN_OPERATION {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DUC_TEXT_DYNAMIC_SOURCE_DATA: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DUC_TEXT_DYNAMIC_SOURCE_DATA: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DUC_TEXT_DYNAMIC_SOURCE_DATA: [DucTextDynamicSourceData; 3] = [
  DucTextDynamicSourceData::NONE,
  DucTextDynamicSourceData::DucTextDynamicElementSource,
  DucTextDynamicSourceData::DucTextDynamicDictionarySource,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DucTextDynamicSourceData(pub u8);
#[allow(non_upper_case_globals)]
impl DucTextDynamicSourceData {
  pub const NONE: Self = Self(0);
  pub const DucTextDynamicElementSource: Self = Self(1);
  pub const DucTextDynamicDictionarySource: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::DucTextDynamicElementSource,
    Self::DucTextDynamicDictionarySource,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::DucTextDynamicElementSource => Some("DucTextDynamicElementSource"),
      Self::DucTextDynamicDictionarySource => Some("DucTextDynamicDictionarySource"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DucTextDynamicSourceData {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DucTextDynamicSourceData {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for DucTextDynamicSourceData {
    type Output = DucTextDynamicSourceData;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DucTextDynamicSourceData {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DucTextDynamicSourceData {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DucTextDynamicSourceData {}
pub struct DucTextDynamicSourceDataUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_LEADER_CONTENT_DATA: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_LEADER_CONTENT_DATA: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_LEADER_CONTENT_DATA: [LeaderContentData; 3] = [
  LeaderContentData::NONE,
  LeaderContentData::LeaderTextBlockContent,
  LeaderContentData::LeaderBlockContent,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct LeaderContentData(pub u8);
#[allow(non_upper_case_globals)]
impl LeaderContentData {
  pub const NONE: Self = Self(0);
  pub const LeaderTextBlockContent: Self = Self(1);
  pub const LeaderBlockContent: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::LeaderTextBlockContent,
    Self::LeaderBlockContent,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::LeaderTextBlockContent => Some("LeaderTextBlockContent"),
      Self::LeaderBlockContent => Some("LeaderBlockContent"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for LeaderContentData {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for LeaderContentData {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for LeaderContentData {
    type Output = LeaderContentData;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for LeaderContentData {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for LeaderContentData {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for LeaderContentData {}
pub struct LeaderContentDataUnionTableOffset {}

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ELEMENT: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ELEMENT: u8 = 22;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ELEMENT: [Element; 23] = [
  Element::NONE,
  Element::DucRectangleElement,
  Element::DucPolygonElement,
  Element::DucEllipseElement,
  Element::DucEmbeddableElement,
  Element::DucPdfElement,
  Element::DucMermaidElement,
  Element::DucTableElement,
  Element::DucImageElement,
  Element::DucTextElement,
  Element::DucLinearElement,
  Element::DucArrowElement,
  Element::DucFreeDrawElement,
  Element::DucBlockInstanceElement,
  Element::DucFrameElement,
  Element::DucPlotElement,
  Element::DucViewportElement,
  Element::DucXRayElement,
  Element::DucLeaderElement,
  Element::DucDimensionElement,
  Element::DucFeatureControlFrameElement,
  Element::DucDocElement,
  Element::DucParametricElement,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Element(pub u8);
#[allow(non_upper_case_globals)]
impl Element {
  pub const NONE: Self = Self(0);
  pub const DucRectangleElement: Self = Self(1);
  pub const DucPolygonElement: Self = Self(2);
  pub const DucEllipseElement: Self = Self(3);
  pub const DucEmbeddableElement: Self = Self(4);
  pub const DucPdfElement: Self = Self(5);
  pub const DucMermaidElement: Self = Self(6);
  pub const DucTableElement: Self = Self(7);
  pub const DucImageElement: Self = Self(8);
  pub const DucTextElement: Self = Self(9);
  pub const DucLinearElement: Self = Self(10);
  pub const DucArrowElement: Self = Self(11);
  pub const DucFreeDrawElement: Self = Self(12);
  pub const DucBlockInstanceElement: Self = Self(13);
  pub const DucFrameElement: Self = Self(14);
  pub const DucPlotElement: Self = Self(15);
  pub const DucViewportElement: Self = Self(16);
  pub const DucXRayElement: Self = Self(17);
  pub const DucLeaderElement: Self = Self(18);
  pub const DucDimensionElement: Self = Self(19);
  pub const DucFeatureControlFrameElement: Self = Self(20);
  pub const DucDocElement: Self = Self(21);
  pub const DucParametricElement: Self = Self(22);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 22;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::DucRectangleElement,
    Self::DucPolygonElement,
    Self::DucEllipseElement,
    Self::DucEmbeddableElement,
    Self::DucPdfElement,
    Self::DucMermaidElement,
    Self::DucTableElement,
    Self::DucImageElement,
    Self::DucTextElement,
    Self::DucLinearElement,
    Self::DucArrowElement,
    Self::DucFreeDrawElement,
    Self::DucBlockInstanceElement,
    Self::DucFrameElement,
    Self::DucPlotElement,
    Self::DucViewportElement,
    Self::DucXRayElement,
    Self::DucLeaderElement,
    Self::DucDimensionElement,
    Self::DucFeatureControlFrameElement,
    Self::DucDocElement,
    Self::DucParametricElement,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::DucRectangleElement => Some("DucRectangleElement"),
      Self::DucPolygonElement => Some("DucPolygonElement"),
      Self::DucEllipseElement => Some("DucEllipseElement"),
      Self::DucEmbeddableElement => Some("DucEmbeddableElement"),
      Self::DucPdfElement => Some("DucPdfElement"),
      Self::DucMermaidElement => Some("DucMermaidElement"),
      Self::DucTableElement => Some("DucTableElement"),
      Self::DucImageElement => Some("DucImageElement"),
      Self::DucTextElement => Some("DucTextElement"),
      Self::DucLinearElement => Some("DucLinearElement"),
      Self::DucArrowElement => Some("DucArrowElement"),
      Self::DucFreeDrawElement => Some("DucFreeDrawElement"),
      Self::DucBlockInstanceElement => Some("DucBlockInstanceElement"),
      Self::DucFrameElement => Some("DucFrameElement"),
      Self::DucPlotElement => Some("DucPlotElement"),
      Self::DucViewportElement => Some("DucViewportElement"),
      Self::DucXRayElement => Some("DucXRayElement"),
      Self::DucLeaderElement => Some("DucLeaderElement"),
      Self::DucDimensionElement => Some("DucDimensionElement"),
      Self::DucFeatureControlFrameElement => Some("DucFeatureControlFrameElement"),
      Self::DucDocElement => Some("DucDocElement"),
      Self::DucParametricElement => Some("DucParametricElement"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Element {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Element {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Element {
    type Output = Element;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Element {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Element {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Element {}
pub struct ElementUnionTableOffset {}

// struct GeometricPoint, aligned to 8
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct GeometricPoint(pub [u8; 16]);
impl Default for GeometricPoint { 
  fn default() -> Self { 
    Self([0; 16])
  }
}
impl core::fmt::Debug for GeometricPoint {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("GeometricPoint")
      .field("x", &self.x())
      .field("y", &self.y())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for GeometricPoint {}
impl<'a> flatbuffers::Follow<'a> for GeometricPoint {
  type Inner = &'a GeometricPoint;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a GeometricPoint>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a GeometricPoint {
  type Inner = &'a GeometricPoint;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<GeometricPoint>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for GeometricPoint {
    type Output = GeometricPoint;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(self as *const GeometricPoint as *const u8, <Self as flatbuffers::Push>::size());
        dst.copy_from_slice(src);
    }
    #[inline]
    fn alignment() -> flatbuffers::PushAlignment {
        flatbuffers::PushAlignment::new(8)
    }
}

impl<'a> flatbuffers::Verifiable for GeometricPoint {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> GeometricPoint {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    x: f64,
    y: f64,
  ) -> Self {
    let mut s = Self([0; 16]);
    s.set_x(x);
    s.set_y(y);
    s
  }

  pub fn x(&self) -> f64 {
    let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[0..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_x(&mut self, x: f64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[0..].as_mut_ptr(),
        core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
      );
    }
  }

  pub fn y(&self) -> f64 {
    let mut mem = core::mem::MaybeUninit::<<f64 as EndianScalar>::Scalar>::uninit();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    EndianScalar::from_little_endian(unsafe {
      core::ptr::copy_nonoverlapping(
        self.0[8..].as_ptr(),
        mem.as_mut_ptr() as *mut u8,
        core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
      );
      mem.assume_init()
    })
  }

  pub fn set_y(&mut self, x: f64) {
    let x_le = x.to_little_endian();
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid value in this slot
    unsafe {
      core::ptr::copy_nonoverlapping(
        &x_le as *const _ as *const u8,
        self.0[8..].as_mut_ptr(),
        core::mem::size_of::<<f64 as EndianScalar>::Scalar>(),
      );
    }
  }

}

pub enum DictionaryEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DictionaryEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DictionaryEntry<'a> {
  type Inner = DictionaryEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DictionaryEntry<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DictionaryEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DictionaryEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<DictionaryEntry<'bldr>> {
    let mut builder = DictionaryEntryBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DictionaryEntry::VT_KEY, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &DictionaryEntry) -> bool {
    self.key() < o.key()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.key();
    key.cmp(val)
  }
  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DictionaryEntry::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for DictionaryEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct DictionaryEntryArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DictionaryEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    DictionaryEntryArgs {
      key: None, // required field
      value: None,
    }
  }
}

pub struct DictionaryEntryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DictionaryEntryBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DictionaryEntry::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DictionaryEntry::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DictionaryEntryBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DictionaryEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DictionaryEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, DictionaryEntry::VT_KEY,"key");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DictionaryEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DictionaryEntry");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum StringValueEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct StringValueEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StringValueEntry<'a> {
  type Inner = StringValueEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> StringValueEntry<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StringValueEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StringValueEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<StringValueEntry<'bldr>> {
    let mut builder = StringValueEntryBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StringValueEntry::VT_KEY, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &StringValueEntry) -> bool {
    self.key() < o.key()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.key();
    key.cmp(val)
  }
  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StringValueEntry::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for StringValueEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct StringValueEntryArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for StringValueEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    StringValueEntryArgs {
      key: None, // required field
      value: None,
    }
  }
}

pub struct StringValueEntryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StringValueEntryBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StringValueEntry::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StringValueEntry::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StringValueEntryBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StringValueEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StringValueEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, StringValueEntry::VT_KEY,"key");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StringValueEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StringValueEntry");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum IdentifierOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Identifier<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Identifier<'a> {
  type Inner = Identifier<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Identifier<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Identifier { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args IdentifierArgs<'args>
  ) -> flatbuffers::WIPOffset<Identifier<'bldr>> {
    let mut builder = IdentifierBuilder::new(_fbb);
    if let Some(x) = args.description { builder.add_description(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Identifier::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &Identifier) -> bool {
    self.id() < o.id()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.id();
    key.cmp(val)
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Identifier::VT_NAME, None)}
  }
  #[inline]
  pub fn description(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Identifier::VT_DESCRIPTION, None)}
  }
}

impl flatbuffers::Verifiable for Identifier<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("description", Self::VT_DESCRIPTION, false)?
     .finish();
    Ok(())
  }
}
pub struct IdentifierArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for IdentifierArgs<'a> {
  #[inline]
  fn default() -> Self {
    IdentifierArgs {
      id: None, // required field
      name: None,
      description: None,
    }
  }
}

pub struct IdentifierBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> IdentifierBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Identifier::VT_ID, id);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Identifier::VT_NAME, name);
  }
  #[inline]
  pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Identifier::VT_DESCRIPTION, description);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> IdentifierBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    IdentifierBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Identifier<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Identifier::VT_ID,"id");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Identifier<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Identifier");
      ds.field("id", &self.id());
      ds.field("name", &self.name());
      ds.field("description", &self.description());
      ds.finish()
  }
}
pub enum DucUcsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucUcs<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucUcs<'a> {
  type Inner = DucUcs<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucUcs<'a> {
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 4;
  pub const VT_ANGLE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucUcs { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucUcsArgs<'args>
  ) -> flatbuffers::WIPOffset<DucUcs<'bldr>> {
    let mut builder = DucUcsBuilder::new(_fbb);
    builder.add_angle(args.angle);
    if let Some(x) = args.origin { builder.add_origin(x); }
    builder.finish()
  }


  #[inline]
  pub fn origin(&self) -> Option<&'a GeometricPoint> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<GeometricPoint>(DucUcs::VT_ORIGIN, None)}
  }
  #[inline]
  pub fn angle(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucUcs::VT_ANGLE, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DucUcs<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<GeometricPoint>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<f64>("angle", Self::VT_ANGLE, false)?
     .finish();
    Ok(())
  }
}
pub struct DucUcsArgs<'a> {
    pub origin: Option<&'a GeometricPoint>,
    pub angle: f64,
}
impl<'a> Default for DucUcsArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucUcsArgs {
      origin: None,
      angle: 0.0,
    }
  }
}

pub struct DucUcsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucUcsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_origin(&mut self, origin: &GeometricPoint) {
    self.fbb_.push_slot_always::<&GeometricPoint>(DucUcs::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_angle(&mut self, angle: f64) {
    self.fbb_.push_slot::<f64>(DucUcs::VT_ANGLE, angle, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucUcsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucUcsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucUcs<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucUcs<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucUcs");
      ds.field("origin", &self.origin());
      ds.field("angle", &self.angle());
      ds.finish()
  }
}
pub enum DucViewOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucView<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucView<'a> {
  type Inner = DucView<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucView<'a> {
  pub const VT_SCROLL_X: flatbuffers::VOffsetT = 4;
  pub const VT_SCROLL_Y: flatbuffers::VOffsetT = 6;
  pub const VT_ZOOM: flatbuffers::VOffsetT = 8;
  pub const VT_TWIST_ANGLE: flatbuffers::VOffsetT = 10;
  pub const VT_CENTER_POINT: flatbuffers::VOffsetT = 12;
  pub const VT_SCOPE: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucView { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucViewArgs<'args>
  ) -> flatbuffers::WIPOffset<DucView<'bldr>> {
    let mut builder = DucViewBuilder::new(_fbb);
    builder.add_twist_angle(args.twist_angle);
    builder.add_zoom(args.zoom);
    builder.add_scroll_y(args.scroll_y);
    builder.add_scroll_x(args.scroll_x);
    if let Some(x) = args.scope { builder.add_scope(x); }
    if let Some(x) = args.center_point { builder.add_center_point(x); }
    builder.finish()
  }


  #[inline]
  pub fn scroll_x(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucView::VT_SCROLL_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn scroll_y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucView::VT_SCROLL_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn zoom(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucView::VT_ZOOM, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn twist_angle(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucView::VT_TWIST_ANGLE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn center_point(&self) -> Option<DucPoint<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucPoint>>(DucView::VT_CENTER_POINT, None)}
  }
  #[inline]
  pub fn scope(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucView::VT_SCOPE, None)}
  }
}

impl flatbuffers::Verifiable for DucView<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("scroll_x", Self::VT_SCROLL_X, false)?
     .visit_field::<f64>("scroll_y", Self::VT_SCROLL_Y, false)?
     .visit_field::<f64>("zoom", Self::VT_ZOOM, false)?
     .visit_field::<f64>("twist_angle", Self::VT_TWIST_ANGLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucPoint>>("center_point", Self::VT_CENTER_POINT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("scope", Self::VT_SCOPE, false)?
     .finish();
    Ok(())
  }
}
pub struct DucViewArgs<'a> {
    pub scroll_x: f64,
    pub scroll_y: f64,
    pub zoom: f64,
    pub twist_angle: f64,
    pub center_point: Option<flatbuffers::WIPOffset<DucPoint<'a>>>,
    pub scope: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DucViewArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucViewArgs {
      scroll_x: 0.0,
      scroll_y: 0.0,
      zoom: 0.0,
      twist_angle: 0.0,
      center_point: None,
      scope: None,
    }
  }
}

pub struct DucViewBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucViewBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_scroll_x(&mut self, scroll_x: f64) {
    self.fbb_.push_slot::<f64>(DucView::VT_SCROLL_X, scroll_x, 0.0);
  }
  #[inline]
  pub fn add_scroll_y(&mut self, scroll_y: f64) {
    self.fbb_.push_slot::<f64>(DucView::VT_SCROLL_Y, scroll_y, 0.0);
  }
  #[inline]
  pub fn add_zoom(&mut self, zoom: f64) {
    self.fbb_.push_slot::<f64>(DucView::VT_ZOOM, zoom, 0.0);
  }
  #[inline]
  pub fn add_twist_angle(&mut self, twist_angle: f64) {
    self.fbb_.push_slot::<f64>(DucView::VT_TWIST_ANGLE, twist_angle, 0.0);
  }
  #[inline]
  pub fn add_center_point(&mut self, center_point: flatbuffers::WIPOffset<DucPoint<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucPoint>>(DucView::VT_CENTER_POINT, center_point);
  }
  #[inline]
  pub fn add_scope(&mut self, scope: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucView::VT_SCOPE, scope);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucViewBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucViewBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucView<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucView<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucView");
      ds.field("scroll_x", &self.scroll_x());
      ds.field("scroll_y", &self.scroll_y());
      ds.field("zoom", &self.zoom());
      ds.field("twist_angle", &self.twist_angle());
      ds.field("center_point", &self.center_point());
      ds.field("scope", &self.scope());
      ds.finish()
  }
}
pub enum MarginsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Margins<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Margins<'a> {
  type Inner = Margins<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Margins<'a> {
  pub const VT_TOP: flatbuffers::VOffsetT = 4;
  pub const VT_RIGHT: flatbuffers::VOffsetT = 6;
  pub const VT_BOTTOM: flatbuffers::VOffsetT = 8;
  pub const VT_LEFT: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Margins { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MarginsArgs
  ) -> flatbuffers::WIPOffset<Margins<'bldr>> {
    let mut builder = MarginsBuilder::new(_fbb);
    builder.add_left(args.left);
    builder.add_bottom(args.bottom);
    builder.add_right(args.right);
    builder.add_top(args.top);
    builder.finish()
  }


  #[inline]
  pub fn top(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Margins::VT_TOP, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn right(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Margins::VT_RIGHT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn bottom(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Margins::VT_BOTTOM, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn left(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Margins::VT_LEFT, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Margins<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("top", Self::VT_TOP, false)?
     .visit_field::<f64>("right", Self::VT_RIGHT, false)?
     .visit_field::<f64>("bottom", Self::VT_BOTTOM, false)?
     .visit_field::<f64>("left", Self::VT_LEFT, false)?
     .finish();
    Ok(())
  }
}
pub struct MarginsArgs {
    pub top: f64,
    pub right: f64,
    pub bottom: f64,
    pub left: f64,
}
impl<'a> Default for MarginsArgs {
  #[inline]
  fn default() -> Self {
    MarginsArgs {
      top: 0.0,
      right: 0.0,
      bottom: 0.0,
      left: 0.0,
    }
  }
}

pub struct MarginsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MarginsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_top(&mut self, top: f64) {
    self.fbb_.push_slot::<f64>(Margins::VT_TOP, top, 0.0);
  }
  #[inline]
  pub fn add_right(&mut self, right: f64) {
    self.fbb_.push_slot::<f64>(Margins::VT_RIGHT, right, 0.0);
  }
  #[inline]
  pub fn add_bottom(&mut self, bottom: f64) {
    self.fbb_.push_slot::<f64>(Margins::VT_BOTTOM, bottom, 0.0);
  }
  #[inline]
  pub fn add_left(&mut self, left: f64) {
    self.fbb_.push_slot::<f64>(Margins::VT_LEFT, left, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MarginsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MarginsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Margins<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Margins<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Margins");
      ds.field("top", &self.top());
      ds.field("right", &self.right());
      ds.field("bottom", &self.bottom());
      ds.field("left", &self.left());
      ds.finish()
  }
}
pub enum TilingPropertiesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TilingProperties<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TilingProperties<'a> {
  type Inner = TilingProperties<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TilingProperties<'a> {
  pub const VT_SIZE_IN_PERCENT: flatbuffers::VOffsetT = 4;
  pub const VT_ANGLE: flatbuffers::VOffsetT = 6;
  pub const VT_SPACING: flatbuffers::VOffsetT = 8;
  pub const VT_OFFSET_X: flatbuffers::VOffsetT = 10;
  pub const VT_OFFSET_Y: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TilingProperties { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TilingPropertiesArgs
  ) -> flatbuffers::WIPOffset<TilingProperties<'bldr>> {
    let mut builder = TilingPropertiesBuilder::new(_fbb);
    if let Some(x) = args.offset_y { builder.add_offset_y(x); }
    if let Some(x) = args.offset_x { builder.add_offset_x(x); }
    if let Some(x) = args.spacing { builder.add_spacing(x); }
    builder.add_angle(args.angle);
    builder.add_size_in_percent(args.size_in_percent);
    builder.finish()
  }


  #[inline]
  pub fn size_in_percent(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(TilingProperties::VT_SIZE_IN_PERCENT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn angle(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TilingProperties::VT_ANGLE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn spacing(&self) -> Option<f64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TilingProperties::VT_SPACING, None)}
  }
  #[inline]
  pub fn offset_x(&self) -> Option<f64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TilingProperties::VT_OFFSET_X, None)}
  }
  #[inline]
  pub fn offset_y(&self) -> Option<f64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TilingProperties::VT_OFFSET_Y, None)}
  }
}

impl flatbuffers::Verifiable for TilingProperties<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("size_in_percent", Self::VT_SIZE_IN_PERCENT, false)?
     .visit_field::<f64>("angle", Self::VT_ANGLE, false)?
     .visit_field::<f64>("spacing", Self::VT_SPACING, false)?
     .visit_field::<f64>("offset_x", Self::VT_OFFSET_X, false)?
     .visit_field::<f64>("offset_y", Self::VT_OFFSET_Y, false)?
     .finish();
    Ok(())
  }
}
pub struct TilingPropertiesArgs {
    pub size_in_percent: f32,
    pub angle: f64,
    pub spacing: Option<f64>,
    pub offset_x: Option<f64>,
    pub offset_y: Option<f64>,
}
impl<'a> Default for TilingPropertiesArgs {
  #[inline]
  fn default() -> Self {
    TilingPropertiesArgs {
      size_in_percent: 0.0,
      angle: 0.0,
      spacing: None,
      offset_x: None,
      offset_y: None,
    }
  }
}

pub struct TilingPropertiesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TilingPropertiesBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_size_in_percent(&mut self, size_in_percent: f32) {
    self.fbb_.push_slot::<f32>(TilingProperties::VT_SIZE_IN_PERCENT, size_in_percent, 0.0);
  }
  #[inline]
  pub fn add_angle(&mut self, angle: f64) {
    self.fbb_.push_slot::<f64>(TilingProperties::VT_ANGLE, angle, 0.0);
  }
  #[inline]
  pub fn add_spacing(&mut self, spacing: f64) {
    self.fbb_.push_slot_always::<f64>(TilingProperties::VT_SPACING, spacing);
  }
  #[inline]
  pub fn add_offset_x(&mut self, offset_x: f64) {
    self.fbb_.push_slot_always::<f64>(TilingProperties::VT_OFFSET_X, offset_x);
  }
  #[inline]
  pub fn add_offset_y(&mut self, offset_y: f64) {
    self.fbb_.push_slot_always::<f64>(TilingProperties::VT_OFFSET_Y, offset_y);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TilingPropertiesBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TilingPropertiesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TilingProperties<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TilingProperties<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TilingProperties");
      ds.field("size_in_percent", &self.size_in_percent());
      ds.field("angle", &self.angle());
      ds.field("spacing", &self.spacing());
      ds.field("offset_x", &self.offset_x());
      ds.field("offset_y", &self.offset_y());
      ds.finish()
  }
}
pub enum HatchPatternLineOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct HatchPatternLine<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for HatchPatternLine<'a> {
  type Inner = HatchPatternLine<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> HatchPatternLine<'a> {
  pub const VT_ANGLE: flatbuffers::VOffsetT = 4;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 6;
  pub const VT_OFFSET: flatbuffers::VOffsetT = 8;
  pub const VT_DASH_PATTERN: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    HatchPatternLine { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args HatchPatternLineArgs<'args>
  ) -> flatbuffers::WIPOffset<HatchPatternLine<'bldr>> {
    let mut builder = HatchPatternLineBuilder::new(_fbb);
    builder.add_angle(args.angle);
    if let Some(x) = args.dash_pattern { builder.add_dash_pattern(x); }
    if let Some(x) = args.offset { builder.add_offset(x); }
    if let Some(x) = args.origin { builder.add_origin(x); }
    builder.finish()
  }


  #[inline]
  pub fn angle(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(HatchPatternLine::VT_ANGLE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn origin(&self) -> Option<DucPoint<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucPoint>>(HatchPatternLine::VT_ORIGIN, None)}
  }
  #[inline]
  pub fn offset(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(HatchPatternLine::VT_OFFSET, None)}
  }
  #[inline]
  pub fn dash_pattern(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(HatchPatternLine::VT_DASH_PATTERN, None)}
  }
}

impl flatbuffers::Verifiable for HatchPatternLine<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("angle", Self::VT_ANGLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucPoint>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("offset", Self::VT_OFFSET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("dash_pattern", Self::VT_DASH_PATTERN, false)?
     .finish();
    Ok(())
  }
}
pub struct HatchPatternLineArgs<'a> {
    pub angle: f64,
    pub origin: Option<flatbuffers::WIPOffset<DucPoint<'a>>>,
    pub offset: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub dash_pattern: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
}
impl<'a> Default for HatchPatternLineArgs<'a> {
  #[inline]
  fn default() -> Self {
    HatchPatternLineArgs {
      angle: 0.0,
      origin: None,
      offset: None,
      dash_pattern: None,
    }
  }
}

pub struct HatchPatternLineBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> HatchPatternLineBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_angle(&mut self, angle: f64) {
    self.fbb_.push_slot::<f64>(HatchPatternLine::VT_ANGLE, angle, 0.0);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<DucPoint<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucPoint>>(HatchPatternLine::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_offset(&mut self, offset: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HatchPatternLine::VT_OFFSET, offset);
  }
  #[inline]
  pub fn add_dash_pattern(&mut self, dash_pattern: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(HatchPatternLine::VT_DASH_PATTERN, dash_pattern);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> HatchPatternLineBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    HatchPatternLineBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<HatchPatternLine<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for HatchPatternLine<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("HatchPatternLine");
      ds.field("angle", &self.angle());
      ds.field("origin", &self.origin());
      ds.field("offset", &self.offset());
      ds.field("dash_pattern", &self.dash_pattern());
      ds.finish()
  }
}
pub enum CustomHatchPatternOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CustomHatchPattern<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CustomHatchPattern<'a> {
  type Inner = CustomHatchPattern<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CustomHatchPattern<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 6;
  pub const VT_LINES: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CustomHatchPattern { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CustomHatchPatternArgs<'args>
  ) -> flatbuffers::WIPOffset<CustomHatchPattern<'bldr>> {
    let mut builder = CustomHatchPatternBuilder::new(_fbb);
    if let Some(x) = args.lines { builder.add_lines(x); }
    if let Some(x) = args.description { builder.add_description(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CustomHatchPattern::VT_NAME, None)}
  }
  #[inline]
  pub fn description(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CustomHatchPattern::VT_DESCRIPTION, None)}
  }
  #[inline]
  pub fn lines(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<HatchPatternLine<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<HatchPatternLine>>>>(CustomHatchPattern::VT_LINES, None)}
  }
}

impl flatbuffers::Verifiable for CustomHatchPattern<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("description", Self::VT_DESCRIPTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<HatchPatternLine>>>>("lines", Self::VT_LINES, false)?
     .finish();
    Ok(())
  }
}
pub struct CustomHatchPatternArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lines: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<HatchPatternLine<'a>>>>>,
}
impl<'a> Default for CustomHatchPatternArgs<'a> {
  #[inline]
  fn default() -> Self {
    CustomHatchPatternArgs {
      name: None,
      description: None,
      lines: None,
    }
  }
}

pub struct CustomHatchPatternBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CustomHatchPatternBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CustomHatchPattern::VT_NAME, name);
  }
  #[inline]
  pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CustomHatchPattern::VT_DESCRIPTION, description);
  }
  #[inline]
  pub fn add_lines(&mut self, lines: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<HatchPatternLine<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CustomHatchPattern::VT_LINES, lines);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CustomHatchPatternBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CustomHatchPatternBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CustomHatchPattern<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CustomHatchPattern<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CustomHatchPattern");
      ds.field("name", &self.name());
      ds.field("description", &self.description());
      ds.field("lines", &self.lines());
      ds.finish()
  }
}
pub enum DucHatchStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucHatchStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucHatchStyle<'a> {
  type Inner = DucHatchStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucHatchStyle<'a> {
  pub const VT_HATCH_STYLE: flatbuffers::VOffsetT = 4;
  pub const VT_PATTERN_NAME: flatbuffers::VOffsetT = 6;
  pub const VT_PATTERN_SCALE: flatbuffers::VOffsetT = 8;
  pub const VT_PATTERN_ANGLE: flatbuffers::VOffsetT = 10;
  pub const VT_PATTERN_ORIGIN: flatbuffers::VOffsetT = 12;
  pub const VT_PATTERN_DOUBLE: flatbuffers::VOffsetT = 14;
  pub const VT_CUSTOM_PATTERN: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucHatchStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucHatchStyleArgs<'args>
  ) -> flatbuffers::WIPOffset<DucHatchStyle<'bldr>> {
    let mut builder = DucHatchStyleBuilder::new(_fbb);
    builder.add_pattern_angle(args.pattern_angle);
    if let Some(x) = args.custom_pattern { builder.add_custom_pattern(x); }
    if let Some(x) = args.pattern_origin { builder.add_pattern_origin(x); }
    builder.add_pattern_scale(args.pattern_scale);
    if let Some(x) = args.pattern_name { builder.add_pattern_name(x); }
    builder.add_pattern_double(args.pattern_double);
    if let Some(x) = args.hatch_style { builder.add_hatch_style(x); }
    builder.finish()
  }


  #[inline]
  pub fn hatch_style(&self) -> Option<HATCH_STYLE> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<HATCH_STYLE>(DucHatchStyle::VT_HATCH_STYLE, None)}
  }
  #[inline]
  pub fn pattern_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucHatchStyle::VT_PATTERN_NAME, None)}
  }
  #[inline]
  pub fn pattern_scale(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucHatchStyle::VT_PATTERN_SCALE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn pattern_angle(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucHatchStyle::VT_PATTERN_ANGLE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn pattern_origin(&self) -> Option<DucPoint<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucPoint>>(DucHatchStyle::VT_PATTERN_ORIGIN, None)}
  }
  #[inline]
  pub fn pattern_double(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucHatchStyle::VT_PATTERN_DOUBLE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn custom_pattern(&self) -> Option<CustomHatchPattern<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<CustomHatchPattern>>(DucHatchStyle::VT_CUSTOM_PATTERN, None)}
  }
}

impl flatbuffers::Verifiable for DucHatchStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<HATCH_STYLE>("hatch_style", Self::VT_HATCH_STYLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pattern_name", Self::VT_PATTERN_NAME, false)?
     .visit_field::<f32>("pattern_scale", Self::VT_PATTERN_SCALE, false)?
     .visit_field::<f64>("pattern_angle", Self::VT_PATTERN_ANGLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucPoint>>("pattern_origin", Self::VT_PATTERN_ORIGIN, false)?
     .visit_field::<bool>("pattern_double", Self::VT_PATTERN_DOUBLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<CustomHatchPattern>>("custom_pattern", Self::VT_CUSTOM_PATTERN, false)?
     .finish();
    Ok(())
  }
}
pub struct DucHatchStyleArgs<'a> {
    pub hatch_style: Option<HATCH_STYLE>,
    pub pattern_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub pattern_scale: f32,
    pub pattern_angle: f64,
    pub pattern_origin: Option<flatbuffers::WIPOffset<DucPoint<'a>>>,
    pub pattern_double: bool,
    pub custom_pattern: Option<flatbuffers::WIPOffset<CustomHatchPattern<'a>>>,
}
impl<'a> Default for DucHatchStyleArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucHatchStyleArgs {
      hatch_style: None,
      pattern_name: None,
      pattern_scale: 0.0,
      pattern_angle: 0.0,
      pattern_origin: None,
      pattern_double: false,
      custom_pattern: None,
    }
  }
}

pub struct DucHatchStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucHatchStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_hatch_style(&mut self, hatch_style: HATCH_STYLE) {
    self.fbb_.push_slot_always::<HATCH_STYLE>(DucHatchStyle::VT_HATCH_STYLE, hatch_style);
  }
  #[inline]
  pub fn add_pattern_name(&mut self, pattern_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucHatchStyle::VT_PATTERN_NAME, pattern_name);
  }
  #[inline]
  pub fn add_pattern_scale(&mut self, pattern_scale: f32) {
    self.fbb_.push_slot::<f32>(DucHatchStyle::VT_PATTERN_SCALE, pattern_scale, 0.0);
  }
  #[inline]
  pub fn add_pattern_angle(&mut self, pattern_angle: f64) {
    self.fbb_.push_slot::<f64>(DucHatchStyle::VT_PATTERN_ANGLE, pattern_angle, 0.0);
  }
  #[inline]
  pub fn add_pattern_origin(&mut self, pattern_origin: flatbuffers::WIPOffset<DucPoint<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucPoint>>(DucHatchStyle::VT_PATTERN_ORIGIN, pattern_origin);
  }
  #[inline]
  pub fn add_pattern_double(&mut self, pattern_double: bool) {
    self.fbb_.push_slot::<bool>(DucHatchStyle::VT_PATTERN_DOUBLE, pattern_double, false);
  }
  #[inline]
  pub fn add_custom_pattern(&mut self, custom_pattern: flatbuffers::WIPOffset<CustomHatchPattern<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<CustomHatchPattern>>(DucHatchStyle::VT_CUSTOM_PATTERN, custom_pattern);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucHatchStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucHatchStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucHatchStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucHatchStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucHatchStyle");
      ds.field("hatch_style", &self.hatch_style());
      ds.field("pattern_name", &self.pattern_name());
      ds.field("pattern_scale", &self.pattern_scale());
      ds.field("pattern_angle", &self.pattern_angle());
      ds.field("pattern_origin", &self.pattern_origin());
      ds.field("pattern_double", &self.pattern_double());
      ds.field("custom_pattern", &self.custom_pattern());
      ds.finish()
  }
}
pub enum DucImageFilterOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucImageFilter<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucImageFilter<'a> {
  type Inner = DucImageFilter<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucImageFilter<'a> {
  pub const VT_BRIGHTNESS: flatbuffers::VOffsetT = 4;
  pub const VT_CONTRAST: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucImageFilter { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucImageFilterArgs
  ) -> flatbuffers::WIPOffset<DucImageFilter<'bldr>> {
    let mut builder = DucImageFilterBuilder::new(_fbb);
    builder.add_contrast(args.contrast);
    builder.add_brightness(args.brightness);
    builder.finish()
  }


  #[inline]
  pub fn brightness(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucImageFilter::VT_BRIGHTNESS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn contrast(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucImageFilter::VT_CONTRAST, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DucImageFilter<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("brightness", Self::VT_BRIGHTNESS, false)?
     .visit_field::<f32>("contrast", Self::VT_CONTRAST, false)?
     .finish();
    Ok(())
  }
}
pub struct DucImageFilterArgs {
    pub brightness: f32,
    pub contrast: f32,
}
impl<'a> Default for DucImageFilterArgs {
  #[inline]
  fn default() -> Self {
    DucImageFilterArgs {
      brightness: 0.0,
      contrast: 0.0,
    }
  }
}

pub struct DucImageFilterBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucImageFilterBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_brightness(&mut self, brightness: f32) {
    self.fbb_.push_slot::<f32>(DucImageFilter::VT_BRIGHTNESS, brightness, 0.0);
  }
  #[inline]
  pub fn add_contrast(&mut self, contrast: f32) {
    self.fbb_.push_slot::<f32>(DucImageFilter::VT_CONTRAST, contrast, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucImageFilterBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucImageFilterBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucImageFilter<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucImageFilter<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucImageFilter");
      ds.field("brightness", &self.brightness());
      ds.field("contrast", &self.contrast());
      ds.finish()
  }
}
pub enum ElementContentBaseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ElementContentBase<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ElementContentBase<'a> {
  type Inner = ElementContentBase<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ElementContentBase<'a> {
  pub const VT_PREFERENCE: flatbuffers::VOffsetT = 4;
  pub const VT_SRC: flatbuffers::VOffsetT = 6;
  pub const VT_VISIBLE: flatbuffers::VOffsetT = 8;
  pub const VT_OPACITY: flatbuffers::VOffsetT = 10;
  pub const VT_TILING: flatbuffers::VOffsetT = 12;
  pub const VT_HATCH: flatbuffers::VOffsetT = 14;
  pub const VT_IMAGE_FILTER: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ElementContentBase { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ElementContentBaseArgs<'args>
  ) -> flatbuffers::WIPOffset<ElementContentBase<'bldr>> {
    let mut builder = ElementContentBaseBuilder::new(_fbb);
    builder.add_opacity(args.opacity);
    if let Some(x) = args.image_filter { builder.add_image_filter(x); }
    if let Some(x) = args.hatch { builder.add_hatch(x); }
    if let Some(x) = args.tiling { builder.add_tiling(x); }
    if let Some(x) = args.src { builder.add_src(x); }
    builder.add_visible(args.visible);
    if let Some(x) = args.preference { builder.add_preference(x); }
    builder.finish()
  }


  #[inline]
  pub fn preference(&self) -> Option<ELEMENT_CONTENT_PREFERENCE> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ELEMENT_CONTENT_PREFERENCE>(ElementContentBase::VT_PREFERENCE, None)}
  }
  #[inline]
  pub fn src(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ElementContentBase::VT_SRC, None)}
  }
  #[inline]
  pub fn visible(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ElementContentBase::VT_VISIBLE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn opacity(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ElementContentBase::VT_OPACITY, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn tiling(&self) -> Option<TilingProperties<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<TilingProperties>>(ElementContentBase::VT_TILING, None)}
  }
  #[inline]
  pub fn hatch(&self) -> Option<DucHatchStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucHatchStyle>>(ElementContentBase::VT_HATCH, None)}
  }
  #[inline]
  pub fn image_filter(&self) -> Option<DucImageFilter<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucImageFilter>>(ElementContentBase::VT_IMAGE_FILTER, None)}
  }
}

impl flatbuffers::Verifiable for ElementContentBase<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<ELEMENT_CONTENT_PREFERENCE>("preference", Self::VT_PREFERENCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("src", Self::VT_SRC, false)?
     .visit_field::<bool>("visible", Self::VT_VISIBLE, false)?
     .visit_field::<f64>("opacity", Self::VT_OPACITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<TilingProperties>>("tiling", Self::VT_TILING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucHatchStyle>>("hatch", Self::VT_HATCH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucImageFilter>>("image_filter", Self::VT_IMAGE_FILTER, false)?
     .finish();
    Ok(())
  }
}
pub struct ElementContentBaseArgs<'a> {
    pub preference: Option<ELEMENT_CONTENT_PREFERENCE>,
    pub src: Option<flatbuffers::WIPOffset<&'a str>>,
    pub visible: bool,
    pub opacity: f64,
    pub tiling: Option<flatbuffers::WIPOffset<TilingProperties<'a>>>,
    pub hatch: Option<flatbuffers::WIPOffset<DucHatchStyle<'a>>>,
    pub image_filter: Option<flatbuffers::WIPOffset<DucImageFilter<'a>>>,
}
impl<'a> Default for ElementContentBaseArgs<'a> {
  #[inline]
  fn default() -> Self {
    ElementContentBaseArgs {
      preference: None,
      src: None,
      visible: false,
      opacity: 0.0,
      tiling: None,
      hatch: None,
      image_filter: None,
    }
  }
}

pub struct ElementContentBaseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ElementContentBaseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_preference(&mut self, preference: ELEMENT_CONTENT_PREFERENCE) {
    self.fbb_.push_slot_always::<ELEMENT_CONTENT_PREFERENCE>(ElementContentBase::VT_PREFERENCE, preference);
  }
  #[inline]
  pub fn add_src(&mut self, src: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ElementContentBase::VT_SRC, src);
  }
  #[inline]
  pub fn add_visible(&mut self, visible: bool) {
    self.fbb_.push_slot::<bool>(ElementContentBase::VT_VISIBLE, visible, false);
  }
  #[inline]
  pub fn add_opacity(&mut self, opacity: f64) {
    self.fbb_.push_slot::<f64>(ElementContentBase::VT_OPACITY, opacity, 0.0);
  }
  #[inline]
  pub fn add_tiling(&mut self, tiling: flatbuffers::WIPOffset<TilingProperties<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<TilingProperties>>(ElementContentBase::VT_TILING, tiling);
  }
  #[inline]
  pub fn add_hatch(&mut self, hatch: flatbuffers::WIPOffset<DucHatchStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucHatchStyle>>(ElementContentBase::VT_HATCH, hatch);
  }
  #[inline]
  pub fn add_image_filter(&mut self, image_filter: flatbuffers::WIPOffset<DucImageFilter<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucImageFilter>>(ElementContentBase::VT_IMAGE_FILTER, image_filter);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ElementContentBaseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ElementContentBaseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ElementContentBase<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ElementContentBase<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ElementContentBase");
      ds.field("preference", &self.preference());
      ds.field("src", &self.src());
      ds.field("visible", &self.visible());
      ds.field("opacity", &self.opacity());
      ds.field("tiling", &self.tiling());
      ds.field("hatch", &self.hatch());
      ds.field("image_filter", &self.image_filter());
      ds.finish()
  }
}
pub enum StrokeStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct StrokeStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StrokeStyle<'a> {
  type Inner = StrokeStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> StrokeStyle<'a> {
  pub const VT_PREFERENCE: flatbuffers::VOffsetT = 4;
  pub const VT_CAP: flatbuffers::VOffsetT = 6;
  pub const VT_JOIN: flatbuffers::VOffsetT = 8;
  pub const VT_DASH: flatbuffers::VOffsetT = 10;
  pub const VT_DASH_LINE_OVERRIDE: flatbuffers::VOffsetT = 12;
  pub const VT_DASH_CAP: flatbuffers::VOffsetT = 14;
  pub const VT_MITER_LIMIT: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StrokeStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StrokeStyleArgs<'args>
  ) -> flatbuffers::WIPOffset<StrokeStyle<'bldr>> {
    let mut builder = StrokeStyleBuilder::new(_fbb);
    if let Some(x) = args.miter_limit { builder.add_miter_limit(x); }
    if let Some(x) = args.dash_line_override { builder.add_dash_line_override(x); }
    if let Some(x) = args.dash { builder.add_dash(x); }
    if let Some(x) = args.dash_cap { builder.add_dash_cap(x); }
    if let Some(x) = args.join { builder.add_join(x); }
    if let Some(x) = args.cap { builder.add_cap(x); }
    if let Some(x) = args.preference { builder.add_preference(x); }
    builder.finish()
  }


  #[inline]
  pub fn preference(&self) -> Option<STROKE_PREFERENCE> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<STROKE_PREFERENCE>(StrokeStyle::VT_PREFERENCE, None)}
  }
  #[inline]
  pub fn cap(&self) -> Option<STROKE_CAP> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<STROKE_CAP>(StrokeStyle::VT_CAP, None)}
  }
  #[inline]
  pub fn join(&self) -> Option<STROKE_JOIN> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<STROKE_JOIN>(StrokeStyle::VT_JOIN, None)}
  }
  #[inline]
  pub fn dash(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(StrokeStyle::VT_DASH, None)}
  }
  #[inline]
  pub fn dash_line_override(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StrokeStyle::VT_DASH_LINE_OVERRIDE, None)}
  }
  #[inline]
  pub fn dash_cap(&self) -> Option<STROKE_CAP> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<STROKE_CAP>(StrokeStyle::VT_DASH_CAP, None)}
  }
  #[inline]
  pub fn miter_limit(&self) -> Option<f64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StrokeStyle::VT_MITER_LIMIT, None)}
  }
}

impl flatbuffers::Verifiable for StrokeStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<STROKE_PREFERENCE>("preference", Self::VT_PREFERENCE, false)?
     .visit_field::<STROKE_CAP>("cap", Self::VT_CAP, false)?
     .visit_field::<STROKE_JOIN>("join", Self::VT_JOIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("dash", Self::VT_DASH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("dash_line_override", Self::VT_DASH_LINE_OVERRIDE, false)?
     .visit_field::<STROKE_CAP>("dash_cap", Self::VT_DASH_CAP, false)?
     .visit_field::<f64>("miter_limit", Self::VT_MITER_LIMIT, false)?
     .finish();
    Ok(())
  }
}
pub struct StrokeStyleArgs<'a> {
    pub preference: Option<STROKE_PREFERENCE>,
    pub cap: Option<STROKE_CAP>,
    pub join: Option<STROKE_JOIN>,
    pub dash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub dash_line_override: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dash_cap: Option<STROKE_CAP>,
    pub miter_limit: Option<f64>,
}
impl<'a> Default for StrokeStyleArgs<'a> {
  #[inline]
  fn default() -> Self {
    StrokeStyleArgs {
      preference: None,
      cap: None,
      join: None,
      dash: None,
      dash_line_override: None,
      dash_cap: None,
      miter_limit: None,
    }
  }
}

pub struct StrokeStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StrokeStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_preference(&mut self, preference: STROKE_PREFERENCE) {
    self.fbb_.push_slot_always::<STROKE_PREFERENCE>(StrokeStyle::VT_PREFERENCE, preference);
  }
  #[inline]
  pub fn add_cap(&mut self, cap: STROKE_CAP) {
    self.fbb_.push_slot_always::<STROKE_CAP>(StrokeStyle::VT_CAP, cap);
  }
  #[inline]
  pub fn add_join(&mut self, join: STROKE_JOIN) {
    self.fbb_.push_slot_always::<STROKE_JOIN>(StrokeStyle::VT_JOIN, join);
  }
  #[inline]
  pub fn add_dash(&mut self, dash: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StrokeStyle::VT_DASH, dash);
  }
  #[inline]
  pub fn add_dash_line_override(&mut self, dash_line_override: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StrokeStyle::VT_DASH_LINE_OVERRIDE, dash_line_override);
  }
  #[inline]
  pub fn add_dash_cap(&mut self, dash_cap: STROKE_CAP) {
    self.fbb_.push_slot_always::<STROKE_CAP>(StrokeStyle::VT_DASH_CAP, dash_cap);
  }
  #[inline]
  pub fn add_miter_limit(&mut self, miter_limit: f64) {
    self.fbb_.push_slot_always::<f64>(StrokeStyle::VT_MITER_LIMIT, miter_limit);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StrokeStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StrokeStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StrokeStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StrokeStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StrokeStyle");
      ds.field("preference", &self.preference());
      ds.field("cap", &self.cap());
      ds.field("join", &self.join());
      ds.field("dash", &self.dash());
      ds.field("dash_line_override", &self.dash_line_override());
      ds.field("dash_cap", &self.dash_cap());
      ds.field("miter_limit", &self.miter_limit());
      ds.finish()
  }
}
pub enum StrokeSidesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct StrokeSides<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StrokeSides<'a> {
  type Inner = StrokeSides<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> StrokeSides<'a> {
  pub const VT_PREFERENCE: flatbuffers::VOffsetT = 4;
  pub const VT_VALUES: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StrokeSides { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StrokeSidesArgs<'args>
  ) -> flatbuffers::WIPOffset<StrokeSides<'bldr>> {
    let mut builder = StrokeSidesBuilder::new(_fbb);
    if let Some(x) = args.values { builder.add_values(x); }
    if let Some(x) = args.preference { builder.add_preference(x); }
    builder.finish()
  }


  #[inline]
  pub fn preference(&self) -> Option<STROKE_SIDE_PREFERENCE> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<STROKE_SIDE_PREFERENCE>(StrokeSides::VT_PREFERENCE, None)}
  }
  #[inline]
  pub fn values(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(StrokeSides::VT_VALUES, None)}
  }
}

impl flatbuffers::Verifiable for StrokeSides<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<STROKE_SIDE_PREFERENCE>("preference", Self::VT_PREFERENCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("values", Self::VT_VALUES, false)?
     .finish();
    Ok(())
  }
}
pub struct StrokeSidesArgs<'a> {
    pub preference: Option<STROKE_SIDE_PREFERENCE>,
    pub values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
}
impl<'a> Default for StrokeSidesArgs<'a> {
  #[inline]
  fn default() -> Self {
    StrokeSidesArgs {
      preference: None,
      values: None,
    }
  }
}

pub struct StrokeSidesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StrokeSidesBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_preference(&mut self, preference: STROKE_SIDE_PREFERENCE) {
    self.fbb_.push_slot_always::<STROKE_SIDE_PREFERENCE>(StrokeSides::VT_PREFERENCE, preference);
  }
  #[inline]
  pub fn add_values(&mut self, values: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StrokeSides::VT_VALUES, values);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StrokeSidesBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StrokeSidesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StrokeSides<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StrokeSides<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StrokeSides");
      ds.field("preference", &self.preference());
      ds.field("values", &self.values());
      ds.finish()
  }
}
pub enum ElementStrokeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ElementStroke<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ElementStroke<'a> {
  type Inner = ElementStroke<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ElementStroke<'a> {
  pub const VT_CONTENT: flatbuffers::VOffsetT = 4;
  pub const VT_WIDTH: flatbuffers::VOffsetT = 6;
  pub const VT_STYLE: flatbuffers::VOffsetT = 8;
  pub const VT_PLACEMENT: flatbuffers::VOffsetT = 10;
  pub const VT_STROKE_SIDES: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ElementStroke { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ElementStrokeArgs<'args>
  ) -> flatbuffers::WIPOffset<ElementStroke<'bldr>> {
    let mut builder = ElementStrokeBuilder::new(_fbb);
    builder.add_width(args.width);
    if let Some(x) = args.stroke_sides { builder.add_stroke_sides(x); }
    if let Some(x) = args.style { builder.add_style(x); }
    if let Some(x) = args.content { builder.add_content(x); }
    if let Some(x) = args.placement { builder.add_placement(x); }
    builder.finish()
  }


  #[inline]
  pub fn content(&self) -> Option<ElementContentBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ElementContentBase>>(ElementStroke::VT_CONTENT, None)}
  }
  #[inline]
  pub fn width(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ElementStroke::VT_WIDTH, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn style(&self) -> Option<StrokeStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<StrokeStyle>>(ElementStroke::VT_STYLE, None)}
  }
  #[inline]
  pub fn placement(&self) -> Option<STROKE_PLACEMENT> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<STROKE_PLACEMENT>(ElementStroke::VT_PLACEMENT, None)}
  }
  #[inline]
  pub fn stroke_sides(&self) -> Option<StrokeSides<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<StrokeSides>>(ElementStroke::VT_STROKE_SIDES, None)}
  }
}

impl flatbuffers::Verifiable for ElementStroke<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<ElementContentBase>>("content", Self::VT_CONTENT, false)?
     .visit_field::<f64>("width", Self::VT_WIDTH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<StrokeStyle>>("style", Self::VT_STYLE, false)?
     .visit_field::<STROKE_PLACEMENT>("placement", Self::VT_PLACEMENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<StrokeSides>>("stroke_sides", Self::VT_STROKE_SIDES, false)?
     .finish();
    Ok(())
  }
}
pub struct ElementStrokeArgs<'a> {
    pub content: Option<flatbuffers::WIPOffset<ElementContentBase<'a>>>,
    pub width: f64,
    pub style: Option<flatbuffers::WIPOffset<StrokeStyle<'a>>>,
    pub placement: Option<STROKE_PLACEMENT>,
    pub stroke_sides: Option<flatbuffers::WIPOffset<StrokeSides<'a>>>,
}
impl<'a> Default for ElementStrokeArgs<'a> {
  #[inline]
  fn default() -> Self {
    ElementStrokeArgs {
      content: None,
      width: 0.0,
      style: None,
      placement: None,
      stroke_sides: None,
    }
  }
}

pub struct ElementStrokeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ElementStrokeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_content(&mut self, content: flatbuffers::WIPOffset<ElementContentBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ElementContentBase>>(ElementStroke::VT_CONTENT, content);
  }
  #[inline]
  pub fn add_width(&mut self, width: f64) {
    self.fbb_.push_slot::<f64>(ElementStroke::VT_WIDTH, width, 0.0);
  }
  #[inline]
  pub fn add_style(&mut self, style: flatbuffers::WIPOffset<StrokeStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<StrokeStyle>>(ElementStroke::VT_STYLE, style);
  }
  #[inline]
  pub fn add_placement(&mut self, placement: STROKE_PLACEMENT) {
    self.fbb_.push_slot_always::<STROKE_PLACEMENT>(ElementStroke::VT_PLACEMENT, placement);
  }
  #[inline]
  pub fn add_stroke_sides(&mut self, stroke_sides: flatbuffers::WIPOffset<StrokeSides<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<StrokeSides>>(ElementStroke::VT_STROKE_SIDES, stroke_sides);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ElementStrokeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ElementStrokeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ElementStroke<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ElementStroke<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ElementStroke");
      ds.field("content", &self.content());
      ds.field("width", &self.width());
      ds.field("style", &self.style());
      ds.field("placement", &self.placement());
      ds.field("stroke_sides", &self.stroke_sides());
      ds.finish()
  }
}
pub enum ElementBackgroundOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ElementBackground<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ElementBackground<'a> {
  type Inner = ElementBackground<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ElementBackground<'a> {
  pub const VT_CONTENT: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ElementBackground { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ElementBackgroundArgs<'args>
  ) -> flatbuffers::WIPOffset<ElementBackground<'bldr>> {
    let mut builder = ElementBackgroundBuilder::new(_fbb);
    if let Some(x) = args.content { builder.add_content(x); }
    builder.finish()
  }


  #[inline]
  pub fn content(&self) -> Option<ElementContentBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ElementContentBase>>(ElementBackground::VT_CONTENT, None)}
  }
}

impl flatbuffers::Verifiable for ElementBackground<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<ElementContentBase>>("content", Self::VT_CONTENT, false)?
     .finish();
    Ok(())
  }
}
pub struct ElementBackgroundArgs<'a> {
    pub content: Option<flatbuffers::WIPOffset<ElementContentBase<'a>>>,
}
impl<'a> Default for ElementBackgroundArgs<'a> {
  #[inline]
  fn default() -> Self {
    ElementBackgroundArgs {
      content: None,
    }
  }
}

pub struct ElementBackgroundBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ElementBackgroundBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_content(&mut self, content: flatbuffers::WIPOffset<ElementContentBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ElementContentBase>>(ElementBackground::VT_CONTENT, content);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ElementBackgroundBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ElementBackgroundBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ElementBackground<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ElementBackground<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ElementBackground");
      ds.field("content", &self.content());
      ds.finish()
  }
}
pub enum _DucElementStylesBaseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct _DucElementStylesBase<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for _DucElementStylesBase<'a> {
  type Inner = _DucElementStylesBase<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> _DucElementStylesBase<'a> {
  pub const VT_ROUNDNESS: flatbuffers::VOffsetT = 4;
  pub const VT_BLENDING: flatbuffers::VOffsetT = 6;
  pub const VT_BACKGROUND: flatbuffers::VOffsetT = 8;
  pub const VT_STROKE: flatbuffers::VOffsetT = 10;
  pub const VT_OPACITY: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    _DucElementStylesBase { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args _DucElementStylesBaseArgs<'args>
  ) -> flatbuffers::WIPOffset<_DucElementStylesBase<'bldr>> {
    let mut builder = _DucElementStylesBaseBuilder::new(_fbb);
    builder.add_opacity(args.opacity);
    builder.add_roundness(args.roundness);
    if let Some(x) = args.stroke { builder.add_stroke(x); }
    if let Some(x) = args.background { builder.add_background(x); }
    if let Some(x) = args.blending { builder.add_blending(x); }
    builder.finish()
  }


  #[inline]
  pub fn roundness(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(_DucElementStylesBase::VT_ROUNDNESS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn blending(&self) -> Option<BLENDING> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<BLENDING>(_DucElementStylesBase::VT_BLENDING, None)}
  }
  #[inline]
  pub fn background(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ElementBackground<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ElementBackground>>>>(_DucElementStylesBase::VT_BACKGROUND, None)}
  }
  #[inline]
  pub fn stroke(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ElementStroke<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ElementStroke>>>>(_DucElementStylesBase::VT_STROKE, None)}
  }
  #[inline]
  pub fn opacity(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(_DucElementStylesBase::VT_OPACITY, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for _DucElementStylesBase<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("roundness", Self::VT_ROUNDNESS, false)?
     .visit_field::<BLENDING>("blending", Self::VT_BLENDING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ElementBackground>>>>("background", Self::VT_BACKGROUND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ElementStroke>>>>("stroke", Self::VT_STROKE, false)?
     .visit_field::<f64>("opacity", Self::VT_OPACITY, false)?
     .finish();
    Ok(())
  }
}
pub struct _DucElementStylesBaseArgs<'a> {
    pub roundness: f64,
    pub blending: Option<BLENDING>,
    pub background: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ElementBackground<'a>>>>>,
    pub stroke: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ElementStroke<'a>>>>>,
    pub opacity: f64,
}
impl<'a> Default for _DucElementStylesBaseArgs<'a> {
  #[inline]
  fn default() -> Self {
    _DucElementStylesBaseArgs {
      roundness: 0.0,
      blending: None,
      background: None,
      stroke: None,
      opacity: 0.0,
    }
  }
}

pub struct _DucElementStylesBaseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> _DucElementStylesBaseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_roundness(&mut self, roundness: f64) {
    self.fbb_.push_slot::<f64>(_DucElementStylesBase::VT_ROUNDNESS, roundness, 0.0);
  }
  #[inline]
  pub fn add_blending(&mut self, blending: BLENDING) {
    self.fbb_.push_slot_always::<BLENDING>(_DucElementStylesBase::VT_BLENDING, blending);
  }
  #[inline]
  pub fn add_background(&mut self, background: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ElementBackground<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(_DucElementStylesBase::VT_BACKGROUND, background);
  }
  #[inline]
  pub fn add_stroke(&mut self, stroke: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ElementStroke<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(_DucElementStylesBase::VT_STROKE, stroke);
  }
  #[inline]
  pub fn add_opacity(&mut self, opacity: f64) {
    self.fbb_.push_slot::<f64>(_DucElementStylesBase::VT_OPACITY, opacity, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> _DucElementStylesBaseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    _DucElementStylesBaseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<_DucElementStylesBase<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for _DucElementStylesBase<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("_DucElementStylesBase");
      ds.field("roundness", &self.roundness());
      ds.field("blending", &self.blending());
      ds.field("background", &self.background());
      ds.field("stroke", &self.stroke());
      ds.field("opacity", &self.opacity());
      ds.finish()
  }
}
pub enum BoundElementOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BoundElement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BoundElement<'a> {
  type Inner = BoundElement<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BoundElement<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BoundElement { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BoundElementArgs<'args>
  ) -> flatbuffers::WIPOffset<BoundElement<'bldr>> {
    let mut builder = BoundElementBuilder::new(_fbb);
    if let Some(x) = args.type_ { builder.add_type_(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BoundElement::VT_ID, None)}
  }
  #[inline]
  pub fn type_(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BoundElement::VT_TYPE_, None)}
  }
}

impl flatbuffers::Verifiable for BoundElement<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, false)?
     .finish();
    Ok(())
  }
}
pub struct BoundElementArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for BoundElementArgs<'a> {
  #[inline]
  fn default() -> Self {
    BoundElementArgs {
      id: None,
      type_: None,
    }
  }
}

pub struct BoundElementBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BoundElementBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BoundElement::VT_ID, id);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BoundElement::VT_TYPE_, type_);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BoundElementBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BoundElementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BoundElement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BoundElement<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BoundElement");
      ds.field("id", &self.id());
      ds.field("type_", &self.type_());
      ds.finish()
  }
}
pub enum _DucElementBaseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct _DucElementBase<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for _DucElementBase<'a> {
  type Inner = _DucElementBase<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> _DucElementBase<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_STYLES: flatbuffers::VOffsetT = 6;
  pub const VT_X: flatbuffers::VOffsetT = 8;
  pub const VT_Y: flatbuffers::VOffsetT = 10;
  pub const VT_WIDTH: flatbuffers::VOffsetT = 12;
  pub const VT_HEIGHT: flatbuffers::VOffsetT = 14;
  pub const VT_ANGLE: flatbuffers::VOffsetT = 16;
  pub const VT_SCOPE: flatbuffers::VOffsetT = 18;
  pub const VT_LABEL: flatbuffers::VOffsetT = 20;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 22;
  pub const VT_IS_VISIBLE: flatbuffers::VOffsetT = 24;
  pub const VT_SEED: flatbuffers::VOffsetT = 26;
  pub const VT_VERSION: flatbuffers::VOffsetT = 28;
  pub const VT_VERSION_NONCE: flatbuffers::VOffsetT = 30;
  pub const VT_UPDATED: flatbuffers::VOffsetT = 32;
  pub const VT_INDEX: flatbuffers::VOffsetT = 34;
  pub const VT_IS_PLOT: flatbuffers::VOffsetT = 36;
  pub const VT_IS_ANNOTATIVE: flatbuffers::VOffsetT = 38;
  pub const VT_IS_DELETED: flatbuffers::VOffsetT = 40;
  pub const VT_GROUP_IDS: flatbuffers::VOffsetT = 42;
  pub const VT_REGION_IDS: flatbuffers::VOffsetT = 44;
  pub const VT_LAYER_ID: flatbuffers::VOffsetT = 46;
  pub const VT_FRAME_ID: flatbuffers::VOffsetT = 48;
  pub const VT_BOUND_ELEMENTS: flatbuffers::VOffsetT = 50;
  pub const VT_Z_INDEX: flatbuffers::VOffsetT = 52;
  pub const VT_LINK: flatbuffers::VOffsetT = 54;
  pub const VT_LOCKED: flatbuffers::VOffsetT = 56;
  pub const VT_CUSTOM_DATA: flatbuffers::VOffsetT = 58;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    _DucElementBase { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args _DucElementBaseArgs<'args>
  ) -> flatbuffers::WIPOffset<_DucElementBase<'bldr>> {
    let mut builder = _DucElementBaseBuilder::new(_fbb);
    builder.add_updated(args.updated);
    builder.add_angle(args.angle);
    builder.add_height(args.height);
    builder.add_width(args.width);
    builder.add_y(args.y);
    builder.add_x(args.x);
    if let Some(x) = args.custom_data { builder.add_custom_data(x); }
    if let Some(x) = args.link { builder.add_link(x); }
    builder.add_z_index(args.z_index);
    if let Some(x) = args.bound_elements { builder.add_bound_elements(x); }
    if let Some(x) = args.frame_id { builder.add_frame_id(x); }
    if let Some(x) = args.layer_id { builder.add_layer_id(x); }
    if let Some(x) = args.region_ids { builder.add_region_ids(x); }
    if let Some(x) = args.group_ids { builder.add_group_ids(x); }
    if let Some(x) = args.index { builder.add_index(x); }
    builder.add_version_nonce(args.version_nonce);
    builder.add_version(args.version);
    builder.add_seed(args.seed);
    if let Some(x) = args.description { builder.add_description(x); }
    if let Some(x) = args.label { builder.add_label(x); }
    if let Some(x) = args.scope { builder.add_scope(x); }
    if let Some(x) = args.styles { builder.add_styles(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_locked(args.locked);
    builder.add_is_deleted(args.is_deleted);
    builder.add_is_annotative(args.is_annotative);
    builder.add_is_plot(args.is_plot);
    builder.add_is_visible(args.is_visible);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(_DucElementBase::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &_DucElementBase) -> bool {
    self.id() < o.id()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.id();
    key.cmp(val)
  }
  #[inline]
  pub fn styles(&self) -> Option<_DucElementStylesBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<_DucElementStylesBase>>(_DucElementBase::VT_STYLES, None)}
  }
  #[inline]
  pub fn x(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(_DucElementBase::VT_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(_DucElementBase::VT_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn width(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(_DucElementBase::VT_WIDTH, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn height(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(_DucElementBase::VT_HEIGHT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn angle(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(_DucElementBase::VT_ANGLE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn scope(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(_DucElementBase::VT_SCOPE, None)}
  }
  #[inline]
  pub fn label(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(_DucElementBase::VT_LABEL, None)}
  }
  #[inline]
  pub fn description(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(_DucElementBase::VT_DESCRIPTION, None)}
  }
  #[inline]
  pub fn is_visible(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(_DucElementBase::VT_IS_VISIBLE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn seed(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(_DucElementBase::VT_SEED, Some(0)).unwrap()}
  }
  #[inline]
  pub fn version(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(_DucElementBase::VT_VERSION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn version_nonce(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(_DucElementBase::VT_VERSION_NONCE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn updated(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(_DucElementBase::VT_UPDATED, Some(0)).unwrap()}
  }
  #[inline]
  pub fn index(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(_DucElementBase::VT_INDEX, None)}
  }
  #[inline]
  pub fn is_plot(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(_DucElementBase::VT_IS_PLOT, Some(false)).unwrap()}
  }
  #[inline]
  pub fn is_annotative(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(_DucElementBase::VT_IS_ANNOTATIVE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn is_deleted(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(_DucElementBase::VT_IS_DELETED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn group_ids(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(_DucElementBase::VT_GROUP_IDS, None)}
  }
  #[inline]
  pub fn region_ids(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(_DucElementBase::VT_REGION_IDS, None)}
  }
  #[inline]
  pub fn layer_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(_DucElementBase::VT_LAYER_ID, None)}
  }
  #[inline]
  pub fn frame_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(_DucElementBase::VT_FRAME_ID, None)}
  }
  #[inline]
  pub fn bound_elements(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BoundElement<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BoundElement>>>>(_DucElementBase::VT_BOUND_ELEMENTS, None)}
  }
  #[inline]
  pub fn z_index(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(_DucElementBase::VT_Z_INDEX, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn link(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(_DucElementBase::VT_LINK, None)}
  }
  #[inline]
  pub fn locked(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(_DucElementBase::VT_LOCKED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn custom_data(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(_DucElementBase::VT_CUSTOM_DATA, None)}
  }
}

impl flatbuffers::Verifiable for _DucElementBase<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<_DucElementStylesBase>>("styles", Self::VT_STYLES, false)?
     .visit_field::<f64>("x", Self::VT_X, false)?
     .visit_field::<f64>("y", Self::VT_Y, false)?
     .visit_field::<f64>("width", Self::VT_WIDTH, false)?
     .visit_field::<f64>("height", Self::VT_HEIGHT, false)?
     .visit_field::<f64>("angle", Self::VT_ANGLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("scope", Self::VT_SCOPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("label", Self::VT_LABEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("description", Self::VT_DESCRIPTION, false)?
     .visit_field::<bool>("is_visible", Self::VT_IS_VISIBLE, false)?
     .visit_field::<i32>("seed", Self::VT_SEED, false)?
     .visit_field::<i32>("version", Self::VT_VERSION, false)?
     .visit_field::<i32>("version_nonce", Self::VT_VERSION_NONCE, false)?
     .visit_field::<i64>("updated", Self::VT_UPDATED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("index", Self::VT_INDEX, false)?
     .visit_field::<bool>("is_plot", Self::VT_IS_PLOT, false)?
     .visit_field::<bool>("is_annotative", Self::VT_IS_ANNOTATIVE, false)?
     .visit_field::<bool>("is_deleted", Self::VT_IS_DELETED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("group_ids", Self::VT_GROUP_IDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("region_ids", Self::VT_REGION_IDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("layer_id", Self::VT_LAYER_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("frame_id", Self::VT_FRAME_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BoundElement>>>>("bound_elements", Self::VT_BOUND_ELEMENTS, false)?
     .visit_field::<f32>("z_index", Self::VT_Z_INDEX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("link", Self::VT_LINK, false)?
     .visit_field::<bool>("locked", Self::VT_LOCKED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("custom_data", Self::VT_CUSTOM_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct _DucElementBaseArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub styles: Option<flatbuffers::WIPOffset<_DucElementStylesBase<'a>>>,
    pub x: f64,
    pub y: f64,
    pub width: f64,
    pub height: f64,
    pub angle: f64,
    pub scope: Option<flatbuffers::WIPOffset<&'a str>>,
    pub label: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub is_visible: bool,
    pub seed: i32,
    pub version: i32,
    pub version_nonce: i32,
    pub updated: i64,
    pub index: Option<flatbuffers::WIPOffset<&'a str>>,
    pub is_plot: bool,
    pub is_annotative: bool,
    pub is_deleted: bool,
    pub group_ids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub region_ids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub layer_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub frame_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bound_elements: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BoundElement<'a>>>>>,
    pub z_index: f32,
    pub link: Option<flatbuffers::WIPOffset<&'a str>>,
    pub locked: bool,
    pub custom_data: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for _DucElementBaseArgs<'a> {
  #[inline]
  fn default() -> Self {
    _DucElementBaseArgs {
      id: None, // required field
      styles: None,
      x: 0.0,
      y: 0.0,
      width: 0.0,
      height: 0.0,
      angle: 0.0,
      scope: None,
      label: None,
      description: None,
      is_visible: false,
      seed: 0,
      version: 0,
      version_nonce: 0,
      updated: 0,
      index: None,
      is_plot: false,
      is_annotative: false,
      is_deleted: false,
      group_ids: None,
      region_ids: None,
      layer_id: None,
      frame_id: None,
      bound_elements: None,
      z_index: 0.0,
      link: None,
      locked: false,
      custom_data: None,
    }
  }
}

pub struct _DucElementBaseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> _DucElementBaseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(_DucElementBase::VT_ID, id);
  }
  #[inline]
  pub fn add_styles(&mut self, styles: flatbuffers::WIPOffset<_DucElementStylesBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_DucElementStylesBase>>(_DucElementBase::VT_STYLES, styles);
  }
  #[inline]
  pub fn add_x(&mut self, x: f64) {
    self.fbb_.push_slot::<f64>(_DucElementBase::VT_X, x, 0.0);
  }
  #[inline]
  pub fn add_y(&mut self, y: f64) {
    self.fbb_.push_slot::<f64>(_DucElementBase::VT_Y, y, 0.0);
  }
  #[inline]
  pub fn add_width(&mut self, width: f64) {
    self.fbb_.push_slot::<f64>(_DucElementBase::VT_WIDTH, width, 0.0);
  }
  #[inline]
  pub fn add_height(&mut self, height: f64) {
    self.fbb_.push_slot::<f64>(_DucElementBase::VT_HEIGHT, height, 0.0);
  }
  #[inline]
  pub fn add_angle(&mut self, angle: f64) {
    self.fbb_.push_slot::<f64>(_DucElementBase::VT_ANGLE, angle, 0.0);
  }
  #[inline]
  pub fn add_scope(&mut self, scope: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(_DucElementBase::VT_SCOPE, scope);
  }
  #[inline]
  pub fn add_label(&mut self, label: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(_DucElementBase::VT_LABEL, label);
  }
  #[inline]
  pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(_DucElementBase::VT_DESCRIPTION, description);
  }
  #[inline]
  pub fn add_is_visible(&mut self, is_visible: bool) {
    self.fbb_.push_slot::<bool>(_DucElementBase::VT_IS_VISIBLE, is_visible, false);
  }
  #[inline]
  pub fn add_seed(&mut self, seed: i32) {
    self.fbb_.push_slot::<i32>(_DucElementBase::VT_SEED, seed, 0);
  }
  #[inline]
  pub fn add_version(&mut self, version: i32) {
    self.fbb_.push_slot::<i32>(_DucElementBase::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_version_nonce(&mut self, version_nonce: i32) {
    self.fbb_.push_slot::<i32>(_DucElementBase::VT_VERSION_NONCE, version_nonce, 0);
  }
  #[inline]
  pub fn add_updated(&mut self, updated: i64) {
    self.fbb_.push_slot::<i64>(_DucElementBase::VT_UPDATED, updated, 0);
  }
  #[inline]
  pub fn add_index(&mut self, index: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(_DucElementBase::VT_INDEX, index);
  }
  #[inline]
  pub fn add_is_plot(&mut self, is_plot: bool) {
    self.fbb_.push_slot::<bool>(_DucElementBase::VT_IS_PLOT, is_plot, false);
  }
  #[inline]
  pub fn add_is_annotative(&mut self, is_annotative: bool) {
    self.fbb_.push_slot::<bool>(_DucElementBase::VT_IS_ANNOTATIVE, is_annotative, false);
  }
  #[inline]
  pub fn add_is_deleted(&mut self, is_deleted: bool) {
    self.fbb_.push_slot::<bool>(_DucElementBase::VT_IS_DELETED, is_deleted, false);
  }
  #[inline]
  pub fn add_group_ids(&mut self, group_ids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(_DucElementBase::VT_GROUP_IDS, group_ids);
  }
  #[inline]
  pub fn add_region_ids(&mut self, region_ids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(_DucElementBase::VT_REGION_IDS, region_ids);
  }
  #[inline]
  pub fn add_layer_id(&mut self, layer_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(_DucElementBase::VT_LAYER_ID, layer_id);
  }
  #[inline]
  pub fn add_frame_id(&mut self, frame_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(_DucElementBase::VT_FRAME_ID, frame_id);
  }
  #[inline]
  pub fn add_bound_elements(&mut self, bound_elements: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BoundElement<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(_DucElementBase::VT_BOUND_ELEMENTS, bound_elements);
  }
  #[inline]
  pub fn add_z_index(&mut self, z_index: f32) {
    self.fbb_.push_slot::<f32>(_DucElementBase::VT_Z_INDEX, z_index, 0.0);
  }
  #[inline]
  pub fn add_link(&mut self, link: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(_DucElementBase::VT_LINK, link);
  }
  #[inline]
  pub fn add_locked(&mut self, locked: bool) {
    self.fbb_.push_slot::<bool>(_DucElementBase::VT_LOCKED, locked, false);
  }
  #[inline]
  pub fn add_custom_data(&mut self, custom_data: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(_DucElementBase::VT_CUSTOM_DATA, custom_data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> _DucElementBaseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    _DucElementBaseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<_DucElementBase<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, _DucElementBase::VT_ID,"id");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for _DucElementBase<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("_DucElementBase");
      ds.field("id", &self.id());
      ds.field("styles", &self.styles());
      ds.field("x", &self.x());
      ds.field("y", &self.y());
      ds.field("width", &self.width());
      ds.field("height", &self.height());
      ds.field("angle", &self.angle());
      ds.field("scope", &self.scope());
      ds.field("label", &self.label());
      ds.field("description", &self.description());
      ds.field("is_visible", &self.is_visible());
      ds.field("seed", &self.seed());
      ds.field("version", &self.version());
      ds.field("version_nonce", &self.version_nonce());
      ds.field("updated", &self.updated());
      ds.field("index", &self.index());
      ds.field("is_plot", &self.is_plot());
      ds.field("is_annotative", &self.is_annotative());
      ds.field("is_deleted", &self.is_deleted());
      ds.field("group_ids", &self.group_ids());
      ds.field("region_ids", &self.region_ids());
      ds.field("layer_id", &self.layer_id());
      ds.field("frame_id", &self.frame_id());
      ds.field("bound_elements", &self.bound_elements());
      ds.field("z_index", &self.z_index());
      ds.field("link", &self.link());
      ds.field("locked", &self.locked());
      ds.field("custom_data", &self.custom_data());
      ds.finish()
  }
}
pub enum DucPointOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucPoint<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucPoint<'a> {
  type Inner = DucPoint<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucPoint<'a> {
  pub const VT_X: flatbuffers::VOffsetT = 4;
  pub const VT_Y: flatbuffers::VOffsetT = 6;
  pub const VT_MIRRORING: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucPoint { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucPointArgs
  ) -> flatbuffers::WIPOffset<DucPoint<'bldr>> {
    let mut builder = DucPointBuilder::new(_fbb);
    builder.add_y(args.y);
    builder.add_x(args.x);
    if let Some(x) = args.mirroring { builder.add_mirroring(x); }
    builder.finish()
  }


  #[inline]
  pub fn x(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucPoint::VT_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucPoint::VT_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn mirroring(&self) -> Option<BEZIER_MIRRORING> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<BEZIER_MIRRORING>(DucPoint::VT_MIRRORING, None)}
  }
}

impl flatbuffers::Verifiable for DucPoint<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("x", Self::VT_X, false)?
     .visit_field::<f64>("y", Self::VT_Y, false)?
     .visit_field::<BEZIER_MIRRORING>("mirroring", Self::VT_MIRRORING, false)?
     .finish();
    Ok(())
  }
}
pub struct DucPointArgs {
    pub x: f64,
    pub y: f64,
    pub mirroring: Option<BEZIER_MIRRORING>,
}
impl<'a> Default for DucPointArgs {
  #[inline]
  fn default() -> Self {
    DucPointArgs {
      x: 0.0,
      y: 0.0,
      mirroring: None,
    }
  }
}

pub struct DucPointBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucPointBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_x(&mut self, x: f64) {
    self.fbb_.push_slot::<f64>(DucPoint::VT_X, x, 0.0);
  }
  #[inline]
  pub fn add_y(&mut self, y: f64) {
    self.fbb_.push_slot::<f64>(DucPoint::VT_Y, y, 0.0);
  }
  #[inline]
  pub fn add_mirroring(&mut self, mirroring: BEZIER_MIRRORING) {
    self.fbb_.push_slot_always::<BEZIER_MIRRORING>(DucPoint::VT_MIRRORING, mirroring);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucPointBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucPointBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucPoint<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucPoint<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucPoint");
      ds.field("x", &self.x());
      ds.field("y", &self.y());
      ds.field("mirroring", &self.mirroring());
      ds.finish()
  }
}
pub enum DucHeadOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucHead<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucHead<'a> {
  type Inner = DucHead<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucHead<'a> {
  pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
  pub const VT_BLOCK_ID: flatbuffers::VOffsetT = 6;
  pub const VT_SIZE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucHead { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucHeadArgs<'args>
  ) -> flatbuffers::WIPOffset<DucHead<'bldr>> {
    let mut builder = DucHeadBuilder::new(_fbb);
    builder.add_size(args.size);
    if let Some(x) = args.block_id { builder.add_block_id(x); }
    if let Some(x) = args.type_ { builder.add_type_(x); }
    builder.finish()
  }


  #[inline]
  pub fn type_(&self) -> Option<LINE_HEAD> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<LINE_HEAD>(DucHead::VT_TYPE_, None)}
  }
  #[inline]
  pub fn block_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucHead::VT_BLOCK_ID, None)}
  }
  #[inline]
  pub fn size(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucHead::VT_SIZE, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DucHead<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<LINE_HEAD>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("block_id", Self::VT_BLOCK_ID, false)?
     .visit_field::<f64>("size", Self::VT_SIZE, false)?
     .finish();
    Ok(())
  }
}
pub struct DucHeadArgs<'a> {
    pub type_: Option<LINE_HEAD>,
    pub block_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub size: f64,
}
impl<'a> Default for DucHeadArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucHeadArgs {
      type_: None,
      block_id: None,
      size: 0.0,
    }
  }
}

pub struct DucHeadBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucHeadBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_type_(&mut self, type_: LINE_HEAD) {
    self.fbb_.push_slot_always::<LINE_HEAD>(DucHead::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_block_id(&mut self, block_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucHead::VT_BLOCK_ID, block_id);
  }
  #[inline]
  pub fn add_size(&mut self, size: f64) {
    self.fbb_.push_slot::<f64>(DucHead::VT_SIZE, size, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucHeadBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucHeadBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucHead<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucHead<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucHead");
      ds.field("type_", &self.type_());
      ds.field("block_id", &self.block_id());
      ds.field("size", &self.size());
      ds.finish()
  }
}
pub enum PointBindingPointOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PointBindingPoint<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PointBindingPoint<'a> {
  type Inner = PointBindingPoint<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PointBindingPoint<'a> {
  pub const VT_INDEX: flatbuffers::VOffsetT = 4;
  pub const VT_OFFSET: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PointBindingPoint { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PointBindingPointArgs
  ) -> flatbuffers::WIPOffset<PointBindingPoint<'bldr>> {
    let mut builder = PointBindingPointBuilder::new(_fbb);
    builder.add_offset(args.offset);
    builder.add_index(args.index);
    builder.finish()
  }


  #[inline]
  pub fn index(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PointBindingPoint::VT_INDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn offset(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(PointBindingPoint::VT_OFFSET, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for PointBindingPoint<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("index", Self::VT_INDEX, false)?
     .visit_field::<f64>("offset", Self::VT_OFFSET, false)?
     .finish();
    Ok(())
  }
}
pub struct PointBindingPointArgs {
    pub index: i32,
    pub offset: f64,
}
impl<'a> Default for PointBindingPointArgs {
  #[inline]
  fn default() -> Self {
    PointBindingPointArgs {
      index: 0,
      offset: 0.0,
    }
  }
}

pub struct PointBindingPointBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PointBindingPointBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_index(&mut self, index: i32) {
    self.fbb_.push_slot::<i32>(PointBindingPoint::VT_INDEX, index, 0);
  }
  #[inline]
  pub fn add_offset(&mut self, offset: f64) {
    self.fbb_.push_slot::<f64>(PointBindingPoint::VT_OFFSET, offset, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PointBindingPointBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PointBindingPointBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PointBindingPoint<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PointBindingPoint<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PointBindingPoint");
      ds.field("index", &self.index());
      ds.field("offset", &self.offset());
      ds.finish()
  }
}
pub enum DucPointBindingOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucPointBinding<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucPointBinding<'a> {
  type Inner = DucPointBinding<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucPointBinding<'a> {
  pub const VT_ELEMENT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_FOCUS: flatbuffers::VOffsetT = 6;
  pub const VT_GAP: flatbuffers::VOffsetT = 8;
  pub const VT_FIXED_POINT: flatbuffers::VOffsetT = 10;
  pub const VT_POINT: flatbuffers::VOffsetT = 12;
  pub const VT_HEAD: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucPointBinding { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucPointBindingArgs<'args>
  ) -> flatbuffers::WIPOffset<DucPointBinding<'bldr>> {
    let mut builder = DucPointBindingBuilder::new(_fbb);
    builder.add_gap(args.gap);
    if let Some(x) = args.head { builder.add_head(x); }
    if let Some(x) = args.point { builder.add_point(x); }
    if let Some(x) = args.fixed_point { builder.add_fixed_point(x); }
    builder.add_focus(args.focus);
    if let Some(x) = args.element_id { builder.add_element_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn element_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucPointBinding::VT_ELEMENT_ID, None)}
  }
  #[inline]
  pub fn focus(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucPointBinding::VT_FOCUS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn gap(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucPointBinding::VT_GAP, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn fixed_point(&self) -> Option<&'a GeometricPoint> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<GeometricPoint>(DucPointBinding::VT_FIXED_POINT, None)}
  }
  #[inline]
  pub fn point(&self) -> Option<PointBindingPoint<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<PointBindingPoint>>(DucPointBinding::VT_POINT, None)}
  }
  #[inline]
  pub fn head(&self) -> Option<DucHead<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucHead>>(DucPointBinding::VT_HEAD, None)}
  }
}

impl flatbuffers::Verifiable for DucPointBinding<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("element_id", Self::VT_ELEMENT_ID, false)?
     .visit_field::<f32>("focus", Self::VT_FOCUS, false)?
     .visit_field::<f64>("gap", Self::VT_GAP, false)?
     .visit_field::<GeometricPoint>("fixed_point", Self::VT_FIXED_POINT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<PointBindingPoint>>("point", Self::VT_POINT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucHead>>("head", Self::VT_HEAD, false)?
     .finish();
    Ok(())
  }
}
pub struct DucPointBindingArgs<'a> {
    pub element_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub focus: f32,
    pub gap: f64,
    pub fixed_point: Option<&'a GeometricPoint>,
    pub point: Option<flatbuffers::WIPOffset<PointBindingPoint<'a>>>,
    pub head: Option<flatbuffers::WIPOffset<DucHead<'a>>>,
}
impl<'a> Default for DucPointBindingArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucPointBindingArgs {
      element_id: None,
      focus: 0.0,
      gap: 0.0,
      fixed_point: None,
      point: None,
      head: None,
    }
  }
}

pub struct DucPointBindingBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucPointBindingBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_element_id(&mut self, element_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucPointBinding::VT_ELEMENT_ID, element_id);
  }
  #[inline]
  pub fn add_focus(&mut self, focus: f32) {
    self.fbb_.push_slot::<f32>(DucPointBinding::VT_FOCUS, focus, 0.0);
  }
  #[inline]
  pub fn add_gap(&mut self, gap: f64) {
    self.fbb_.push_slot::<f64>(DucPointBinding::VT_GAP, gap, 0.0);
  }
  #[inline]
  pub fn add_fixed_point(&mut self, fixed_point: &GeometricPoint) {
    self.fbb_.push_slot_always::<&GeometricPoint>(DucPointBinding::VT_FIXED_POINT, fixed_point);
  }
  #[inline]
  pub fn add_point(&mut self, point: flatbuffers::WIPOffset<PointBindingPoint<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PointBindingPoint>>(DucPointBinding::VT_POINT, point);
  }
  #[inline]
  pub fn add_head(&mut self, head: flatbuffers::WIPOffset<DucHead<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucHead>>(DucPointBinding::VT_HEAD, head);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucPointBindingBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucPointBindingBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucPointBinding<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucPointBinding<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucPointBinding");
      ds.field("element_id", &self.element_id());
      ds.field("focus", &self.focus());
      ds.field("gap", &self.gap());
      ds.field("fixed_point", &self.fixed_point());
      ds.field("point", &self.point());
      ds.field("head", &self.head());
      ds.finish()
  }
}
pub enum DucLineReferenceOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucLineReference<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucLineReference<'a> {
  type Inner = DucLineReference<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucLineReference<'a> {
  pub const VT_INDEX: flatbuffers::VOffsetT = 4;
  pub const VT_HANDLE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucLineReference { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucLineReferenceArgs<'args>
  ) -> flatbuffers::WIPOffset<DucLineReference<'bldr>> {
    let mut builder = DucLineReferenceBuilder::new(_fbb);
    if let Some(x) = args.handle { builder.add_handle(x); }
    builder.add_index(args.index);
    builder.finish()
  }


  #[inline]
  pub fn index(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DucLineReference::VT_INDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn handle(&self) -> Option<&'a GeometricPoint> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<GeometricPoint>(DucLineReference::VT_HANDLE, None)}
  }
}

impl flatbuffers::Verifiable for DucLineReference<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("index", Self::VT_INDEX, false)?
     .visit_field::<GeometricPoint>("handle", Self::VT_HANDLE, false)?
     .finish();
    Ok(())
  }
}
pub struct DucLineReferenceArgs<'a> {
    pub index: i32,
    pub handle: Option<&'a GeometricPoint>,
}
impl<'a> Default for DucLineReferenceArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucLineReferenceArgs {
      index: 0,
      handle: None,
    }
  }
}

pub struct DucLineReferenceBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucLineReferenceBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_index(&mut self, index: i32) {
    self.fbb_.push_slot::<i32>(DucLineReference::VT_INDEX, index, 0);
  }
  #[inline]
  pub fn add_handle(&mut self, handle: &GeometricPoint) {
    self.fbb_.push_slot_always::<&GeometricPoint>(DucLineReference::VT_HANDLE, handle);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucLineReferenceBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucLineReferenceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucLineReference<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucLineReference<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucLineReference");
      ds.field("index", &self.index());
      ds.field("handle", &self.handle());
      ds.finish()
  }
}
pub enum DucLineOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucLine<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucLine<'a> {
  type Inner = DucLine<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucLine<'a> {
  pub const VT_START: flatbuffers::VOffsetT = 4;
  pub const VT_END: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucLine { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucLineArgs<'args>
  ) -> flatbuffers::WIPOffset<DucLine<'bldr>> {
    let mut builder = DucLineBuilder::new(_fbb);
    if let Some(x) = args.end { builder.add_end(x); }
    if let Some(x) = args.start { builder.add_start(x); }
    builder.finish()
  }


  #[inline]
  pub fn start(&self) -> Option<DucLineReference<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucLineReference>>(DucLine::VT_START, None)}
  }
  #[inline]
  pub fn end(&self) -> Option<DucLineReference<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucLineReference>>(DucLine::VT_END, None)}
  }
}

impl flatbuffers::Verifiable for DucLine<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucLineReference>>("start", Self::VT_START, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucLineReference>>("end", Self::VT_END, false)?
     .finish();
    Ok(())
  }
}
pub struct DucLineArgs<'a> {
    pub start: Option<flatbuffers::WIPOffset<DucLineReference<'a>>>,
    pub end: Option<flatbuffers::WIPOffset<DucLineReference<'a>>>,
}
impl<'a> Default for DucLineArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucLineArgs {
      start: None,
      end: None,
    }
  }
}

pub struct DucLineBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucLineBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_start(&mut self, start: flatbuffers::WIPOffset<DucLineReference<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucLineReference>>(DucLine::VT_START, start);
  }
  #[inline]
  pub fn add_end(&mut self, end: flatbuffers::WIPOffset<DucLineReference<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucLineReference>>(DucLine::VT_END, end);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucLineBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucLineBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucLine<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucLine<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucLine");
      ds.field("start", &self.start());
      ds.field("end", &self.end());
      ds.finish()
  }
}
pub enum DucPathOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucPath<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucPath<'a> {
  type Inner = DucPath<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucPath<'a> {
  pub const VT_LINE_INDICES: flatbuffers::VOffsetT = 4;
  pub const VT_BACKGROUND: flatbuffers::VOffsetT = 6;
  pub const VT_STROKE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucPath { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucPathArgs<'args>
  ) -> flatbuffers::WIPOffset<DucPath<'bldr>> {
    let mut builder = DucPathBuilder::new(_fbb);
    if let Some(x) = args.stroke { builder.add_stroke(x); }
    if let Some(x) = args.background { builder.add_background(x); }
    if let Some(x) = args.line_indices { builder.add_line_indices(x); }
    builder.finish()
  }


  #[inline]
  pub fn line_indices(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(DucPath::VT_LINE_INDICES, None)}
  }
  #[inline]
  pub fn background(&self) -> Option<ElementBackground<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ElementBackground>>(DucPath::VT_BACKGROUND, None)}
  }
  #[inline]
  pub fn stroke(&self) -> Option<ElementStroke<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ElementStroke>>(DucPath::VT_STROKE, None)}
  }
}

impl flatbuffers::Verifiable for DucPath<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("line_indices", Self::VT_LINE_INDICES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ElementBackground>>("background", Self::VT_BACKGROUND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ElementStroke>>("stroke", Self::VT_STROKE, false)?
     .finish();
    Ok(())
  }
}
pub struct DucPathArgs<'a> {
    pub line_indices: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub background: Option<flatbuffers::WIPOffset<ElementBackground<'a>>>,
    pub stroke: Option<flatbuffers::WIPOffset<ElementStroke<'a>>>,
}
impl<'a> Default for DucPathArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucPathArgs {
      line_indices: None,
      background: None,
      stroke: None,
    }
  }
}

pub struct DucPathBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucPathBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_line_indices(&mut self, line_indices: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucPath::VT_LINE_INDICES, line_indices);
  }
  #[inline]
  pub fn add_background(&mut self, background: flatbuffers::WIPOffset<ElementBackground<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ElementBackground>>(DucPath::VT_BACKGROUND, background);
  }
  #[inline]
  pub fn add_stroke(&mut self, stroke: flatbuffers::WIPOffset<ElementStroke<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ElementStroke>>(DucPath::VT_STROKE, stroke);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucPathBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucPathBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucPath<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucPath<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucPath");
      ds.field("line_indices", &self.line_indices());
      ds.field("background", &self.background());
      ds.field("stroke", &self.stroke());
      ds.finish()
  }
}
pub enum _DucLinearElementBaseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct _DucLinearElementBase<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for _DucLinearElementBase<'a> {
  type Inner = _DucLinearElementBase<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> _DucLinearElementBase<'a> {
  pub const VT_BASE: flatbuffers::VOffsetT = 4;
  pub const VT_POINTS: flatbuffers::VOffsetT = 6;
  pub const VT_LINES: flatbuffers::VOffsetT = 8;
  pub const VT_PATH_OVERRIDES: flatbuffers::VOffsetT = 10;
  pub const VT_LAST_COMMITTED_POINT: flatbuffers::VOffsetT = 12;
  pub const VT_START_BINDING: flatbuffers::VOffsetT = 14;
  pub const VT_END_BINDING: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    _DucLinearElementBase { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args _DucLinearElementBaseArgs<'args>
  ) -> flatbuffers::WIPOffset<_DucLinearElementBase<'bldr>> {
    let mut builder = _DucLinearElementBaseBuilder::new(_fbb);
    if let Some(x) = args.end_binding { builder.add_end_binding(x); }
    if let Some(x) = args.start_binding { builder.add_start_binding(x); }
    if let Some(x) = args.last_committed_point { builder.add_last_committed_point(x); }
    if let Some(x) = args.path_overrides { builder.add_path_overrides(x); }
    if let Some(x) = args.lines { builder.add_lines(x); }
    if let Some(x) = args.points { builder.add_points(x); }
    if let Some(x) = args.base { builder.add_base(x); }
    builder.finish()
  }


  #[inline]
  pub fn base(&self) -> Option<_DucElementBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<_DucElementBase>>(_DucLinearElementBase::VT_BASE, None)}
  }
  #[inline]
  pub fn points(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucPoint<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucPoint>>>>(_DucLinearElementBase::VT_POINTS, None)}
  }
  #[inline]
  pub fn lines(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucLine<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucLine>>>>(_DucLinearElementBase::VT_LINES, None)}
  }
  #[inline]
  pub fn path_overrides(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucPath<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucPath>>>>(_DucLinearElementBase::VT_PATH_OVERRIDES, None)}
  }
  #[inline]
  pub fn last_committed_point(&self) -> Option<DucPoint<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucPoint>>(_DucLinearElementBase::VT_LAST_COMMITTED_POINT, None)}
  }
  #[inline]
  pub fn start_binding(&self) -> Option<DucPointBinding<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucPointBinding>>(_DucLinearElementBase::VT_START_BINDING, None)}
  }
  #[inline]
  pub fn end_binding(&self) -> Option<DucPointBinding<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucPointBinding>>(_DucLinearElementBase::VT_END_BINDING, None)}
  }
}

impl flatbuffers::Verifiable for _DucLinearElementBase<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<_DucElementBase>>("base", Self::VT_BASE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DucPoint>>>>("points", Self::VT_POINTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DucLine>>>>("lines", Self::VT_LINES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DucPath>>>>("path_overrides", Self::VT_PATH_OVERRIDES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucPoint>>("last_committed_point", Self::VT_LAST_COMMITTED_POINT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucPointBinding>>("start_binding", Self::VT_START_BINDING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucPointBinding>>("end_binding", Self::VT_END_BINDING, false)?
     .finish();
    Ok(())
  }
}
pub struct _DucLinearElementBaseArgs<'a> {
    pub base: Option<flatbuffers::WIPOffset<_DucElementBase<'a>>>,
    pub points: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucPoint<'a>>>>>,
    pub lines: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucLine<'a>>>>>,
    pub path_overrides: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucPath<'a>>>>>,
    pub last_committed_point: Option<flatbuffers::WIPOffset<DucPoint<'a>>>,
    pub start_binding: Option<flatbuffers::WIPOffset<DucPointBinding<'a>>>,
    pub end_binding: Option<flatbuffers::WIPOffset<DucPointBinding<'a>>>,
}
impl<'a> Default for _DucLinearElementBaseArgs<'a> {
  #[inline]
  fn default() -> Self {
    _DucLinearElementBaseArgs {
      base: None,
      points: None,
      lines: None,
      path_overrides: None,
      last_committed_point: None,
      start_binding: None,
      end_binding: None,
    }
  }
}

pub struct _DucLinearElementBaseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> _DucLinearElementBaseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_base(&mut self, base: flatbuffers::WIPOffset<_DucElementBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_DucElementBase>>(_DucLinearElementBase::VT_BASE, base);
  }
  #[inline]
  pub fn add_points(&mut self, points: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DucPoint<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(_DucLinearElementBase::VT_POINTS, points);
  }
  #[inline]
  pub fn add_lines(&mut self, lines: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DucLine<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(_DucLinearElementBase::VT_LINES, lines);
  }
  #[inline]
  pub fn add_path_overrides(&mut self, path_overrides: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DucPath<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(_DucLinearElementBase::VT_PATH_OVERRIDES, path_overrides);
  }
  #[inline]
  pub fn add_last_committed_point(&mut self, last_committed_point: flatbuffers::WIPOffset<DucPoint<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucPoint>>(_DucLinearElementBase::VT_LAST_COMMITTED_POINT, last_committed_point);
  }
  #[inline]
  pub fn add_start_binding(&mut self, start_binding: flatbuffers::WIPOffset<DucPointBinding<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucPointBinding>>(_DucLinearElementBase::VT_START_BINDING, start_binding);
  }
  #[inline]
  pub fn add_end_binding(&mut self, end_binding: flatbuffers::WIPOffset<DucPointBinding<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucPointBinding>>(_DucLinearElementBase::VT_END_BINDING, end_binding);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> _DucLinearElementBaseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    _DucLinearElementBaseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<_DucLinearElementBase<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for _DucLinearElementBase<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("_DucLinearElementBase");
      ds.field("base", &self.base());
      ds.field("points", &self.points());
      ds.field("lines", &self.lines());
      ds.field("path_overrides", &self.path_overrides());
      ds.field("last_committed_point", &self.last_committed_point());
      ds.field("start_binding", &self.start_binding());
      ds.field("end_binding", &self.end_binding());
      ds.finish()
  }
}
pub enum DucStackLikeStylesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucStackLikeStyles<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucStackLikeStyles<'a> {
  type Inner = DucStackLikeStyles<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucStackLikeStyles<'a> {
  pub const VT_OPACITY: flatbuffers::VOffsetT = 4;
  pub const VT_LABELING_COLOR: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucStackLikeStyles { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucStackLikeStylesArgs<'args>
  ) -> flatbuffers::WIPOffset<DucStackLikeStyles<'bldr>> {
    let mut builder = DucStackLikeStylesBuilder::new(_fbb);
    builder.add_opacity(args.opacity);
    if let Some(x) = args.labeling_color { builder.add_labeling_color(x); }
    builder.finish()
  }


  #[inline]
  pub fn opacity(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucStackLikeStyles::VT_OPACITY, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn labeling_color(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucStackLikeStyles::VT_LABELING_COLOR, None)}
  }
}

impl flatbuffers::Verifiable for DucStackLikeStyles<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("opacity", Self::VT_OPACITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("labeling_color", Self::VT_LABELING_COLOR, false)?
     .finish();
    Ok(())
  }
}
pub struct DucStackLikeStylesArgs<'a> {
    pub opacity: f64,
    pub labeling_color: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DucStackLikeStylesArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucStackLikeStylesArgs {
      opacity: 0.0,
      labeling_color: None,
    }
  }
}

pub struct DucStackLikeStylesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucStackLikeStylesBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_opacity(&mut self, opacity: f64) {
    self.fbb_.push_slot::<f64>(DucStackLikeStyles::VT_OPACITY, opacity, 0.0);
  }
  #[inline]
  pub fn add_labeling_color(&mut self, labeling_color: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucStackLikeStyles::VT_LABELING_COLOR, labeling_color);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucStackLikeStylesBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucStackLikeStylesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucStackLikeStyles<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucStackLikeStyles<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucStackLikeStyles");
      ds.field("opacity", &self.opacity());
      ds.field("labeling_color", &self.labeling_color());
      ds.finish()
  }
}
pub enum _DucStackBaseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct _DucStackBase<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for _DucStackBase<'a> {
  type Inner = _DucStackBase<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> _DucStackBase<'a> {
  pub const VT_LABEL: flatbuffers::VOffsetT = 4;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 6;
  pub const VT_IS_COLLAPSED: flatbuffers::VOffsetT = 8;
  pub const VT_IS_PLOT: flatbuffers::VOffsetT = 10;
  pub const VT_IS_VISIBLE: flatbuffers::VOffsetT = 12;
  pub const VT_LOCKED: flatbuffers::VOffsetT = 14;
  pub const VT_STYLES: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    _DucStackBase { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args _DucStackBaseArgs<'args>
  ) -> flatbuffers::WIPOffset<_DucStackBase<'bldr>> {
    let mut builder = _DucStackBaseBuilder::new(_fbb);
    if let Some(x) = args.styles { builder.add_styles(x); }
    if let Some(x) = args.description { builder.add_description(x); }
    if let Some(x) = args.label { builder.add_label(x); }
    builder.add_locked(args.locked);
    builder.add_is_visible(args.is_visible);
    builder.add_is_plot(args.is_plot);
    builder.add_is_collapsed(args.is_collapsed);
    builder.finish()
  }


  #[inline]
  pub fn label(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(_DucStackBase::VT_LABEL, None)}
  }
  #[inline]
  pub fn description(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(_DucStackBase::VT_DESCRIPTION, None)}
  }
  #[inline]
  pub fn is_collapsed(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(_DucStackBase::VT_IS_COLLAPSED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn is_plot(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(_DucStackBase::VT_IS_PLOT, Some(false)).unwrap()}
  }
  #[inline]
  pub fn is_visible(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(_DucStackBase::VT_IS_VISIBLE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn locked(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(_DucStackBase::VT_LOCKED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn styles(&self) -> Option<DucStackLikeStyles<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucStackLikeStyles>>(_DucStackBase::VT_STYLES, None)}
  }
}

impl flatbuffers::Verifiable for _DucStackBase<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("label", Self::VT_LABEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("description", Self::VT_DESCRIPTION, false)?
     .visit_field::<bool>("is_collapsed", Self::VT_IS_COLLAPSED, false)?
     .visit_field::<bool>("is_plot", Self::VT_IS_PLOT, false)?
     .visit_field::<bool>("is_visible", Self::VT_IS_VISIBLE, false)?
     .visit_field::<bool>("locked", Self::VT_LOCKED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucStackLikeStyles>>("styles", Self::VT_STYLES, false)?
     .finish();
    Ok(())
  }
}
pub struct _DucStackBaseArgs<'a> {
    pub label: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub is_collapsed: bool,
    pub is_plot: bool,
    pub is_visible: bool,
    pub locked: bool,
    pub styles: Option<flatbuffers::WIPOffset<DucStackLikeStyles<'a>>>,
}
impl<'a> Default for _DucStackBaseArgs<'a> {
  #[inline]
  fn default() -> Self {
    _DucStackBaseArgs {
      label: None,
      description: None,
      is_collapsed: false,
      is_plot: false,
      is_visible: false,
      locked: false,
      styles: None,
    }
  }
}

pub struct _DucStackBaseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> _DucStackBaseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_label(&mut self, label: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(_DucStackBase::VT_LABEL, label);
  }
  #[inline]
  pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(_DucStackBase::VT_DESCRIPTION, description);
  }
  #[inline]
  pub fn add_is_collapsed(&mut self, is_collapsed: bool) {
    self.fbb_.push_slot::<bool>(_DucStackBase::VT_IS_COLLAPSED, is_collapsed, false);
  }
  #[inline]
  pub fn add_is_plot(&mut self, is_plot: bool) {
    self.fbb_.push_slot::<bool>(_DucStackBase::VT_IS_PLOT, is_plot, false);
  }
  #[inline]
  pub fn add_is_visible(&mut self, is_visible: bool) {
    self.fbb_.push_slot::<bool>(_DucStackBase::VT_IS_VISIBLE, is_visible, false);
  }
  #[inline]
  pub fn add_locked(&mut self, locked: bool) {
    self.fbb_.push_slot::<bool>(_DucStackBase::VT_LOCKED, locked, false);
  }
  #[inline]
  pub fn add_styles(&mut self, styles: flatbuffers::WIPOffset<DucStackLikeStyles<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucStackLikeStyles>>(_DucStackBase::VT_STYLES, styles);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> _DucStackBaseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    _DucStackBaseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<_DucStackBase<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for _DucStackBase<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("_DucStackBase");
      ds.field("label", &self.label());
      ds.field("description", &self.description());
      ds.field("is_collapsed", &self.is_collapsed());
      ds.field("is_plot", &self.is_plot());
      ds.field("is_visible", &self.is_visible());
      ds.field("locked", &self.locked());
      ds.field("styles", &self.styles());
      ds.finish()
  }
}
pub enum _DucStackElementBaseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct _DucStackElementBase<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for _DucStackElementBase<'a> {
  type Inner = _DucStackElementBase<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> _DucStackElementBase<'a> {
  pub const VT_BASE: flatbuffers::VOffsetT = 4;
  pub const VT_STACK_BASE: flatbuffers::VOffsetT = 6;
  pub const VT_CLIP: flatbuffers::VOffsetT = 8;
  pub const VT_LABEL_VISIBLE: flatbuffers::VOffsetT = 10;
  pub const VT_STANDARD_OVERRIDE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    _DucStackElementBase { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args _DucStackElementBaseArgs<'args>
  ) -> flatbuffers::WIPOffset<_DucStackElementBase<'bldr>> {
    let mut builder = _DucStackElementBaseBuilder::new(_fbb);
    if let Some(x) = args.standard_override { builder.add_standard_override(x); }
    if let Some(x) = args.stack_base { builder.add_stack_base(x); }
    if let Some(x) = args.base { builder.add_base(x); }
    builder.add_label_visible(args.label_visible);
    builder.add_clip(args.clip);
    builder.finish()
  }


  #[inline]
  pub fn base(&self) -> Option<_DucElementBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<_DucElementBase>>(_DucStackElementBase::VT_BASE, None)}
  }
  #[inline]
  pub fn stack_base(&self) -> Option<_DucStackBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<_DucStackBase>>(_DucStackElementBase::VT_STACK_BASE, None)}
  }
  #[inline]
  pub fn clip(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(_DucStackElementBase::VT_CLIP, Some(false)).unwrap()}
  }
  #[inline]
  pub fn label_visible(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(_DucStackElementBase::VT_LABEL_VISIBLE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn standard_override(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(_DucStackElementBase::VT_STANDARD_OVERRIDE, None)}
  }
}

impl flatbuffers::Verifiable for _DucStackElementBase<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<_DucElementBase>>("base", Self::VT_BASE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<_DucStackBase>>("stack_base", Self::VT_STACK_BASE, false)?
     .visit_field::<bool>("clip", Self::VT_CLIP, false)?
     .visit_field::<bool>("label_visible", Self::VT_LABEL_VISIBLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("standard_override", Self::VT_STANDARD_OVERRIDE, false)?
     .finish();
    Ok(())
  }
}
pub struct _DucStackElementBaseArgs<'a> {
    pub base: Option<flatbuffers::WIPOffset<_DucElementBase<'a>>>,
    pub stack_base: Option<flatbuffers::WIPOffset<_DucStackBase<'a>>>,
    pub clip: bool,
    pub label_visible: bool,
    pub standard_override: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for _DucStackElementBaseArgs<'a> {
  #[inline]
  fn default() -> Self {
    _DucStackElementBaseArgs {
      base: None,
      stack_base: None,
      clip: false,
      label_visible: false,
      standard_override: None,
    }
  }
}

pub struct _DucStackElementBaseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> _DucStackElementBaseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_base(&mut self, base: flatbuffers::WIPOffset<_DucElementBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_DucElementBase>>(_DucStackElementBase::VT_BASE, base);
  }
  #[inline]
  pub fn add_stack_base(&mut self, stack_base: flatbuffers::WIPOffset<_DucStackBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_DucStackBase>>(_DucStackElementBase::VT_STACK_BASE, stack_base);
  }
  #[inline]
  pub fn add_clip(&mut self, clip: bool) {
    self.fbb_.push_slot::<bool>(_DucStackElementBase::VT_CLIP, clip, false);
  }
  #[inline]
  pub fn add_label_visible(&mut self, label_visible: bool) {
    self.fbb_.push_slot::<bool>(_DucStackElementBase::VT_LABEL_VISIBLE, label_visible, false);
  }
  #[inline]
  pub fn add_standard_override(&mut self, standard_override: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(_DucStackElementBase::VT_STANDARD_OVERRIDE, standard_override);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> _DucStackElementBaseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    _DucStackElementBaseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<_DucStackElementBase<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for _DucStackElementBase<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("_DucStackElementBase");
      ds.field("base", &self.base());
      ds.field("stack_base", &self.stack_base());
      ds.field("clip", &self.clip());
      ds.field("label_visible", &self.label_visible());
      ds.field("standard_override", &self.standard_override());
      ds.finish()
  }
}
pub enum LineSpacingOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LineSpacing<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LineSpacing<'a> {
  type Inner = LineSpacing<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LineSpacing<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LineSpacing { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LineSpacingArgs
  ) -> flatbuffers::WIPOffset<LineSpacing<'bldr>> {
    let mut builder = LineSpacingBuilder::new(_fbb);
    builder.add_value(args.value);
    if let Some(x) = args.type_ { builder.add_type_(x); }
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(LineSpacing::VT_VALUE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn type_(&self) -> Option<LINE_SPACING_TYPE> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<LINE_SPACING_TYPE>(LineSpacing::VT_TYPE_, None)}
  }
}

impl flatbuffers::Verifiable for LineSpacing<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("value", Self::VT_VALUE, false)?
     .visit_field::<LINE_SPACING_TYPE>("type_", Self::VT_TYPE_, false)?
     .finish();
    Ok(())
  }
}
pub struct LineSpacingArgs {
    pub value: f64,
    pub type_: Option<LINE_SPACING_TYPE>,
}
impl<'a> Default for LineSpacingArgs {
  #[inline]
  fn default() -> Self {
    LineSpacingArgs {
      value: 0.0,
      type_: None,
    }
  }
}

pub struct LineSpacingBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LineSpacingBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_value(&mut self, value: f64) {
    self.fbb_.push_slot::<f64>(LineSpacing::VT_VALUE, value, 0.0);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: LINE_SPACING_TYPE) {
    self.fbb_.push_slot_always::<LINE_SPACING_TYPE>(LineSpacing::VT_TYPE_, type_);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LineSpacingBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LineSpacingBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LineSpacing<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LineSpacing<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LineSpacing");
      ds.field("value", &self.value());
      ds.field("type_", &self.type_());
      ds.finish()
  }
}
pub enum DucTextStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucTextStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucTextStyle<'a> {
  type Inner = DucTextStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucTextStyle<'a> {
  pub const VT_IS_LTR: flatbuffers::VOffsetT = 6;
  pub const VT_FONT_FAMILY: flatbuffers::VOffsetT = 8;
  pub const VT_BIG_FONT_FAMILY: flatbuffers::VOffsetT = 10;
  pub const VT_TEXT_ALIGN: flatbuffers::VOffsetT = 12;
  pub const VT_VERTICAL_ALIGN: flatbuffers::VOffsetT = 14;
  pub const VT_LINE_HEIGHT: flatbuffers::VOffsetT = 16;
  pub const VT_LINE_SPACING: flatbuffers::VOffsetT = 18;
  pub const VT_OBLIQUE_ANGLE: flatbuffers::VOffsetT = 20;
  pub const VT_FONT_SIZE: flatbuffers::VOffsetT = 22;
  pub const VT_PAPER_TEXT_HEIGHT: flatbuffers::VOffsetT = 24;
  pub const VT_WIDTH_FACTOR: flatbuffers::VOffsetT = 26;
  pub const VT_IS_UPSIDE_DOWN: flatbuffers::VOffsetT = 28;
  pub const VT_IS_BACKWARDS: flatbuffers::VOffsetT = 30;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucTextStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucTextStyleArgs<'args>
  ) -> flatbuffers::WIPOffset<DucTextStyle<'bldr>> {
    let mut builder = DucTextStyleBuilder::new(_fbb);
    builder.add_paper_text_height(args.paper_text_height);
    builder.add_font_size(args.font_size);
    builder.add_oblique_angle(args.oblique_angle);
    builder.add_width_factor(args.width_factor);
    if let Some(x) = args.line_spacing { builder.add_line_spacing(x); }
    builder.add_line_height(args.line_height);
    if let Some(x) = args.big_font_family { builder.add_big_font_family(x); }
    if let Some(x) = args.font_family { builder.add_font_family(x); }
    builder.add_is_backwards(args.is_backwards);
    builder.add_is_upside_down(args.is_upside_down);
    if let Some(x) = args.vertical_align { builder.add_vertical_align(x); }
    if let Some(x) = args.text_align { builder.add_text_align(x); }
    builder.add_is_ltr(args.is_ltr);
    builder.finish()
  }


  #[inline]
  pub fn is_ltr(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucTextStyle::VT_IS_LTR, Some(false)).unwrap()}
  }
  #[inline]
  pub fn font_family(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucTextStyle::VT_FONT_FAMILY, None)}
  }
  #[inline]
  pub fn big_font_family(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucTextStyle::VT_BIG_FONT_FAMILY, None)}
  }
  #[inline]
  pub fn text_align(&self) -> Option<TEXT_ALIGN> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TEXT_ALIGN>(DucTextStyle::VT_TEXT_ALIGN, None)}
  }
  #[inline]
  pub fn vertical_align(&self) -> Option<VERTICAL_ALIGN> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<VERTICAL_ALIGN>(DucTextStyle::VT_VERTICAL_ALIGN, None)}
  }
  #[inline]
  pub fn line_height(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucTextStyle::VT_LINE_HEIGHT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn line_spacing(&self) -> Option<LineSpacing<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<LineSpacing>>(DucTextStyle::VT_LINE_SPACING, None)}
  }
  #[inline]
  pub fn oblique_angle(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucTextStyle::VT_OBLIQUE_ANGLE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn font_size(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucTextStyle::VT_FONT_SIZE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn paper_text_height(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucTextStyle::VT_PAPER_TEXT_HEIGHT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn width_factor(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucTextStyle::VT_WIDTH_FACTOR, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn is_upside_down(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucTextStyle::VT_IS_UPSIDE_DOWN, Some(false)).unwrap()}
  }
  #[inline]
  pub fn is_backwards(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucTextStyle::VT_IS_BACKWARDS, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DucTextStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("is_ltr", Self::VT_IS_LTR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("font_family", Self::VT_FONT_FAMILY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("big_font_family", Self::VT_BIG_FONT_FAMILY, false)?
     .visit_field::<TEXT_ALIGN>("text_align", Self::VT_TEXT_ALIGN, false)?
     .visit_field::<VERTICAL_ALIGN>("vertical_align", Self::VT_VERTICAL_ALIGN, false)?
     .visit_field::<f32>("line_height", Self::VT_LINE_HEIGHT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<LineSpacing>>("line_spacing", Self::VT_LINE_SPACING, false)?
     .visit_field::<f64>("oblique_angle", Self::VT_OBLIQUE_ANGLE, false)?
     .visit_field::<f64>("font_size", Self::VT_FONT_SIZE, false)?
     .visit_field::<f64>("paper_text_height", Self::VT_PAPER_TEXT_HEIGHT, false)?
     .visit_field::<f32>("width_factor", Self::VT_WIDTH_FACTOR, false)?
     .visit_field::<bool>("is_upside_down", Self::VT_IS_UPSIDE_DOWN, false)?
     .visit_field::<bool>("is_backwards", Self::VT_IS_BACKWARDS, false)?
     .finish();
    Ok(())
  }
}
pub struct DucTextStyleArgs<'a> {
    pub is_ltr: bool,
    pub font_family: Option<flatbuffers::WIPOffset<&'a str>>,
    pub big_font_family: Option<flatbuffers::WIPOffset<&'a str>>,
    pub text_align: Option<TEXT_ALIGN>,
    pub vertical_align: Option<VERTICAL_ALIGN>,
    pub line_height: f32,
    pub line_spacing: Option<flatbuffers::WIPOffset<LineSpacing<'a>>>,
    pub oblique_angle: f64,
    pub font_size: f64,
    pub paper_text_height: f64,
    pub width_factor: f32,
    pub is_upside_down: bool,
    pub is_backwards: bool,
}
impl<'a> Default for DucTextStyleArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucTextStyleArgs {
      is_ltr: false,
      font_family: None,
      big_font_family: None,
      text_align: None,
      vertical_align: None,
      line_height: 0.0,
      line_spacing: None,
      oblique_angle: 0.0,
      font_size: 0.0,
      paper_text_height: 0.0,
      width_factor: 0.0,
      is_upside_down: false,
      is_backwards: false,
    }
  }
}

pub struct DucTextStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucTextStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_is_ltr(&mut self, is_ltr: bool) {
    self.fbb_.push_slot::<bool>(DucTextStyle::VT_IS_LTR, is_ltr, false);
  }
  #[inline]
  pub fn add_font_family(&mut self, font_family: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucTextStyle::VT_FONT_FAMILY, font_family);
  }
  #[inline]
  pub fn add_big_font_family(&mut self, big_font_family: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucTextStyle::VT_BIG_FONT_FAMILY, big_font_family);
  }
  #[inline]
  pub fn add_text_align(&mut self, text_align: TEXT_ALIGN) {
    self.fbb_.push_slot_always::<TEXT_ALIGN>(DucTextStyle::VT_TEXT_ALIGN, text_align);
  }
  #[inline]
  pub fn add_vertical_align(&mut self, vertical_align: VERTICAL_ALIGN) {
    self.fbb_.push_slot_always::<VERTICAL_ALIGN>(DucTextStyle::VT_VERTICAL_ALIGN, vertical_align);
  }
  #[inline]
  pub fn add_line_height(&mut self, line_height: f32) {
    self.fbb_.push_slot::<f32>(DucTextStyle::VT_LINE_HEIGHT, line_height, 0.0);
  }
  #[inline]
  pub fn add_line_spacing(&mut self, line_spacing: flatbuffers::WIPOffset<LineSpacing<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<LineSpacing>>(DucTextStyle::VT_LINE_SPACING, line_spacing);
  }
  #[inline]
  pub fn add_oblique_angle(&mut self, oblique_angle: f64) {
    self.fbb_.push_slot::<f64>(DucTextStyle::VT_OBLIQUE_ANGLE, oblique_angle, 0.0);
  }
  #[inline]
  pub fn add_font_size(&mut self, font_size: f64) {
    self.fbb_.push_slot::<f64>(DucTextStyle::VT_FONT_SIZE, font_size, 0.0);
  }
  #[inline]
  pub fn add_paper_text_height(&mut self, paper_text_height: f64) {
    self.fbb_.push_slot::<f64>(DucTextStyle::VT_PAPER_TEXT_HEIGHT, paper_text_height, 0.0);
  }
  #[inline]
  pub fn add_width_factor(&mut self, width_factor: f32) {
    self.fbb_.push_slot::<f32>(DucTextStyle::VT_WIDTH_FACTOR, width_factor, 0.0);
  }
  #[inline]
  pub fn add_is_upside_down(&mut self, is_upside_down: bool) {
    self.fbb_.push_slot::<bool>(DucTextStyle::VT_IS_UPSIDE_DOWN, is_upside_down, false);
  }
  #[inline]
  pub fn add_is_backwards(&mut self, is_backwards: bool) {
    self.fbb_.push_slot::<bool>(DucTextStyle::VT_IS_BACKWARDS, is_backwards, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucTextStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucTextStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucTextStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucTextStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucTextStyle");
      ds.field("is_ltr", &self.is_ltr());
      ds.field("font_family", &self.font_family());
      ds.field("big_font_family", &self.big_font_family());
      ds.field("text_align", &self.text_align());
      ds.field("vertical_align", &self.vertical_align());
      ds.field("line_height", &self.line_height());
      ds.field("line_spacing", &self.line_spacing());
      ds.field("oblique_angle", &self.oblique_angle());
      ds.field("font_size", &self.font_size());
      ds.field("paper_text_height", &self.paper_text_height());
      ds.field("width_factor", &self.width_factor());
      ds.field("is_upside_down", &self.is_upside_down());
      ds.field("is_backwards", &self.is_backwards());
      ds.finish()
  }
}
pub enum DucTableCellStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucTableCellStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucTableCellStyle<'a> {
  type Inner = DucTableCellStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucTableCellStyle<'a> {
  pub const VT_BASE_STYLE: flatbuffers::VOffsetT = 4;
  pub const VT_TEXT_STYLE: flatbuffers::VOffsetT = 6;
  pub const VT_MARGINS: flatbuffers::VOffsetT = 8;
  pub const VT_ALIGNMENT: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucTableCellStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucTableCellStyleArgs<'args>
  ) -> flatbuffers::WIPOffset<DucTableCellStyle<'bldr>> {
    let mut builder = DucTableCellStyleBuilder::new(_fbb);
    if let Some(x) = args.margins { builder.add_margins(x); }
    if let Some(x) = args.text_style { builder.add_text_style(x); }
    if let Some(x) = args.base_style { builder.add_base_style(x); }
    if let Some(x) = args.alignment { builder.add_alignment(x); }
    builder.finish()
  }


  #[inline]
  pub fn base_style(&self) -> Option<_DucElementStylesBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<_DucElementStylesBase>>(DucTableCellStyle::VT_BASE_STYLE, None)}
  }
  #[inline]
  pub fn text_style(&self) -> Option<DucTextStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucTextStyle>>(DucTableCellStyle::VT_TEXT_STYLE, None)}
  }
  #[inline]
  pub fn margins(&self) -> Option<Margins<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Margins>>(DucTableCellStyle::VT_MARGINS, None)}
  }
  #[inline]
  pub fn alignment(&self) -> Option<TABLE_CELL_ALIGNMENT> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TABLE_CELL_ALIGNMENT>(DucTableCellStyle::VT_ALIGNMENT, None)}
  }
}

impl flatbuffers::Verifiable for DucTableCellStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<_DucElementStylesBase>>("base_style", Self::VT_BASE_STYLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucTextStyle>>("text_style", Self::VT_TEXT_STYLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Margins>>("margins", Self::VT_MARGINS, false)?
     .visit_field::<TABLE_CELL_ALIGNMENT>("alignment", Self::VT_ALIGNMENT, false)?
     .finish();
    Ok(())
  }
}
pub struct DucTableCellStyleArgs<'a> {
    pub base_style: Option<flatbuffers::WIPOffset<_DucElementStylesBase<'a>>>,
    pub text_style: Option<flatbuffers::WIPOffset<DucTextStyle<'a>>>,
    pub margins: Option<flatbuffers::WIPOffset<Margins<'a>>>,
    pub alignment: Option<TABLE_CELL_ALIGNMENT>,
}
impl<'a> Default for DucTableCellStyleArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucTableCellStyleArgs {
      base_style: None,
      text_style: None,
      margins: None,
      alignment: None,
    }
  }
}

pub struct DucTableCellStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucTableCellStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_base_style(&mut self, base_style: flatbuffers::WIPOffset<_DucElementStylesBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_DucElementStylesBase>>(DucTableCellStyle::VT_BASE_STYLE, base_style);
  }
  #[inline]
  pub fn add_text_style(&mut self, text_style: flatbuffers::WIPOffset<DucTextStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucTextStyle>>(DucTableCellStyle::VT_TEXT_STYLE, text_style);
  }
  #[inline]
  pub fn add_margins(&mut self, margins: flatbuffers::WIPOffset<Margins<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Margins>>(DucTableCellStyle::VT_MARGINS, margins);
  }
  #[inline]
  pub fn add_alignment(&mut self, alignment: TABLE_CELL_ALIGNMENT) {
    self.fbb_.push_slot_always::<TABLE_CELL_ALIGNMENT>(DucTableCellStyle::VT_ALIGNMENT, alignment);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucTableCellStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucTableCellStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucTableCellStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucTableCellStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucTableCellStyle");
      ds.field("base_style", &self.base_style());
      ds.field("text_style", &self.text_style());
      ds.field("margins", &self.margins());
      ds.field("alignment", &self.alignment());
      ds.finish()
  }
}
pub enum DucTableStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucTableStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucTableStyle<'a> {
  type Inner = DucTableStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucTableStyle<'a> {
  pub const VT_FLOW_DIRECTION: flatbuffers::VOffsetT = 6;
  pub const VT_HEADER_ROW_STYLE: flatbuffers::VOffsetT = 8;
  pub const VT_DATA_ROW_STYLE: flatbuffers::VOffsetT = 10;
  pub const VT_DATA_COLUMN_STYLE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucTableStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucTableStyleArgs<'args>
  ) -> flatbuffers::WIPOffset<DucTableStyle<'bldr>> {
    let mut builder = DucTableStyleBuilder::new(_fbb);
    if let Some(x) = args.data_column_style { builder.add_data_column_style(x); }
    if let Some(x) = args.data_row_style { builder.add_data_row_style(x); }
    if let Some(x) = args.header_row_style { builder.add_header_row_style(x); }
    if let Some(x) = args.flow_direction { builder.add_flow_direction(x); }
    builder.finish()
  }


  #[inline]
  pub fn flow_direction(&self) -> Option<TABLE_FLOW_DIRECTION> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TABLE_FLOW_DIRECTION>(DucTableStyle::VT_FLOW_DIRECTION, None)}
  }
  #[inline]
  pub fn header_row_style(&self) -> Option<DucTableCellStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucTableCellStyle>>(DucTableStyle::VT_HEADER_ROW_STYLE, None)}
  }
  #[inline]
  pub fn data_row_style(&self) -> Option<DucTableCellStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucTableCellStyle>>(DucTableStyle::VT_DATA_ROW_STYLE, None)}
  }
  #[inline]
  pub fn data_column_style(&self) -> Option<DucTableCellStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucTableCellStyle>>(DucTableStyle::VT_DATA_COLUMN_STYLE, None)}
  }
}

impl flatbuffers::Verifiable for DucTableStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<TABLE_FLOW_DIRECTION>("flow_direction", Self::VT_FLOW_DIRECTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucTableCellStyle>>("header_row_style", Self::VT_HEADER_ROW_STYLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucTableCellStyle>>("data_row_style", Self::VT_DATA_ROW_STYLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucTableCellStyle>>("data_column_style", Self::VT_DATA_COLUMN_STYLE, false)?
     .finish();
    Ok(())
  }
}
pub struct DucTableStyleArgs<'a> {
    pub flow_direction: Option<TABLE_FLOW_DIRECTION>,
    pub header_row_style: Option<flatbuffers::WIPOffset<DucTableCellStyle<'a>>>,
    pub data_row_style: Option<flatbuffers::WIPOffset<DucTableCellStyle<'a>>>,
    pub data_column_style: Option<flatbuffers::WIPOffset<DucTableCellStyle<'a>>>,
}
impl<'a> Default for DucTableStyleArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucTableStyleArgs {
      flow_direction: None,
      header_row_style: None,
      data_row_style: None,
      data_column_style: None,
    }
  }
}

pub struct DucTableStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucTableStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_flow_direction(&mut self, flow_direction: TABLE_FLOW_DIRECTION) {
    self.fbb_.push_slot_always::<TABLE_FLOW_DIRECTION>(DucTableStyle::VT_FLOW_DIRECTION, flow_direction);
  }
  #[inline]
  pub fn add_header_row_style(&mut self, header_row_style: flatbuffers::WIPOffset<DucTableCellStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucTableCellStyle>>(DucTableStyle::VT_HEADER_ROW_STYLE, header_row_style);
  }
  #[inline]
  pub fn add_data_row_style(&mut self, data_row_style: flatbuffers::WIPOffset<DucTableCellStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucTableCellStyle>>(DucTableStyle::VT_DATA_ROW_STYLE, data_row_style);
  }
  #[inline]
  pub fn add_data_column_style(&mut self, data_column_style: flatbuffers::WIPOffset<DucTableCellStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucTableCellStyle>>(DucTableStyle::VT_DATA_COLUMN_STYLE, data_column_style);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucTableStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucTableStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucTableStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucTableStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucTableStyle");
      ds.field("flow_direction", &self.flow_direction());
      ds.field("header_row_style", &self.header_row_style());
      ds.field("data_row_style", &self.data_row_style());
      ds.field("data_column_style", &self.data_column_style());
      ds.finish()
  }
}
pub enum DucLeaderStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucLeaderStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucLeaderStyle<'a> {
  type Inner = DucLeaderStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucLeaderStyle<'a> {
  pub const VT_HEADS_OVERRIDE: flatbuffers::VOffsetT = 6;
  pub const VT_DOGLEG: flatbuffers::VOffsetT = 8;
  pub const VT_TEXT_STYLE: flatbuffers::VOffsetT = 10;
  pub const VT_TEXT_ATTACHMENT: flatbuffers::VOffsetT = 12;
  pub const VT_BLOCK_ATTACHMENT: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucLeaderStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucLeaderStyleArgs<'args>
  ) -> flatbuffers::WIPOffset<DucLeaderStyle<'bldr>> {
    let mut builder = DucLeaderStyleBuilder::new(_fbb);
    builder.add_dogleg(args.dogleg);
    if let Some(x) = args.text_style { builder.add_text_style(x); }
    if let Some(x) = args.heads_override { builder.add_heads_override(x); }
    if let Some(x) = args.block_attachment { builder.add_block_attachment(x); }
    if let Some(x) = args.text_attachment { builder.add_text_attachment(x); }
    builder.finish()
  }


  #[inline]
  pub fn heads_override(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucHead<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucHead>>>>(DucLeaderStyle::VT_HEADS_OVERRIDE, None)}
  }
  #[inline]
  pub fn dogleg(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucLeaderStyle::VT_DOGLEG, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn text_style(&self) -> Option<DucTextStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucTextStyle>>(DucLeaderStyle::VT_TEXT_STYLE, None)}
  }
  #[inline]
  pub fn text_attachment(&self) -> Option<VERTICAL_ALIGN> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<VERTICAL_ALIGN>(DucLeaderStyle::VT_TEXT_ATTACHMENT, None)}
  }
  #[inline]
  pub fn block_attachment(&self) -> Option<BLOCK_ATTACHMENT> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<BLOCK_ATTACHMENT>(DucLeaderStyle::VT_BLOCK_ATTACHMENT, None)}
  }
}

impl flatbuffers::Verifiable for DucLeaderStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DucHead>>>>("heads_override", Self::VT_HEADS_OVERRIDE, false)?
     .visit_field::<f64>("dogleg", Self::VT_DOGLEG, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucTextStyle>>("text_style", Self::VT_TEXT_STYLE, false)?
     .visit_field::<VERTICAL_ALIGN>("text_attachment", Self::VT_TEXT_ATTACHMENT, false)?
     .visit_field::<BLOCK_ATTACHMENT>("block_attachment", Self::VT_BLOCK_ATTACHMENT, false)?
     .finish();
    Ok(())
  }
}
pub struct DucLeaderStyleArgs<'a> {
    pub heads_override: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucHead<'a>>>>>,
    pub dogleg: f64,
    pub text_style: Option<flatbuffers::WIPOffset<DucTextStyle<'a>>>,
    pub text_attachment: Option<VERTICAL_ALIGN>,
    pub block_attachment: Option<BLOCK_ATTACHMENT>,
}
impl<'a> Default for DucLeaderStyleArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucLeaderStyleArgs {
      heads_override: None,
      dogleg: 0.0,
      text_style: None,
      text_attachment: None,
      block_attachment: None,
    }
  }
}

pub struct DucLeaderStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucLeaderStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_heads_override(&mut self, heads_override: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DucHead<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucLeaderStyle::VT_HEADS_OVERRIDE, heads_override);
  }
  #[inline]
  pub fn add_dogleg(&mut self, dogleg: f64) {
    self.fbb_.push_slot::<f64>(DucLeaderStyle::VT_DOGLEG, dogleg, 0.0);
  }
  #[inline]
  pub fn add_text_style(&mut self, text_style: flatbuffers::WIPOffset<DucTextStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucTextStyle>>(DucLeaderStyle::VT_TEXT_STYLE, text_style);
  }
  #[inline]
  pub fn add_text_attachment(&mut self, text_attachment: VERTICAL_ALIGN) {
    self.fbb_.push_slot_always::<VERTICAL_ALIGN>(DucLeaderStyle::VT_TEXT_ATTACHMENT, text_attachment);
  }
  #[inline]
  pub fn add_block_attachment(&mut self, block_attachment: BLOCK_ATTACHMENT) {
    self.fbb_.push_slot_always::<BLOCK_ATTACHMENT>(DucLeaderStyle::VT_BLOCK_ATTACHMENT, block_attachment);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucLeaderStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucLeaderStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucLeaderStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucLeaderStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucLeaderStyle");
      ds.field("heads_override", &self.heads_override());
      ds.field("dogleg", &self.dogleg());
      ds.field("text_style", &self.text_style());
      ds.field("text_attachment", &self.text_attachment());
      ds.field("block_attachment", &self.block_attachment());
      ds.finish()
  }
}
pub enum DimensionToleranceStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DimensionToleranceStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DimensionToleranceStyle<'a> {
  type Inner = DimensionToleranceStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DimensionToleranceStyle<'a> {
  pub const VT_ENABLED: flatbuffers::VOffsetT = 4;
  pub const VT_DISPLAY_METHOD: flatbuffers::VOffsetT = 6;
  pub const VT_UPPER_VALUE: flatbuffers::VOffsetT = 8;
  pub const VT_LOWER_VALUE: flatbuffers::VOffsetT = 10;
  pub const VT_PRECISION: flatbuffers::VOffsetT = 12;
  pub const VT_TEXT_STYLE: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DimensionToleranceStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DimensionToleranceStyleArgs<'args>
  ) -> flatbuffers::WIPOffset<DimensionToleranceStyle<'bldr>> {
    let mut builder = DimensionToleranceStyleBuilder::new(_fbb);
    builder.add_lower_value(args.lower_value);
    builder.add_upper_value(args.upper_value);
    if let Some(x) = args.text_style { builder.add_text_style(x); }
    builder.add_precision(args.precision);
    if let Some(x) = args.display_method { builder.add_display_method(x); }
    builder.add_enabled(args.enabled);
    builder.finish()
  }


  #[inline]
  pub fn enabled(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DimensionToleranceStyle::VT_ENABLED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn display_method(&self) -> Option<TOLERANCE_DISPLAY> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TOLERANCE_DISPLAY>(DimensionToleranceStyle::VT_DISPLAY_METHOD, None)}
  }
  #[inline]
  pub fn upper_value(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DimensionToleranceStyle::VT_UPPER_VALUE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn lower_value(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DimensionToleranceStyle::VT_LOWER_VALUE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn precision(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DimensionToleranceStyle::VT_PRECISION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn text_style(&self) -> Option<DucTextStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucTextStyle>>(DimensionToleranceStyle::VT_TEXT_STYLE, None)}
  }
}

impl flatbuffers::Verifiable for DimensionToleranceStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("enabled", Self::VT_ENABLED, false)?
     .visit_field::<TOLERANCE_DISPLAY>("display_method", Self::VT_DISPLAY_METHOD, false)?
     .visit_field::<f64>("upper_value", Self::VT_UPPER_VALUE, false)?
     .visit_field::<f64>("lower_value", Self::VT_LOWER_VALUE, false)?
     .visit_field::<i32>("precision", Self::VT_PRECISION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucTextStyle>>("text_style", Self::VT_TEXT_STYLE, false)?
     .finish();
    Ok(())
  }
}
pub struct DimensionToleranceStyleArgs<'a> {
    pub enabled: bool,
    pub display_method: Option<TOLERANCE_DISPLAY>,
    pub upper_value: f64,
    pub lower_value: f64,
    pub precision: i32,
    pub text_style: Option<flatbuffers::WIPOffset<DucTextStyle<'a>>>,
}
impl<'a> Default for DimensionToleranceStyleArgs<'a> {
  #[inline]
  fn default() -> Self {
    DimensionToleranceStyleArgs {
      enabled: false,
      display_method: None,
      upper_value: 0.0,
      lower_value: 0.0,
      precision: 0,
      text_style: None,
    }
  }
}

pub struct DimensionToleranceStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DimensionToleranceStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_enabled(&mut self, enabled: bool) {
    self.fbb_.push_slot::<bool>(DimensionToleranceStyle::VT_ENABLED, enabled, false);
  }
  #[inline]
  pub fn add_display_method(&mut self, display_method: TOLERANCE_DISPLAY) {
    self.fbb_.push_slot_always::<TOLERANCE_DISPLAY>(DimensionToleranceStyle::VT_DISPLAY_METHOD, display_method);
  }
  #[inline]
  pub fn add_upper_value(&mut self, upper_value: f64) {
    self.fbb_.push_slot::<f64>(DimensionToleranceStyle::VT_UPPER_VALUE, upper_value, 0.0);
  }
  #[inline]
  pub fn add_lower_value(&mut self, lower_value: f64) {
    self.fbb_.push_slot::<f64>(DimensionToleranceStyle::VT_LOWER_VALUE, lower_value, 0.0);
  }
  #[inline]
  pub fn add_precision(&mut self, precision: i32) {
    self.fbb_.push_slot::<i32>(DimensionToleranceStyle::VT_PRECISION, precision, 0);
  }
  #[inline]
  pub fn add_text_style(&mut self, text_style: flatbuffers::WIPOffset<DucTextStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucTextStyle>>(DimensionToleranceStyle::VT_TEXT_STYLE, text_style);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DimensionToleranceStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DimensionToleranceStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DimensionToleranceStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DimensionToleranceStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DimensionToleranceStyle");
      ds.field("enabled", &self.enabled());
      ds.field("display_method", &self.display_method());
      ds.field("upper_value", &self.upper_value());
      ds.field("lower_value", &self.lower_value());
      ds.field("precision", &self.precision());
      ds.field("text_style", &self.text_style());
      ds.finish()
  }
}
pub enum DimensionFitStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DimensionFitStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DimensionFitStyle<'a> {
  type Inner = DimensionFitStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DimensionFitStyle<'a> {
  pub const VT_RULE: flatbuffers::VOffsetT = 4;
  pub const VT_TEXT_PLACEMENT: flatbuffers::VOffsetT = 6;
  pub const VT_FORCE_TEXT_INSIDE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DimensionFitStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DimensionFitStyleArgs
  ) -> flatbuffers::WIPOffset<DimensionFitStyle<'bldr>> {
    let mut builder = DimensionFitStyleBuilder::new(_fbb);
    builder.add_force_text_inside(args.force_text_inside);
    if let Some(x) = args.text_placement { builder.add_text_placement(x); }
    if let Some(x) = args.rule { builder.add_rule(x); }
    builder.finish()
  }


  #[inline]
  pub fn rule(&self) -> Option<DIMENSION_FIT_RULE> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DIMENSION_FIT_RULE>(DimensionFitStyle::VT_RULE, None)}
  }
  #[inline]
  pub fn text_placement(&self) -> Option<DIMENSION_TEXT_PLACEMENT> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DIMENSION_TEXT_PLACEMENT>(DimensionFitStyle::VT_TEXT_PLACEMENT, None)}
  }
  #[inline]
  pub fn force_text_inside(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DimensionFitStyle::VT_FORCE_TEXT_INSIDE, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DimensionFitStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<DIMENSION_FIT_RULE>("rule", Self::VT_RULE, false)?
     .visit_field::<DIMENSION_TEXT_PLACEMENT>("text_placement", Self::VT_TEXT_PLACEMENT, false)?
     .visit_field::<bool>("force_text_inside", Self::VT_FORCE_TEXT_INSIDE, false)?
     .finish();
    Ok(())
  }
}
pub struct DimensionFitStyleArgs {
    pub rule: Option<DIMENSION_FIT_RULE>,
    pub text_placement: Option<DIMENSION_TEXT_PLACEMENT>,
    pub force_text_inside: bool,
}
impl<'a> Default for DimensionFitStyleArgs {
  #[inline]
  fn default() -> Self {
    DimensionFitStyleArgs {
      rule: None,
      text_placement: None,
      force_text_inside: false,
    }
  }
}

pub struct DimensionFitStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DimensionFitStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_rule(&mut self, rule: DIMENSION_FIT_RULE) {
    self.fbb_.push_slot_always::<DIMENSION_FIT_RULE>(DimensionFitStyle::VT_RULE, rule);
  }
  #[inline]
  pub fn add_text_placement(&mut self, text_placement: DIMENSION_TEXT_PLACEMENT) {
    self.fbb_.push_slot_always::<DIMENSION_TEXT_PLACEMENT>(DimensionFitStyle::VT_TEXT_PLACEMENT, text_placement);
  }
  #[inline]
  pub fn add_force_text_inside(&mut self, force_text_inside: bool) {
    self.fbb_.push_slot::<bool>(DimensionFitStyle::VT_FORCE_TEXT_INSIDE, force_text_inside, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DimensionFitStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DimensionFitStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DimensionFitStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DimensionFitStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DimensionFitStyle");
      ds.field("rule", &self.rule());
      ds.field("text_placement", &self.text_placement());
      ds.field("force_text_inside", &self.force_text_inside());
      ds.finish()
  }
}
pub enum DimensionLineStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DimensionLineStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DimensionLineStyle<'a> {
  type Inner = DimensionLineStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DimensionLineStyle<'a> {
  pub const VT_STROKE: flatbuffers::VOffsetT = 4;
  pub const VT_TEXT_GAP: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DimensionLineStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DimensionLineStyleArgs<'args>
  ) -> flatbuffers::WIPOffset<DimensionLineStyle<'bldr>> {
    let mut builder = DimensionLineStyleBuilder::new(_fbb);
    builder.add_text_gap(args.text_gap);
    if let Some(x) = args.stroke { builder.add_stroke(x); }
    builder.finish()
  }


  #[inline]
  pub fn stroke(&self) -> Option<ElementStroke<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ElementStroke>>(DimensionLineStyle::VT_STROKE, None)}
  }
  #[inline]
  pub fn text_gap(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DimensionLineStyle::VT_TEXT_GAP, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DimensionLineStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<ElementStroke>>("stroke", Self::VT_STROKE, false)?
     .visit_field::<f64>("text_gap", Self::VT_TEXT_GAP, false)?
     .finish();
    Ok(())
  }
}
pub struct DimensionLineStyleArgs<'a> {
    pub stroke: Option<flatbuffers::WIPOffset<ElementStroke<'a>>>,
    pub text_gap: f64,
}
impl<'a> Default for DimensionLineStyleArgs<'a> {
  #[inline]
  fn default() -> Self {
    DimensionLineStyleArgs {
      stroke: None,
      text_gap: 0.0,
    }
  }
}

pub struct DimensionLineStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DimensionLineStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_stroke(&mut self, stroke: flatbuffers::WIPOffset<ElementStroke<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ElementStroke>>(DimensionLineStyle::VT_STROKE, stroke);
  }
  #[inline]
  pub fn add_text_gap(&mut self, text_gap: f64) {
    self.fbb_.push_slot::<f64>(DimensionLineStyle::VT_TEXT_GAP, text_gap, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DimensionLineStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DimensionLineStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DimensionLineStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DimensionLineStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DimensionLineStyle");
      ds.field("stroke", &self.stroke());
      ds.field("text_gap", &self.text_gap());
      ds.finish()
  }
}
pub enum DimensionExtLineStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DimensionExtLineStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DimensionExtLineStyle<'a> {
  type Inner = DimensionExtLineStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DimensionExtLineStyle<'a> {
  pub const VT_STROKE: flatbuffers::VOffsetT = 4;
  pub const VT_OVERSHOOT: flatbuffers::VOffsetT = 6;
  pub const VT_OFFSET: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DimensionExtLineStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DimensionExtLineStyleArgs<'args>
  ) -> flatbuffers::WIPOffset<DimensionExtLineStyle<'bldr>> {
    let mut builder = DimensionExtLineStyleBuilder::new(_fbb);
    builder.add_offset(args.offset);
    builder.add_overshoot(args.overshoot);
    if let Some(x) = args.stroke { builder.add_stroke(x); }
    builder.finish()
  }


  #[inline]
  pub fn stroke(&self) -> Option<ElementStroke<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ElementStroke>>(DimensionExtLineStyle::VT_STROKE, None)}
  }
  #[inline]
  pub fn overshoot(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DimensionExtLineStyle::VT_OVERSHOOT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn offset(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DimensionExtLineStyle::VT_OFFSET, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DimensionExtLineStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<ElementStroke>>("stroke", Self::VT_STROKE, false)?
     .visit_field::<f64>("overshoot", Self::VT_OVERSHOOT, false)?
     .visit_field::<f64>("offset", Self::VT_OFFSET, false)?
     .finish();
    Ok(())
  }
}
pub struct DimensionExtLineStyleArgs<'a> {
    pub stroke: Option<flatbuffers::WIPOffset<ElementStroke<'a>>>,
    pub overshoot: f64,
    pub offset: f64,
}
impl<'a> Default for DimensionExtLineStyleArgs<'a> {
  #[inline]
  fn default() -> Self {
    DimensionExtLineStyleArgs {
      stroke: None,
      overshoot: 0.0,
      offset: 0.0,
    }
  }
}

pub struct DimensionExtLineStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DimensionExtLineStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_stroke(&mut self, stroke: flatbuffers::WIPOffset<ElementStroke<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ElementStroke>>(DimensionExtLineStyle::VT_STROKE, stroke);
  }
  #[inline]
  pub fn add_overshoot(&mut self, overshoot: f64) {
    self.fbb_.push_slot::<f64>(DimensionExtLineStyle::VT_OVERSHOOT, overshoot, 0.0);
  }
  #[inline]
  pub fn add_offset(&mut self, offset: f64) {
    self.fbb_.push_slot::<f64>(DimensionExtLineStyle::VT_OFFSET, offset, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DimensionExtLineStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DimensionExtLineStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DimensionExtLineStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DimensionExtLineStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DimensionExtLineStyle");
      ds.field("stroke", &self.stroke());
      ds.field("overshoot", &self.overshoot());
      ds.field("offset", &self.offset());
      ds.finish()
  }
}
pub enum DimensionSymbolStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DimensionSymbolStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DimensionSymbolStyle<'a> {
  type Inner = DimensionSymbolStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DimensionSymbolStyle<'a> {
  pub const VT_HEADS_OVERRIDE: flatbuffers::VOffsetT = 4;
  pub const VT_CENTER_MARK_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_CENTER_MARK_SIZE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DimensionSymbolStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DimensionSymbolStyleArgs<'args>
  ) -> flatbuffers::WIPOffset<DimensionSymbolStyle<'bldr>> {
    let mut builder = DimensionSymbolStyleBuilder::new(_fbb);
    builder.add_center_mark_size(args.center_mark_size);
    if let Some(x) = args.heads_override { builder.add_heads_override(x); }
    if let Some(x) = args.center_mark_type { builder.add_center_mark_type(x); }
    builder.finish()
  }


  #[inline]
  pub fn heads_override(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucHead<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucHead>>>>(DimensionSymbolStyle::VT_HEADS_OVERRIDE, None)}
  }
  #[inline]
  pub fn center_mark_type(&self) -> Option<MARK_ELLIPSE_CENTER> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<MARK_ELLIPSE_CENTER>(DimensionSymbolStyle::VT_CENTER_MARK_TYPE, None)}
  }
  #[inline]
  pub fn center_mark_size(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DimensionSymbolStyle::VT_CENTER_MARK_SIZE, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DimensionSymbolStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DucHead>>>>("heads_override", Self::VT_HEADS_OVERRIDE, false)?
     .visit_field::<MARK_ELLIPSE_CENTER>("center_mark_type", Self::VT_CENTER_MARK_TYPE, false)?
     .visit_field::<f64>("center_mark_size", Self::VT_CENTER_MARK_SIZE, false)?
     .finish();
    Ok(())
  }
}
pub struct DimensionSymbolStyleArgs<'a> {
    pub heads_override: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucHead<'a>>>>>,
    pub center_mark_type: Option<MARK_ELLIPSE_CENTER>,
    pub center_mark_size: f64,
}
impl<'a> Default for DimensionSymbolStyleArgs<'a> {
  #[inline]
  fn default() -> Self {
    DimensionSymbolStyleArgs {
      heads_override: None,
      center_mark_type: None,
      center_mark_size: 0.0,
    }
  }
}

pub struct DimensionSymbolStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DimensionSymbolStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_heads_override(&mut self, heads_override: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DucHead<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DimensionSymbolStyle::VT_HEADS_OVERRIDE, heads_override);
  }
  #[inline]
  pub fn add_center_mark_type(&mut self, center_mark_type: MARK_ELLIPSE_CENTER) {
    self.fbb_.push_slot_always::<MARK_ELLIPSE_CENTER>(DimensionSymbolStyle::VT_CENTER_MARK_TYPE, center_mark_type);
  }
  #[inline]
  pub fn add_center_mark_size(&mut self, center_mark_size: f64) {
    self.fbb_.push_slot::<f64>(DimensionSymbolStyle::VT_CENTER_MARK_SIZE, center_mark_size, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DimensionSymbolStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DimensionSymbolStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DimensionSymbolStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DimensionSymbolStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DimensionSymbolStyle");
      ds.field("heads_override", &self.heads_override());
      ds.field("center_mark_type", &self.center_mark_type());
      ds.field("center_mark_size", &self.center_mark_size());
      ds.finish()
  }
}
pub enum DucDimensionStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucDimensionStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucDimensionStyle<'a> {
  type Inner = DucDimensionStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucDimensionStyle<'a> {
  pub const VT_DIM_LINE: flatbuffers::VOffsetT = 4;
  pub const VT_EXT_LINE: flatbuffers::VOffsetT = 6;
  pub const VT_TEXT_STYLE: flatbuffers::VOffsetT = 8;
  pub const VT_SYMBOLS: flatbuffers::VOffsetT = 10;
  pub const VT_TOLERANCE: flatbuffers::VOffsetT = 12;
  pub const VT_FIT: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucDimensionStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucDimensionStyleArgs<'args>
  ) -> flatbuffers::WIPOffset<DucDimensionStyle<'bldr>> {
    let mut builder = DucDimensionStyleBuilder::new(_fbb);
    if let Some(x) = args.fit { builder.add_fit(x); }
    if let Some(x) = args.tolerance { builder.add_tolerance(x); }
    if let Some(x) = args.symbols { builder.add_symbols(x); }
    if let Some(x) = args.text_style { builder.add_text_style(x); }
    if let Some(x) = args.ext_line { builder.add_ext_line(x); }
    if let Some(x) = args.dim_line { builder.add_dim_line(x); }
    builder.finish()
  }


  #[inline]
  pub fn dim_line(&self) -> Option<DimensionLineStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DimensionLineStyle>>(DucDimensionStyle::VT_DIM_LINE, None)}
  }
  #[inline]
  pub fn ext_line(&self) -> Option<DimensionExtLineStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DimensionExtLineStyle>>(DucDimensionStyle::VT_EXT_LINE, None)}
  }
  #[inline]
  pub fn text_style(&self) -> Option<DucTextStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucTextStyle>>(DucDimensionStyle::VT_TEXT_STYLE, None)}
  }
  #[inline]
  pub fn symbols(&self) -> Option<DimensionSymbolStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DimensionSymbolStyle>>(DucDimensionStyle::VT_SYMBOLS, None)}
  }
  #[inline]
  pub fn tolerance(&self) -> Option<DimensionToleranceStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DimensionToleranceStyle>>(DucDimensionStyle::VT_TOLERANCE, None)}
  }
  #[inline]
  pub fn fit(&self) -> Option<DimensionFitStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DimensionFitStyle>>(DucDimensionStyle::VT_FIT, None)}
  }
}

impl flatbuffers::Verifiable for DucDimensionStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<DimensionLineStyle>>("dim_line", Self::VT_DIM_LINE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DimensionExtLineStyle>>("ext_line", Self::VT_EXT_LINE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucTextStyle>>("text_style", Self::VT_TEXT_STYLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DimensionSymbolStyle>>("symbols", Self::VT_SYMBOLS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DimensionToleranceStyle>>("tolerance", Self::VT_TOLERANCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DimensionFitStyle>>("fit", Self::VT_FIT, false)?
     .finish();
    Ok(())
  }
}
pub struct DucDimensionStyleArgs<'a> {
    pub dim_line: Option<flatbuffers::WIPOffset<DimensionLineStyle<'a>>>,
    pub ext_line: Option<flatbuffers::WIPOffset<DimensionExtLineStyle<'a>>>,
    pub text_style: Option<flatbuffers::WIPOffset<DucTextStyle<'a>>>,
    pub symbols: Option<flatbuffers::WIPOffset<DimensionSymbolStyle<'a>>>,
    pub tolerance: Option<flatbuffers::WIPOffset<DimensionToleranceStyle<'a>>>,
    pub fit: Option<flatbuffers::WIPOffset<DimensionFitStyle<'a>>>,
}
impl<'a> Default for DucDimensionStyleArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucDimensionStyleArgs {
      dim_line: None,
      ext_line: None,
      text_style: None,
      symbols: None,
      tolerance: None,
      fit: None,
    }
  }
}

pub struct DucDimensionStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucDimensionStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_dim_line(&mut self, dim_line: flatbuffers::WIPOffset<DimensionLineStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DimensionLineStyle>>(DucDimensionStyle::VT_DIM_LINE, dim_line);
  }
  #[inline]
  pub fn add_ext_line(&mut self, ext_line: flatbuffers::WIPOffset<DimensionExtLineStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DimensionExtLineStyle>>(DucDimensionStyle::VT_EXT_LINE, ext_line);
  }
  #[inline]
  pub fn add_text_style(&mut self, text_style: flatbuffers::WIPOffset<DucTextStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucTextStyle>>(DucDimensionStyle::VT_TEXT_STYLE, text_style);
  }
  #[inline]
  pub fn add_symbols(&mut self, symbols: flatbuffers::WIPOffset<DimensionSymbolStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DimensionSymbolStyle>>(DucDimensionStyle::VT_SYMBOLS, symbols);
  }
  #[inline]
  pub fn add_tolerance(&mut self, tolerance: flatbuffers::WIPOffset<DimensionToleranceStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DimensionToleranceStyle>>(DucDimensionStyle::VT_TOLERANCE, tolerance);
  }
  #[inline]
  pub fn add_fit(&mut self, fit: flatbuffers::WIPOffset<DimensionFitStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DimensionFitStyle>>(DucDimensionStyle::VT_FIT, fit);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucDimensionStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucDimensionStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucDimensionStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucDimensionStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucDimensionStyle");
      ds.field("dim_line", &self.dim_line());
      ds.field("ext_line", &self.ext_line());
      ds.field("text_style", &self.text_style());
      ds.field("symbols", &self.symbols());
      ds.field("tolerance", &self.tolerance());
      ds.field("fit", &self.fit());
      ds.finish()
  }
}
pub enum FCFLayoutStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FCFLayoutStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FCFLayoutStyle<'a> {
  type Inner = FCFLayoutStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> FCFLayoutStyle<'a> {
  pub const VT_PADDING: flatbuffers::VOffsetT = 4;
  pub const VT_SEGMENT_SPACING: flatbuffers::VOffsetT = 6;
  pub const VT_ROW_SPACING: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FCFLayoutStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FCFLayoutStyleArgs
  ) -> flatbuffers::WIPOffset<FCFLayoutStyle<'bldr>> {
    let mut builder = FCFLayoutStyleBuilder::new(_fbb);
    builder.add_row_spacing(args.row_spacing);
    builder.add_segment_spacing(args.segment_spacing);
    builder.add_padding(args.padding);
    builder.finish()
  }


  #[inline]
  pub fn padding(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(FCFLayoutStyle::VT_PADDING, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn segment_spacing(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(FCFLayoutStyle::VT_SEGMENT_SPACING, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn row_spacing(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(FCFLayoutStyle::VT_ROW_SPACING, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for FCFLayoutStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("padding", Self::VT_PADDING, false)?
     .visit_field::<f64>("segment_spacing", Self::VT_SEGMENT_SPACING, false)?
     .visit_field::<f64>("row_spacing", Self::VT_ROW_SPACING, false)?
     .finish();
    Ok(())
  }
}
pub struct FCFLayoutStyleArgs {
    pub padding: f64,
    pub segment_spacing: f64,
    pub row_spacing: f64,
}
impl<'a> Default for FCFLayoutStyleArgs {
  #[inline]
  fn default() -> Self {
    FCFLayoutStyleArgs {
      padding: 0.0,
      segment_spacing: 0.0,
      row_spacing: 0.0,
    }
  }
}

pub struct FCFLayoutStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FCFLayoutStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_padding(&mut self, padding: f64) {
    self.fbb_.push_slot::<f64>(FCFLayoutStyle::VT_PADDING, padding, 0.0);
  }
  #[inline]
  pub fn add_segment_spacing(&mut self, segment_spacing: f64) {
    self.fbb_.push_slot::<f64>(FCFLayoutStyle::VT_SEGMENT_SPACING, segment_spacing, 0.0);
  }
  #[inline]
  pub fn add_row_spacing(&mut self, row_spacing: f64) {
    self.fbb_.push_slot::<f64>(FCFLayoutStyle::VT_ROW_SPACING, row_spacing, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FCFLayoutStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FCFLayoutStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FCFLayoutStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FCFLayoutStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FCFLayoutStyle");
      ds.field("padding", &self.padding());
      ds.field("segment_spacing", &self.segment_spacing());
      ds.field("row_spacing", &self.row_spacing());
      ds.finish()
  }
}
pub enum FCFSymbolStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FCFSymbolStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FCFSymbolStyle<'a> {
  type Inner = FCFSymbolStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> FCFSymbolStyle<'a> {
  pub const VT_SCALE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FCFSymbolStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FCFSymbolStyleArgs
  ) -> flatbuffers::WIPOffset<FCFSymbolStyle<'bldr>> {
    let mut builder = FCFSymbolStyleBuilder::new(_fbb);
    builder.add_scale(args.scale);
    builder.finish()
  }


  #[inline]
  pub fn scale(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(FCFSymbolStyle::VT_SCALE, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for FCFSymbolStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("scale", Self::VT_SCALE, false)?
     .finish();
    Ok(())
  }
}
pub struct FCFSymbolStyleArgs {
    pub scale: f32,
}
impl<'a> Default for FCFSymbolStyleArgs {
  #[inline]
  fn default() -> Self {
    FCFSymbolStyleArgs {
      scale: 0.0,
    }
  }
}

pub struct FCFSymbolStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FCFSymbolStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_scale(&mut self, scale: f32) {
    self.fbb_.push_slot::<f32>(FCFSymbolStyle::VT_SCALE, scale, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FCFSymbolStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FCFSymbolStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FCFSymbolStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FCFSymbolStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FCFSymbolStyle");
      ds.field("scale", &self.scale());
      ds.finish()
  }
}
pub enum FCFDatumStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FCFDatumStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FCFDatumStyle<'a> {
  type Inner = FCFDatumStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> FCFDatumStyle<'a> {
  pub const VT_BRACKET_STYLE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FCFDatumStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FCFDatumStyleArgs
  ) -> flatbuffers::WIPOffset<FCFDatumStyle<'bldr>> {
    let mut builder = FCFDatumStyleBuilder::new(_fbb);
    if let Some(x) = args.bracket_style { builder.add_bracket_style(x); }
    builder.finish()
  }


  #[inline]
  pub fn bracket_style(&self) -> Option<DATUM_BRACKET_STYLE> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DATUM_BRACKET_STYLE>(FCFDatumStyle::VT_BRACKET_STYLE, None)}
  }
}

impl flatbuffers::Verifiable for FCFDatumStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<DATUM_BRACKET_STYLE>("bracket_style", Self::VT_BRACKET_STYLE, false)?
     .finish();
    Ok(())
  }
}
pub struct FCFDatumStyleArgs {
    pub bracket_style: Option<DATUM_BRACKET_STYLE>,
}
impl<'a> Default for FCFDatumStyleArgs {
  #[inline]
  fn default() -> Self {
    FCFDatumStyleArgs {
      bracket_style: None,
    }
  }
}

pub struct FCFDatumStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FCFDatumStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_bracket_style(&mut self, bracket_style: DATUM_BRACKET_STYLE) {
    self.fbb_.push_slot_always::<DATUM_BRACKET_STYLE>(FCFDatumStyle::VT_BRACKET_STYLE, bracket_style);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FCFDatumStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FCFDatumStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FCFDatumStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FCFDatumStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FCFDatumStyle");
      ds.field("bracket_style", &self.bracket_style());
      ds.finish()
  }
}
pub enum DucFeatureControlFrameStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucFeatureControlFrameStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucFeatureControlFrameStyle<'a> {
  type Inner = DucFeatureControlFrameStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucFeatureControlFrameStyle<'a> {
  pub const VT_TEXT_STYLE: flatbuffers::VOffsetT = 6;
  pub const VT_LAYOUT: flatbuffers::VOffsetT = 8;
  pub const VT_SYMBOLS: flatbuffers::VOffsetT = 10;
  pub const VT_DATUM_STYLE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucFeatureControlFrameStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucFeatureControlFrameStyleArgs<'args>
  ) -> flatbuffers::WIPOffset<DucFeatureControlFrameStyle<'bldr>> {
    let mut builder = DucFeatureControlFrameStyleBuilder::new(_fbb);
    if let Some(x) = args.datum_style { builder.add_datum_style(x); }
    if let Some(x) = args.symbols { builder.add_symbols(x); }
    if let Some(x) = args.layout { builder.add_layout(x); }
    if let Some(x) = args.text_style { builder.add_text_style(x); }
    builder.finish()
  }


  #[inline]
  pub fn text_style(&self) -> Option<DucTextStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucTextStyle>>(DucFeatureControlFrameStyle::VT_TEXT_STYLE, None)}
  }
  #[inline]
  pub fn layout(&self) -> Option<FCFLayoutStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<FCFLayoutStyle>>(DucFeatureControlFrameStyle::VT_LAYOUT, None)}
  }
  #[inline]
  pub fn symbols(&self) -> Option<FCFSymbolStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<FCFSymbolStyle>>(DucFeatureControlFrameStyle::VT_SYMBOLS, None)}
  }
  #[inline]
  pub fn datum_style(&self) -> Option<FCFDatumStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<FCFDatumStyle>>(DucFeatureControlFrameStyle::VT_DATUM_STYLE, None)}
  }
}

impl flatbuffers::Verifiable for DucFeatureControlFrameStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucTextStyle>>("text_style", Self::VT_TEXT_STYLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<FCFLayoutStyle>>("layout", Self::VT_LAYOUT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<FCFSymbolStyle>>("symbols", Self::VT_SYMBOLS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<FCFDatumStyle>>("datum_style", Self::VT_DATUM_STYLE, false)?
     .finish();
    Ok(())
  }
}
pub struct DucFeatureControlFrameStyleArgs<'a> {
    pub text_style: Option<flatbuffers::WIPOffset<DucTextStyle<'a>>>,
    pub layout: Option<flatbuffers::WIPOffset<FCFLayoutStyle<'a>>>,
    pub symbols: Option<flatbuffers::WIPOffset<FCFSymbolStyle<'a>>>,
    pub datum_style: Option<flatbuffers::WIPOffset<FCFDatumStyle<'a>>>,
}
impl<'a> Default for DucFeatureControlFrameStyleArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucFeatureControlFrameStyleArgs {
      text_style: None,
      layout: None,
      symbols: None,
      datum_style: None,
    }
  }
}

pub struct DucFeatureControlFrameStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucFeatureControlFrameStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_text_style(&mut self, text_style: flatbuffers::WIPOffset<DucTextStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucTextStyle>>(DucFeatureControlFrameStyle::VT_TEXT_STYLE, text_style);
  }
  #[inline]
  pub fn add_layout(&mut self, layout: flatbuffers::WIPOffset<FCFLayoutStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FCFLayoutStyle>>(DucFeatureControlFrameStyle::VT_LAYOUT, layout);
  }
  #[inline]
  pub fn add_symbols(&mut self, symbols: flatbuffers::WIPOffset<FCFSymbolStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FCFSymbolStyle>>(DucFeatureControlFrameStyle::VT_SYMBOLS, symbols);
  }
  #[inline]
  pub fn add_datum_style(&mut self, datum_style: flatbuffers::WIPOffset<FCFDatumStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FCFDatumStyle>>(DucFeatureControlFrameStyle::VT_DATUM_STYLE, datum_style);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucFeatureControlFrameStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucFeatureControlFrameStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucFeatureControlFrameStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucFeatureControlFrameStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucFeatureControlFrameStyle");
      ds.field("text_style", &self.text_style());
      ds.field("layout", &self.layout());
      ds.field("symbols", &self.symbols());
      ds.field("datum_style", &self.datum_style());
      ds.finish()
  }
}
pub enum ParagraphFormattingOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ParagraphFormatting<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ParagraphFormatting<'a> {
  type Inner = ParagraphFormatting<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ParagraphFormatting<'a> {
  pub const VT_FIRST_LINE_INDENT: flatbuffers::VOffsetT = 4;
  pub const VT_HANGING_INDENT: flatbuffers::VOffsetT = 6;
  pub const VT_LEFT_INDENT: flatbuffers::VOffsetT = 8;
  pub const VT_RIGHT_INDENT: flatbuffers::VOffsetT = 10;
  pub const VT_SPACE_BEFORE: flatbuffers::VOffsetT = 12;
  pub const VT_SPACE_AFTER: flatbuffers::VOffsetT = 14;
  pub const VT_TAB_STOPS: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ParagraphFormatting { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ParagraphFormattingArgs<'args>
  ) -> flatbuffers::WIPOffset<ParagraphFormatting<'bldr>> {
    let mut builder = ParagraphFormattingBuilder::new(_fbb);
    builder.add_space_after(args.space_after);
    builder.add_space_before(args.space_before);
    builder.add_right_indent(args.right_indent);
    builder.add_left_indent(args.left_indent);
    builder.add_hanging_indent(args.hanging_indent);
    builder.add_first_line_indent(args.first_line_indent);
    if let Some(x) = args.tab_stops { builder.add_tab_stops(x); }
    builder.finish()
  }


  #[inline]
  pub fn first_line_indent(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ParagraphFormatting::VT_FIRST_LINE_INDENT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn hanging_indent(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ParagraphFormatting::VT_HANGING_INDENT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn left_indent(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ParagraphFormatting::VT_LEFT_INDENT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn right_indent(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ParagraphFormatting::VT_RIGHT_INDENT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn space_before(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ParagraphFormatting::VT_SPACE_BEFORE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn space_after(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ParagraphFormatting::VT_SPACE_AFTER, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn tab_stops(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(ParagraphFormatting::VT_TAB_STOPS, None)}
  }
}

impl flatbuffers::Verifiable for ParagraphFormatting<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("first_line_indent", Self::VT_FIRST_LINE_INDENT, false)?
     .visit_field::<f64>("hanging_indent", Self::VT_HANGING_INDENT, false)?
     .visit_field::<f64>("left_indent", Self::VT_LEFT_INDENT, false)?
     .visit_field::<f64>("right_indent", Self::VT_RIGHT_INDENT, false)?
     .visit_field::<f64>("space_before", Self::VT_SPACE_BEFORE, false)?
     .visit_field::<f64>("space_after", Self::VT_SPACE_AFTER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("tab_stops", Self::VT_TAB_STOPS, false)?
     .finish();
    Ok(())
  }
}
pub struct ParagraphFormattingArgs<'a> {
    pub first_line_indent: f64,
    pub hanging_indent: f64,
    pub left_indent: f64,
    pub right_indent: f64,
    pub space_before: f64,
    pub space_after: f64,
    pub tab_stops: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
}
impl<'a> Default for ParagraphFormattingArgs<'a> {
  #[inline]
  fn default() -> Self {
    ParagraphFormattingArgs {
      first_line_indent: 0.0,
      hanging_indent: 0.0,
      left_indent: 0.0,
      right_indent: 0.0,
      space_before: 0.0,
      space_after: 0.0,
      tab_stops: None,
    }
  }
}

pub struct ParagraphFormattingBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ParagraphFormattingBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_first_line_indent(&mut self, first_line_indent: f64) {
    self.fbb_.push_slot::<f64>(ParagraphFormatting::VT_FIRST_LINE_INDENT, first_line_indent, 0.0);
  }
  #[inline]
  pub fn add_hanging_indent(&mut self, hanging_indent: f64) {
    self.fbb_.push_slot::<f64>(ParagraphFormatting::VT_HANGING_INDENT, hanging_indent, 0.0);
  }
  #[inline]
  pub fn add_left_indent(&mut self, left_indent: f64) {
    self.fbb_.push_slot::<f64>(ParagraphFormatting::VT_LEFT_INDENT, left_indent, 0.0);
  }
  #[inline]
  pub fn add_right_indent(&mut self, right_indent: f64) {
    self.fbb_.push_slot::<f64>(ParagraphFormatting::VT_RIGHT_INDENT, right_indent, 0.0);
  }
  #[inline]
  pub fn add_space_before(&mut self, space_before: f64) {
    self.fbb_.push_slot::<f64>(ParagraphFormatting::VT_SPACE_BEFORE, space_before, 0.0);
  }
  #[inline]
  pub fn add_space_after(&mut self, space_after: f64) {
    self.fbb_.push_slot::<f64>(ParagraphFormatting::VT_SPACE_AFTER, space_after, 0.0);
  }
  #[inline]
  pub fn add_tab_stops(&mut self, tab_stops: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ParagraphFormatting::VT_TAB_STOPS, tab_stops);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ParagraphFormattingBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ParagraphFormattingBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ParagraphFormatting<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ParagraphFormatting<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ParagraphFormatting");
      ds.field("first_line_indent", &self.first_line_indent());
      ds.field("hanging_indent", &self.hanging_indent());
      ds.field("left_indent", &self.left_indent());
      ds.field("right_indent", &self.right_indent());
      ds.field("space_before", &self.space_before());
      ds.field("space_after", &self.space_after());
      ds.field("tab_stops", &self.tab_stops());
      ds.finish()
  }
}
pub enum StackFormatPropertiesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct StackFormatProperties<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StackFormatProperties<'a> {
  type Inner = StackFormatProperties<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> StackFormatProperties<'a> {
  pub const VT_UPPER_SCALE: flatbuffers::VOffsetT = 4;
  pub const VT_LOWER_SCALE: flatbuffers::VOffsetT = 6;
  pub const VT_ALIGNMENT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StackFormatProperties { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StackFormatPropertiesArgs
  ) -> flatbuffers::WIPOffset<StackFormatProperties<'bldr>> {
    let mut builder = StackFormatPropertiesBuilder::new(_fbb);
    builder.add_lower_scale(args.lower_scale);
    builder.add_upper_scale(args.upper_scale);
    if let Some(x) = args.alignment { builder.add_alignment(x); }
    builder.finish()
  }


  #[inline]
  pub fn upper_scale(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StackFormatProperties::VT_UPPER_SCALE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn lower_scale(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StackFormatProperties::VT_LOWER_SCALE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn alignment(&self) -> Option<STACKED_TEXT_ALIGN> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<STACKED_TEXT_ALIGN>(StackFormatProperties::VT_ALIGNMENT, None)}
  }
}

impl flatbuffers::Verifiable for StackFormatProperties<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("upper_scale", Self::VT_UPPER_SCALE, false)?
     .visit_field::<f64>("lower_scale", Self::VT_LOWER_SCALE, false)?
     .visit_field::<STACKED_TEXT_ALIGN>("alignment", Self::VT_ALIGNMENT, false)?
     .finish();
    Ok(())
  }
}
pub struct StackFormatPropertiesArgs {
    pub upper_scale: f64,
    pub lower_scale: f64,
    pub alignment: Option<STACKED_TEXT_ALIGN>,
}
impl<'a> Default for StackFormatPropertiesArgs {
  #[inline]
  fn default() -> Self {
    StackFormatPropertiesArgs {
      upper_scale: 0.0,
      lower_scale: 0.0,
      alignment: None,
    }
  }
}

pub struct StackFormatPropertiesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StackFormatPropertiesBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_upper_scale(&mut self, upper_scale: f64) {
    self.fbb_.push_slot::<f64>(StackFormatProperties::VT_UPPER_SCALE, upper_scale, 0.0);
  }
  #[inline]
  pub fn add_lower_scale(&mut self, lower_scale: f64) {
    self.fbb_.push_slot::<f64>(StackFormatProperties::VT_LOWER_SCALE, lower_scale, 0.0);
  }
  #[inline]
  pub fn add_alignment(&mut self, alignment: STACKED_TEXT_ALIGN) {
    self.fbb_.push_slot_always::<STACKED_TEXT_ALIGN>(StackFormatProperties::VT_ALIGNMENT, alignment);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StackFormatPropertiesBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StackFormatPropertiesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StackFormatProperties<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StackFormatProperties<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StackFormatProperties");
      ds.field("upper_scale", &self.upper_scale());
      ds.field("lower_scale", &self.lower_scale());
      ds.field("alignment", &self.alignment());
      ds.finish()
  }
}
pub enum StackFormatOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct StackFormat<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StackFormat<'a> {
  type Inner = StackFormat<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> StackFormat<'a> {
  pub const VT_AUTO_STACK: flatbuffers::VOffsetT = 4;
  pub const VT_STACK_CHARS: flatbuffers::VOffsetT = 6;
  pub const VT_PROPERTIES: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StackFormat { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StackFormatArgs<'args>
  ) -> flatbuffers::WIPOffset<StackFormat<'bldr>> {
    let mut builder = StackFormatBuilder::new(_fbb);
    if let Some(x) = args.properties { builder.add_properties(x); }
    if let Some(x) = args.stack_chars { builder.add_stack_chars(x); }
    builder.add_auto_stack(args.auto_stack);
    builder.finish()
  }


  #[inline]
  pub fn auto_stack(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(StackFormat::VT_AUTO_STACK, Some(false)).unwrap()}
  }
  #[inline]
  pub fn stack_chars(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(StackFormat::VT_STACK_CHARS, None)}
  }
  #[inline]
  pub fn properties(&self) -> Option<StackFormatProperties<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<StackFormatProperties>>(StackFormat::VT_PROPERTIES, None)}
  }
}

impl flatbuffers::Verifiable for StackFormat<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("auto_stack", Self::VT_AUTO_STACK, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("stack_chars", Self::VT_STACK_CHARS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<StackFormatProperties>>("properties", Self::VT_PROPERTIES, false)?
     .finish();
    Ok(())
  }
}
pub struct StackFormatArgs<'a> {
    pub auto_stack: bool,
    pub stack_chars: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub properties: Option<flatbuffers::WIPOffset<StackFormatProperties<'a>>>,
}
impl<'a> Default for StackFormatArgs<'a> {
  #[inline]
  fn default() -> Self {
    StackFormatArgs {
      auto_stack: false,
      stack_chars: None,
      properties: None,
    }
  }
}

pub struct StackFormatBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StackFormatBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_auto_stack(&mut self, auto_stack: bool) {
    self.fbb_.push_slot::<bool>(StackFormat::VT_AUTO_STACK, auto_stack, false);
  }
  #[inline]
  pub fn add_stack_chars(&mut self, stack_chars: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StackFormat::VT_STACK_CHARS, stack_chars);
  }
  #[inline]
  pub fn add_properties(&mut self, properties: flatbuffers::WIPOffset<StackFormatProperties<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<StackFormatProperties>>(StackFormat::VT_PROPERTIES, properties);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StackFormatBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StackFormatBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StackFormat<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StackFormat<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StackFormat");
      ds.field("auto_stack", &self.auto_stack());
      ds.field("stack_chars", &self.stack_chars());
      ds.field("properties", &self.properties());
      ds.finish()
  }
}
pub enum DucDocStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucDocStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucDocStyle<'a> {
  type Inner = DucDocStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucDocStyle<'a> {
  pub const VT_TEXT_STYLE: flatbuffers::VOffsetT = 4;
  pub const VT_PARAGRAPH: flatbuffers::VOffsetT = 6;
  pub const VT_STACK_FORMAT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucDocStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucDocStyleArgs<'args>
  ) -> flatbuffers::WIPOffset<DucDocStyle<'bldr>> {
    let mut builder = DucDocStyleBuilder::new(_fbb);
    if let Some(x) = args.stack_format { builder.add_stack_format(x); }
    if let Some(x) = args.paragraph { builder.add_paragraph(x); }
    if let Some(x) = args.text_style { builder.add_text_style(x); }
    builder.finish()
  }


  #[inline]
  pub fn text_style(&self) -> Option<DucTextStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucTextStyle>>(DucDocStyle::VT_TEXT_STYLE, None)}
  }
  #[inline]
  pub fn paragraph(&self) -> Option<ParagraphFormatting<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ParagraphFormatting>>(DucDocStyle::VT_PARAGRAPH, None)}
  }
  #[inline]
  pub fn stack_format(&self) -> Option<StackFormat<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<StackFormat>>(DucDocStyle::VT_STACK_FORMAT, None)}
  }
}

impl flatbuffers::Verifiable for DucDocStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucTextStyle>>("text_style", Self::VT_TEXT_STYLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ParagraphFormatting>>("paragraph", Self::VT_PARAGRAPH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<StackFormat>>("stack_format", Self::VT_STACK_FORMAT, false)?
     .finish();
    Ok(())
  }
}
pub struct DucDocStyleArgs<'a> {
    pub text_style: Option<flatbuffers::WIPOffset<DucTextStyle<'a>>>,
    pub paragraph: Option<flatbuffers::WIPOffset<ParagraphFormatting<'a>>>,
    pub stack_format: Option<flatbuffers::WIPOffset<StackFormat<'a>>>,
}
impl<'a> Default for DucDocStyleArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucDocStyleArgs {
      text_style: None,
      paragraph: None,
      stack_format: None,
    }
  }
}

pub struct DucDocStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucDocStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_text_style(&mut self, text_style: flatbuffers::WIPOffset<DucTextStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucTextStyle>>(DucDocStyle::VT_TEXT_STYLE, text_style);
  }
  #[inline]
  pub fn add_paragraph(&mut self, paragraph: flatbuffers::WIPOffset<ParagraphFormatting<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ParagraphFormatting>>(DucDocStyle::VT_PARAGRAPH, paragraph);
  }
  #[inline]
  pub fn add_stack_format(&mut self, stack_format: flatbuffers::WIPOffset<StackFormat<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<StackFormat>>(DucDocStyle::VT_STACK_FORMAT, stack_format);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucDocStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucDocStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucDocStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucDocStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucDocStyle");
      ds.field("text_style", &self.text_style());
      ds.field("paragraph", &self.paragraph());
      ds.field("stack_format", &self.stack_format());
      ds.finish()
  }
}
pub enum DucViewportStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucViewportStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucViewportStyle<'a> {
  type Inner = DucViewportStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucViewportStyle<'a> {
  pub const VT_SCALE_INDICATOR_VISIBLE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucViewportStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucViewportStyleArgs
  ) -> flatbuffers::WIPOffset<DucViewportStyle<'bldr>> {
    let mut builder = DucViewportStyleBuilder::new(_fbb);
    builder.add_scale_indicator_visible(args.scale_indicator_visible);
    builder.finish()
  }


  #[inline]
  pub fn scale_indicator_visible(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucViewportStyle::VT_SCALE_INDICATOR_VISIBLE, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DucViewportStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("scale_indicator_visible", Self::VT_SCALE_INDICATOR_VISIBLE, false)?
     .finish();
    Ok(())
  }
}
pub struct DucViewportStyleArgs {
    pub scale_indicator_visible: bool,
}
impl<'a> Default for DucViewportStyleArgs {
  #[inline]
  fn default() -> Self {
    DucViewportStyleArgs {
      scale_indicator_visible: false,
    }
  }
}

pub struct DucViewportStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucViewportStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_scale_indicator_visible(&mut self, scale_indicator_visible: bool) {
    self.fbb_.push_slot::<bool>(DucViewportStyle::VT_SCALE_INDICATOR_VISIBLE, scale_indicator_visible, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucViewportStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucViewportStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucViewportStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucViewportStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucViewportStyle");
      ds.field("scale_indicator_visible", &self.scale_indicator_visible());
      ds.finish()
  }
}
pub enum DucPlotStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucPlotStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucPlotStyle<'a> {
  type Inner = DucPlotStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucPlotStyle<'a> {

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucPlotStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucPlotStyleArgs
  ) -> flatbuffers::WIPOffset<DucPlotStyle<'bldr>> {
    let mut builder = DucPlotStyleBuilder::new(_fbb);
    builder.finish()
  }


}

impl flatbuffers::Verifiable for DucPlotStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .finish();
    Ok(())
  }
}
pub struct DucPlotStyleArgs {
}
impl<'a> Default for DucPlotStyleArgs {
  #[inline]
  fn default() -> Self {
    DucPlotStyleArgs {
    }
  }
}

pub struct DucPlotStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucPlotStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucPlotStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucPlotStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucPlotStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucPlotStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucPlotStyle");
      ds.finish()
  }
}
pub enum DucXRayStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucXRayStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucXRayStyle<'a> {
  type Inner = DucXRayStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucXRayStyle<'a> {
  pub const VT_COLOR: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucXRayStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucXRayStyleArgs<'args>
  ) -> flatbuffers::WIPOffset<DucXRayStyle<'bldr>> {
    let mut builder = DucXRayStyleBuilder::new(_fbb);
    if let Some(x) = args.color { builder.add_color(x); }
    builder.finish()
  }


  #[inline]
  pub fn color(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucXRayStyle::VT_COLOR, None)}
  }
}

impl flatbuffers::Verifiable for DucXRayStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("color", Self::VT_COLOR, false)?
     .finish();
    Ok(())
  }
}
pub struct DucXRayStyleArgs<'a> {
    pub color: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DucXRayStyleArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucXRayStyleArgs {
      color: None,
    }
  }
}

pub struct DucXRayStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucXRayStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_color(&mut self, color: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucXRayStyle::VT_COLOR, color);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucXRayStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucXRayStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucXRayStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucXRayStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucXRayStyle");
      ds.field("color", &self.color());
      ds.finish()
  }
}
pub enum DucRectangleElementOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucRectangleElement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucRectangleElement<'a> {
  type Inner = DucRectangleElement<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucRectangleElement<'a> {
  pub const VT_BASE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucRectangleElement { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucRectangleElementArgs<'args>
  ) -> flatbuffers::WIPOffset<DucRectangleElement<'bldr>> {
    let mut builder = DucRectangleElementBuilder::new(_fbb);
    if let Some(x) = args.base { builder.add_base(x); }
    builder.finish()
  }


  #[inline]
  pub fn base(&self) -> Option<_DucElementBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<_DucElementBase>>(DucRectangleElement::VT_BASE, None)}
  }
}

impl flatbuffers::Verifiable for DucRectangleElement<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<_DucElementBase>>("base", Self::VT_BASE, false)?
     .finish();
    Ok(())
  }
}
pub struct DucRectangleElementArgs<'a> {
    pub base: Option<flatbuffers::WIPOffset<_DucElementBase<'a>>>,
}
impl<'a> Default for DucRectangleElementArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucRectangleElementArgs {
      base: None,
    }
  }
}

pub struct DucRectangleElementBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucRectangleElementBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_base(&mut self, base: flatbuffers::WIPOffset<_DucElementBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_DucElementBase>>(DucRectangleElement::VT_BASE, base);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucRectangleElementBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucRectangleElementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucRectangleElement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucRectangleElement<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucRectangleElement");
      ds.field("base", &self.base());
      ds.finish()
  }
}
pub enum DucPolygonElementOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucPolygonElement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucPolygonElement<'a> {
  type Inner = DucPolygonElement<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucPolygonElement<'a> {
  pub const VT_BASE: flatbuffers::VOffsetT = 4;
  pub const VT_SIDES: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucPolygonElement { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucPolygonElementArgs<'args>
  ) -> flatbuffers::WIPOffset<DucPolygonElement<'bldr>> {
    let mut builder = DucPolygonElementBuilder::new(_fbb);
    builder.add_sides(args.sides);
    if let Some(x) = args.base { builder.add_base(x); }
    builder.finish()
  }


  #[inline]
  pub fn base(&self) -> Option<_DucElementBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<_DucElementBase>>(DucPolygonElement::VT_BASE, None)}
  }
  #[inline]
  pub fn sides(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DucPolygonElement::VT_SIDES, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DucPolygonElement<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<_DucElementBase>>("base", Self::VT_BASE, false)?
     .visit_field::<i32>("sides", Self::VT_SIDES, false)?
     .finish();
    Ok(())
  }
}
pub struct DucPolygonElementArgs<'a> {
    pub base: Option<flatbuffers::WIPOffset<_DucElementBase<'a>>>,
    pub sides: i32,
}
impl<'a> Default for DucPolygonElementArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucPolygonElementArgs {
      base: None,
      sides: 0,
    }
  }
}

pub struct DucPolygonElementBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucPolygonElementBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_base(&mut self, base: flatbuffers::WIPOffset<_DucElementBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_DucElementBase>>(DucPolygonElement::VT_BASE, base);
  }
  #[inline]
  pub fn add_sides(&mut self, sides: i32) {
    self.fbb_.push_slot::<i32>(DucPolygonElement::VT_SIDES, sides, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucPolygonElementBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucPolygonElementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucPolygonElement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucPolygonElement<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucPolygonElement");
      ds.field("base", &self.base());
      ds.field("sides", &self.sides());
      ds.finish()
  }
}
pub enum DucEllipseElementOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucEllipseElement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucEllipseElement<'a> {
  type Inner = DucEllipseElement<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucEllipseElement<'a> {
  pub const VT_BASE: flatbuffers::VOffsetT = 4;
  pub const VT_RATIO: flatbuffers::VOffsetT = 6;
  pub const VT_START_ANGLE: flatbuffers::VOffsetT = 8;
  pub const VT_END_ANGLE: flatbuffers::VOffsetT = 10;
  pub const VT_SHOW_AUX_CROSSHAIR: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucEllipseElement { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucEllipseElementArgs<'args>
  ) -> flatbuffers::WIPOffset<DucEllipseElement<'bldr>> {
    let mut builder = DucEllipseElementBuilder::new(_fbb);
    builder.add_end_angle(args.end_angle);
    builder.add_start_angle(args.start_angle);
    builder.add_ratio(args.ratio);
    if let Some(x) = args.base { builder.add_base(x); }
    builder.add_show_aux_crosshair(args.show_aux_crosshair);
    builder.finish()
  }


  #[inline]
  pub fn base(&self) -> Option<_DucElementBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<_DucElementBase>>(DucEllipseElement::VT_BASE, None)}
  }
  #[inline]
  pub fn ratio(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucEllipseElement::VT_RATIO, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn start_angle(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucEllipseElement::VT_START_ANGLE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn end_angle(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucEllipseElement::VT_END_ANGLE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn show_aux_crosshair(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucEllipseElement::VT_SHOW_AUX_CROSSHAIR, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DucEllipseElement<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<_DucElementBase>>("base", Self::VT_BASE, false)?
     .visit_field::<f32>("ratio", Self::VT_RATIO, false)?
     .visit_field::<f64>("start_angle", Self::VT_START_ANGLE, false)?
     .visit_field::<f64>("end_angle", Self::VT_END_ANGLE, false)?
     .visit_field::<bool>("show_aux_crosshair", Self::VT_SHOW_AUX_CROSSHAIR, false)?
     .finish();
    Ok(())
  }
}
pub struct DucEllipseElementArgs<'a> {
    pub base: Option<flatbuffers::WIPOffset<_DucElementBase<'a>>>,
    pub ratio: f32,
    pub start_angle: f64,
    pub end_angle: f64,
    pub show_aux_crosshair: bool,
}
impl<'a> Default for DucEllipseElementArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucEllipseElementArgs {
      base: None,
      ratio: 0.0,
      start_angle: 0.0,
      end_angle: 0.0,
      show_aux_crosshair: false,
    }
  }
}

pub struct DucEllipseElementBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucEllipseElementBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_base(&mut self, base: flatbuffers::WIPOffset<_DucElementBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_DucElementBase>>(DucEllipseElement::VT_BASE, base);
  }
  #[inline]
  pub fn add_ratio(&mut self, ratio: f32) {
    self.fbb_.push_slot::<f32>(DucEllipseElement::VT_RATIO, ratio, 0.0);
  }
  #[inline]
  pub fn add_start_angle(&mut self, start_angle: f64) {
    self.fbb_.push_slot::<f64>(DucEllipseElement::VT_START_ANGLE, start_angle, 0.0);
  }
  #[inline]
  pub fn add_end_angle(&mut self, end_angle: f64) {
    self.fbb_.push_slot::<f64>(DucEllipseElement::VT_END_ANGLE, end_angle, 0.0);
  }
  #[inline]
  pub fn add_show_aux_crosshair(&mut self, show_aux_crosshair: bool) {
    self.fbb_.push_slot::<bool>(DucEllipseElement::VT_SHOW_AUX_CROSSHAIR, show_aux_crosshair, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucEllipseElementBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucEllipseElementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucEllipseElement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucEllipseElement<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucEllipseElement");
      ds.field("base", &self.base());
      ds.field("ratio", &self.ratio());
      ds.field("start_angle", &self.start_angle());
      ds.field("end_angle", &self.end_angle());
      ds.field("show_aux_crosshair", &self.show_aux_crosshair());
      ds.finish()
  }
}
pub enum DucEmbeddableElementOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucEmbeddableElement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucEmbeddableElement<'a> {
  type Inner = DucEmbeddableElement<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucEmbeddableElement<'a> {
  pub const VT_BASE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucEmbeddableElement { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucEmbeddableElementArgs<'args>
  ) -> flatbuffers::WIPOffset<DucEmbeddableElement<'bldr>> {
    let mut builder = DucEmbeddableElementBuilder::new(_fbb);
    if let Some(x) = args.base { builder.add_base(x); }
    builder.finish()
  }


  #[inline]
  pub fn base(&self) -> Option<_DucElementBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<_DucElementBase>>(DucEmbeddableElement::VT_BASE, None)}
  }
}

impl flatbuffers::Verifiable for DucEmbeddableElement<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<_DucElementBase>>("base", Self::VT_BASE, false)?
     .finish();
    Ok(())
  }
}
pub struct DucEmbeddableElementArgs<'a> {
    pub base: Option<flatbuffers::WIPOffset<_DucElementBase<'a>>>,
}
impl<'a> Default for DucEmbeddableElementArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucEmbeddableElementArgs {
      base: None,
    }
  }
}

pub struct DucEmbeddableElementBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucEmbeddableElementBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_base(&mut self, base: flatbuffers::WIPOffset<_DucElementBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_DucElementBase>>(DucEmbeddableElement::VT_BASE, base);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucEmbeddableElementBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucEmbeddableElementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucEmbeddableElement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucEmbeddableElement<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucEmbeddableElement");
      ds.field("base", &self.base());
      ds.finish()
  }
}
pub enum DucPdfElementOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucPdfElement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucPdfElement<'a> {
  type Inner = DucPdfElement<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucPdfElement<'a> {
  pub const VT_BASE: flatbuffers::VOffsetT = 4;
  pub const VT_FILE_ID: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucPdfElement { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucPdfElementArgs<'args>
  ) -> flatbuffers::WIPOffset<DucPdfElement<'bldr>> {
    let mut builder = DucPdfElementBuilder::new(_fbb);
    if let Some(x) = args.file_id { builder.add_file_id(x); }
    if let Some(x) = args.base { builder.add_base(x); }
    builder.finish()
  }


  #[inline]
  pub fn base(&self) -> Option<_DucElementBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<_DucElementBase>>(DucPdfElement::VT_BASE, None)}
  }
  #[inline]
  pub fn file_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucPdfElement::VT_FILE_ID, None)}
  }
}

impl flatbuffers::Verifiable for DucPdfElement<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<_DucElementBase>>("base", Self::VT_BASE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("file_id", Self::VT_FILE_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct DucPdfElementArgs<'a> {
    pub base: Option<flatbuffers::WIPOffset<_DucElementBase<'a>>>,
    pub file_id: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DucPdfElementArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucPdfElementArgs {
      base: None,
      file_id: None,
    }
  }
}

pub struct DucPdfElementBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucPdfElementBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_base(&mut self, base: flatbuffers::WIPOffset<_DucElementBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_DucElementBase>>(DucPdfElement::VT_BASE, base);
  }
  #[inline]
  pub fn add_file_id(&mut self, file_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucPdfElement::VT_FILE_ID, file_id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucPdfElementBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucPdfElementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucPdfElement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucPdfElement<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucPdfElement");
      ds.field("base", &self.base());
      ds.field("file_id", &self.file_id());
      ds.finish()
  }
}
pub enum DucMermaidElementOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucMermaidElement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucMermaidElement<'a> {
  type Inner = DucMermaidElement<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucMermaidElement<'a> {
  pub const VT_BASE: flatbuffers::VOffsetT = 4;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 6;
  pub const VT_THEME: flatbuffers::VOffsetT = 8;
  pub const VT_SVG_PATH: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucMermaidElement { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucMermaidElementArgs<'args>
  ) -> flatbuffers::WIPOffset<DucMermaidElement<'bldr>> {
    let mut builder = DucMermaidElementBuilder::new(_fbb);
    if let Some(x) = args.svg_path { builder.add_svg_path(x); }
    if let Some(x) = args.theme { builder.add_theme(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.base { builder.add_base(x); }
    builder.finish()
  }


  #[inline]
  pub fn base(&self) -> Option<_DucElementBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<_DucElementBase>>(DucMermaidElement::VT_BASE, None)}
  }
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucMermaidElement::VT_SOURCE, None)}
  }
  #[inline]
  pub fn theme(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucMermaidElement::VT_THEME, None)}
  }
  #[inline]
  pub fn svg_path(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucMermaidElement::VT_SVG_PATH, None)}
  }
}

impl flatbuffers::Verifiable for DucMermaidElement<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<_DucElementBase>>("base", Self::VT_BASE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("theme", Self::VT_THEME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("svg_path", Self::VT_SVG_PATH, false)?
     .finish();
    Ok(())
  }
}
pub struct DucMermaidElementArgs<'a> {
    pub base: Option<flatbuffers::WIPOffset<_DucElementBase<'a>>>,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub theme: Option<flatbuffers::WIPOffset<&'a str>>,
    pub svg_path: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DucMermaidElementArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucMermaidElementArgs {
      base: None,
      source: None,
      theme: None,
      svg_path: None,
    }
  }
}

pub struct DucMermaidElementBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucMermaidElementBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_base(&mut self, base: flatbuffers::WIPOffset<_DucElementBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_DucElementBase>>(DucMermaidElement::VT_BASE, base);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucMermaidElement::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_theme(&mut self, theme: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucMermaidElement::VT_THEME, theme);
  }
  #[inline]
  pub fn add_svg_path(&mut self, svg_path: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucMermaidElement::VT_SVG_PATH, svg_path);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucMermaidElementBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucMermaidElementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucMermaidElement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucMermaidElement<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucMermaidElement");
      ds.field("base", &self.base());
      ds.field("source", &self.source());
      ds.field("theme", &self.theme());
      ds.field("svg_path", &self.svg_path());
      ds.finish()
  }
}
pub enum DucTableColumnOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucTableColumn<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucTableColumn<'a> {
  type Inner = DucTableColumn<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucTableColumn<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_WIDTH: flatbuffers::VOffsetT = 6;
  pub const VT_STYLE_OVERRIDES: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucTableColumn { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucTableColumnArgs<'args>
  ) -> flatbuffers::WIPOffset<DucTableColumn<'bldr>> {
    let mut builder = DucTableColumnBuilder::new(_fbb);
    builder.add_width(args.width);
    if let Some(x) = args.style_overrides { builder.add_style_overrides(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucTableColumn::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &DucTableColumn) -> bool {
    self.id() < o.id()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.id();
    key.cmp(val)
  }
  #[inline]
  pub fn width(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucTableColumn::VT_WIDTH, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn style_overrides(&self) -> Option<DucTableCellStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucTableCellStyle>>(DucTableColumn::VT_STYLE_OVERRIDES, None)}
  }
}

impl flatbuffers::Verifiable for DucTableColumn<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<f64>("width", Self::VT_WIDTH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucTableCellStyle>>("style_overrides", Self::VT_STYLE_OVERRIDES, false)?
     .finish();
    Ok(())
  }
}
pub struct DucTableColumnArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub width: f64,
    pub style_overrides: Option<flatbuffers::WIPOffset<DucTableCellStyle<'a>>>,
}
impl<'a> Default for DucTableColumnArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucTableColumnArgs {
      id: None, // required field
      width: 0.0,
      style_overrides: None,
    }
  }
}

pub struct DucTableColumnBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucTableColumnBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucTableColumn::VT_ID, id);
  }
  #[inline]
  pub fn add_width(&mut self, width: f64) {
    self.fbb_.push_slot::<f64>(DucTableColumn::VT_WIDTH, width, 0.0);
  }
  #[inline]
  pub fn add_style_overrides(&mut self, style_overrides: flatbuffers::WIPOffset<DucTableCellStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucTableCellStyle>>(DucTableColumn::VT_STYLE_OVERRIDES, style_overrides);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucTableColumnBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucTableColumnBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucTableColumn<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, DucTableColumn::VT_ID,"id");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucTableColumn<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucTableColumn");
      ds.field("id", &self.id());
      ds.field("width", &self.width());
      ds.field("style_overrides", &self.style_overrides());
      ds.finish()
  }
}
pub enum DucTableRowOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucTableRow<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucTableRow<'a> {
  type Inner = DucTableRow<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucTableRow<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_HEIGHT: flatbuffers::VOffsetT = 6;
  pub const VT_STYLE_OVERRIDES: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucTableRow { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucTableRowArgs<'args>
  ) -> flatbuffers::WIPOffset<DucTableRow<'bldr>> {
    let mut builder = DucTableRowBuilder::new(_fbb);
    builder.add_height(args.height);
    if let Some(x) = args.style_overrides { builder.add_style_overrides(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucTableRow::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &DucTableRow) -> bool {
    self.id() < o.id()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.id();
    key.cmp(val)
  }
  #[inline]
  pub fn height(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucTableRow::VT_HEIGHT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn style_overrides(&self) -> Option<DucTableCellStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucTableCellStyle>>(DucTableRow::VT_STYLE_OVERRIDES, None)}
  }
}

impl flatbuffers::Verifiable for DucTableRow<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<f64>("height", Self::VT_HEIGHT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucTableCellStyle>>("style_overrides", Self::VT_STYLE_OVERRIDES, false)?
     .finish();
    Ok(())
  }
}
pub struct DucTableRowArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub height: f64,
    pub style_overrides: Option<flatbuffers::WIPOffset<DucTableCellStyle<'a>>>,
}
impl<'a> Default for DucTableRowArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucTableRowArgs {
      id: None, // required field
      height: 0.0,
      style_overrides: None,
    }
  }
}

pub struct DucTableRowBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucTableRowBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucTableRow::VT_ID, id);
  }
  #[inline]
  pub fn add_height(&mut self, height: f64) {
    self.fbb_.push_slot::<f64>(DucTableRow::VT_HEIGHT, height, 0.0);
  }
  #[inline]
  pub fn add_style_overrides(&mut self, style_overrides: flatbuffers::WIPOffset<DucTableCellStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucTableCellStyle>>(DucTableRow::VT_STYLE_OVERRIDES, style_overrides);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucTableRowBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucTableRowBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucTableRow<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, DucTableRow::VT_ID,"id");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucTableRow<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucTableRow");
      ds.field("id", &self.id());
      ds.field("height", &self.height());
      ds.field("style_overrides", &self.style_overrides());
      ds.finish()
  }
}
pub enum DucTableCellSpanOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucTableCellSpan<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucTableCellSpan<'a> {
  type Inner = DucTableCellSpan<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucTableCellSpan<'a> {
  pub const VT_COLUMNS: flatbuffers::VOffsetT = 4;
  pub const VT_ROWS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucTableCellSpan { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucTableCellSpanArgs
  ) -> flatbuffers::WIPOffset<DucTableCellSpan<'bldr>> {
    let mut builder = DucTableCellSpanBuilder::new(_fbb);
    builder.add_rows(args.rows);
    builder.add_columns(args.columns);
    builder.finish()
  }


  #[inline]
  pub fn columns(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DucTableCellSpan::VT_COLUMNS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn rows(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DucTableCellSpan::VT_ROWS, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DucTableCellSpan<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("columns", Self::VT_COLUMNS, false)?
     .visit_field::<i32>("rows", Self::VT_ROWS, false)?
     .finish();
    Ok(())
  }
}
pub struct DucTableCellSpanArgs {
    pub columns: i32,
    pub rows: i32,
}
impl<'a> Default for DucTableCellSpanArgs {
  #[inline]
  fn default() -> Self {
    DucTableCellSpanArgs {
      columns: 0,
      rows: 0,
    }
  }
}

pub struct DucTableCellSpanBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucTableCellSpanBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_columns(&mut self, columns: i32) {
    self.fbb_.push_slot::<i32>(DucTableCellSpan::VT_COLUMNS, columns, 0);
  }
  #[inline]
  pub fn add_rows(&mut self, rows: i32) {
    self.fbb_.push_slot::<i32>(DucTableCellSpan::VT_ROWS, rows, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucTableCellSpanBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucTableCellSpanBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucTableCellSpan<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucTableCellSpan<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucTableCellSpan");
      ds.field("columns", &self.columns());
      ds.field("rows", &self.rows());
      ds.finish()
  }
}
pub enum DucTableCellOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucTableCell<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucTableCell<'a> {
  type Inner = DucTableCell<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucTableCell<'a> {
  pub const VT_ROW_ID: flatbuffers::VOffsetT = 4;
  pub const VT_COLUMN_ID: flatbuffers::VOffsetT = 6;
  pub const VT_DATA: flatbuffers::VOffsetT = 8;
  pub const VT_SPAN: flatbuffers::VOffsetT = 10;
  pub const VT_LOCKED: flatbuffers::VOffsetT = 12;
  pub const VT_STYLE_OVERRIDES: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucTableCell { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucTableCellArgs<'args>
  ) -> flatbuffers::WIPOffset<DucTableCell<'bldr>> {
    let mut builder = DucTableCellBuilder::new(_fbb);
    if let Some(x) = args.style_overrides { builder.add_style_overrides(x); }
    if let Some(x) = args.span { builder.add_span(x); }
    if let Some(x) = args.data { builder.add_data(x); }
    if let Some(x) = args.column_id { builder.add_column_id(x); }
    if let Some(x) = args.row_id { builder.add_row_id(x); }
    builder.add_locked(args.locked);
    builder.finish()
  }


  #[inline]
  pub fn row_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucTableCell::VT_ROW_ID, None)}
  }
  #[inline]
  pub fn column_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucTableCell::VT_COLUMN_ID, None)}
  }
  #[inline]
  pub fn data(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucTableCell::VT_DATA, None)}
  }
  #[inline]
  pub fn span(&self) -> Option<DucTableCellSpan<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucTableCellSpan>>(DucTableCell::VT_SPAN, None)}
  }
  #[inline]
  pub fn locked(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucTableCell::VT_LOCKED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn style_overrides(&self) -> Option<DucTableCellStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucTableCellStyle>>(DucTableCell::VT_STYLE_OVERRIDES, None)}
  }
}

impl flatbuffers::Verifiable for DucTableCell<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("row_id", Self::VT_ROW_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("column_id", Self::VT_COLUMN_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("data", Self::VT_DATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucTableCellSpan>>("span", Self::VT_SPAN, false)?
     .visit_field::<bool>("locked", Self::VT_LOCKED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucTableCellStyle>>("style_overrides", Self::VT_STYLE_OVERRIDES, false)?
     .finish();
    Ok(())
  }
}
pub struct DucTableCellArgs<'a> {
    pub row_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub column_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub data: Option<flatbuffers::WIPOffset<&'a str>>,
    pub span: Option<flatbuffers::WIPOffset<DucTableCellSpan<'a>>>,
    pub locked: bool,
    pub style_overrides: Option<flatbuffers::WIPOffset<DucTableCellStyle<'a>>>,
}
impl<'a> Default for DucTableCellArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucTableCellArgs {
      row_id: None,
      column_id: None,
      data: None,
      span: None,
      locked: false,
      style_overrides: None,
    }
  }
}

pub struct DucTableCellBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucTableCellBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_row_id(&mut self, row_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucTableCell::VT_ROW_ID, row_id);
  }
  #[inline]
  pub fn add_column_id(&mut self, column_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucTableCell::VT_COLUMN_ID, column_id);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucTableCell::VT_DATA, data);
  }
  #[inline]
  pub fn add_span(&mut self, span: flatbuffers::WIPOffset<DucTableCellSpan<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucTableCellSpan>>(DucTableCell::VT_SPAN, span);
  }
  #[inline]
  pub fn add_locked(&mut self, locked: bool) {
    self.fbb_.push_slot::<bool>(DucTableCell::VT_LOCKED, locked, false);
  }
  #[inline]
  pub fn add_style_overrides(&mut self, style_overrides: flatbuffers::WIPOffset<DucTableCellStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucTableCellStyle>>(DucTableCell::VT_STYLE_OVERRIDES, style_overrides);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucTableCellBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucTableCellBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucTableCell<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucTableCell<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucTableCell");
      ds.field("row_id", &self.row_id());
      ds.field("column_id", &self.column_id());
      ds.field("data", &self.data());
      ds.field("span", &self.span());
      ds.field("locked", &self.locked());
      ds.field("style_overrides", &self.style_overrides());
      ds.finish()
  }
}
pub enum DucTableColumnEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucTableColumnEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucTableColumnEntry<'a> {
  type Inner = DucTableColumnEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucTableColumnEntry<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucTableColumnEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucTableColumnEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<DucTableColumnEntry<'bldr>> {
    let mut builder = DucTableColumnEntryBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucTableColumnEntry::VT_KEY, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &DucTableColumnEntry) -> bool {
    self.key() < o.key()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.key();
    key.cmp(val)
  }
  #[inline]
  pub fn value(&self) -> Option<DucTableColumn<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucTableColumn>>(DucTableColumnEntry::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for DucTableColumnEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucTableColumn>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct DucTableColumnEntryArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<DucTableColumn<'a>>>,
}
impl<'a> Default for DucTableColumnEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucTableColumnEntryArgs {
      key: None, // required field
      value: None,
    }
  }
}

pub struct DucTableColumnEntryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucTableColumnEntryBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucTableColumnEntry::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<DucTableColumn<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucTableColumn>>(DucTableColumnEntry::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucTableColumnEntryBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucTableColumnEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucTableColumnEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, DucTableColumnEntry::VT_KEY,"key");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucTableColumnEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucTableColumnEntry");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum DucTableRowEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucTableRowEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucTableRowEntry<'a> {
  type Inner = DucTableRowEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucTableRowEntry<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucTableRowEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucTableRowEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<DucTableRowEntry<'bldr>> {
    let mut builder = DucTableRowEntryBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucTableRowEntry::VT_KEY, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &DucTableRowEntry) -> bool {
    self.key() < o.key()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.key();
    key.cmp(val)
  }
  #[inline]
  pub fn value(&self) -> Option<DucTableRow<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucTableRow>>(DucTableRowEntry::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for DucTableRowEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucTableRow>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct DucTableRowEntryArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<DucTableRow<'a>>>,
}
impl<'a> Default for DucTableRowEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucTableRowEntryArgs {
      key: None, // required field
      value: None,
    }
  }
}

pub struct DucTableRowEntryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucTableRowEntryBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucTableRowEntry::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<DucTableRow<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucTableRow>>(DucTableRowEntry::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucTableRowEntryBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucTableRowEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucTableRowEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, DucTableRowEntry::VT_KEY,"key");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucTableRowEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucTableRowEntry");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum DucTableCellEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucTableCellEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucTableCellEntry<'a> {
  type Inner = DucTableCellEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucTableCellEntry<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucTableCellEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucTableCellEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<DucTableCellEntry<'bldr>> {
    let mut builder = DucTableCellEntryBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucTableCellEntry::VT_KEY, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &DucTableCellEntry) -> bool {
    self.key() < o.key()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.key();
    key.cmp(val)
  }
  #[inline]
  pub fn value(&self) -> Option<DucTableCell<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucTableCell>>(DucTableCellEntry::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for DucTableCellEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucTableCell>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct DucTableCellEntryArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<DucTableCell<'a>>>,
}
impl<'a> Default for DucTableCellEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucTableCellEntryArgs {
      key: None, // required field
      value: None,
    }
  }
}

pub struct DucTableCellEntryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucTableCellEntryBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucTableCellEntry::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<DucTableCell<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucTableCell>>(DucTableCellEntry::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucTableCellEntryBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucTableCellEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucTableCellEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, DucTableCellEntry::VT_KEY,"key");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucTableCellEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucTableCellEntry");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum DucTableAutoSizeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucTableAutoSize<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucTableAutoSize<'a> {
  type Inner = DucTableAutoSize<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucTableAutoSize<'a> {
  pub const VT_COLUMNS: flatbuffers::VOffsetT = 4;
  pub const VT_ROWS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucTableAutoSize { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucTableAutoSizeArgs
  ) -> flatbuffers::WIPOffset<DucTableAutoSize<'bldr>> {
    let mut builder = DucTableAutoSizeBuilder::new(_fbb);
    builder.add_rows(args.rows);
    builder.add_columns(args.columns);
    builder.finish()
  }


  #[inline]
  pub fn columns(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucTableAutoSize::VT_COLUMNS, Some(false)).unwrap()}
  }
  #[inline]
  pub fn rows(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucTableAutoSize::VT_ROWS, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DucTableAutoSize<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("columns", Self::VT_COLUMNS, false)?
     .visit_field::<bool>("rows", Self::VT_ROWS, false)?
     .finish();
    Ok(())
  }
}
pub struct DucTableAutoSizeArgs {
    pub columns: bool,
    pub rows: bool,
}
impl<'a> Default for DucTableAutoSizeArgs {
  #[inline]
  fn default() -> Self {
    DucTableAutoSizeArgs {
      columns: false,
      rows: false,
    }
  }
}

pub struct DucTableAutoSizeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucTableAutoSizeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_columns(&mut self, columns: bool) {
    self.fbb_.push_slot::<bool>(DucTableAutoSize::VT_COLUMNS, columns, false);
  }
  #[inline]
  pub fn add_rows(&mut self, rows: bool) {
    self.fbb_.push_slot::<bool>(DucTableAutoSize::VT_ROWS, rows, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucTableAutoSizeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucTableAutoSizeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucTableAutoSize<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucTableAutoSize<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucTableAutoSize");
      ds.field("columns", &self.columns());
      ds.field("rows", &self.rows());
      ds.finish()
  }
}
pub enum DucTableElementOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucTableElement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucTableElement<'a> {
  type Inner = DucTableElement<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucTableElement<'a> {
  pub const VT_BASE: flatbuffers::VOffsetT = 4;
  pub const VT_STYLE: flatbuffers::VOffsetT = 6;
  pub const VT_COLUMN_ORDER: flatbuffers::VOffsetT = 8;
  pub const VT_ROW_ORDER: flatbuffers::VOffsetT = 10;
  pub const VT_COLUMNS: flatbuffers::VOffsetT = 12;
  pub const VT_ROWS: flatbuffers::VOffsetT = 14;
  pub const VT_CELLS: flatbuffers::VOffsetT = 16;
  pub const VT_HEADER_ROW_COUNT: flatbuffers::VOffsetT = 18;
  pub const VT_AUTO_SIZE: flatbuffers::VOffsetT = 20;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucTableElement { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucTableElementArgs<'args>
  ) -> flatbuffers::WIPOffset<DucTableElement<'bldr>> {
    let mut builder = DucTableElementBuilder::new(_fbb);
    if let Some(x) = args.auto_size { builder.add_auto_size(x); }
    builder.add_header_row_count(args.header_row_count);
    if let Some(x) = args.cells { builder.add_cells(x); }
    if let Some(x) = args.rows { builder.add_rows(x); }
    if let Some(x) = args.columns { builder.add_columns(x); }
    if let Some(x) = args.row_order { builder.add_row_order(x); }
    if let Some(x) = args.column_order { builder.add_column_order(x); }
    if let Some(x) = args.style { builder.add_style(x); }
    if let Some(x) = args.base { builder.add_base(x); }
    builder.finish()
  }


  #[inline]
  pub fn base(&self) -> Option<_DucElementBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<_DucElementBase>>(DucTableElement::VT_BASE, None)}
  }
  #[inline]
  pub fn style(&self) -> Option<DucTableStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucTableStyle>>(DucTableElement::VT_STYLE, None)}
  }
  #[inline]
  pub fn column_order(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(DucTableElement::VT_COLUMN_ORDER, None)}
  }
  #[inline]
  pub fn row_order(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(DucTableElement::VT_ROW_ORDER, None)}
  }
  #[inline]
  pub fn columns(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucTableColumnEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucTableColumnEntry>>>>(DucTableElement::VT_COLUMNS, None)}
  }
  #[inline]
  pub fn rows(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucTableRowEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucTableRowEntry>>>>(DucTableElement::VT_ROWS, None)}
  }
  #[inline]
  pub fn cells(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucTableCellEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucTableCellEntry>>>>(DucTableElement::VT_CELLS, None)}
  }
  #[inline]
  pub fn header_row_count(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DucTableElement::VT_HEADER_ROW_COUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn auto_size(&self) -> Option<DucTableAutoSize<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucTableAutoSize>>(DucTableElement::VT_AUTO_SIZE, None)}
  }
}

impl flatbuffers::Verifiable for DucTableElement<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<_DucElementBase>>("base", Self::VT_BASE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucTableStyle>>("style", Self::VT_STYLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("column_order", Self::VT_COLUMN_ORDER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("row_order", Self::VT_ROW_ORDER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DucTableColumnEntry>>>>("columns", Self::VT_COLUMNS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DucTableRowEntry>>>>("rows", Self::VT_ROWS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DucTableCellEntry>>>>("cells", Self::VT_CELLS, false)?
     .visit_field::<i32>("header_row_count", Self::VT_HEADER_ROW_COUNT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucTableAutoSize>>("auto_size", Self::VT_AUTO_SIZE, false)?
     .finish();
    Ok(())
  }
}
pub struct DucTableElementArgs<'a> {
    pub base: Option<flatbuffers::WIPOffset<_DucElementBase<'a>>>,
    pub style: Option<flatbuffers::WIPOffset<DucTableStyle<'a>>>,
    pub column_order: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub row_order: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub columns: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucTableColumnEntry<'a>>>>>,
    pub rows: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucTableRowEntry<'a>>>>>,
    pub cells: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucTableCellEntry<'a>>>>>,
    pub header_row_count: i32,
    pub auto_size: Option<flatbuffers::WIPOffset<DucTableAutoSize<'a>>>,
}
impl<'a> Default for DucTableElementArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucTableElementArgs {
      base: None,
      style: None,
      column_order: None,
      row_order: None,
      columns: None,
      rows: None,
      cells: None,
      header_row_count: 0,
      auto_size: None,
    }
  }
}

pub struct DucTableElementBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucTableElementBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_base(&mut self, base: flatbuffers::WIPOffset<_DucElementBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_DucElementBase>>(DucTableElement::VT_BASE, base);
  }
  #[inline]
  pub fn add_style(&mut self, style: flatbuffers::WIPOffset<DucTableStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucTableStyle>>(DucTableElement::VT_STYLE, style);
  }
  #[inline]
  pub fn add_column_order(&mut self, column_order: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucTableElement::VT_COLUMN_ORDER, column_order);
  }
  #[inline]
  pub fn add_row_order(&mut self, row_order: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucTableElement::VT_ROW_ORDER, row_order);
  }
  #[inline]
  pub fn add_columns(&mut self, columns: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DucTableColumnEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucTableElement::VT_COLUMNS, columns);
  }
  #[inline]
  pub fn add_rows(&mut self, rows: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DucTableRowEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucTableElement::VT_ROWS, rows);
  }
  #[inline]
  pub fn add_cells(&mut self, cells: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DucTableCellEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucTableElement::VT_CELLS, cells);
  }
  #[inline]
  pub fn add_header_row_count(&mut self, header_row_count: i32) {
    self.fbb_.push_slot::<i32>(DucTableElement::VT_HEADER_ROW_COUNT, header_row_count, 0);
  }
  #[inline]
  pub fn add_auto_size(&mut self, auto_size: flatbuffers::WIPOffset<DucTableAutoSize<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucTableAutoSize>>(DucTableElement::VT_AUTO_SIZE, auto_size);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucTableElementBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucTableElementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucTableElement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucTableElement<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucTableElement");
      ds.field("base", &self.base());
      ds.field("style", &self.style());
      ds.field("column_order", &self.column_order());
      ds.field("row_order", &self.row_order());
      ds.field("columns", &self.columns());
      ds.field("rows", &self.rows());
      ds.field("cells", &self.cells());
      ds.field("header_row_count", &self.header_row_count());
      ds.field("auto_size", &self.auto_size());
      ds.finish()
  }
}
pub enum ImageCropOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ImageCrop<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ImageCrop<'a> {
  type Inner = ImageCrop<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ImageCrop<'a> {
  pub const VT_X: flatbuffers::VOffsetT = 4;
  pub const VT_Y: flatbuffers::VOffsetT = 6;
  pub const VT_WIDTH: flatbuffers::VOffsetT = 8;
  pub const VT_HEIGHT: flatbuffers::VOffsetT = 10;
  pub const VT_NATURAL_WIDTH: flatbuffers::VOffsetT = 12;
  pub const VT_NATURAL_HEIGHT: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ImageCrop { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ImageCropArgs
  ) -> flatbuffers::WIPOffset<ImageCrop<'bldr>> {
    let mut builder = ImageCropBuilder::new(_fbb);
    builder.add_natural_height(args.natural_height);
    builder.add_natural_width(args.natural_width);
    builder.add_height(args.height);
    builder.add_width(args.width);
    builder.add_y(args.y);
    builder.add_x(args.x);
    builder.finish()
  }


  #[inline]
  pub fn x(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ImageCrop::VT_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ImageCrop::VT_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn width(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ImageCrop::VT_WIDTH, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn height(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ImageCrop::VT_HEIGHT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn natural_width(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ImageCrop::VT_NATURAL_WIDTH, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn natural_height(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ImageCrop::VT_NATURAL_HEIGHT, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ImageCrop<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("x", Self::VT_X, false)?
     .visit_field::<f64>("y", Self::VT_Y, false)?
     .visit_field::<f64>("width", Self::VT_WIDTH, false)?
     .visit_field::<f64>("height", Self::VT_HEIGHT, false)?
     .visit_field::<f64>("natural_width", Self::VT_NATURAL_WIDTH, false)?
     .visit_field::<f64>("natural_height", Self::VT_NATURAL_HEIGHT, false)?
     .finish();
    Ok(())
  }
}
pub struct ImageCropArgs {
    pub x: f64,
    pub y: f64,
    pub width: f64,
    pub height: f64,
    pub natural_width: f64,
    pub natural_height: f64,
}
impl<'a> Default for ImageCropArgs {
  #[inline]
  fn default() -> Self {
    ImageCropArgs {
      x: 0.0,
      y: 0.0,
      width: 0.0,
      height: 0.0,
      natural_width: 0.0,
      natural_height: 0.0,
    }
  }
}

pub struct ImageCropBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ImageCropBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_x(&mut self, x: f64) {
    self.fbb_.push_slot::<f64>(ImageCrop::VT_X, x, 0.0);
  }
  #[inline]
  pub fn add_y(&mut self, y: f64) {
    self.fbb_.push_slot::<f64>(ImageCrop::VT_Y, y, 0.0);
  }
  #[inline]
  pub fn add_width(&mut self, width: f64) {
    self.fbb_.push_slot::<f64>(ImageCrop::VT_WIDTH, width, 0.0);
  }
  #[inline]
  pub fn add_height(&mut self, height: f64) {
    self.fbb_.push_slot::<f64>(ImageCrop::VT_HEIGHT, height, 0.0);
  }
  #[inline]
  pub fn add_natural_width(&mut self, natural_width: f64) {
    self.fbb_.push_slot::<f64>(ImageCrop::VT_NATURAL_WIDTH, natural_width, 0.0);
  }
  #[inline]
  pub fn add_natural_height(&mut self, natural_height: f64) {
    self.fbb_.push_slot::<f64>(ImageCrop::VT_NATURAL_HEIGHT, natural_height, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ImageCropBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ImageCropBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ImageCrop<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ImageCrop<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ImageCrop");
      ds.field("x", &self.x());
      ds.field("y", &self.y());
      ds.field("width", &self.width());
      ds.field("height", &self.height());
      ds.field("natural_width", &self.natural_width());
      ds.field("natural_height", &self.natural_height());
      ds.finish()
  }
}
pub enum DucImageElementOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucImageElement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucImageElement<'a> {
  type Inner = DucImageElement<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucImageElement<'a> {
  pub const VT_BASE: flatbuffers::VOffsetT = 4;
  pub const VT_FILE_ID: flatbuffers::VOffsetT = 6;
  pub const VT_STATUS: flatbuffers::VOffsetT = 8;
  pub const VT_SCALE: flatbuffers::VOffsetT = 10;
  pub const VT_CROP: flatbuffers::VOffsetT = 12;
  pub const VT_FILTER: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucImageElement { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucImageElementArgs<'args>
  ) -> flatbuffers::WIPOffset<DucImageElement<'bldr>> {
    let mut builder = DucImageElementBuilder::new(_fbb);
    if let Some(x) = args.filter { builder.add_filter(x); }
    if let Some(x) = args.crop { builder.add_crop(x); }
    if let Some(x) = args.scale { builder.add_scale(x); }
    if let Some(x) = args.file_id { builder.add_file_id(x); }
    if let Some(x) = args.base { builder.add_base(x); }
    if let Some(x) = args.status { builder.add_status(x); }
    builder.finish()
  }


  #[inline]
  pub fn base(&self) -> Option<_DucElementBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<_DucElementBase>>(DucImageElement::VT_BASE, None)}
  }
  #[inline]
  pub fn file_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucImageElement::VT_FILE_ID, None)}
  }
  #[inline]
  pub fn status(&self) -> Option<IMAGE_STATUS> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<IMAGE_STATUS>(DucImageElement::VT_STATUS, None)}
  }
  #[inline]
  pub fn scale(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(DucImageElement::VT_SCALE, None)}
  }
  #[inline]
  pub fn crop(&self) -> Option<ImageCrop<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ImageCrop>>(DucImageElement::VT_CROP, None)}
  }
  #[inline]
  pub fn filter(&self) -> Option<DucImageFilter<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucImageFilter>>(DucImageElement::VT_FILTER, None)}
  }
}

impl flatbuffers::Verifiable for DucImageElement<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<_DucElementBase>>("base", Self::VT_BASE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("file_id", Self::VT_FILE_ID, false)?
     .visit_field::<IMAGE_STATUS>("status", Self::VT_STATUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("scale", Self::VT_SCALE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ImageCrop>>("crop", Self::VT_CROP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucImageFilter>>("filter", Self::VT_FILTER, false)?
     .finish();
    Ok(())
  }
}
pub struct DucImageElementArgs<'a> {
    pub base: Option<flatbuffers::WIPOffset<_DucElementBase<'a>>>,
    pub file_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub status: Option<IMAGE_STATUS>,
    pub scale: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub crop: Option<flatbuffers::WIPOffset<ImageCrop<'a>>>,
    pub filter: Option<flatbuffers::WIPOffset<DucImageFilter<'a>>>,
}
impl<'a> Default for DucImageElementArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucImageElementArgs {
      base: None,
      file_id: None,
      status: None,
      scale: None,
      crop: None,
      filter: None,
    }
  }
}

pub struct DucImageElementBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucImageElementBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_base(&mut self, base: flatbuffers::WIPOffset<_DucElementBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_DucElementBase>>(DucImageElement::VT_BASE, base);
  }
  #[inline]
  pub fn add_file_id(&mut self, file_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucImageElement::VT_FILE_ID, file_id);
  }
  #[inline]
  pub fn add_status(&mut self, status: IMAGE_STATUS) {
    self.fbb_.push_slot_always::<IMAGE_STATUS>(DucImageElement::VT_STATUS, status);
  }
  #[inline]
  pub fn add_scale(&mut self, scale: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucImageElement::VT_SCALE, scale);
  }
  #[inline]
  pub fn add_crop(&mut self, crop: flatbuffers::WIPOffset<ImageCrop<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ImageCrop>>(DucImageElement::VT_CROP, crop);
  }
  #[inline]
  pub fn add_filter(&mut self, filter: flatbuffers::WIPOffset<DucImageFilter<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucImageFilter>>(DucImageElement::VT_FILTER, filter);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucImageElementBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucImageElementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucImageElement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucImageElement<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucImageElement");
      ds.field("base", &self.base());
      ds.field("file_id", &self.file_id());
      ds.field("status", &self.status());
      ds.field("scale", &self.scale());
      ds.field("crop", &self.crop());
      ds.field("filter", &self.filter());
      ds.finish()
  }
}
pub enum DucTextDynamicElementSourceOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucTextDynamicElementSource<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucTextDynamicElementSource<'a> {
  type Inner = DucTextDynamicElementSource<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucTextDynamicElementSource<'a> {
  pub const VT_ELEMENT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_PROPERTY: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucTextDynamicElementSource { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucTextDynamicElementSourceArgs<'args>
  ) -> flatbuffers::WIPOffset<DucTextDynamicElementSource<'bldr>> {
    let mut builder = DucTextDynamicElementSourceBuilder::new(_fbb);
    if let Some(x) = args.element_id { builder.add_element_id(x); }
    if let Some(x) = args.property { builder.add_property(x); }
    builder.finish()
  }


  #[inline]
  pub fn element_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucTextDynamicElementSource::VT_ELEMENT_ID, None)}
  }
  #[inline]
  pub fn property(&self) -> Option<TEXT_FIELD_SOURCE_PROPERTY> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TEXT_FIELD_SOURCE_PROPERTY>(DucTextDynamicElementSource::VT_PROPERTY, None)}
  }
}

impl flatbuffers::Verifiable for DucTextDynamicElementSource<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("element_id", Self::VT_ELEMENT_ID, false)?
     .visit_field::<TEXT_FIELD_SOURCE_PROPERTY>("property", Self::VT_PROPERTY, false)?
     .finish();
    Ok(())
  }
}
pub struct DucTextDynamicElementSourceArgs<'a> {
    pub element_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub property: Option<TEXT_FIELD_SOURCE_PROPERTY>,
}
impl<'a> Default for DucTextDynamicElementSourceArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucTextDynamicElementSourceArgs {
      element_id: None,
      property: None,
    }
  }
}

pub struct DucTextDynamicElementSourceBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucTextDynamicElementSourceBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_element_id(&mut self, element_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucTextDynamicElementSource::VT_ELEMENT_ID, element_id);
  }
  #[inline]
  pub fn add_property(&mut self, property: TEXT_FIELD_SOURCE_PROPERTY) {
    self.fbb_.push_slot_always::<TEXT_FIELD_SOURCE_PROPERTY>(DucTextDynamicElementSource::VT_PROPERTY, property);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucTextDynamicElementSourceBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucTextDynamicElementSourceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucTextDynamicElementSource<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucTextDynamicElementSource<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucTextDynamicElementSource");
      ds.field("element_id", &self.element_id());
      ds.field("property", &self.property());
      ds.finish()
  }
}
pub enum DucTextDynamicDictionarySourceOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucTextDynamicDictionarySource<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucTextDynamicDictionarySource<'a> {
  type Inner = DucTextDynamicDictionarySource<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucTextDynamicDictionarySource<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucTextDynamicDictionarySource { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucTextDynamicDictionarySourceArgs<'args>
  ) -> flatbuffers::WIPOffset<DucTextDynamicDictionarySource<'bldr>> {
    let mut builder = DucTextDynamicDictionarySourceBuilder::new(_fbb);
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucTextDynamicDictionarySource::VT_KEY, None)}
  }
}

impl flatbuffers::Verifiable for DucTextDynamicDictionarySource<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
     .finish();
    Ok(())
  }
}
pub struct DucTextDynamicDictionarySourceArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DucTextDynamicDictionarySourceArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucTextDynamicDictionarySourceArgs {
      key: None,
    }
  }
}

pub struct DucTextDynamicDictionarySourceBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucTextDynamicDictionarySourceBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucTextDynamicDictionarySource::VT_KEY, key);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucTextDynamicDictionarySourceBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucTextDynamicDictionarySourceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucTextDynamicDictionarySource<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucTextDynamicDictionarySource<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucTextDynamicDictionarySource");
      ds.field("key", &self.key());
      ds.finish()
  }
}
pub enum DucTextDynamicSourceOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucTextDynamicSource<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucTextDynamicSource<'a> {
  type Inner = DucTextDynamicSource<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucTextDynamicSource<'a> {
  pub const VT_TEXT_SOURCE_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_SOURCE_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucTextDynamicSource { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucTextDynamicSourceArgs
  ) -> flatbuffers::WIPOffset<DucTextDynamicSource<'bldr>> {
    let mut builder = DucTextDynamicSourceBuilder::new(_fbb);
    if let Some(x) = args.source { builder.add_source(x); }
    builder.add_source_type(args.source_type);
    if let Some(x) = args.text_source_type { builder.add_text_source_type(x); }
    builder.finish()
  }


  #[inline]
  pub fn text_source_type(&self) -> Option<TEXT_FIELD_SOURCE_TYPE> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TEXT_FIELD_SOURCE_TYPE>(DucTextDynamicSource::VT_TEXT_SOURCE_TYPE, None)}
  }
  #[inline]
  pub fn source_type(&self) -> DucTextDynamicSourceData {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DucTextDynamicSourceData>(DucTextDynamicSource::VT_SOURCE_TYPE, Some(DucTextDynamicSourceData::NONE)).unwrap()}
  }
  #[inline]
  pub fn source(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(DucTextDynamicSource::VT_SOURCE, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn source_as_duc_text_dynamic_element_source(&self) -> Option<DucTextDynamicElementSource<'a>> {
    if self.source_type() == DucTextDynamicSourceData::DucTextDynamicElementSource {
      self.source().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DucTextDynamicElementSource::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn source_as_duc_text_dynamic_dictionary_source(&self) -> Option<DucTextDynamicDictionarySource<'a>> {
    if self.source_type() == DucTextDynamicSourceData::DucTextDynamicDictionarySource {
      self.source().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DucTextDynamicDictionarySource::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for DucTextDynamicSource<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<TEXT_FIELD_SOURCE_TYPE>("text_source_type", Self::VT_TEXT_SOURCE_TYPE, false)?
     .visit_union::<DucTextDynamicSourceData, _>("source_type", Self::VT_SOURCE_TYPE, "source", Self::VT_SOURCE, false, |key, v, pos| {
        match key {
          DucTextDynamicSourceData::DucTextDynamicElementSource => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DucTextDynamicElementSource>>("DucTextDynamicSourceData::DucTextDynamicElementSource", pos),
          DucTextDynamicSourceData::DucTextDynamicDictionarySource => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DucTextDynamicDictionarySource>>("DucTextDynamicSourceData::DucTextDynamicDictionarySource", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct DucTextDynamicSourceArgs {
    pub text_source_type: Option<TEXT_FIELD_SOURCE_TYPE>,
    pub source_type: DucTextDynamicSourceData,
    pub source: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for DucTextDynamicSourceArgs {
  #[inline]
  fn default() -> Self {
    DucTextDynamicSourceArgs {
      text_source_type: None,
      source_type: DucTextDynamicSourceData::NONE,
      source: None,
    }
  }
}

pub struct DucTextDynamicSourceBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucTextDynamicSourceBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_text_source_type(&mut self, text_source_type: TEXT_FIELD_SOURCE_TYPE) {
    self.fbb_.push_slot_always::<TEXT_FIELD_SOURCE_TYPE>(DucTextDynamicSource::VT_TEXT_SOURCE_TYPE, text_source_type);
  }
  #[inline]
  pub fn add_source_type(&mut self, source_type: DucTextDynamicSourceData) {
    self.fbb_.push_slot::<DucTextDynamicSourceData>(DucTextDynamicSource::VT_SOURCE_TYPE, source_type, DucTextDynamicSourceData::NONE);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucTextDynamicSource::VT_SOURCE, source);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucTextDynamicSourceBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucTextDynamicSourceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucTextDynamicSource<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucTextDynamicSource<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucTextDynamicSource");
      ds.field("text_source_type", &self.text_source_type());
      ds.field("source_type", &self.source_type());
      match self.source_type() {
        DucTextDynamicSourceData::DucTextDynamicElementSource => {
          if let Some(x) = self.source_as_duc_text_dynamic_element_source() {
            ds.field("source", &x)
          } else {
            ds.field("source", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        DucTextDynamicSourceData::DucTextDynamicDictionarySource => {
          if let Some(x) = self.source_as_duc_text_dynamic_dictionary_source() {
            ds.field("source", &x)
          } else {
            ds.field("source", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("source", &x)
        },
      };
      ds.finish()
  }
}
pub enum DucTextDynamicPartOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucTextDynamicPart<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucTextDynamicPart<'a> {
  type Inner = DucTextDynamicPart<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucTextDynamicPart<'a> {
  pub const VT_TAG: flatbuffers::VOffsetT = 4;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 6;
  pub const VT_FORMATTING: flatbuffers::VOffsetT = 8;
  pub const VT_CACHED_VALUE: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucTextDynamicPart { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucTextDynamicPartArgs<'args>
  ) -> flatbuffers::WIPOffset<DucTextDynamicPart<'bldr>> {
    let mut builder = DucTextDynamicPartBuilder::new(_fbb);
    if let Some(x) = args.cached_value { builder.add_cached_value(x); }
    if let Some(x) = args.formatting { builder.add_formatting(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.tag { builder.add_tag(x); }
    builder.finish()
  }


  #[inline]
  pub fn tag(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucTextDynamicPart::VT_TAG, None)}
  }
  #[inline]
  pub fn source(&self) -> Option<DucTextDynamicSource<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucTextDynamicSource>>(DucTextDynamicPart::VT_SOURCE, None)}
  }
  #[inline]
  pub fn formatting(&self) -> Option<PrimaryUnits<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<PrimaryUnits>>(DucTextDynamicPart::VT_FORMATTING, None)}
  }
  #[inline]
  pub fn cached_value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucTextDynamicPart::VT_CACHED_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for DucTextDynamicPart<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tag", Self::VT_TAG, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucTextDynamicSource>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<PrimaryUnits>>("formatting", Self::VT_FORMATTING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("cached_value", Self::VT_CACHED_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct DucTextDynamicPartArgs<'a> {
    pub tag: Option<flatbuffers::WIPOffset<&'a str>>,
    pub source: Option<flatbuffers::WIPOffset<DucTextDynamicSource<'a>>>,
    pub formatting: Option<flatbuffers::WIPOffset<PrimaryUnits<'a>>>,
    pub cached_value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DucTextDynamicPartArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucTextDynamicPartArgs {
      tag: None,
      source: None,
      formatting: None,
      cached_value: None,
    }
  }
}

pub struct DucTextDynamicPartBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucTextDynamicPartBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_tag(&mut self, tag: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucTextDynamicPart::VT_TAG, tag);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<DucTextDynamicSource<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucTextDynamicSource>>(DucTextDynamicPart::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_formatting(&mut self, formatting: flatbuffers::WIPOffset<PrimaryUnits<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PrimaryUnits>>(DucTextDynamicPart::VT_FORMATTING, formatting);
  }
  #[inline]
  pub fn add_cached_value(&mut self, cached_value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucTextDynamicPart::VT_CACHED_VALUE, cached_value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucTextDynamicPartBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucTextDynamicPartBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucTextDynamicPart<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucTextDynamicPart<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucTextDynamicPart");
      ds.field("tag", &self.tag());
      ds.field("source", &self.source());
      ds.field("formatting", &self.formatting());
      ds.field("cached_value", &self.cached_value());
      ds.finish()
  }
}
pub enum DucTextElementOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucTextElement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucTextElement<'a> {
  type Inner = DucTextElement<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucTextElement<'a> {
  pub const VT_BASE: flatbuffers::VOffsetT = 4;
  pub const VT_STYLE: flatbuffers::VOffsetT = 6;
  pub const VT_TEXT: flatbuffers::VOffsetT = 8;
  pub const VT_DYNAMIC: flatbuffers::VOffsetT = 10;
  pub const VT_AUTO_RESIZE: flatbuffers::VOffsetT = 12;
  pub const VT_CONTAINER_ID: flatbuffers::VOffsetT = 14;
  pub const VT_ORIGINAL_TEXT: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucTextElement { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucTextElementArgs<'args>
  ) -> flatbuffers::WIPOffset<DucTextElement<'bldr>> {
    let mut builder = DucTextElementBuilder::new(_fbb);
    if let Some(x) = args.original_text { builder.add_original_text(x); }
    if let Some(x) = args.container_id { builder.add_container_id(x); }
    if let Some(x) = args.dynamic { builder.add_dynamic(x); }
    if let Some(x) = args.text { builder.add_text(x); }
    if let Some(x) = args.style { builder.add_style(x); }
    if let Some(x) = args.base { builder.add_base(x); }
    builder.add_auto_resize(args.auto_resize);
    builder.finish()
  }


  #[inline]
  pub fn base(&self) -> Option<_DucElementBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<_DucElementBase>>(DucTextElement::VT_BASE, None)}
  }
  #[inline]
  pub fn style(&self) -> Option<DucTextStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucTextStyle>>(DucTextElement::VT_STYLE, None)}
  }
  #[inline]
  pub fn text(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucTextElement::VT_TEXT, None)}
  }
  #[inline]
  pub fn dynamic(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucTextDynamicPart<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucTextDynamicPart>>>>(DucTextElement::VT_DYNAMIC, None)}
  }
  #[inline]
  pub fn auto_resize(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucTextElement::VT_AUTO_RESIZE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn container_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucTextElement::VT_CONTAINER_ID, None)}
  }
  #[inline]
  pub fn original_text(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucTextElement::VT_ORIGINAL_TEXT, None)}
  }
}

impl flatbuffers::Verifiable for DucTextElement<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<_DucElementBase>>("base", Self::VT_BASE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucTextStyle>>("style", Self::VT_STYLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("text", Self::VT_TEXT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DucTextDynamicPart>>>>("dynamic", Self::VT_DYNAMIC, false)?
     .visit_field::<bool>("auto_resize", Self::VT_AUTO_RESIZE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("container_id", Self::VT_CONTAINER_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("original_text", Self::VT_ORIGINAL_TEXT, false)?
     .finish();
    Ok(())
  }
}
pub struct DucTextElementArgs<'a> {
    pub base: Option<flatbuffers::WIPOffset<_DucElementBase<'a>>>,
    pub style: Option<flatbuffers::WIPOffset<DucTextStyle<'a>>>,
    pub text: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dynamic: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucTextDynamicPart<'a>>>>>,
    pub auto_resize: bool,
    pub container_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub original_text: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DucTextElementArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucTextElementArgs {
      base: None,
      style: None,
      text: None,
      dynamic: None,
      auto_resize: false,
      container_id: None,
      original_text: None,
    }
  }
}

pub struct DucTextElementBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucTextElementBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_base(&mut self, base: flatbuffers::WIPOffset<_DucElementBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_DucElementBase>>(DucTextElement::VT_BASE, base);
  }
  #[inline]
  pub fn add_style(&mut self, style: flatbuffers::WIPOffset<DucTextStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucTextStyle>>(DucTextElement::VT_STYLE, style);
  }
  #[inline]
  pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucTextElement::VT_TEXT, text);
  }
  #[inline]
  pub fn add_dynamic(&mut self, dynamic: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DucTextDynamicPart<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucTextElement::VT_DYNAMIC, dynamic);
  }
  #[inline]
  pub fn add_auto_resize(&mut self, auto_resize: bool) {
    self.fbb_.push_slot::<bool>(DucTextElement::VT_AUTO_RESIZE, auto_resize, false);
  }
  #[inline]
  pub fn add_container_id(&mut self, container_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucTextElement::VT_CONTAINER_ID, container_id);
  }
  #[inline]
  pub fn add_original_text(&mut self, original_text: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucTextElement::VT_ORIGINAL_TEXT, original_text);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucTextElementBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucTextElementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucTextElement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucTextElement<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucTextElement");
      ds.field("base", &self.base());
      ds.field("style", &self.style());
      ds.field("text", &self.text());
      ds.field("dynamic", &self.dynamic());
      ds.field("auto_resize", &self.auto_resize());
      ds.field("container_id", &self.container_id());
      ds.field("original_text", &self.original_text());
      ds.finish()
  }
}
pub enum DucLinearElementOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucLinearElement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucLinearElement<'a> {
  type Inner = DucLinearElement<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucLinearElement<'a> {
  pub const VT_LINEAR_BASE: flatbuffers::VOffsetT = 4;
  pub const VT_WIPEOUT_BELOW: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucLinearElement { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucLinearElementArgs<'args>
  ) -> flatbuffers::WIPOffset<DucLinearElement<'bldr>> {
    let mut builder = DucLinearElementBuilder::new(_fbb);
    if let Some(x) = args.linear_base { builder.add_linear_base(x); }
    builder.add_wipeout_below(args.wipeout_below);
    builder.finish()
  }


  #[inline]
  pub fn linear_base(&self) -> Option<_DucLinearElementBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<_DucLinearElementBase>>(DucLinearElement::VT_LINEAR_BASE, None)}
  }
  #[inline]
  pub fn wipeout_below(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucLinearElement::VT_WIPEOUT_BELOW, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DucLinearElement<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<_DucLinearElementBase>>("linear_base", Self::VT_LINEAR_BASE, false)?
     .visit_field::<bool>("wipeout_below", Self::VT_WIPEOUT_BELOW, false)?
     .finish();
    Ok(())
  }
}
pub struct DucLinearElementArgs<'a> {
    pub linear_base: Option<flatbuffers::WIPOffset<_DucLinearElementBase<'a>>>,
    pub wipeout_below: bool,
}
impl<'a> Default for DucLinearElementArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucLinearElementArgs {
      linear_base: None,
      wipeout_below: false,
    }
  }
}

pub struct DucLinearElementBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucLinearElementBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_linear_base(&mut self, linear_base: flatbuffers::WIPOffset<_DucLinearElementBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_DucLinearElementBase>>(DucLinearElement::VT_LINEAR_BASE, linear_base);
  }
  #[inline]
  pub fn add_wipeout_below(&mut self, wipeout_below: bool) {
    self.fbb_.push_slot::<bool>(DucLinearElement::VT_WIPEOUT_BELOW, wipeout_below, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucLinearElementBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucLinearElementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucLinearElement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucLinearElement<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucLinearElement");
      ds.field("linear_base", &self.linear_base());
      ds.field("wipeout_below", &self.wipeout_below());
      ds.finish()
  }
}
pub enum DucArrowElementOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucArrowElement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucArrowElement<'a> {
  type Inner = DucArrowElement<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucArrowElement<'a> {
  pub const VT_LINEAR_BASE: flatbuffers::VOffsetT = 4;
  pub const VT_ELBOWED: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucArrowElement { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucArrowElementArgs<'args>
  ) -> flatbuffers::WIPOffset<DucArrowElement<'bldr>> {
    let mut builder = DucArrowElementBuilder::new(_fbb);
    if let Some(x) = args.linear_base { builder.add_linear_base(x); }
    builder.add_elbowed(args.elbowed);
    builder.finish()
  }


  #[inline]
  pub fn linear_base(&self) -> Option<_DucLinearElementBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<_DucLinearElementBase>>(DucArrowElement::VT_LINEAR_BASE, None)}
  }
  #[inline]
  pub fn elbowed(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucArrowElement::VT_ELBOWED, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DucArrowElement<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<_DucLinearElementBase>>("linear_base", Self::VT_LINEAR_BASE, false)?
     .visit_field::<bool>("elbowed", Self::VT_ELBOWED, false)?
     .finish();
    Ok(())
  }
}
pub struct DucArrowElementArgs<'a> {
    pub linear_base: Option<flatbuffers::WIPOffset<_DucLinearElementBase<'a>>>,
    pub elbowed: bool,
}
impl<'a> Default for DucArrowElementArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucArrowElementArgs {
      linear_base: None,
      elbowed: false,
    }
  }
}

pub struct DucArrowElementBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucArrowElementBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_linear_base(&mut self, linear_base: flatbuffers::WIPOffset<_DucLinearElementBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_DucLinearElementBase>>(DucArrowElement::VT_LINEAR_BASE, linear_base);
  }
  #[inline]
  pub fn add_elbowed(&mut self, elbowed: bool) {
    self.fbb_.push_slot::<bool>(DucArrowElement::VT_ELBOWED, elbowed, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucArrowElementBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucArrowElementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucArrowElement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucArrowElement<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucArrowElement");
      ds.field("linear_base", &self.linear_base());
      ds.field("elbowed", &self.elbowed());
      ds.finish()
  }
}
pub enum DucFreeDrawEndsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucFreeDrawEnds<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucFreeDrawEnds<'a> {
  type Inner = DucFreeDrawEnds<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucFreeDrawEnds<'a> {
  pub const VT_CAP: flatbuffers::VOffsetT = 4;
  pub const VT_TAPER: flatbuffers::VOffsetT = 6;
  pub const VT_EASING: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucFreeDrawEnds { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucFreeDrawEndsArgs<'args>
  ) -> flatbuffers::WIPOffset<DucFreeDrawEnds<'bldr>> {
    let mut builder = DucFreeDrawEndsBuilder::new(_fbb);
    if let Some(x) = args.easing { builder.add_easing(x); }
    builder.add_taper(args.taper);
    builder.add_cap(args.cap);
    builder.finish()
  }


  #[inline]
  pub fn cap(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucFreeDrawEnds::VT_CAP, Some(false)).unwrap()}
  }
  #[inline]
  pub fn taper(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucFreeDrawEnds::VT_TAPER, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn easing(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucFreeDrawEnds::VT_EASING, None)}
  }
}

impl flatbuffers::Verifiable for DucFreeDrawEnds<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("cap", Self::VT_CAP, false)?
     .visit_field::<f32>("taper", Self::VT_TAPER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("easing", Self::VT_EASING, false)?
     .finish();
    Ok(())
  }
}
pub struct DucFreeDrawEndsArgs<'a> {
    pub cap: bool,
    pub taper: f32,
    pub easing: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DucFreeDrawEndsArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucFreeDrawEndsArgs {
      cap: false,
      taper: 0.0,
      easing: None,
    }
  }
}

pub struct DucFreeDrawEndsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucFreeDrawEndsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_cap(&mut self, cap: bool) {
    self.fbb_.push_slot::<bool>(DucFreeDrawEnds::VT_CAP, cap, false);
  }
  #[inline]
  pub fn add_taper(&mut self, taper: f32) {
    self.fbb_.push_slot::<f32>(DucFreeDrawEnds::VT_TAPER, taper, 0.0);
  }
  #[inline]
  pub fn add_easing(&mut self, easing: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucFreeDrawEnds::VT_EASING, easing);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucFreeDrawEndsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucFreeDrawEndsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucFreeDrawEnds<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucFreeDrawEnds<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucFreeDrawEnds");
      ds.field("cap", &self.cap());
      ds.field("taper", &self.taper());
      ds.field("easing", &self.easing());
      ds.finish()
  }
}
pub enum DucFreeDrawElementOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucFreeDrawElement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucFreeDrawElement<'a> {
  type Inner = DucFreeDrawElement<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucFreeDrawElement<'a> {
  pub const VT_BASE: flatbuffers::VOffsetT = 4;
  pub const VT_POINTS: flatbuffers::VOffsetT = 6;
  pub const VT_SIZE: flatbuffers::VOffsetT = 8;
  pub const VT_THINNING: flatbuffers::VOffsetT = 10;
  pub const VT_SMOOTHING: flatbuffers::VOffsetT = 12;
  pub const VT_STREAMLINE: flatbuffers::VOffsetT = 14;
  pub const VT_EASING: flatbuffers::VOffsetT = 16;
  pub const VT_START: flatbuffers::VOffsetT = 18;
  pub const VT_END: flatbuffers::VOffsetT = 20;
  pub const VT_PRESSURES: flatbuffers::VOffsetT = 22;
  pub const VT_SIMULATE_PRESSURE: flatbuffers::VOffsetT = 24;
  pub const VT_LAST_COMMITTED_POINT: flatbuffers::VOffsetT = 26;
  pub const VT_SVG_PATH: flatbuffers::VOffsetT = 28;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucFreeDrawElement { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucFreeDrawElementArgs<'args>
  ) -> flatbuffers::WIPOffset<DucFreeDrawElement<'bldr>> {
    let mut builder = DucFreeDrawElementBuilder::new(_fbb);
    builder.add_size(args.size);
    if let Some(x) = args.svg_path { builder.add_svg_path(x); }
    if let Some(x) = args.last_committed_point { builder.add_last_committed_point(x); }
    if let Some(x) = args.pressures { builder.add_pressures(x); }
    if let Some(x) = args.end { builder.add_end(x); }
    if let Some(x) = args.start { builder.add_start(x); }
    if let Some(x) = args.easing { builder.add_easing(x); }
    builder.add_streamline(args.streamline);
    builder.add_smoothing(args.smoothing);
    builder.add_thinning(args.thinning);
    if let Some(x) = args.points { builder.add_points(x); }
    if let Some(x) = args.base { builder.add_base(x); }
    builder.add_simulate_pressure(args.simulate_pressure);
    builder.finish()
  }


  #[inline]
  pub fn base(&self) -> Option<_DucElementBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<_DucElementBase>>(DucFreeDrawElement::VT_BASE, None)}
  }
  #[inline]
  pub fn points(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucPoint<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucPoint>>>>(DucFreeDrawElement::VT_POINTS, None)}
  }
  #[inline]
  pub fn size(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucFreeDrawElement::VT_SIZE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn thinning(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucFreeDrawElement::VT_THINNING, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn smoothing(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucFreeDrawElement::VT_SMOOTHING, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn streamline(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucFreeDrawElement::VT_STREAMLINE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn easing(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucFreeDrawElement::VT_EASING, None)}
  }
  #[inline]
  pub fn start(&self) -> Option<DucFreeDrawEnds<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucFreeDrawEnds>>(DucFreeDrawElement::VT_START, None)}
  }
  #[inline]
  pub fn end(&self) -> Option<DucFreeDrawEnds<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucFreeDrawEnds>>(DucFreeDrawElement::VT_END, None)}
  }
  #[inline]
  pub fn pressures(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(DucFreeDrawElement::VT_PRESSURES, None)}
  }
  #[inline]
  pub fn simulate_pressure(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucFreeDrawElement::VT_SIMULATE_PRESSURE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn last_committed_point(&self) -> Option<DucPoint<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucPoint>>(DucFreeDrawElement::VT_LAST_COMMITTED_POINT, None)}
  }
  #[inline]
  pub fn svg_path(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucFreeDrawElement::VT_SVG_PATH, None)}
  }
}

impl flatbuffers::Verifiable for DucFreeDrawElement<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<_DucElementBase>>("base", Self::VT_BASE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DucPoint>>>>("points", Self::VT_POINTS, false)?
     .visit_field::<f64>("size", Self::VT_SIZE, false)?
     .visit_field::<f32>("thinning", Self::VT_THINNING, false)?
     .visit_field::<f32>("smoothing", Self::VT_SMOOTHING, false)?
     .visit_field::<f32>("streamline", Self::VT_STREAMLINE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("easing", Self::VT_EASING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucFreeDrawEnds>>("start", Self::VT_START, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucFreeDrawEnds>>("end", Self::VT_END, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>("pressures", Self::VT_PRESSURES, false)?
     .visit_field::<bool>("simulate_pressure", Self::VT_SIMULATE_PRESSURE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucPoint>>("last_committed_point", Self::VT_LAST_COMMITTED_POINT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("svg_path", Self::VT_SVG_PATH, false)?
     .finish();
    Ok(())
  }
}
pub struct DucFreeDrawElementArgs<'a> {
    pub base: Option<flatbuffers::WIPOffset<_DucElementBase<'a>>>,
    pub points: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucPoint<'a>>>>>,
    pub size: f64,
    pub thinning: f32,
    pub smoothing: f32,
    pub streamline: f32,
    pub easing: Option<flatbuffers::WIPOffset<&'a str>>,
    pub start: Option<flatbuffers::WIPOffset<DucFreeDrawEnds<'a>>>,
    pub end: Option<flatbuffers::WIPOffset<DucFreeDrawEnds<'a>>>,
    pub pressures: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub simulate_pressure: bool,
    pub last_committed_point: Option<flatbuffers::WIPOffset<DucPoint<'a>>>,
    pub svg_path: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DucFreeDrawElementArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucFreeDrawElementArgs {
      base: None,
      points: None,
      size: 0.0,
      thinning: 0.0,
      smoothing: 0.0,
      streamline: 0.0,
      easing: None,
      start: None,
      end: None,
      pressures: None,
      simulate_pressure: false,
      last_committed_point: None,
      svg_path: None,
    }
  }
}

pub struct DucFreeDrawElementBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucFreeDrawElementBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_base(&mut self, base: flatbuffers::WIPOffset<_DucElementBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_DucElementBase>>(DucFreeDrawElement::VT_BASE, base);
  }
  #[inline]
  pub fn add_points(&mut self, points: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DucPoint<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucFreeDrawElement::VT_POINTS, points);
  }
  #[inline]
  pub fn add_size(&mut self, size: f64) {
    self.fbb_.push_slot::<f64>(DucFreeDrawElement::VT_SIZE, size, 0.0);
  }
  #[inline]
  pub fn add_thinning(&mut self, thinning: f32) {
    self.fbb_.push_slot::<f32>(DucFreeDrawElement::VT_THINNING, thinning, 0.0);
  }
  #[inline]
  pub fn add_smoothing(&mut self, smoothing: f32) {
    self.fbb_.push_slot::<f32>(DucFreeDrawElement::VT_SMOOTHING, smoothing, 0.0);
  }
  #[inline]
  pub fn add_streamline(&mut self, streamline: f32) {
    self.fbb_.push_slot::<f32>(DucFreeDrawElement::VT_STREAMLINE, streamline, 0.0);
  }
  #[inline]
  pub fn add_easing(&mut self, easing: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucFreeDrawElement::VT_EASING, easing);
  }
  #[inline]
  pub fn add_start(&mut self, start: flatbuffers::WIPOffset<DucFreeDrawEnds<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucFreeDrawEnds>>(DucFreeDrawElement::VT_START, start);
  }
  #[inline]
  pub fn add_end(&mut self, end: flatbuffers::WIPOffset<DucFreeDrawEnds<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucFreeDrawEnds>>(DucFreeDrawElement::VT_END, end);
  }
  #[inline]
  pub fn add_pressures(&mut self, pressures: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucFreeDrawElement::VT_PRESSURES, pressures);
  }
  #[inline]
  pub fn add_simulate_pressure(&mut self, simulate_pressure: bool) {
    self.fbb_.push_slot::<bool>(DucFreeDrawElement::VT_SIMULATE_PRESSURE, simulate_pressure, false);
  }
  #[inline]
  pub fn add_last_committed_point(&mut self, last_committed_point: flatbuffers::WIPOffset<DucPoint<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucPoint>>(DucFreeDrawElement::VT_LAST_COMMITTED_POINT, last_committed_point);
  }
  #[inline]
  pub fn add_svg_path(&mut self, svg_path: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucFreeDrawElement::VT_SVG_PATH, svg_path);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucFreeDrawElementBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucFreeDrawElementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucFreeDrawElement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucFreeDrawElement<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucFreeDrawElement");
      ds.field("base", &self.base());
      ds.field("points", &self.points());
      ds.field("size", &self.size());
      ds.field("thinning", &self.thinning());
      ds.field("smoothing", &self.smoothing());
      ds.field("streamline", &self.streamline());
      ds.field("easing", &self.easing());
      ds.field("start", &self.start());
      ds.field("end", &self.end());
      ds.field("pressures", &self.pressures());
      ds.field("simulate_pressure", &self.simulate_pressure());
      ds.field("last_committed_point", &self.last_committed_point());
      ds.field("svg_path", &self.svg_path());
      ds.finish()
  }
}
pub enum DucBlockAttributeDefinitionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucBlockAttributeDefinition<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucBlockAttributeDefinition<'a> {
  type Inner = DucBlockAttributeDefinition<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucBlockAttributeDefinition<'a> {
  pub const VT_TAG: flatbuffers::VOffsetT = 4;
  pub const VT_PROMPT: flatbuffers::VOffsetT = 6;
  pub const VT_DEFAULT_VALUE: flatbuffers::VOffsetT = 8;
  pub const VT_IS_CONSTANT: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucBlockAttributeDefinition { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucBlockAttributeDefinitionArgs<'args>
  ) -> flatbuffers::WIPOffset<DucBlockAttributeDefinition<'bldr>> {
    let mut builder = DucBlockAttributeDefinitionBuilder::new(_fbb);
    if let Some(x) = args.default_value { builder.add_default_value(x); }
    if let Some(x) = args.prompt { builder.add_prompt(x); }
    if let Some(x) = args.tag { builder.add_tag(x); }
    builder.add_is_constant(args.is_constant);
    builder.finish()
  }


  #[inline]
  pub fn tag(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucBlockAttributeDefinition::VT_TAG, None)}
  }
  #[inline]
  pub fn prompt(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucBlockAttributeDefinition::VT_PROMPT, None)}
  }
  #[inline]
  pub fn default_value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucBlockAttributeDefinition::VT_DEFAULT_VALUE, None)}
  }
  #[inline]
  pub fn is_constant(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucBlockAttributeDefinition::VT_IS_CONSTANT, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DucBlockAttributeDefinition<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("tag", Self::VT_TAG, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("prompt", Self::VT_PROMPT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("default_value", Self::VT_DEFAULT_VALUE, false)?
     .visit_field::<bool>("is_constant", Self::VT_IS_CONSTANT, false)?
     .finish();
    Ok(())
  }
}
pub struct DucBlockAttributeDefinitionArgs<'a> {
    pub tag: Option<flatbuffers::WIPOffset<&'a str>>,
    pub prompt: Option<flatbuffers::WIPOffset<&'a str>>,
    pub default_value: Option<flatbuffers::WIPOffset<&'a str>>,
    pub is_constant: bool,
}
impl<'a> Default for DucBlockAttributeDefinitionArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucBlockAttributeDefinitionArgs {
      tag: None,
      prompt: None,
      default_value: None,
      is_constant: false,
    }
  }
}

pub struct DucBlockAttributeDefinitionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucBlockAttributeDefinitionBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_tag(&mut self, tag: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucBlockAttributeDefinition::VT_TAG, tag);
  }
  #[inline]
  pub fn add_prompt(&mut self, prompt: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucBlockAttributeDefinition::VT_PROMPT, prompt);
  }
  #[inline]
  pub fn add_default_value(&mut self, default_value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucBlockAttributeDefinition::VT_DEFAULT_VALUE, default_value);
  }
  #[inline]
  pub fn add_is_constant(&mut self, is_constant: bool) {
    self.fbb_.push_slot::<bool>(DucBlockAttributeDefinition::VT_IS_CONSTANT, is_constant, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucBlockAttributeDefinitionBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucBlockAttributeDefinitionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucBlockAttributeDefinition<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucBlockAttributeDefinition<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucBlockAttributeDefinition");
      ds.field("tag", &self.tag());
      ds.field("prompt", &self.prompt());
      ds.field("default_value", &self.default_value());
      ds.field("is_constant", &self.is_constant());
      ds.finish()
  }
}
pub enum DucBlockAttributeDefinitionEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucBlockAttributeDefinitionEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucBlockAttributeDefinitionEntry<'a> {
  type Inner = DucBlockAttributeDefinitionEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucBlockAttributeDefinitionEntry<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucBlockAttributeDefinitionEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucBlockAttributeDefinitionEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<DucBlockAttributeDefinitionEntry<'bldr>> {
    let mut builder = DucBlockAttributeDefinitionEntryBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucBlockAttributeDefinitionEntry::VT_KEY, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &DucBlockAttributeDefinitionEntry) -> bool {
    self.key() < o.key()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.key();
    key.cmp(val)
  }
  #[inline]
  pub fn value(&self) -> Option<DucBlockAttributeDefinition<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucBlockAttributeDefinition>>(DucBlockAttributeDefinitionEntry::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for DucBlockAttributeDefinitionEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucBlockAttributeDefinition>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct DucBlockAttributeDefinitionEntryArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<DucBlockAttributeDefinition<'a>>>,
}
impl<'a> Default for DucBlockAttributeDefinitionEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucBlockAttributeDefinitionEntryArgs {
      key: None, // required field
      value: None,
    }
  }
}

pub struct DucBlockAttributeDefinitionEntryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucBlockAttributeDefinitionEntryBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucBlockAttributeDefinitionEntry::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<DucBlockAttributeDefinition<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucBlockAttributeDefinition>>(DucBlockAttributeDefinitionEntry::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucBlockAttributeDefinitionEntryBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucBlockAttributeDefinitionEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucBlockAttributeDefinitionEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, DucBlockAttributeDefinitionEntry::VT_KEY,"key");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucBlockAttributeDefinitionEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucBlockAttributeDefinitionEntry");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum DucBlockOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucBlock<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucBlock<'a> {
  type Inner = DucBlock<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucBlock<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_LABEL: flatbuffers::VOffsetT = 6;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 8;
  pub const VT_VERSION: flatbuffers::VOffsetT = 10;
  pub const VT_ELEMENTS: flatbuffers::VOffsetT = 12;
  pub const VT_ATTRIBUTE_DEFINITIONS: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucBlock { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucBlockArgs<'args>
  ) -> flatbuffers::WIPOffset<DucBlock<'bldr>> {
    let mut builder = DucBlockBuilder::new(_fbb);
    if let Some(x) = args.attribute_definitions { builder.add_attribute_definitions(x); }
    if let Some(x) = args.elements { builder.add_elements(x); }
    builder.add_version(args.version);
    if let Some(x) = args.description { builder.add_description(x); }
    if let Some(x) = args.label { builder.add_label(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucBlock::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &DucBlock) -> bool {
    self.id() < o.id()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.id();
    key.cmp(val)
  }
  #[inline]
  pub fn label(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucBlock::VT_LABEL, None)}
  }
  #[inline]
  pub fn description(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucBlock::VT_DESCRIPTION, None)}
  }
  #[inline]
  pub fn version(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DucBlock::VT_VERSION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn elements(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ElementWrapper<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ElementWrapper>>>>(DucBlock::VT_ELEMENTS, None)}
  }
  #[inline]
  pub fn attribute_definitions(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucBlockAttributeDefinitionEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucBlockAttributeDefinitionEntry>>>>(DucBlock::VT_ATTRIBUTE_DEFINITIONS, None)}
  }
}

impl flatbuffers::Verifiable for DucBlock<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("label", Self::VT_LABEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("description", Self::VT_DESCRIPTION, false)?
     .visit_field::<i32>("version", Self::VT_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ElementWrapper>>>>("elements", Self::VT_ELEMENTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DucBlockAttributeDefinitionEntry>>>>("attribute_definitions", Self::VT_ATTRIBUTE_DEFINITIONS, false)?
     .finish();
    Ok(())
  }
}
pub struct DucBlockArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub label: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub version: i32,
    pub elements: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ElementWrapper<'a>>>>>,
    pub attribute_definitions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucBlockAttributeDefinitionEntry<'a>>>>>,
}
impl<'a> Default for DucBlockArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucBlockArgs {
      id: None, // required field
      label: None,
      description: None,
      version: 0,
      elements: None,
      attribute_definitions: None,
    }
  }
}

pub struct DucBlockBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucBlockBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucBlock::VT_ID, id);
  }
  #[inline]
  pub fn add_label(&mut self, label: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucBlock::VT_LABEL, label);
  }
  #[inline]
  pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucBlock::VT_DESCRIPTION, description);
  }
  #[inline]
  pub fn add_version(&mut self, version: i32) {
    self.fbb_.push_slot::<i32>(DucBlock::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_elements(&mut self, elements: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ElementWrapper<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucBlock::VT_ELEMENTS, elements);
  }
  #[inline]
  pub fn add_attribute_definitions(&mut self, attribute_definitions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DucBlockAttributeDefinitionEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucBlock::VT_ATTRIBUTE_DEFINITIONS, attribute_definitions);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucBlockBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucBlockBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucBlock<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, DucBlock::VT_ID,"id");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucBlock<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucBlock");
      ds.field("id", &self.id());
      ds.field("label", &self.label());
      ds.field("description", &self.description());
      ds.field("version", &self.version());
      ds.field("elements", &self.elements());
      ds.field("attribute_definitions", &self.attribute_definitions());
      ds.finish()
  }
}
pub enum DucBlockDuplicationArrayOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucBlockDuplicationArray<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucBlockDuplicationArray<'a> {
  type Inner = DucBlockDuplicationArray<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucBlockDuplicationArray<'a> {
  pub const VT_ROWS: flatbuffers::VOffsetT = 4;
  pub const VT_COLS: flatbuffers::VOffsetT = 6;
  pub const VT_ROW_SPACING: flatbuffers::VOffsetT = 8;
  pub const VT_COL_SPACING: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucBlockDuplicationArray { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucBlockDuplicationArrayArgs
  ) -> flatbuffers::WIPOffset<DucBlockDuplicationArray<'bldr>> {
    let mut builder = DucBlockDuplicationArrayBuilder::new(_fbb);
    builder.add_col_spacing(args.col_spacing);
    builder.add_row_spacing(args.row_spacing);
    builder.add_cols(args.cols);
    builder.add_rows(args.rows);
    builder.finish()
  }


  #[inline]
  pub fn rows(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DucBlockDuplicationArray::VT_ROWS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn cols(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DucBlockDuplicationArray::VT_COLS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn row_spacing(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucBlockDuplicationArray::VT_ROW_SPACING, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn col_spacing(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucBlockDuplicationArray::VT_COL_SPACING, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DucBlockDuplicationArray<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("rows", Self::VT_ROWS, false)?
     .visit_field::<i32>("cols", Self::VT_COLS, false)?
     .visit_field::<f64>("row_spacing", Self::VT_ROW_SPACING, false)?
     .visit_field::<f64>("col_spacing", Self::VT_COL_SPACING, false)?
     .finish();
    Ok(())
  }
}
pub struct DucBlockDuplicationArrayArgs {
    pub rows: i32,
    pub cols: i32,
    pub row_spacing: f64,
    pub col_spacing: f64,
}
impl<'a> Default for DucBlockDuplicationArrayArgs {
  #[inline]
  fn default() -> Self {
    DucBlockDuplicationArrayArgs {
      rows: 0,
      cols: 0,
      row_spacing: 0.0,
      col_spacing: 0.0,
    }
  }
}

pub struct DucBlockDuplicationArrayBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucBlockDuplicationArrayBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_rows(&mut self, rows: i32) {
    self.fbb_.push_slot::<i32>(DucBlockDuplicationArray::VT_ROWS, rows, 0);
  }
  #[inline]
  pub fn add_cols(&mut self, cols: i32) {
    self.fbb_.push_slot::<i32>(DucBlockDuplicationArray::VT_COLS, cols, 0);
  }
  #[inline]
  pub fn add_row_spacing(&mut self, row_spacing: f64) {
    self.fbb_.push_slot::<f64>(DucBlockDuplicationArray::VT_ROW_SPACING, row_spacing, 0.0);
  }
  #[inline]
  pub fn add_col_spacing(&mut self, col_spacing: f64) {
    self.fbb_.push_slot::<f64>(DucBlockDuplicationArray::VT_COL_SPACING, col_spacing, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucBlockDuplicationArrayBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucBlockDuplicationArrayBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucBlockDuplicationArray<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucBlockDuplicationArray<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucBlockDuplicationArray");
      ds.field("rows", &self.rows());
      ds.field("cols", &self.cols());
      ds.field("row_spacing", &self.row_spacing());
      ds.field("col_spacing", &self.col_spacing());
      ds.finish()
  }
}
pub enum DucBlockInstanceElementOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucBlockInstanceElement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucBlockInstanceElement<'a> {
  type Inner = DucBlockInstanceElement<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucBlockInstanceElement<'a> {
  pub const VT_BASE: flatbuffers::VOffsetT = 4;
  pub const VT_BLOCK_ID: flatbuffers::VOffsetT = 6;
  pub const VT_ELEMENT_OVERRIDES: flatbuffers::VOffsetT = 8;
  pub const VT_ATTRIBUTE_VALUES: flatbuffers::VOffsetT = 10;
  pub const VT_DUPLICATION_ARRAY: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucBlockInstanceElement { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucBlockInstanceElementArgs<'args>
  ) -> flatbuffers::WIPOffset<DucBlockInstanceElement<'bldr>> {
    let mut builder = DucBlockInstanceElementBuilder::new(_fbb);
    if let Some(x) = args.duplication_array { builder.add_duplication_array(x); }
    if let Some(x) = args.attribute_values { builder.add_attribute_values(x); }
    if let Some(x) = args.element_overrides { builder.add_element_overrides(x); }
    if let Some(x) = args.block_id { builder.add_block_id(x); }
    if let Some(x) = args.base { builder.add_base(x); }
    builder.finish()
  }


  #[inline]
  pub fn base(&self) -> Option<_DucElementBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<_DucElementBase>>(DucBlockInstanceElement::VT_BASE, None)}
  }
  #[inline]
  pub fn block_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucBlockInstanceElement::VT_BLOCK_ID, None)}
  }
  #[inline]
  pub fn element_overrides(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringValueEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringValueEntry>>>>(DucBlockInstanceElement::VT_ELEMENT_OVERRIDES, None)}
  }
  #[inline]
  pub fn attribute_values(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringValueEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringValueEntry>>>>(DucBlockInstanceElement::VT_ATTRIBUTE_VALUES, None)}
  }
  #[inline]
  pub fn duplication_array(&self) -> Option<DucBlockDuplicationArray<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucBlockDuplicationArray>>(DucBlockInstanceElement::VT_DUPLICATION_ARRAY, None)}
  }
}

impl flatbuffers::Verifiable for DucBlockInstanceElement<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<_DucElementBase>>("base", Self::VT_BASE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("block_id", Self::VT_BLOCK_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<StringValueEntry>>>>("element_overrides", Self::VT_ELEMENT_OVERRIDES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<StringValueEntry>>>>("attribute_values", Self::VT_ATTRIBUTE_VALUES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucBlockDuplicationArray>>("duplication_array", Self::VT_DUPLICATION_ARRAY, false)?
     .finish();
    Ok(())
  }
}
pub struct DucBlockInstanceElementArgs<'a> {
    pub base: Option<flatbuffers::WIPOffset<_DucElementBase<'a>>>,
    pub block_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub element_overrides: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringValueEntry<'a>>>>>,
    pub attribute_values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringValueEntry<'a>>>>>,
    pub duplication_array: Option<flatbuffers::WIPOffset<DucBlockDuplicationArray<'a>>>,
}
impl<'a> Default for DucBlockInstanceElementArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucBlockInstanceElementArgs {
      base: None,
      block_id: None,
      element_overrides: None,
      attribute_values: None,
      duplication_array: None,
    }
  }
}

pub struct DucBlockInstanceElementBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucBlockInstanceElementBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_base(&mut self, base: flatbuffers::WIPOffset<_DucElementBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_DucElementBase>>(DucBlockInstanceElement::VT_BASE, base);
  }
  #[inline]
  pub fn add_block_id(&mut self, block_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucBlockInstanceElement::VT_BLOCK_ID, block_id);
  }
  #[inline]
  pub fn add_element_overrides(&mut self, element_overrides: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<StringValueEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucBlockInstanceElement::VT_ELEMENT_OVERRIDES, element_overrides);
  }
  #[inline]
  pub fn add_attribute_values(&mut self, attribute_values: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<StringValueEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucBlockInstanceElement::VT_ATTRIBUTE_VALUES, attribute_values);
  }
  #[inline]
  pub fn add_duplication_array(&mut self, duplication_array: flatbuffers::WIPOffset<DucBlockDuplicationArray<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucBlockDuplicationArray>>(DucBlockInstanceElement::VT_DUPLICATION_ARRAY, duplication_array);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucBlockInstanceElementBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucBlockInstanceElementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucBlockInstanceElement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucBlockInstanceElement<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucBlockInstanceElement");
      ds.field("base", &self.base());
      ds.field("block_id", &self.block_id());
      ds.field("element_overrides", &self.element_overrides());
      ds.field("attribute_values", &self.attribute_values());
      ds.field("duplication_array", &self.duplication_array());
      ds.finish()
  }
}
pub enum DucFrameElementOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucFrameElement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucFrameElement<'a> {
  type Inner = DucFrameElement<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucFrameElement<'a> {
  pub const VT_STACK_ELEMENT_BASE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucFrameElement { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucFrameElementArgs<'args>
  ) -> flatbuffers::WIPOffset<DucFrameElement<'bldr>> {
    let mut builder = DucFrameElementBuilder::new(_fbb);
    if let Some(x) = args.stack_element_base { builder.add_stack_element_base(x); }
    builder.finish()
  }


  #[inline]
  pub fn stack_element_base(&self) -> Option<_DucStackElementBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<_DucStackElementBase>>(DucFrameElement::VT_STACK_ELEMENT_BASE, None)}
  }
}

impl flatbuffers::Verifiable for DucFrameElement<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<_DucStackElementBase>>("stack_element_base", Self::VT_STACK_ELEMENT_BASE, false)?
     .finish();
    Ok(())
  }
}
pub struct DucFrameElementArgs<'a> {
    pub stack_element_base: Option<flatbuffers::WIPOffset<_DucStackElementBase<'a>>>,
}
impl<'a> Default for DucFrameElementArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucFrameElementArgs {
      stack_element_base: None,
    }
  }
}

pub struct DucFrameElementBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucFrameElementBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_stack_element_base(&mut self, stack_element_base: flatbuffers::WIPOffset<_DucStackElementBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_DucStackElementBase>>(DucFrameElement::VT_STACK_ELEMENT_BASE, stack_element_base);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucFrameElementBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucFrameElementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucFrameElement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucFrameElement<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucFrameElement");
      ds.field("stack_element_base", &self.stack_element_base());
      ds.finish()
  }
}
pub enum PlotLayoutOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PlotLayout<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PlotLayout<'a> {
  type Inner = PlotLayout<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PlotLayout<'a> {
  pub const VT_MARGINS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PlotLayout { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PlotLayoutArgs<'args>
  ) -> flatbuffers::WIPOffset<PlotLayout<'bldr>> {
    let mut builder = PlotLayoutBuilder::new(_fbb);
    if let Some(x) = args.margins { builder.add_margins(x); }
    builder.finish()
  }


  #[inline]
  pub fn margins(&self) -> Option<Margins<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Margins>>(PlotLayout::VT_MARGINS, None)}
  }
}

impl flatbuffers::Verifiable for PlotLayout<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Margins>>("margins", Self::VT_MARGINS, false)?
     .finish();
    Ok(())
  }
}
pub struct PlotLayoutArgs<'a> {
    pub margins: Option<flatbuffers::WIPOffset<Margins<'a>>>,
}
impl<'a> Default for PlotLayoutArgs<'a> {
  #[inline]
  fn default() -> Self {
    PlotLayoutArgs {
      margins: None,
    }
  }
}

pub struct PlotLayoutBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PlotLayoutBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_margins(&mut self, margins: flatbuffers::WIPOffset<Margins<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Margins>>(PlotLayout::VT_MARGINS, margins);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PlotLayoutBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PlotLayoutBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PlotLayout<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PlotLayout<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PlotLayout");
      ds.field("margins", &self.margins());
      ds.finish()
  }
}
pub enum DucPlotElementOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucPlotElement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucPlotElement<'a> {
  type Inner = DucPlotElement<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucPlotElement<'a> {
  pub const VT_STACK_ELEMENT_BASE: flatbuffers::VOffsetT = 4;
  pub const VT_STYLE: flatbuffers::VOffsetT = 6;
  pub const VT_LAYOUT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucPlotElement { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucPlotElementArgs<'args>
  ) -> flatbuffers::WIPOffset<DucPlotElement<'bldr>> {
    let mut builder = DucPlotElementBuilder::new(_fbb);
    if let Some(x) = args.layout { builder.add_layout(x); }
    if let Some(x) = args.style { builder.add_style(x); }
    if let Some(x) = args.stack_element_base { builder.add_stack_element_base(x); }
    builder.finish()
  }


  #[inline]
  pub fn stack_element_base(&self) -> Option<_DucStackElementBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<_DucStackElementBase>>(DucPlotElement::VT_STACK_ELEMENT_BASE, None)}
  }
  #[inline]
  pub fn style(&self) -> Option<DucPlotStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucPlotStyle>>(DucPlotElement::VT_STYLE, None)}
  }
  #[inline]
  pub fn layout(&self) -> Option<PlotLayout<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<PlotLayout>>(DucPlotElement::VT_LAYOUT, None)}
  }
}

impl flatbuffers::Verifiable for DucPlotElement<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<_DucStackElementBase>>("stack_element_base", Self::VT_STACK_ELEMENT_BASE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucPlotStyle>>("style", Self::VT_STYLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<PlotLayout>>("layout", Self::VT_LAYOUT, false)?
     .finish();
    Ok(())
  }
}
pub struct DucPlotElementArgs<'a> {
    pub stack_element_base: Option<flatbuffers::WIPOffset<_DucStackElementBase<'a>>>,
    pub style: Option<flatbuffers::WIPOffset<DucPlotStyle<'a>>>,
    pub layout: Option<flatbuffers::WIPOffset<PlotLayout<'a>>>,
}
impl<'a> Default for DucPlotElementArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucPlotElementArgs {
      stack_element_base: None,
      style: None,
      layout: None,
    }
  }
}

pub struct DucPlotElementBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucPlotElementBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_stack_element_base(&mut self, stack_element_base: flatbuffers::WIPOffset<_DucStackElementBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_DucStackElementBase>>(DucPlotElement::VT_STACK_ELEMENT_BASE, stack_element_base);
  }
  #[inline]
  pub fn add_style(&mut self, style: flatbuffers::WIPOffset<DucPlotStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucPlotStyle>>(DucPlotElement::VT_STYLE, style);
  }
  #[inline]
  pub fn add_layout(&mut self, layout: flatbuffers::WIPOffset<PlotLayout<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PlotLayout>>(DucPlotElement::VT_LAYOUT, layout);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucPlotElementBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucPlotElementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucPlotElement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucPlotElement<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucPlotElement");
      ds.field("stack_element_base", &self.stack_element_base());
      ds.field("style", &self.style());
      ds.field("layout", &self.layout());
      ds.finish()
  }
}
pub enum DucViewportElementOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucViewportElement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucViewportElement<'a> {
  type Inner = DucViewportElement<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucViewportElement<'a> {
  pub const VT_LINEAR_BASE: flatbuffers::VOffsetT = 4;
  pub const VT_STACK_BASE: flatbuffers::VOffsetT = 6;
  pub const VT_STYLE: flatbuffers::VOffsetT = 8;
  pub const VT_VIEW: flatbuffers::VOffsetT = 10;
  pub const VT_SCALE: flatbuffers::VOffsetT = 12;
  pub const VT_SHADE_PLOT: flatbuffers::VOffsetT = 14;
  pub const VT_FROZEN_GROUP_IDS: flatbuffers::VOffsetT = 16;
  pub const VT_STANDARD_OVERRIDE: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucViewportElement { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucViewportElementArgs<'args>
  ) -> flatbuffers::WIPOffset<DucViewportElement<'bldr>> {
    let mut builder = DucViewportElementBuilder::new(_fbb);
    if let Some(x) = args.standard_override { builder.add_standard_override(x); }
    if let Some(x) = args.frozen_group_ids { builder.add_frozen_group_ids(x); }
    builder.add_scale(args.scale);
    if let Some(x) = args.view { builder.add_view(x); }
    if let Some(x) = args.style { builder.add_style(x); }
    if let Some(x) = args.stack_base { builder.add_stack_base(x); }
    if let Some(x) = args.linear_base { builder.add_linear_base(x); }
    if let Some(x) = args.shade_plot { builder.add_shade_plot(x); }
    builder.finish()
  }


  #[inline]
  pub fn linear_base(&self) -> Option<_DucLinearElementBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<_DucLinearElementBase>>(DucViewportElement::VT_LINEAR_BASE, None)}
  }
  #[inline]
  pub fn stack_base(&self) -> Option<_DucStackBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<_DucStackBase>>(DucViewportElement::VT_STACK_BASE, None)}
  }
  #[inline]
  pub fn style(&self) -> Option<DucViewportStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucViewportStyle>>(DucViewportElement::VT_STYLE, None)}
  }
  #[inline]
  pub fn view(&self) -> Option<DucView<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucView>>(DucViewportElement::VT_VIEW, None)}
  }
  #[inline]
  pub fn scale(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucViewportElement::VT_SCALE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn shade_plot(&self) -> Option<VIEWPORT_SHADE_PLOT> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<VIEWPORT_SHADE_PLOT>(DucViewportElement::VT_SHADE_PLOT, None)}
  }
  #[inline]
  pub fn frozen_group_ids(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(DucViewportElement::VT_FROZEN_GROUP_IDS, None)}
  }
  #[inline]
  pub fn standard_override(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucViewportElement::VT_STANDARD_OVERRIDE, None)}
  }
}

impl flatbuffers::Verifiable for DucViewportElement<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<_DucLinearElementBase>>("linear_base", Self::VT_LINEAR_BASE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<_DucStackBase>>("stack_base", Self::VT_STACK_BASE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucViewportStyle>>("style", Self::VT_STYLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucView>>("view", Self::VT_VIEW, false)?
     .visit_field::<f32>("scale", Self::VT_SCALE, false)?
     .visit_field::<VIEWPORT_SHADE_PLOT>("shade_plot", Self::VT_SHADE_PLOT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("frozen_group_ids", Self::VT_FROZEN_GROUP_IDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("standard_override", Self::VT_STANDARD_OVERRIDE, false)?
     .finish();
    Ok(())
  }
}
pub struct DucViewportElementArgs<'a> {
    pub linear_base: Option<flatbuffers::WIPOffset<_DucLinearElementBase<'a>>>,
    pub stack_base: Option<flatbuffers::WIPOffset<_DucStackBase<'a>>>,
    pub style: Option<flatbuffers::WIPOffset<DucViewportStyle<'a>>>,
    pub view: Option<flatbuffers::WIPOffset<DucView<'a>>>,
    pub scale: f32,
    pub shade_plot: Option<VIEWPORT_SHADE_PLOT>,
    pub frozen_group_ids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub standard_override: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DucViewportElementArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucViewportElementArgs {
      linear_base: None,
      stack_base: None,
      style: None,
      view: None,
      scale: 0.0,
      shade_plot: None,
      frozen_group_ids: None,
      standard_override: None,
    }
  }
}

pub struct DucViewportElementBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucViewportElementBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_linear_base(&mut self, linear_base: flatbuffers::WIPOffset<_DucLinearElementBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_DucLinearElementBase>>(DucViewportElement::VT_LINEAR_BASE, linear_base);
  }
  #[inline]
  pub fn add_stack_base(&mut self, stack_base: flatbuffers::WIPOffset<_DucStackBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_DucStackBase>>(DucViewportElement::VT_STACK_BASE, stack_base);
  }
  #[inline]
  pub fn add_style(&mut self, style: flatbuffers::WIPOffset<DucViewportStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucViewportStyle>>(DucViewportElement::VT_STYLE, style);
  }
  #[inline]
  pub fn add_view(&mut self, view: flatbuffers::WIPOffset<DucView<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucView>>(DucViewportElement::VT_VIEW, view);
  }
  #[inline]
  pub fn add_scale(&mut self, scale: f32) {
    self.fbb_.push_slot::<f32>(DucViewportElement::VT_SCALE, scale, 0.0);
  }
  #[inline]
  pub fn add_shade_plot(&mut self, shade_plot: VIEWPORT_SHADE_PLOT) {
    self.fbb_.push_slot_always::<VIEWPORT_SHADE_PLOT>(DucViewportElement::VT_SHADE_PLOT, shade_plot);
  }
  #[inline]
  pub fn add_frozen_group_ids(&mut self, frozen_group_ids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucViewportElement::VT_FROZEN_GROUP_IDS, frozen_group_ids);
  }
  #[inline]
  pub fn add_standard_override(&mut self, standard_override: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucViewportElement::VT_STANDARD_OVERRIDE, standard_override);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucViewportElementBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucViewportElementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucViewportElement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucViewportElement<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucViewportElement");
      ds.field("linear_base", &self.linear_base());
      ds.field("stack_base", &self.stack_base());
      ds.field("style", &self.style());
      ds.field("view", &self.view());
      ds.field("scale", &self.scale());
      ds.field("shade_plot", &self.shade_plot());
      ds.field("frozen_group_ids", &self.frozen_group_ids());
      ds.field("standard_override", &self.standard_override());
      ds.finish()
  }
}
pub enum DucXRayElementOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucXRayElement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucXRayElement<'a> {
  type Inner = DucXRayElement<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucXRayElement<'a> {
  pub const VT_BASE: flatbuffers::VOffsetT = 4;
  pub const VT_STYLE: flatbuffers::VOffsetT = 6;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 8;
  pub const VT_DIRECTION: flatbuffers::VOffsetT = 10;
  pub const VT_START_FROM_ORIGIN: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucXRayElement { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucXRayElementArgs<'args>
  ) -> flatbuffers::WIPOffset<DucXRayElement<'bldr>> {
    let mut builder = DucXRayElementBuilder::new(_fbb);
    if let Some(x) = args.direction { builder.add_direction(x); }
    if let Some(x) = args.origin { builder.add_origin(x); }
    if let Some(x) = args.style { builder.add_style(x); }
    if let Some(x) = args.base { builder.add_base(x); }
    builder.add_start_from_origin(args.start_from_origin);
    builder.finish()
  }


  #[inline]
  pub fn base(&self) -> Option<_DucElementBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<_DucElementBase>>(DucXRayElement::VT_BASE, None)}
  }
  #[inline]
  pub fn style(&self) -> Option<DucXRayStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucXRayStyle>>(DucXRayElement::VT_STYLE, None)}
  }
  #[inline]
  pub fn origin(&self) -> Option<DucPoint<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucPoint>>(DucXRayElement::VT_ORIGIN, None)}
  }
  #[inline]
  pub fn direction(&self) -> Option<DucPoint<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucPoint>>(DucXRayElement::VT_DIRECTION, None)}
  }
  #[inline]
  pub fn start_from_origin(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucXRayElement::VT_START_FROM_ORIGIN, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DucXRayElement<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<_DucElementBase>>("base", Self::VT_BASE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucXRayStyle>>("style", Self::VT_STYLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucPoint>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucPoint>>("direction", Self::VT_DIRECTION, false)?
     .visit_field::<bool>("start_from_origin", Self::VT_START_FROM_ORIGIN, false)?
     .finish();
    Ok(())
  }
}
pub struct DucXRayElementArgs<'a> {
    pub base: Option<flatbuffers::WIPOffset<_DucElementBase<'a>>>,
    pub style: Option<flatbuffers::WIPOffset<DucXRayStyle<'a>>>,
    pub origin: Option<flatbuffers::WIPOffset<DucPoint<'a>>>,
    pub direction: Option<flatbuffers::WIPOffset<DucPoint<'a>>>,
    pub start_from_origin: bool,
}
impl<'a> Default for DucXRayElementArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucXRayElementArgs {
      base: None,
      style: None,
      origin: None,
      direction: None,
      start_from_origin: false,
    }
  }
}

pub struct DucXRayElementBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucXRayElementBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_base(&mut self, base: flatbuffers::WIPOffset<_DucElementBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_DucElementBase>>(DucXRayElement::VT_BASE, base);
  }
  #[inline]
  pub fn add_style(&mut self, style: flatbuffers::WIPOffset<DucXRayStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucXRayStyle>>(DucXRayElement::VT_STYLE, style);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<DucPoint<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucPoint>>(DucXRayElement::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_direction(&mut self, direction: flatbuffers::WIPOffset<DucPoint<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucPoint>>(DucXRayElement::VT_DIRECTION, direction);
  }
  #[inline]
  pub fn add_start_from_origin(&mut self, start_from_origin: bool) {
    self.fbb_.push_slot::<bool>(DucXRayElement::VT_START_FROM_ORIGIN, start_from_origin, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucXRayElementBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucXRayElementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucXRayElement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucXRayElement<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucXRayElement");
      ds.field("base", &self.base());
      ds.field("style", &self.style());
      ds.field("origin", &self.origin());
      ds.field("direction", &self.direction());
      ds.field("start_from_origin", &self.start_from_origin());
      ds.finish()
  }
}
pub enum LeaderTextBlockContentOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LeaderTextBlockContent<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LeaderTextBlockContent<'a> {
  type Inner = LeaderTextBlockContent<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LeaderTextBlockContent<'a> {
  pub const VT_TEXT: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LeaderTextBlockContent { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LeaderTextBlockContentArgs<'args>
  ) -> flatbuffers::WIPOffset<LeaderTextBlockContent<'bldr>> {
    let mut builder = LeaderTextBlockContentBuilder::new(_fbb);
    if let Some(x) = args.text { builder.add_text(x); }
    builder.finish()
  }


  #[inline]
  pub fn text(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LeaderTextBlockContent::VT_TEXT, None)}
  }
}

impl flatbuffers::Verifiable for LeaderTextBlockContent<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("text", Self::VT_TEXT, false)?
     .finish();
    Ok(())
  }
}
pub struct LeaderTextBlockContentArgs<'a> {
    pub text: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for LeaderTextBlockContentArgs<'a> {
  #[inline]
  fn default() -> Self {
    LeaderTextBlockContentArgs {
      text: None,
    }
  }
}

pub struct LeaderTextBlockContentBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LeaderTextBlockContentBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LeaderTextBlockContent::VT_TEXT, text);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LeaderTextBlockContentBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LeaderTextBlockContentBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LeaderTextBlockContent<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LeaderTextBlockContent<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LeaderTextBlockContent");
      ds.field("text", &self.text());
      ds.finish()
  }
}
pub enum LeaderBlockContentOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LeaderBlockContent<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LeaderBlockContent<'a> {
  type Inner = LeaderBlockContent<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LeaderBlockContent<'a> {
  pub const VT_BLOCK_ID: flatbuffers::VOffsetT = 4;
  pub const VT_ATTRIBUTE_VALUES: flatbuffers::VOffsetT = 6;
  pub const VT_ELEMENT_OVERRIDES: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LeaderBlockContent { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LeaderBlockContentArgs<'args>
  ) -> flatbuffers::WIPOffset<LeaderBlockContent<'bldr>> {
    let mut builder = LeaderBlockContentBuilder::new(_fbb);
    if let Some(x) = args.element_overrides { builder.add_element_overrides(x); }
    if let Some(x) = args.attribute_values { builder.add_attribute_values(x); }
    if let Some(x) = args.block_id { builder.add_block_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn block_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LeaderBlockContent::VT_BLOCK_ID, None)}
  }
  #[inline]
  pub fn attribute_values(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringValueEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringValueEntry>>>>(LeaderBlockContent::VT_ATTRIBUTE_VALUES, None)}
  }
  #[inline]
  pub fn element_overrides(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringValueEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringValueEntry>>>>(LeaderBlockContent::VT_ELEMENT_OVERRIDES, None)}
  }
}

impl flatbuffers::Verifiable for LeaderBlockContent<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("block_id", Self::VT_BLOCK_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<StringValueEntry>>>>("attribute_values", Self::VT_ATTRIBUTE_VALUES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<StringValueEntry>>>>("element_overrides", Self::VT_ELEMENT_OVERRIDES, false)?
     .finish();
    Ok(())
  }
}
pub struct LeaderBlockContentArgs<'a> {
    pub block_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub attribute_values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringValueEntry<'a>>>>>,
    pub element_overrides: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<StringValueEntry<'a>>>>>,
}
impl<'a> Default for LeaderBlockContentArgs<'a> {
  #[inline]
  fn default() -> Self {
    LeaderBlockContentArgs {
      block_id: None,
      attribute_values: None,
      element_overrides: None,
    }
  }
}

pub struct LeaderBlockContentBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LeaderBlockContentBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_block_id(&mut self, block_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LeaderBlockContent::VT_BLOCK_ID, block_id);
  }
  #[inline]
  pub fn add_attribute_values(&mut self, attribute_values: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<StringValueEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LeaderBlockContent::VT_ATTRIBUTE_VALUES, attribute_values);
  }
  #[inline]
  pub fn add_element_overrides(&mut self, element_overrides: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<StringValueEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LeaderBlockContent::VT_ELEMENT_OVERRIDES, element_overrides);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LeaderBlockContentBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LeaderBlockContentBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LeaderBlockContent<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LeaderBlockContent<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LeaderBlockContent");
      ds.field("block_id", &self.block_id());
      ds.field("attribute_values", &self.attribute_values());
      ds.field("element_overrides", &self.element_overrides());
      ds.finish()
  }
}
pub enum LeaderContentOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LeaderContent<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LeaderContent<'a> {
  type Inner = LeaderContent<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LeaderContent<'a> {
  pub const VT_LEADER_CONTENT_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_CONTENT_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_CONTENT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LeaderContent { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LeaderContentArgs
  ) -> flatbuffers::WIPOffset<LeaderContent<'bldr>> {
    let mut builder = LeaderContentBuilder::new(_fbb);
    if let Some(x) = args.content { builder.add_content(x); }
    builder.add_content_type(args.content_type);
    if let Some(x) = args.leader_content_type { builder.add_leader_content_type(x); }
    builder.finish()
  }


  #[inline]
  pub fn leader_content_type(&self) -> Option<LEADER_CONTENT_TYPE> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<LEADER_CONTENT_TYPE>(LeaderContent::VT_LEADER_CONTENT_TYPE, None)}
  }
  #[inline]
  pub fn content_type(&self) -> LeaderContentData {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<LeaderContentData>(LeaderContent::VT_CONTENT_TYPE, Some(LeaderContentData::NONE)).unwrap()}
  }
  #[inline]
  pub fn content(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(LeaderContent::VT_CONTENT, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_leader_text_block_content(&self) -> Option<LeaderTextBlockContent<'a>> {
    if self.content_type() == LeaderContentData::LeaderTextBlockContent {
      self.content().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { LeaderTextBlockContent::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_leader_block_content(&self) -> Option<LeaderBlockContent<'a>> {
    if self.content_type() == LeaderContentData::LeaderBlockContent {
      self.content().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { LeaderBlockContent::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for LeaderContent<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<LEADER_CONTENT_TYPE>("leader_content_type", Self::VT_LEADER_CONTENT_TYPE, false)?
     .visit_union::<LeaderContentData, _>("content_type", Self::VT_CONTENT_TYPE, "content", Self::VT_CONTENT, false, |key, v, pos| {
        match key {
          LeaderContentData::LeaderTextBlockContent => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LeaderTextBlockContent>>("LeaderContentData::LeaderTextBlockContent", pos),
          LeaderContentData::LeaderBlockContent => v.verify_union_variant::<flatbuffers::ForwardsUOffset<LeaderBlockContent>>("LeaderContentData::LeaderBlockContent", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct LeaderContentArgs {
    pub leader_content_type: Option<LEADER_CONTENT_TYPE>,
    pub content_type: LeaderContentData,
    pub content: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for LeaderContentArgs {
  #[inline]
  fn default() -> Self {
    LeaderContentArgs {
      leader_content_type: None,
      content_type: LeaderContentData::NONE,
      content: None,
    }
  }
}

pub struct LeaderContentBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LeaderContentBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_leader_content_type(&mut self, leader_content_type: LEADER_CONTENT_TYPE) {
    self.fbb_.push_slot_always::<LEADER_CONTENT_TYPE>(LeaderContent::VT_LEADER_CONTENT_TYPE, leader_content_type);
  }
  #[inline]
  pub fn add_content_type(&mut self, content_type: LeaderContentData) {
    self.fbb_.push_slot::<LeaderContentData>(LeaderContent::VT_CONTENT_TYPE, content_type, LeaderContentData::NONE);
  }
  #[inline]
  pub fn add_content(&mut self, content: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LeaderContent::VT_CONTENT, content);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LeaderContentBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LeaderContentBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LeaderContent<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LeaderContent<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LeaderContent");
      ds.field("leader_content_type", &self.leader_content_type());
      ds.field("content_type", &self.content_type());
      match self.content_type() {
        LeaderContentData::LeaderTextBlockContent => {
          if let Some(x) = self.content_as_leader_text_block_content() {
            ds.field("content", &x)
          } else {
            ds.field("content", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        LeaderContentData::LeaderBlockContent => {
          if let Some(x) = self.content_as_leader_block_content() {
            ds.field("content", &x)
          } else {
            ds.field("content", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("content", &x)
        },
      };
      ds.finish()
  }
}
pub enum DucLeaderElementOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucLeaderElement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucLeaderElement<'a> {
  type Inner = DucLeaderElement<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucLeaderElement<'a> {
  pub const VT_LINEAR_BASE: flatbuffers::VOffsetT = 4;
  pub const VT_STYLE: flatbuffers::VOffsetT = 6;
  pub const VT_CONTENT: flatbuffers::VOffsetT = 8;
  pub const VT_CONTENT_ANCHOR: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucLeaderElement { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucLeaderElementArgs<'args>
  ) -> flatbuffers::WIPOffset<DucLeaderElement<'bldr>> {
    let mut builder = DucLeaderElementBuilder::new(_fbb);
    if let Some(x) = args.content_anchor { builder.add_content_anchor(x); }
    if let Some(x) = args.content { builder.add_content(x); }
    if let Some(x) = args.style { builder.add_style(x); }
    if let Some(x) = args.linear_base { builder.add_linear_base(x); }
    builder.finish()
  }


  #[inline]
  pub fn linear_base(&self) -> Option<_DucLinearElementBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<_DucLinearElementBase>>(DucLeaderElement::VT_LINEAR_BASE, None)}
  }
  #[inline]
  pub fn style(&self) -> Option<DucLeaderStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucLeaderStyle>>(DucLeaderElement::VT_STYLE, None)}
  }
  #[inline]
  pub fn content(&self) -> Option<LeaderContent<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<LeaderContent>>(DucLeaderElement::VT_CONTENT, None)}
  }
  #[inline]
  pub fn content_anchor(&self) -> Option<&'a GeometricPoint> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<GeometricPoint>(DucLeaderElement::VT_CONTENT_ANCHOR, None)}
  }
}

impl flatbuffers::Verifiable for DucLeaderElement<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<_DucLinearElementBase>>("linear_base", Self::VT_LINEAR_BASE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucLeaderStyle>>("style", Self::VT_STYLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<LeaderContent>>("content", Self::VT_CONTENT, false)?
     .visit_field::<GeometricPoint>("content_anchor", Self::VT_CONTENT_ANCHOR, false)?
     .finish();
    Ok(())
  }
}
pub struct DucLeaderElementArgs<'a> {
    pub linear_base: Option<flatbuffers::WIPOffset<_DucLinearElementBase<'a>>>,
    pub style: Option<flatbuffers::WIPOffset<DucLeaderStyle<'a>>>,
    pub content: Option<flatbuffers::WIPOffset<LeaderContent<'a>>>,
    pub content_anchor: Option<&'a GeometricPoint>,
}
impl<'a> Default for DucLeaderElementArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucLeaderElementArgs {
      linear_base: None,
      style: None,
      content: None,
      content_anchor: None,
    }
  }
}

pub struct DucLeaderElementBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucLeaderElementBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_linear_base(&mut self, linear_base: flatbuffers::WIPOffset<_DucLinearElementBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_DucLinearElementBase>>(DucLeaderElement::VT_LINEAR_BASE, linear_base);
  }
  #[inline]
  pub fn add_style(&mut self, style: flatbuffers::WIPOffset<DucLeaderStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucLeaderStyle>>(DucLeaderElement::VT_STYLE, style);
  }
  #[inline]
  pub fn add_content(&mut self, content: flatbuffers::WIPOffset<LeaderContent<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<LeaderContent>>(DucLeaderElement::VT_CONTENT, content);
  }
  #[inline]
  pub fn add_content_anchor(&mut self, content_anchor: &GeometricPoint) {
    self.fbb_.push_slot_always::<&GeometricPoint>(DucLeaderElement::VT_CONTENT_ANCHOR, content_anchor);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucLeaderElementBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucLeaderElementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucLeaderElement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucLeaderElement<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucLeaderElement");
      ds.field("linear_base", &self.linear_base());
      ds.field("style", &self.style());
      ds.field("content", &self.content());
      ds.field("content_anchor", &self.content_anchor());
      ds.finish()
  }
}
pub enum DimensionDefinitionPointsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DimensionDefinitionPoints<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DimensionDefinitionPoints<'a> {
  type Inner = DimensionDefinitionPoints<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DimensionDefinitionPoints<'a> {
  pub const VT_ORIGIN1: flatbuffers::VOffsetT = 4;
  pub const VT_ORIGIN2: flatbuffers::VOffsetT = 6;
  pub const VT_LOCATION: flatbuffers::VOffsetT = 8;
  pub const VT_CENTER: flatbuffers::VOffsetT = 10;
  pub const VT_JOG: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DimensionDefinitionPoints { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DimensionDefinitionPointsArgs<'args>
  ) -> flatbuffers::WIPOffset<DimensionDefinitionPoints<'bldr>> {
    let mut builder = DimensionDefinitionPointsBuilder::new(_fbb);
    if let Some(x) = args.jog { builder.add_jog(x); }
    if let Some(x) = args.center { builder.add_center(x); }
    if let Some(x) = args.location { builder.add_location(x); }
    if let Some(x) = args.origin2 { builder.add_origin2(x); }
    if let Some(x) = args.origin1 { builder.add_origin1(x); }
    builder.finish()
  }


  #[inline]
  pub fn origin1(&self) -> Option<&'a GeometricPoint> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<GeometricPoint>(DimensionDefinitionPoints::VT_ORIGIN1, None)}
  }
  #[inline]
  pub fn origin2(&self) -> Option<&'a GeometricPoint> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<GeometricPoint>(DimensionDefinitionPoints::VT_ORIGIN2, None)}
  }
  #[inline]
  pub fn location(&self) -> Option<&'a GeometricPoint> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<GeometricPoint>(DimensionDefinitionPoints::VT_LOCATION, None)}
  }
  #[inline]
  pub fn center(&self) -> Option<&'a GeometricPoint> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<GeometricPoint>(DimensionDefinitionPoints::VT_CENTER, None)}
  }
  #[inline]
  pub fn jog(&self) -> Option<&'a GeometricPoint> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<GeometricPoint>(DimensionDefinitionPoints::VT_JOG, None)}
  }
}

impl flatbuffers::Verifiable for DimensionDefinitionPoints<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<GeometricPoint>("origin1", Self::VT_ORIGIN1, false)?
     .visit_field::<GeometricPoint>("origin2", Self::VT_ORIGIN2, false)?
     .visit_field::<GeometricPoint>("location", Self::VT_LOCATION, false)?
     .visit_field::<GeometricPoint>("center", Self::VT_CENTER, false)?
     .visit_field::<GeometricPoint>("jog", Self::VT_JOG, false)?
     .finish();
    Ok(())
  }
}
pub struct DimensionDefinitionPointsArgs<'a> {
    pub origin1: Option<&'a GeometricPoint>,
    pub origin2: Option<&'a GeometricPoint>,
    pub location: Option<&'a GeometricPoint>,
    pub center: Option<&'a GeometricPoint>,
    pub jog: Option<&'a GeometricPoint>,
}
impl<'a> Default for DimensionDefinitionPointsArgs<'a> {
  #[inline]
  fn default() -> Self {
    DimensionDefinitionPointsArgs {
      origin1: None,
      origin2: None,
      location: None,
      center: None,
      jog: None,
    }
  }
}

pub struct DimensionDefinitionPointsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DimensionDefinitionPointsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_origin1(&mut self, origin1: &GeometricPoint) {
    self.fbb_.push_slot_always::<&GeometricPoint>(DimensionDefinitionPoints::VT_ORIGIN1, origin1);
  }
  #[inline]
  pub fn add_origin2(&mut self, origin2: &GeometricPoint) {
    self.fbb_.push_slot_always::<&GeometricPoint>(DimensionDefinitionPoints::VT_ORIGIN2, origin2);
  }
  #[inline]
  pub fn add_location(&mut self, location: &GeometricPoint) {
    self.fbb_.push_slot_always::<&GeometricPoint>(DimensionDefinitionPoints::VT_LOCATION, location);
  }
  #[inline]
  pub fn add_center(&mut self, center: &GeometricPoint) {
    self.fbb_.push_slot_always::<&GeometricPoint>(DimensionDefinitionPoints::VT_CENTER, center);
  }
  #[inline]
  pub fn add_jog(&mut self, jog: &GeometricPoint) {
    self.fbb_.push_slot_always::<&GeometricPoint>(DimensionDefinitionPoints::VT_JOG, jog);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DimensionDefinitionPointsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DimensionDefinitionPointsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DimensionDefinitionPoints<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DimensionDefinitionPoints<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DimensionDefinitionPoints");
      ds.field("origin1", &self.origin1());
      ds.field("origin2", &self.origin2());
      ds.field("location", &self.location());
      ds.field("center", &self.center());
      ds.field("jog", &self.jog());
      ds.finish()
  }
}
pub enum DimensionBindingsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DimensionBindings<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DimensionBindings<'a> {
  type Inner = DimensionBindings<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DimensionBindings<'a> {
  pub const VT_ORIGIN1: flatbuffers::VOffsetT = 4;
  pub const VT_ORIGIN2: flatbuffers::VOffsetT = 6;
  pub const VT_CENTER: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DimensionBindings { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DimensionBindingsArgs<'args>
  ) -> flatbuffers::WIPOffset<DimensionBindings<'bldr>> {
    let mut builder = DimensionBindingsBuilder::new(_fbb);
    if let Some(x) = args.center { builder.add_center(x); }
    if let Some(x) = args.origin2 { builder.add_origin2(x); }
    if let Some(x) = args.origin1 { builder.add_origin1(x); }
    builder.finish()
  }


  #[inline]
  pub fn origin1(&self) -> Option<DucPointBinding<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucPointBinding>>(DimensionBindings::VT_ORIGIN1, None)}
  }
  #[inline]
  pub fn origin2(&self) -> Option<DucPointBinding<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucPointBinding>>(DimensionBindings::VT_ORIGIN2, None)}
  }
  #[inline]
  pub fn center(&self) -> Option<DucPointBinding<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucPointBinding>>(DimensionBindings::VT_CENTER, None)}
  }
}

impl flatbuffers::Verifiable for DimensionBindings<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucPointBinding>>("origin1", Self::VT_ORIGIN1, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucPointBinding>>("origin2", Self::VT_ORIGIN2, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucPointBinding>>("center", Self::VT_CENTER, false)?
     .finish();
    Ok(())
  }
}
pub struct DimensionBindingsArgs<'a> {
    pub origin1: Option<flatbuffers::WIPOffset<DucPointBinding<'a>>>,
    pub origin2: Option<flatbuffers::WIPOffset<DucPointBinding<'a>>>,
    pub center: Option<flatbuffers::WIPOffset<DucPointBinding<'a>>>,
}
impl<'a> Default for DimensionBindingsArgs<'a> {
  #[inline]
  fn default() -> Self {
    DimensionBindingsArgs {
      origin1: None,
      origin2: None,
      center: None,
    }
  }
}

pub struct DimensionBindingsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DimensionBindingsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_origin1(&mut self, origin1: flatbuffers::WIPOffset<DucPointBinding<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucPointBinding>>(DimensionBindings::VT_ORIGIN1, origin1);
  }
  #[inline]
  pub fn add_origin2(&mut self, origin2: flatbuffers::WIPOffset<DucPointBinding<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucPointBinding>>(DimensionBindings::VT_ORIGIN2, origin2);
  }
  #[inline]
  pub fn add_center(&mut self, center: flatbuffers::WIPOffset<DucPointBinding<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucPointBinding>>(DimensionBindings::VT_CENTER, center);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DimensionBindingsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DimensionBindingsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DimensionBindings<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DimensionBindings<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DimensionBindings");
      ds.field("origin1", &self.origin1());
      ds.field("origin2", &self.origin2());
      ds.field("center", &self.center());
      ds.finish()
  }
}
pub enum DimensionBaselineDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DimensionBaselineData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DimensionBaselineData<'a> {
  type Inner = DimensionBaselineData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DimensionBaselineData<'a> {
  pub const VT_BASE_DIMENSION_ID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DimensionBaselineData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DimensionBaselineDataArgs<'args>
  ) -> flatbuffers::WIPOffset<DimensionBaselineData<'bldr>> {
    let mut builder = DimensionBaselineDataBuilder::new(_fbb);
    if let Some(x) = args.base_dimension_id { builder.add_base_dimension_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn base_dimension_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DimensionBaselineData::VT_BASE_DIMENSION_ID, None)}
  }
}

impl flatbuffers::Verifiable for DimensionBaselineData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("base_dimension_id", Self::VT_BASE_DIMENSION_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct DimensionBaselineDataArgs<'a> {
    pub base_dimension_id: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DimensionBaselineDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    DimensionBaselineDataArgs {
      base_dimension_id: None,
    }
  }
}

pub struct DimensionBaselineDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DimensionBaselineDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_base_dimension_id(&mut self, base_dimension_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DimensionBaselineData::VT_BASE_DIMENSION_ID, base_dimension_id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DimensionBaselineDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DimensionBaselineDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DimensionBaselineData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DimensionBaselineData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DimensionBaselineData");
      ds.field("base_dimension_id", &self.base_dimension_id());
      ds.finish()
  }
}
pub enum DimensionContinueDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DimensionContinueData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DimensionContinueData<'a> {
  type Inner = DimensionContinueData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DimensionContinueData<'a> {
  pub const VT_CONTINUE_FROM_DIMENSION_ID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DimensionContinueData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DimensionContinueDataArgs<'args>
  ) -> flatbuffers::WIPOffset<DimensionContinueData<'bldr>> {
    let mut builder = DimensionContinueDataBuilder::new(_fbb);
    if let Some(x) = args.continue_from_dimension_id { builder.add_continue_from_dimension_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn continue_from_dimension_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DimensionContinueData::VT_CONTINUE_FROM_DIMENSION_ID, None)}
  }
}

impl flatbuffers::Verifiable for DimensionContinueData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("continue_from_dimension_id", Self::VT_CONTINUE_FROM_DIMENSION_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct DimensionContinueDataArgs<'a> {
    pub continue_from_dimension_id: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DimensionContinueDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    DimensionContinueDataArgs {
      continue_from_dimension_id: None,
    }
  }
}

pub struct DimensionContinueDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DimensionContinueDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_continue_from_dimension_id(&mut self, continue_from_dimension_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DimensionContinueData::VT_CONTINUE_FROM_DIMENSION_ID, continue_from_dimension_id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DimensionContinueDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DimensionContinueDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DimensionContinueData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DimensionContinueData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DimensionContinueData");
      ds.field("continue_from_dimension_id", &self.continue_from_dimension_id());
      ds.finish()
  }
}
pub enum DucDimensionElementOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucDimensionElement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucDimensionElement<'a> {
  type Inner = DucDimensionElement<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucDimensionElement<'a> {
  pub const VT_BASE: flatbuffers::VOffsetT = 4;
  pub const VT_STYLE: flatbuffers::VOffsetT = 6;
  pub const VT_DIMENSION_TYPE: flatbuffers::VOffsetT = 8;
  pub const VT_DEFINITION_POINTS: flatbuffers::VOffsetT = 10;
  pub const VT_OBLIQUE_ANGLE: flatbuffers::VOffsetT = 12;
  pub const VT_ORDINATE_AXIS: flatbuffers::VOffsetT = 14;
  pub const VT_BINDINGS: flatbuffers::VOffsetT = 16;
  pub const VT_TEXT_OVERRIDE: flatbuffers::VOffsetT = 18;
  pub const VT_TEXT_POSITION: flatbuffers::VOffsetT = 20;
  pub const VT_TOLERANCE_OVERRIDE: flatbuffers::VOffsetT = 22;
  pub const VT_BASELINE_DATA: flatbuffers::VOffsetT = 24;
  pub const VT_CONTINUE_DATA: flatbuffers::VOffsetT = 26;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucDimensionElement { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucDimensionElementArgs<'args>
  ) -> flatbuffers::WIPOffset<DucDimensionElement<'bldr>> {
    let mut builder = DucDimensionElementBuilder::new(_fbb);
    if let Some(x) = args.continue_data { builder.add_continue_data(x); }
    if let Some(x) = args.baseline_data { builder.add_baseline_data(x); }
    if let Some(x) = args.tolerance_override { builder.add_tolerance_override(x); }
    if let Some(x) = args.text_position { builder.add_text_position(x); }
    if let Some(x) = args.text_override { builder.add_text_override(x); }
    if let Some(x) = args.bindings { builder.add_bindings(x); }
    builder.add_oblique_angle(args.oblique_angle);
    if let Some(x) = args.definition_points { builder.add_definition_points(x); }
    if let Some(x) = args.style { builder.add_style(x); }
    if let Some(x) = args.base { builder.add_base(x); }
    if let Some(x) = args.ordinate_axis { builder.add_ordinate_axis(x); }
    if let Some(x) = args.dimension_type { builder.add_dimension_type(x); }
    builder.finish()
  }


  #[inline]
  pub fn base(&self) -> Option<_DucElementBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<_DucElementBase>>(DucDimensionElement::VT_BASE, None)}
  }
  #[inline]
  pub fn style(&self) -> Option<DucDimensionStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucDimensionStyle>>(DucDimensionElement::VT_STYLE, None)}
  }
  #[inline]
  pub fn dimension_type(&self) -> Option<DIMENSION_TYPE> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DIMENSION_TYPE>(DucDimensionElement::VT_DIMENSION_TYPE, None)}
  }
  #[inline]
  pub fn definition_points(&self) -> Option<DimensionDefinitionPoints<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DimensionDefinitionPoints>>(DucDimensionElement::VT_DEFINITION_POINTS, None)}
  }
  #[inline]
  pub fn oblique_angle(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucDimensionElement::VT_OBLIQUE_ANGLE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn ordinate_axis(&self) -> Option<AXIS> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<AXIS>(DucDimensionElement::VT_ORDINATE_AXIS, None)}
  }
  #[inline]
  pub fn bindings(&self) -> Option<DimensionBindings<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DimensionBindings>>(DucDimensionElement::VT_BINDINGS, None)}
  }
  #[inline]
  pub fn text_override(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucDimensionElement::VT_TEXT_OVERRIDE, None)}
  }
  #[inline]
  pub fn text_position(&self) -> Option<&'a GeometricPoint> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<GeometricPoint>(DucDimensionElement::VT_TEXT_POSITION, None)}
  }
  #[inline]
  pub fn tolerance_override(&self) -> Option<DimensionToleranceStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DimensionToleranceStyle>>(DucDimensionElement::VT_TOLERANCE_OVERRIDE, None)}
  }
  #[inline]
  pub fn baseline_data(&self) -> Option<DimensionBaselineData<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DimensionBaselineData>>(DucDimensionElement::VT_BASELINE_DATA, None)}
  }
  #[inline]
  pub fn continue_data(&self) -> Option<DimensionContinueData<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DimensionContinueData>>(DucDimensionElement::VT_CONTINUE_DATA, None)}
  }
}

impl flatbuffers::Verifiable for DucDimensionElement<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<_DucElementBase>>("base", Self::VT_BASE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucDimensionStyle>>("style", Self::VT_STYLE, false)?
     .visit_field::<DIMENSION_TYPE>("dimension_type", Self::VT_DIMENSION_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DimensionDefinitionPoints>>("definition_points", Self::VT_DEFINITION_POINTS, false)?
     .visit_field::<f32>("oblique_angle", Self::VT_OBLIQUE_ANGLE, false)?
     .visit_field::<AXIS>("ordinate_axis", Self::VT_ORDINATE_AXIS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DimensionBindings>>("bindings", Self::VT_BINDINGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("text_override", Self::VT_TEXT_OVERRIDE, false)?
     .visit_field::<GeometricPoint>("text_position", Self::VT_TEXT_POSITION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DimensionToleranceStyle>>("tolerance_override", Self::VT_TOLERANCE_OVERRIDE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DimensionBaselineData>>("baseline_data", Self::VT_BASELINE_DATA, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DimensionContinueData>>("continue_data", Self::VT_CONTINUE_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct DucDimensionElementArgs<'a> {
    pub base: Option<flatbuffers::WIPOffset<_DucElementBase<'a>>>,
    pub style: Option<flatbuffers::WIPOffset<DucDimensionStyle<'a>>>,
    pub dimension_type: Option<DIMENSION_TYPE>,
    pub definition_points: Option<flatbuffers::WIPOffset<DimensionDefinitionPoints<'a>>>,
    pub oblique_angle: f32,
    pub ordinate_axis: Option<AXIS>,
    pub bindings: Option<flatbuffers::WIPOffset<DimensionBindings<'a>>>,
    pub text_override: Option<flatbuffers::WIPOffset<&'a str>>,
    pub text_position: Option<&'a GeometricPoint>,
    pub tolerance_override: Option<flatbuffers::WIPOffset<DimensionToleranceStyle<'a>>>,
    pub baseline_data: Option<flatbuffers::WIPOffset<DimensionBaselineData<'a>>>,
    pub continue_data: Option<flatbuffers::WIPOffset<DimensionContinueData<'a>>>,
}
impl<'a> Default for DucDimensionElementArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucDimensionElementArgs {
      base: None,
      style: None,
      dimension_type: None,
      definition_points: None,
      oblique_angle: 0.0,
      ordinate_axis: None,
      bindings: None,
      text_override: None,
      text_position: None,
      tolerance_override: None,
      baseline_data: None,
      continue_data: None,
    }
  }
}

pub struct DucDimensionElementBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucDimensionElementBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_base(&mut self, base: flatbuffers::WIPOffset<_DucElementBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_DucElementBase>>(DucDimensionElement::VT_BASE, base);
  }
  #[inline]
  pub fn add_style(&mut self, style: flatbuffers::WIPOffset<DucDimensionStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucDimensionStyle>>(DucDimensionElement::VT_STYLE, style);
  }
  #[inline]
  pub fn add_dimension_type(&mut self, dimension_type: DIMENSION_TYPE) {
    self.fbb_.push_slot_always::<DIMENSION_TYPE>(DucDimensionElement::VT_DIMENSION_TYPE, dimension_type);
  }
  #[inline]
  pub fn add_definition_points(&mut self, definition_points: flatbuffers::WIPOffset<DimensionDefinitionPoints<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DimensionDefinitionPoints>>(DucDimensionElement::VT_DEFINITION_POINTS, definition_points);
  }
  #[inline]
  pub fn add_oblique_angle(&mut self, oblique_angle: f32) {
    self.fbb_.push_slot::<f32>(DucDimensionElement::VT_OBLIQUE_ANGLE, oblique_angle, 0.0);
  }
  #[inline]
  pub fn add_ordinate_axis(&mut self, ordinate_axis: AXIS) {
    self.fbb_.push_slot_always::<AXIS>(DucDimensionElement::VT_ORDINATE_AXIS, ordinate_axis);
  }
  #[inline]
  pub fn add_bindings(&mut self, bindings: flatbuffers::WIPOffset<DimensionBindings<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DimensionBindings>>(DucDimensionElement::VT_BINDINGS, bindings);
  }
  #[inline]
  pub fn add_text_override(&mut self, text_override: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucDimensionElement::VT_TEXT_OVERRIDE, text_override);
  }
  #[inline]
  pub fn add_text_position(&mut self, text_position: &GeometricPoint) {
    self.fbb_.push_slot_always::<&GeometricPoint>(DucDimensionElement::VT_TEXT_POSITION, text_position);
  }
  #[inline]
  pub fn add_tolerance_override(&mut self, tolerance_override: flatbuffers::WIPOffset<DimensionToleranceStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DimensionToleranceStyle>>(DucDimensionElement::VT_TOLERANCE_OVERRIDE, tolerance_override);
  }
  #[inline]
  pub fn add_baseline_data(&mut self, baseline_data: flatbuffers::WIPOffset<DimensionBaselineData<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DimensionBaselineData>>(DucDimensionElement::VT_BASELINE_DATA, baseline_data);
  }
  #[inline]
  pub fn add_continue_data(&mut self, continue_data: flatbuffers::WIPOffset<DimensionContinueData<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DimensionContinueData>>(DucDimensionElement::VT_CONTINUE_DATA, continue_data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucDimensionElementBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucDimensionElementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucDimensionElement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucDimensionElement<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucDimensionElement");
      ds.field("base", &self.base());
      ds.field("style", &self.style());
      ds.field("dimension_type", &self.dimension_type());
      ds.field("definition_points", &self.definition_points());
      ds.field("oblique_angle", &self.oblique_angle());
      ds.field("ordinate_axis", &self.ordinate_axis());
      ds.field("bindings", &self.bindings());
      ds.field("text_override", &self.text_override());
      ds.field("text_position", &self.text_position());
      ds.field("tolerance_override", &self.tolerance_override());
      ds.field("baseline_data", &self.baseline_data());
      ds.field("continue_data", &self.continue_data());
      ds.finish()
  }
}
pub enum DatumReferenceOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DatumReference<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DatumReference<'a> {
  type Inner = DatumReference<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DatumReference<'a> {
  pub const VT_LETTERS: flatbuffers::VOffsetT = 4;
  pub const VT_MODIFIER: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DatumReference { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DatumReferenceArgs<'args>
  ) -> flatbuffers::WIPOffset<DatumReference<'bldr>> {
    let mut builder = DatumReferenceBuilder::new(_fbb);
    if let Some(x) = args.letters { builder.add_letters(x); }
    if let Some(x) = args.modifier { builder.add_modifier(x); }
    builder.finish()
  }


  #[inline]
  pub fn letters(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DatumReference::VT_LETTERS, None)}
  }
  #[inline]
  pub fn modifier(&self) -> Option<MATERIAL_CONDITION> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<MATERIAL_CONDITION>(DatumReference::VT_MODIFIER, None)}
  }
}

impl flatbuffers::Verifiable for DatumReference<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("letters", Self::VT_LETTERS, false)?
     .visit_field::<MATERIAL_CONDITION>("modifier", Self::VT_MODIFIER, false)?
     .finish();
    Ok(())
  }
}
pub struct DatumReferenceArgs<'a> {
    pub letters: Option<flatbuffers::WIPOffset<&'a str>>,
    pub modifier: Option<MATERIAL_CONDITION>,
}
impl<'a> Default for DatumReferenceArgs<'a> {
  #[inline]
  fn default() -> Self {
    DatumReferenceArgs {
      letters: None,
      modifier: None,
    }
  }
}

pub struct DatumReferenceBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DatumReferenceBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_letters(&mut self, letters: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DatumReference::VT_LETTERS, letters);
  }
  #[inline]
  pub fn add_modifier(&mut self, modifier: MATERIAL_CONDITION) {
    self.fbb_.push_slot_always::<MATERIAL_CONDITION>(DatumReference::VT_MODIFIER, modifier);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DatumReferenceBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DatumReferenceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DatumReference<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DatumReference<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DatumReference");
      ds.field("letters", &self.letters());
      ds.field("modifier", &self.modifier());
      ds.finish()
  }
}
pub enum ToleranceClauseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ToleranceClause<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ToleranceClause<'a> {
  type Inner = ToleranceClause<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ToleranceClause<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;
  pub const VT_ZONE_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_FEATURE_MODIFIERS: flatbuffers::VOffsetT = 8;
  pub const VT_MATERIAL_CONDITION: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ToleranceClause { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ToleranceClauseArgs<'args>
  ) -> flatbuffers::WIPOffset<ToleranceClause<'bldr>> {
    let mut builder = ToleranceClauseBuilder::new(_fbb);
    if let Some(x) = args.feature_modifiers { builder.add_feature_modifiers(x); }
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.material_condition { builder.add_material_condition(x); }
    if let Some(x) = args.zone_type { builder.add_zone_type(x); }
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ToleranceClause::VT_VALUE, None)}
  }
  #[inline]
  pub fn zone_type(&self) -> Option<TOLERANCE_ZONE_TYPE> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TOLERANCE_ZONE_TYPE>(ToleranceClause::VT_ZONE_TYPE, None)}
  }
  #[inline]
  pub fn feature_modifiers(&self) -> Option<flatbuffers::Vector<'a, FEATURE_MODIFIER>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, FEATURE_MODIFIER>>>(ToleranceClause::VT_FEATURE_MODIFIERS, None)}
  }
  #[inline]
  pub fn material_condition(&self) -> Option<MATERIAL_CONDITION> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<MATERIAL_CONDITION>(ToleranceClause::VT_MATERIAL_CONDITION, None)}
  }
}

impl flatbuffers::Verifiable for ToleranceClause<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
     .visit_field::<TOLERANCE_ZONE_TYPE>("zone_type", Self::VT_ZONE_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, FEATURE_MODIFIER>>>("feature_modifiers", Self::VT_FEATURE_MODIFIERS, false)?
     .visit_field::<MATERIAL_CONDITION>("material_condition", Self::VT_MATERIAL_CONDITION, false)?
     .finish();
    Ok(())
  }
}
pub struct ToleranceClauseArgs<'a> {
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
    pub zone_type: Option<TOLERANCE_ZONE_TYPE>,
    pub feature_modifiers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, FEATURE_MODIFIER>>>,
    pub material_condition: Option<MATERIAL_CONDITION>,
}
impl<'a> Default for ToleranceClauseArgs<'a> {
  #[inline]
  fn default() -> Self {
    ToleranceClauseArgs {
      value: None,
      zone_type: None,
      feature_modifiers: None,
      material_condition: None,
    }
  }
}

pub struct ToleranceClauseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ToleranceClauseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ToleranceClause::VT_VALUE, value);
  }
  #[inline]
  pub fn add_zone_type(&mut self, zone_type: TOLERANCE_ZONE_TYPE) {
    self.fbb_.push_slot_always::<TOLERANCE_ZONE_TYPE>(ToleranceClause::VT_ZONE_TYPE, zone_type);
  }
  #[inline]
  pub fn add_feature_modifiers(&mut self, feature_modifiers: flatbuffers::WIPOffset<flatbuffers::Vector<'b , FEATURE_MODIFIER>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ToleranceClause::VT_FEATURE_MODIFIERS, feature_modifiers);
  }
  #[inline]
  pub fn add_material_condition(&mut self, material_condition: MATERIAL_CONDITION) {
    self.fbb_.push_slot_always::<MATERIAL_CONDITION>(ToleranceClause::VT_MATERIAL_CONDITION, material_condition);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ToleranceClauseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ToleranceClauseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ToleranceClause<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ToleranceClause<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ToleranceClause");
      ds.field("value", &self.value());
      ds.field("zone_type", &self.zone_type());
      ds.field("feature_modifiers", &self.feature_modifiers());
      ds.field("material_condition", &self.material_condition());
      ds.finish()
  }
}
pub enum FeatureControlFrameSegmentOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FeatureControlFrameSegment<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FeatureControlFrameSegment<'a> {
  type Inner = FeatureControlFrameSegment<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> FeatureControlFrameSegment<'a> {
  pub const VT_SYMBOL: flatbuffers::VOffsetT = 4;
  pub const VT_TOLERANCE: flatbuffers::VOffsetT = 6;
  pub const VT_DATUMS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FeatureControlFrameSegment { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FeatureControlFrameSegmentArgs<'args>
  ) -> flatbuffers::WIPOffset<FeatureControlFrameSegment<'bldr>> {
    let mut builder = FeatureControlFrameSegmentBuilder::new(_fbb);
    if let Some(x) = args.datums { builder.add_datums(x); }
    if let Some(x) = args.tolerance { builder.add_tolerance(x); }
    if let Some(x) = args.symbol { builder.add_symbol(x); }
    builder.finish()
  }


  #[inline]
  pub fn symbol(&self) -> Option<GDT_SYMBOL> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<GDT_SYMBOL>(FeatureControlFrameSegment::VT_SYMBOL, None)}
  }
  #[inline]
  pub fn tolerance(&self) -> Option<ToleranceClause<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ToleranceClause>>(FeatureControlFrameSegment::VT_TOLERANCE, None)}
  }
  #[inline]
  pub fn datums(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DatumReference<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DatumReference>>>>(FeatureControlFrameSegment::VT_DATUMS, None)}
  }
}

impl flatbuffers::Verifiable for FeatureControlFrameSegment<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<GDT_SYMBOL>("symbol", Self::VT_SYMBOL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ToleranceClause>>("tolerance", Self::VT_TOLERANCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DatumReference>>>>("datums", Self::VT_DATUMS, false)?
     .finish();
    Ok(())
  }
}
pub struct FeatureControlFrameSegmentArgs<'a> {
    pub symbol: Option<GDT_SYMBOL>,
    pub tolerance: Option<flatbuffers::WIPOffset<ToleranceClause<'a>>>,
    pub datums: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DatumReference<'a>>>>>,
}
impl<'a> Default for FeatureControlFrameSegmentArgs<'a> {
  #[inline]
  fn default() -> Self {
    FeatureControlFrameSegmentArgs {
      symbol: None,
      tolerance: None,
      datums: None,
    }
  }
}

pub struct FeatureControlFrameSegmentBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FeatureControlFrameSegmentBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_symbol(&mut self, symbol: GDT_SYMBOL) {
    self.fbb_.push_slot_always::<GDT_SYMBOL>(FeatureControlFrameSegment::VT_SYMBOL, symbol);
  }
  #[inline]
  pub fn add_tolerance(&mut self, tolerance: flatbuffers::WIPOffset<ToleranceClause<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ToleranceClause>>(FeatureControlFrameSegment::VT_TOLERANCE, tolerance);
  }
  #[inline]
  pub fn add_datums(&mut self, datums: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DatumReference<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FeatureControlFrameSegment::VT_DATUMS, datums);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FeatureControlFrameSegmentBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FeatureControlFrameSegmentBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FeatureControlFrameSegment<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FeatureControlFrameSegment<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FeatureControlFrameSegment");
      ds.field("symbol", &self.symbol());
      ds.field("tolerance", &self.tolerance());
      ds.field("datums", &self.datums());
      ds.finish()
  }
}
pub enum FCFBetweenModifierOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FCFBetweenModifier<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FCFBetweenModifier<'a> {
  type Inner = FCFBetweenModifier<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> FCFBetweenModifier<'a> {
  pub const VT_START: flatbuffers::VOffsetT = 4;
  pub const VT_END: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FCFBetweenModifier { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FCFBetweenModifierArgs<'args>
  ) -> flatbuffers::WIPOffset<FCFBetweenModifier<'bldr>> {
    let mut builder = FCFBetweenModifierBuilder::new(_fbb);
    if let Some(x) = args.end { builder.add_end(x); }
    if let Some(x) = args.start { builder.add_start(x); }
    builder.finish()
  }


  #[inline]
  pub fn start(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FCFBetweenModifier::VT_START, None)}
  }
  #[inline]
  pub fn end(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FCFBetweenModifier::VT_END, None)}
  }
}

impl flatbuffers::Verifiable for FCFBetweenModifier<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("start", Self::VT_START, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("end", Self::VT_END, false)?
     .finish();
    Ok(())
  }
}
pub struct FCFBetweenModifierArgs<'a> {
    pub start: Option<flatbuffers::WIPOffset<&'a str>>,
    pub end: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for FCFBetweenModifierArgs<'a> {
  #[inline]
  fn default() -> Self {
    FCFBetweenModifierArgs {
      start: None,
      end: None,
    }
  }
}

pub struct FCFBetweenModifierBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FCFBetweenModifierBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_start(&mut self, start: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FCFBetweenModifier::VT_START, start);
  }
  #[inline]
  pub fn add_end(&mut self, end: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FCFBetweenModifier::VT_END, end);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FCFBetweenModifierBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FCFBetweenModifierBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FCFBetweenModifier<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FCFBetweenModifier<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FCFBetweenModifier");
      ds.field("start", &self.start());
      ds.field("end", &self.end());
      ds.finish()
  }
}
pub enum FCFProjectedZoneModifierOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FCFProjectedZoneModifier<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FCFProjectedZoneModifier<'a> {
  type Inner = FCFProjectedZoneModifier<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> FCFProjectedZoneModifier<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FCFProjectedZoneModifier { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FCFProjectedZoneModifierArgs
  ) -> flatbuffers::WIPOffset<FCFProjectedZoneModifier<'bldr>> {
    let mut builder = FCFProjectedZoneModifierBuilder::new(_fbb);
    builder.add_value(args.value);
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(FCFProjectedZoneModifier::VT_VALUE, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for FCFProjectedZoneModifier<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct FCFProjectedZoneModifierArgs {
    pub value: f64,
}
impl<'a> Default for FCFProjectedZoneModifierArgs {
  #[inline]
  fn default() -> Self {
    FCFProjectedZoneModifierArgs {
      value: 0.0,
    }
  }
}

pub struct FCFProjectedZoneModifierBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FCFProjectedZoneModifierBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_value(&mut self, value: f64) {
    self.fbb_.push_slot::<f64>(FCFProjectedZoneModifier::VT_VALUE, value, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FCFProjectedZoneModifierBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FCFProjectedZoneModifierBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FCFProjectedZoneModifier<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FCFProjectedZoneModifier<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FCFProjectedZoneModifier");
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum FCFFrameModifiersOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FCFFrameModifiers<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FCFFrameModifiers<'a> {
  type Inner = FCFFrameModifiers<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> FCFFrameModifiers<'a> {
  pub const VT_ALL_AROUND: flatbuffers::VOffsetT = 4;
  pub const VT_ALL_OVER: flatbuffers::VOffsetT = 6;
  pub const VT_CONTINUOUS_FEATURE: flatbuffers::VOffsetT = 8;
  pub const VT_BETWEEN: flatbuffers::VOffsetT = 10;
  pub const VT_PROJECTED_TOLERANCE_ZONE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FCFFrameModifiers { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FCFFrameModifiersArgs<'args>
  ) -> flatbuffers::WIPOffset<FCFFrameModifiers<'bldr>> {
    let mut builder = FCFFrameModifiersBuilder::new(_fbb);
    if let Some(x) = args.projected_tolerance_zone { builder.add_projected_tolerance_zone(x); }
    if let Some(x) = args.between { builder.add_between(x); }
    builder.add_continuous_feature(args.continuous_feature);
    builder.add_all_over(args.all_over);
    builder.add_all_around(args.all_around);
    builder.finish()
  }


  #[inline]
  pub fn all_around(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(FCFFrameModifiers::VT_ALL_AROUND, Some(false)).unwrap()}
  }
  #[inline]
  pub fn all_over(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(FCFFrameModifiers::VT_ALL_OVER, Some(false)).unwrap()}
  }
  #[inline]
  pub fn continuous_feature(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(FCFFrameModifiers::VT_CONTINUOUS_FEATURE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn between(&self) -> Option<FCFBetweenModifier<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<FCFBetweenModifier>>(FCFFrameModifiers::VT_BETWEEN, None)}
  }
  #[inline]
  pub fn projected_tolerance_zone(&self) -> Option<FCFProjectedZoneModifier<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<FCFProjectedZoneModifier>>(FCFFrameModifiers::VT_PROJECTED_TOLERANCE_ZONE, None)}
  }
}

impl flatbuffers::Verifiable for FCFFrameModifiers<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("all_around", Self::VT_ALL_AROUND, false)?
     .visit_field::<bool>("all_over", Self::VT_ALL_OVER, false)?
     .visit_field::<bool>("continuous_feature", Self::VT_CONTINUOUS_FEATURE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<FCFBetweenModifier>>("between", Self::VT_BETWEEN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<FCFProjectedZoneModifier>>("projected_tolerance_zone", Self::VT_PROJECTED_TOLERANCE_ZONE, false)?
     .finish();
    Ok(())
  }
}
pub struct FCFFrameModifiersArgs<'a> {
    pub all_around: bool,
    pub all_over: bool,
    pub continuous_feature: bool,
    pub between: Option<flatbuffers::WIPOffset<FCFBetweenModifier<'a>>>,
    pub projected_tolerance_zone: Option<flatbuffers::WIPOffset<FCFProjectedZoneModifier<'a>>>,
}
impl<'a> Default for FCFFrameModifiersArgs<'a> {
  #[inline]
  fn default() -> Self {
    FCFFrameModifiersArgs {
      all_around: false,
      all_over: false,
      continuous_feature: false,
      between: None,
      projected_tolerance_zone: None,
    }
  }
}

pub struct FCFFrameModifiersBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FCFFrameModifiersBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_all_around(&mut self, all_around: bool) {
    self.fbb_.push_slot::<bool>(FCFFrameModifiers::VT_ALL_AROUND, all_around, false);
  }
  #[inline]
  pub fn add_all_over(&mut self, all_over: bool) {
    self.fbb_.push_slot::<bool>(FCFFrameModifiers::VT_ALL_OVER, all_over, false);
  }
  #[inline]
  pub fn add_continuous_feature(&mut self, continuous_feature: bool) {
    self.fbb_.push_slot::<bool>(FCFFrameModifiers::VT_CONTINUOUS_FEATURE, continuous_feature, false);
  }
  #[inline]
  pub fn add_between(&mut self, between: flatbuffers::WIPOffset<FCFBetweenModifier<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FCFBetweenModifier>>(FCFFrameModifiers::VT_BETWEEN, between);
  }
  #[inline]
  pub fn add_projected_tolerance_zone(&mut self, projected_tolerance_zone: flatbuffers::WIPOffset<FCFProjectedZoneModifier<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FCFProjectedZoneModifier>>(FCFFrameModifiers::VT_PROJECTED_TOLERANCE_ZONE, projected_tolerance_zone);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FCFFrameModifiersBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FCFFrameModifiersBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FCFFrameModifiers<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FCFFrameModifiers<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FCFFrameModifiers");
      ds.field("all_around", &self.all_around());
      ds.field("all_over", &self.all_over());
      ds.field("continuous_feature", &self.continuous_feature());
      ds.field("between", &self.between());
      ds.field("projected_tolerance_zone", &self.projected_tolerance_zone());
      ds.finish()
  }
}
pub enum FCFDatumDefinitionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FCFDatumDefinition<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FCFDatumDefinition<'a> {
  type Inner = FCFDatumDefinition<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> FCFDatumDefinition<'a> {
  pub const VT_LETTER: flatbuffers::VOffsetT = 4;
  pub const VT_FEATURE_BINDING: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FCFDatumDefinition { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FCFDatumDefinitionArgs<'args>
  ) -> flatbuffers::WIPOffset<FCFDatumDefinition<'bldr>> {
    let mut builder = FCFDatumDefinitionBuilder::new(_fbb);
    if let Some(x) = args.feature_binding { builder.add_feature_binding(x); }
    if let Some(x) = args.letter { builder.add_letter(x); }
    builder.finish()
  }


  #[inline]
  pub fn letter(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(FCFDatumDefinition::VT_LETTER, None)}
  }
  #[inline]
  pub fn feature_binding(&self) -> Option<DucPointBinding<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucPointBinding>>(FCFDatumDefinition::VT_FEATURE_BINDING, None)}
  }
}

impl flatbuffers::Verifiable for FCFDatumDefinition<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("letter", Self::VT_LETTER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucPointBinding>>("feature_binding", Self::VT_FEATURE_BINDING, false)?
     .finish();
    Ok(())
  }
}
pub struct FCFDatumDefinitionArgs<'a> {
    pub letter: Option<flatbuffers::WIPOffset<&'a str>>,
    pub feature_binding: Option<flatbuffers::WIPOffset<DucPointBinding<'a>>>,
}
impl<'a> Default for FCFDatumDefinitionArgs<'a> {
  #[inline]
  fn default() -> Self {
    FCFDatumDefinitionArgs {
      letter: None,
      feature_binding: None,
    }
  }
}

pub struct FCFDatumDefinitionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FCFDatumDefinitionBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_letter(&mut self, letter: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FCFDatumDefinition::VT_LETTER, letter);
  }
  #[inline]
  pub fn add_feature_binding(&mut self, feature_binding: flatbuffers::WIPOffset<DucPointBinding<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucPointBinding>>(FCFDatumDefinition::VT_FEATURE_BINDING, feature_binding);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FCFDatumDefinitionBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FCFDatumDefinitionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FCFDatumDefinition<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FCFDatumDefinition<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FCFDatumDefinition");
      ds.field("letter", &self.letter());
      ds.field("feature_binding", &self.feature_binding());
      ds.finish()
  }
}
pub enum FCFSegmentRowOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct FCFSegmentRow<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for FCFSegmentRow<'a> {
  type Inner = FCFSegmentRow<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> FCFSegmentRow<'a> {
  pub const VT_SEGMENTS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    FCFSegmentRow { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FCFSegmentRowArgs<'args>
  ) -> flatbuffers::WIPOffset<FCFSegmentRow<'bldr>> {
    let mut builder = FCFSegmentRowBuilder::new(_fbb);
    if let Some(x) = args.segments { builder.add_segments(x); }
    builder.finish()
  }


  #[inline]
  pub fn segments(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FeatureControlFrameSegment<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FeatureControlFrameSegment>>>>(FCFSegmentRow::VT_SEGMENTS, None)}
  }
}

impl flatbuffers::Verifiable for FCFSegmentRow<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FeatureControlFrameSegment>>>>("segments", Self::VT_SEGMENTS, false)?
     .finish();
    Ok(())
  }
}
pub struct FCFSegmentRowArgs<'a> {
    pub segments: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FeatureControlFrameSegment<'a>>>>>,
}
impl<'a> Default for FCFSegmentRowArgs<'a> {
  #[inline]
  fn default() -> Self {
    FCFSegmentRowArgs {
      segments: None,
    }
  }
}

pub struct FCFSegmentRowBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> FCFSegmentRowBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_segments(&mut self, segments: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FeatureControlFrameSegment<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(FCFSegmentRow::VT_SEGMENTS, segments);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> FCFSegmentRowBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FCFSegmentRowBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<FCFSegmentRow<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for FCFSegmentRow<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("FCFSegmentRow");
      ds.field("segments", &self.segments());
      ds.finish()
  }
}
pub enum DucFeatureControlFrameElementOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucFeatureControlFrameElement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucFeatureControlFrameElement<'a> {
  type Inner = DucFeatureControlFrameElement<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucFeatureControlFrameElement<'a> {
  pub const VT_BASE: flatbuffers::VOffsetT = 4;
  pub const VT_STYLE: flatbuffers::VOffsetT = 6;
  pub const VT_ROWS: flatbuffers::VOffsetT = 8;
  pub const VT_FRAME_MODIFIERS: flatbuffers::VOffsetT = 10;
  pub const VT_LEADER_ELEMENT_ID: flatbuffers::VOffsetT = 12;
  pub const VT_DATUM_DEFINITION: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucFeatureControlFrameElement { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucFeatureControlFrameElementArgs<'args>
  ) -> flatbuffers::WIPOffset<DucFeatureControlFrameElement<'bldr>> {
    let mut builder = DucFeatureControlFrameElementBuilder::new(_fbb);
    if let Some(x) = args.datum_definition { builder.add_datum_definition(x); }
    if let Some(x) = args.leader_element_id { builder.add_leader_element_id(x); }
    if let Some(x) = args.frame_modifiers { builder.add_frame_modifiers(x); }
    if let Some(x) = args.rows { builder.add_rows(x); }
    if let Some(x) = args.style { builder.add_style(x); }
    if let Some(x) = args.base { builder.add_base(x); }
    builder.finish()
  }


  #[inline]
  pub fn base(&self) -> Option<_DucElementBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<_DucElementBase>>(DucFeatureControlFrameElement::VT_BASE, None)}
  }
  #[inline]
  pub fn style(&self) -> Option<DucFeatureControlFrameStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucFeatureControlFrameStyle>>(DucFeatureControlFrameElement::VT_STYLE, None)}
  }
  #[inline]
  pub fn rows(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FCFSegmentRow<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FCFSegmentRow>>>>(DucFeatureControlFrameElement::VT_ROWS, None)}
  }
  #[inline]
  pub fn frame_modifiers(&self) -> Option<FCFFrameModifiers<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<FCFFrameModifiers>>(DucFeatureControlFrameElement::VT_FRAME_MODIFIERS, None)}
  }
  #[inline]
  pub fn leader_element_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucFeatureControlFrameElement::VT_LEADER_ELEMENT_ID, None)}
  }
  #[inline]
  pub fn datum_definition(&self) -> Option<FCFDatumDefinition<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<FCFDatumDefinition>>(DucFeatureControlFrameElement::VT_DATUM_DEFINITION, None)}
  }
}

impl flatbuffers::Verifiable for DucFeatureControlFrameElement<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<_DucElementBase>>("base", Self::VT_BASE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucFeatureControlFrameStyle>>("style", Self::VT_STYLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<FCFSegmentRow>>>>("rows", Self::VT_ROWS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<FCFFrameModifiers>>("frame_modifiers", Self::VT_FRAME_MODIFIERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("leader_element_id", Self::VT_LEADER_ELEMENT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<FCFDatumDefinition>>("datum_definition", Self::VT_DATUM_DEFINITION, false)?
     .finish();
    Ok(())
  }
}
pub struct DucFeatureControlFrameElementArgs<'a> {
    pub base: Option<flatbuffers::WIPOffset<_DucElementBase<'a>>>,
    pub style: Option<flatbuffers::WIPOffset<DucFeatureControlFrameStyle<'a>>>,
    pub rows: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<FCFSegmentRow<'a>>>>>,
    pub frame_modifiers: Option<flatbuffers::WIPOffset<FCFFrameModifiers<'a>>>,
    pub leader_element_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub datum_definition: Option<flatbuffers::WIPOffset<FCFDatumDefinition<'a>>>,
}
impl<'a> Default for DucFeatureControlFrameElementArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucFeatureControlFrameElementArgs {
      base: None,
      style: None,
      rows: None,
      frame_modifiers: None,
      leader_element_id: None,
      datum_definition: None,
    }
  }
}

pub struct DucFeatureControlFrameElementBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucFeatureControlFrameElementBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_base(&mut self, base: flatbuffers::WIPOffset<_DucElementBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_DucElementBase>>(DucFeatureControlFrameElement::VT_BASE, base);
  }
  #[inline]
  pub fn add_style(&mut self, style: flatbuffers::WIPOffset<DucFeatureControlFrameStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucFeatureControlFrameStyle>>(DucFeatureControlFrameElement::VT_STYLE, style);
  }
  #[inline]
  pub fn add_rows(&mut self, rows: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<FCFSegmentRow<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucFeatureControlFrameElement::VT_ROWS, rows);
  }
  #[inline]
  pub fn add_frame_modifiers(&mut self, frame_modifiers: flatbuffers::WIPOffset<FCFFrameModifiers<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FCFFrameModifiers>>(DucFeatureControlFrameElement::VT_FRAME_MODIFIERS, frame_modifiers);
  }
  #[inline]
  pub fn add_leader_element_id(&mut self, leader_element_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucFeatureControlFrameElement::VT_LEADER_ELEMENT_ID, leader_element_id);
  }
  #[inline]
  pub fn add_datum_definition(&mut self, datum_definition: flatbuffers::WIPOffset<FCFDatumDefinition<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<FCFDatumDefinition>>(DucFeatureControlFrameElement::VT_DATUM_DEFINITION, datum_definition);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucFeatureControlFrameElementBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucFeatureControlFrameElementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucFeatureControlFrameElement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucFeatureControlFrameElement<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucFeatureControlFrameElement");
      ds.field("base", &self.base());
      ds.field("style", &self.style());
      ds.field("rows", &self.rows());
      ds.field("frame_modifiers", &self.frame_modifiers());
      ds.field("leader_element_id", &self.leader_element_id());
      ds.field("datum_definition", &self.datum_definition());
      ds.finish()
  }
}
pub enum TextColumnOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TextColumn<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TextColumn<'a> {
  type Inner = TextColumn<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TextColumn<'a> {
  pub const VT_WIDTH: flatbuffers::VOffsetT = 4;
  pub const VT_GUTTER: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TextColumn { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TextColumnArgs
  ) -> flatbuffers::WIPOffset<TextColumn<'bldr>> {
    let mut builder = TextColumnBuilder::new(_fbb);
    builder.add_gutter(args.gutter);
    builder.add_width(args.width);
    builder.finish()
  }


  #[inline]
  pub fn width(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TextColumn::VT_WIDTH, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn gutter(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TextColumn::VT_GUTTER, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for TextColumn<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("width", Self::VT_WIDTH, false)?
     .visit_field::<f64>("gutter", Self::VT_GUTTER, false)?
     .finish();
    Ok(())
  }
}
pub struct TextColumnArgs {
    pub width: f64,
    pub gutter: f64,
}
impl<'a> Default for TextColumnArgs {
  #[inline]
  fn default() -> Self {
    TextColumnArgs {
      width: 0.0,
      gutter: 0.0,
    }
  }
}

pub struct TextColumnBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TextColumnBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_width(&mut self, width: f64) {
    self.fbb_.push_slot::<f64>(TextColumn::VT_WIDTH, width, 0.0);
  }
  #[inline]
  pub fn add_gutter(&mut self, gutter: f64) {
    self.fbb_.push_slot::<f64>(TextColumn::VT_GUTTER, gutter, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TextColumnBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TextColumnBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TextColumn<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TextColumn<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TextColumn");
      ds.field("width", &self.width());
      ds.field("gutter", &self.gutter());
      ds.finish()
  }
}
pub enum ColumnLayoutOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ColumnLayout<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ColumnLayout<'a> {
  type Inner = ColumnLayout<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ColumnLayout<'a> {
  pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
  pub const VT_DEFINITIONS: flatbuffers::VOffsetT = 6;
  pub const VT_AUTO_HEIGHT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ColumnLayout { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ColumnLayoutArgs<'args>
  ) -> flatbuffers::WIPOffset<ColumnLayout<'bldr>> {
    let mut builder = ColumnLayoutBuilder::new(_fbb);
    if let Some(x) = args.definitions { builder.add_definitions(x); }
    builder.add_auto_height(args.auto_height);
    if let Some(x) = args.type_ { builder.add_type_(x); }
    builder.finish()
  }


  #[inline]
  pub fn type_(&self) -> Option<COLUMN_TYPE> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<COLUMN_TYPE>(ColumnLayout::VT_TYPE_, None)}
  }
  #[inline]
  pub fn definitions(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TextColumn<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TextColumn>>>>(ColumnLayout::VT_DEFINITIONS, None)}
  }
  #[inline]
  pub fn auto_height(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ColumnLayout::VT_AUTO_HEIGHT, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ColumnLayout<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<COLUMN_TYPE>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<TextColumn>>>>("definitions", Self::VT_DEFINITIONS, false)?
     .visit_field::<bool>("auto_height", Self::VT_AUTO_HEIGHT, false)?
     .finish();
    Ok(())
  }
}
pub struct ColumnLayoutArgs<'a> {
    pub type_: Option<COLUMN_TYPE>,
    pub definitions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<TextColumn<'a>>>>>,
    pub auto_height: bool,
}
impl<'a> Default for ColumnLayoutArgs<'a> {
  #[inline]
  fn default() -> Self {
    ColumnLayoutArgs {
      type_: None,
      definitions: None,
      auto_height: false,
    }
  }
}

pub struct ColumnLayoutBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ColumnLayoutBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_type_(&mut self, type_: COLUMN_TYPE) {
    self.fbb_.push_slot_always::<COLUMN_TYPE>(ColumnLayout::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_definitions(&mut self, definitions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<TextColumn<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ColumnLayout::VT_DEFINITIONS, definitions);
  }
  #[inline]
  pub fn add_auto_height(&mut self, auto_height: bool) {
    self.fbb_.push_slot::<bool>(ColumnLayout::VT_AUTO_HEIGHT, auto_height, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ColumnLayoutBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ColumnLayoutBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ColumnLayout<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ColumnLayout<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ColumnLayout");
      ds.field("type_", &self.type_());
      ds.field("definitions", &self.definitions());
      ds.field("auto_height", &self.auto_height());
      ds.finish()
  }
}
pub enum DucDocElementOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucDocElement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucDocElement<'a> {
  type Inner = DucDocElement<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucDocElement<'a> {
  pub const VT_BASE: flatbuffers::VOffsetT = 4;
  pub const VT_STYLE: flatbuffers::VOffsetT = 6;
  pub const VT_TEXT: flatbuffers::VOffsetT = 8;
  pub const VT_DYNAMIC: flatbuffers::VOffsetT = 10;
  pub const VT_FLOW_DIRECTION: flatbuffers::VOffsetT = 12;
  pub const VT_COLUMNS: flatbuffers::VOffsetT = 14;
  pub const VT_AUTO_RESIZE: flatbuffers::VOffsetT = 16;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucDocElement { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucDocElementArgs<'args>
  ) -> flatbuffers::WIPOffset<DucDocElement<'bldr>> {
    let mut builder = DucDocElementBuilder::new(_fbb);
    if let Some(x) = args.columns { builder.add_columns(x); }
    if let Some(x) = args.dynamic { builder.add_dynamic(x); }
    if let Some(x) = args.text { builder.add_text(x); }
    if let Some(x) = args.style { builder.add_style(x); }
    if let Some(x) = args.base { builder.add_base(x); }
    builder.add_auto_resize(args.auto_resize);
    if let Some(x) = args.flow_direction { builder.add_flow_direction(x); }
    builder.finish()
  }


  #[inline]
  pub fn base(&self) -> Option<_DucElementBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<_DucElementBase>>(DucDocElement::VT_BASE, None)}
  }
  #[inline]
  pub fn style(&self) -> Option<DucDocStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucDocStyle>>(DucDocElement::VT_STYLE, None)}
  }
  #[inline]
  pub fn text(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucDocElement::VT_TEXT, None)}
  }
  #[inline]
  pub fn dynamic(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucTextDynamicPart<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucTextDynamicPart>>>>(DucDocElement::VT_DYNAMIC, None)}
  }
  #[inline]
  pub fn flow_direction(&self) -> Option<TEXT_FLOW_DIRECTION> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TEXT_FLOW_DIRECTION>(DucDocElement::VT_FLOW_DIRECTION, None)}
  }
  #[inline]
  pub fn columns(&self) -> Option<ColumnLayout<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ColumnLayout>>(DucDocElement::VT_COLUMNS, None)}
  }
  #[inline]
  pub fn auto_resize(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucDocElement::VT_AUTO_RESIZE, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DucDocElement<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<_DucElementBase>>("base", Self::VT_BASE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucDocStyle>>("style", Self::VT_STYLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("text", Self::VT_TEXT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DucTextDynamicPart>>>>("dynamic", Self::VT_DYNAMIC, false)?
     .visit_field::<TEXT_FLOW_DIRECTION>("flow_direction", Self::VT_FLOW_DIRECTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ColumnLayout>>("columns", Self::VT_COLUMNS, false)?
     .visit_field::<bool>("auto_resize", Self::VT_AUTO_RESIZE, false)?
     .finish();
    Ok(())
  }
}
pub struct DucDocElementArgs<'a> {
    pub base: Option<flatbuffers::WIPOffset<_DucElementBase<'a>>>,
    pub style: Option<flatbuffers::WIPOffset<DucDocStyle<'a>>>,
    pub text: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dynamic: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucTextDynamicPart<'a>>>>>,
    pub flow_direction: Option<TEXT_FLOW_DIRECTION>,
    pub columns: Option<flatbuffers::WIPOffset<ColumnLayout<'a>>>,
    pub auto_resize: bool,
}
impl<'a> Default for DucDocElementArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucDocElementArgs {
      base: None,
      style: None,
      text: None,
      dynamic: None,
      flow_direction: None,
      columns: None,
      auto_resize: false,
    }
  }
}

pub struct DucDocElementBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucDocElementBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_base(&mut self, base: flatbuffers::WIPOffset<_DucElementBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_DucElementBase>>(DucDocElement::VT_BASE, base);
  }
  #[inline]
  pub fn add_style(&mut self, style: flatbuffers::WIPOffset<DucDocStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucDocStyle>>(DucDocElement::VT_STYLE, style);
  }
  #[inline]
  pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucDocElement::VT_TEXT, text);
  }
  #[inline]
  pub fn add_dynamic(&mut self, dynamic: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DucTextDynamicPart<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucDocElement::VT_DYNAMIC, dynamic);
  }
  #[inline]
  pub fn add_flow_direction(&mut self, flow_direction: TEXT_FLOW_DIRECTION) {
    self.fbb_.push_slot_always::<TEXT_FLOW_DIRECTION>(DucDocElement::VT_FLOW_DIRECTION, flow_direction);
  }
  #[inline]
  pub fn add_columns(&mut self, columns: flatbuffers::WIPOffset<ColumnLayout<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ColumnLayout>>(DucDocElement::VT_COLUMNS, columns);
  }
  #[inline]
  pub fn add_auto_resize(&mut self, auto_resize: bool) {
    self.fbb_.push_slot::<bool>(DucDocElement::VT_AUTO_RESIZE, auto_resize, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucDocElementBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucDocElementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucDocElement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucDocElement<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucDocElement");
      ds.field("base", &self.base());
      ds.field("style", &self.style());
      ds.field("text", &self.text());
      ds.field("dynamic", &self.dynamic());
      ds.field("flow_direction", &self.flow_direction());
      ds.field("columns", &self.columns());
      ds.field("auto_resize", &self.auto_resize());
      ds.finish()
  }
}
pub enum ParametricSourceOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ParametricSource<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ParametricSource<'a> {
  type Inner = ParametricSource<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ParametricSource<'a> {
  pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
  pub const VT_CODE: flatbuffers::VOffsetT = 6;
  pub const VT_FILE_ID: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ParametricSource { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ParametricSourceArgs<'args>
  ) -> flatbuffers::WIPOffset<ParametricSource<'bldr>> {
    let mut builder = ParametricSourceBuilder::new(_fbb);
    if let Some(x) = args.file_id { builder.add_file_id(x); }
    if let Some(x) = args.code { builder.add_code(x); }
    if let Some(x) = args.type_ { builder.add_type_(x); }
    builder.finish()
  }


  #[inline]
  pub fn type_(&self) -> Option<PARAMETRIC_SOURCE_TYPE> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<PARAMETRIC_SOURCE_TYPE>(ParametricSource::VT_TYPE_, None)}
  }
  #[inline]
  pub fn code(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ParametricSource::VT_CODE, None)}
  }
  #[inline]
  pub fn file_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ParametricSource::VT_FILE_ID, None)}
  }
}

impl flatbuffers::Verifiable for ParametricSource<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<PARAMETRIC_SOURCE_TYPE>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("code", Self::VT_CODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("file_id", Self::VT_FILE_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct ParametricSourceArgs<'a> {
    pub type_: Option<PARAMETRIC_SOURCE_TYPE>,
    pub code: Option<flatbuffers::WIPOffset<&'a str>>,
    pub file_id: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ParametricSourceArgs<'a> {
  #[inline]
  fn default() -> Self {
    ParametricSourceArgs {
      type_: None,
      code: None,
      file_id: None,
    }
  }
}

pub struct ParametricSourceBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ParametricSourceBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_type_(&mut self, type_: PARAMETRIC_SOURCE_TYPE) {
    self.fbb_.push_slot_always::<PARAMETRIC_SOURCE_TYPE>(ParametricSource::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_code(&mut self, code: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ParametricSource::VT_CODE, code);
  }
  #[inline]
  pub fn add_file_id(&mut self, file_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ParametricSource::VT_FILE_ID, file_id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ParametricSourceBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ParametricSourceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ParametricSource<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ParametricSource<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ParametricSource");
      ds.field("type_", &self.type_());
      ds.field("code", &self.code());
      ds.field("file_id", &self.file_id());
      ds.finish()
  }
}
pub enum DucParametricElementOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucParametricElement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucParametricElement<'a> {
  type Inner = DucParametricElement<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucParametricElement<'a> {
  pub const VT_BASE: flatbuffers::VOffsetT = 4;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucParametricElement { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucParametricElementArgs<'args>
  ) -> flatbuffers::WIPOffset<DucParametricElement<'bldr>> {
    let mut builder = DucParametricElementBuilder::new(_fbb);
    if let Some(x) = args.source { builder.add_source(x); }
    if let Some(x) = args.base { builder.add_base(x); }
    builder.finish()
  }


  #[inline]
  pub fn base(&self) -> Option<_DucElementBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<_DucElementBase>>(DucParametricElement::VT_BASE, None)}
  }
  #[inline]
  pub fn source(&self) -> Option<ParametricSource<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ParametricSource>>(DucParametricElement::VT_SOURCE, None)}
  }
}

impl flatbuffers::Verifiable for DucParametricElement<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<_DucElementBase>>("base", Self::VT_BASE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ParametricSource>>("source", Self::VT_SOURCE, false)?
     .finish();
    Ok(())
  }
}
pub struct DucParametricElementArgs<'a> {
    pub base: Option<flatbuffers::WIPOffset<_DucElementBase<'a>>>,
    pub source: Option<flatbuffers::WIPOffset<ParametricSource<'a>>>,
}
impl<'a> Default for DucParametricElementArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucParametricElementArgs {
      base: None,
      source: None,
    }
  }
}

pub struct DucParametricElementBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucParametricElementBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_base(&mut self, base: flatbuffers::WIPOffset<_DucElementBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_DucElementBase>>(DucParametricElement::VT_BASE, base);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<ParametricSource<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ParametricSource>>(DucParametricElement::VT_SOURCE, source);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucParametricElementBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucParametricElementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucParametricElement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucParametricElement<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucParametricElement");
      ds.field("base", &self.base());
      ds.field("source", &self.source());
      ds.finish()
  }
}
pub enum ElementWrapperOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ElementWrapper<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ElementWrapper<'a> {
  type Inner = ElementWrapper<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ElementWrapper<'a> {
  pub const VT_ELEMENT_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_ELEMENT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ElementWrapper { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ElementWrapperArgs
  ) -> flatbuffers::WIPOffset<ElementWrapper<'bldr>> {
    let mut builder = ElementWrapperBuilder::new(_fbb);
    if let Some(x) = args.element { builder.add_element(x); }
    builder.add_element_type(args.element_type);
    builder.finish()
  }


  #[inline]
  pub fn element_type(&self) -> Element {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Element>(ElementWrapper::VT_ELEMENT_TYPE, Some(Element::NONE)).unwrap()}
  }
  #[inline]
  pub fn element(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(ElementWrapper::VT_ELEMENT, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn element_as_duc_rectangle_element(&self) -> Option<DucRectangleElement<'a>> {
    if self.element_type() == Element::DucRectangleElement {
      self.element().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DucRectangleElement::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn element_as_duc_polygon_element(&self) -> Option<DucPolygonElement<'a>> {
    if self.element_type() == Element::DucPolygonElement {
      self.element().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DucPolygonElement::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn element_as_duc_ellipse_element(&self) -> Option<DucEllipseElement<'a>> {
    if self.element_type() == Element::DucEllipseElement {
      self.element().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DucEllipseElement::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn element_as_duc_embeddable_element(&self) -> Option<DucEmbeddableElement<'a>> {
    if self.element_type() == Element::DucEmbeddableElement {
      self.element().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DucEmbeddableElement::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn element_as_duc_pdf_element(&self) -> Option<DucPdfElement<'a>> {
    if self.element_type() == Element::DucPdfElement {
      self.element().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DucPdfElement::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn element_as_duc_mermaid_element(&self) -> Option<DucMermaidElement<'a>> {
    if self.element_type() == Element::DucMermaidElement {
      self.element().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DucMermaidElement::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn element_as_duc_table_element(&self) -> Option<DucTableElement<'a>> {
    if self.element_type() == Element::DucTableElement {
      self.element().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DucTableElement::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn element_as_duc_image_element(&self) -> Option<DucImageElement<'a>> {
    if self.element_type() == Element::DucImageElement {
      self.element().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DucImageElement::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn element_as_duc_text_element(&self) -> Option<DucTextElement<'a>> {
    if self.element_type() == Element::DucTextElement {
      self.element().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DucTextElement::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn element_as_duc_linear_element(&self) -> Option<DucLinearElement<'a>> {
    if self.element_type() == Element::DucLinearElement {
      self.element().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DucLinearElement::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn element_as_duc_arrow_element(&self) -> Option<DucArrowElement<'a>> {
    if self.element_type() == Element::DucArrowElement {
      self.element().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DucArrowElement::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn element_as_duc_free_draw_element(&self) -> Option<DucFreeDrawElement<'a>> {
    if self.element_type() == Element::DucFreeDrawElement {
      self.element().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DucFreeDrawElement::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn element_as_duc_block_instance_element(&self) -> Option<DucBlockInstanceElement<'a>> {
    if self.element_type() == Element::DucBlockInstanceElement {
      self.element().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DucBlockInstanceElement::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn element_as_duc_frame_element(&self) -> Option<DucFrameElement<'a>> {
    if self.element_type() == Element::DucFrameElement {
      self.element().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DucFrameElement::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn element_as_duc_plot_element(&self) -> Option<DucPlotElement<'a>> {
    if self.element_type() == Element::DucPlotElement {
      self.element().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DucPlotElement::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn element_as_duc_viewport_element(&self) -> Option<DucViewportElement<'a>> {
    if self.element_type() == Element::DucViewportElement {
      self.element().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DucViewportElement::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn element_as_duc_xray_element(&self) -> Option<DucXRayElement<'a>> {
    if self.element_type() == Element::DucXRayElement {
      self.element().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DucXRayElement::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn element_as_duc_leader_element(&self) -> Option<DucLeaderElement<'a>> {
    if self.element_type() == Element::DucLeaderElement {
      self.element().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DucLeaderElement::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn element_as_duc_dimension_element(&self) -> Option<DucDimensionElement<'a>> {
    if self.element_type() == Element::DucDimensionElement {
      self.element().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DucDimensionElement::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn element_as_duc_feature_control_frame_element(&self) -> Option<DucFeatureControlFrameElement<'a>> {
    if self.element_type() == Element::DucFeatureControlFrameElement {
      self.element().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DucFeatureControlFrameElement::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn element_as_duc_doc_element(&self) -> Option<DucDocElement<'a>> {
    if self.element_type() == Element::DucDocElement {
      self.element().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DucDocElement::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn element_as_duc_parametric_element(&self) -> Option<DucParametricElement<'a>> {
    if self.element_type() == Element::DucParametricElement {
      self.element().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { DucParametricElement::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for ElementWrapper<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<Element, _>("element_type", Self::VT_ELEMENT_TYPE, "element", Self::VT_ELEMENT, false, |key, v, pos| {
        match key {
          Element::DucRectangleElement => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DucRectangleElement>>("Element::DucRectangleElement", pos),
          Element::DucPolygonElement => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DucPolygonElement>>("Element::DucPolygonElement", pos),
          Element::DucEllipseElement => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DucEllipseElement>>("Element::DucEllipseElement", pos),
          Element::DucEmbeddableElement => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DucEmbeddableElement>>("Element::DucEmbeddableElement", pos),
          Element::DucPdfElement => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DucPdfElement>>("Element::DucPdfElement", pos),
          Element::DucMermaidElement => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DucMermaidElement>>("Element::DucMermaidElement", pos),
          Element::DucTableElement => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DucTableElement>>("Element::DucTableElement", pos),
          Element::DucImageElement => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DucImageElement>>("Element::DucImageElement", pos),
          Element::DucTextElement => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DucTextElement>>("Element::DucTextElement", pos),
          Element::DucLinearElement => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DucLinearElement>>("Element::DucLinearElement", pos),
          Element::DucArrowElement => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DucArrowElement>>("Element::DucArrowElement", pos),
          Element::DucFreeDrawElement => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DucFreeDrawElement>>("Element::DucFreeDrawElement", pos),
          Element::DucBlockInstanceElement => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DucBlockInstanceElement>>("Element::DucBlockInstanceElement", pos),
          Element::DucFrameElement => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DucFrameElement>>("Element::DucFrameElement", pos),
          Element::DucPlotElement => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DucPlotElement>>("Element::DucPlotElement", pos),
          Element::DucViewportElement => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DucViewportElement>>("Element::DucViewportElement", pos),
          Element::DucXRayElement => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DucXRayElement>>("Element::DucXRayElement", pos),
          Element::DucLeaderElement => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DucLeaderElement>>("Element::DucLeaderElement", pos),
          Element::DucDimensionElement => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DucDimensionElement>>("Element::DucDimensionElement", pos),
          Element::DucFeatureControlFrameElement => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DucFeatureControlFrameElement>>("Element::DucFeatureControlFrameElement", pos),
          Element::DucDocElement => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DucDocElement>>("Element::DucDocElement", pos),
          Element::DucParametricElement => v.verify_union_variant::<flatbuffers::ForwardsUOffset<DucParametricElement>>("Element::DucParametricElement", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct ElementWrapperArgs {
    pub element_type: Element,
    pub element: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for ElementWrapperArgs {
  #[inline]
  fn default() -> Self {
    ElementWrapperArgs {
      element_type: Element::NONE,
      element: None,
    }
  }
}

pub struct ElementWrapperBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ElementWrapperBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_element_type(&mut self, element_type: Element) {
    self.fbb_.push_slot::<Element>(ElementWrapper::VT_ELEMENT_TYPE, element_type, Element::NONE);
  }
  #[inline]
  pub fn add_element(&mut self, element: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ElementWrapper::VT_ELEMENT, element);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ElementWrapperBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ElementWrapperBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ElementWrapper<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ElementWrapper<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ElementWrapper");
      ds.field("element_type", &self.element_type());
      match self.element_type() {
        Element::DucRectangleElement => {
          if let Some(x) = self.element_as_duc_rectangle_element() {
            ds.field("element", &x)
          } else {
            ds.field("element", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Element::DucPolygonElement => {
          if let Some(x) = self.element_as_duc_polygon_element() {
            ds.field("element", &x)
          } else {
            ds.field("element", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Element::DucEllipseElement => {
          if let Some(x) = self.element_as_duc_ellipse_element() {
            ds.field("element", &x)
          } else {
            ds.field("element", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Element::DucEmbeddableElement => {
          if let Some(x) = self.element_as_duc_embeddable_element() {
            ds.field("element", &x)
          } else {
            ds.field("element", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Element::DucPdfElement => {
          if let Some(x) = self.element_as_duc_pdf_element() {
            ds.field("element", &x)
          } else {
            ds.field("element", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Element::DucMermaidElement => {
          if let Some(x) = self.element_as_duc_mermaid_element() {
            ds.field("element", &x)
          } else {
            ds.field("element", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Element::DucTableElement => {
          if let Some(x) = self.element_as_duc_table_element() {
            ds.field("element", &x)
          } else {
            ds.field("element", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Element::DucImageElement => {
          if let Some(x) = self.element_as_duc_image_element() {
            ds.field("element", &x)
          } else {
            ds.field("element", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Element::DucTextElement => {
          if let Some(x) = self.element_as_duc_text_element() {
            ds.field("element", &x)
          } else {
            ds.field("element", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Element::DucLinearElement => {
          if let Some(x) = self.element_as_duc_linear_element() {
            ds.field("element", &x)
          } else {
            ds.field("element", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Element::DucArrowElement => {
          if let Some(x) = self.element_as_duc_arrow_element() {
            ds.field("element", &x)
          } else {
            ds.field("element", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Element::DucFreeDrawElement => {
          if let Some(x) = self.element_as_duc_free_draw_element() {
            ds.field("element", &x)
          } else {
            ds.field("element", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Element::DucBlockInstanceElement => {
          if let Some(x) = self.element_as_duc_block_instance_element() {
            ds.field("element", &x)
          } else {
            ds.field("element", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Element::DucFrameElement => {
          if let Some(x) = self.element_as_duc_frame_element() {
            ds.field("element", &x)
          } else {
            ds.field("element", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Element::DucPlotElement => {
          if let Some(x) = self.element_as_duc_plot_element() {
            ds.field("element", &x)
          } else {
            ds.field("element", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Element::DucViewportElement => {
          if let Some(x) = self.element_as_duc_viewport_element() {
            ds.field("element", &x)
          } else {
            ds.field("element", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Element::DucXRayElement => {
          if let Some(x) = self.element_as_duc_xray_element() {
            ds.field("element", &x)
          } else {
            ds.field("element", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Element::DucLeaderElement => {
          if let Some(x) = self.element_as_duc_leader_element() {
            ds.field("element", &x)
          } else {
            ds.field("element", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Element::DucDimensionElement => {
          if let Some(x) = self.element_as_duc_dimension_element() {
            ds.field("element", &x)
          } else {
            ds.field("element", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Element::DucFeatureControlFrameElement => {
          if let Some(x) = self.element_as_duc_feature_control_frame_element() {
            ds.field("element", &x)
          } else {
            ds.field("element", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Element::DucDocElement => {
          if let Some(x) = self.element_as_duc_doc_element() {
            ds.field("element", &x)
          } else {
            ds.field("element", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Element::DucParametricElement => {
          if let Some(x) = self.element_as_duc_parametric_element() {
            ds.field("element", &x)
          } else {
            ds.field("element", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("element", &x)
        },
      };
      ds.finish()
  }
}
pub enum DucGlobalStateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucGlobalState<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucGlobalState<'a> {
  type Inner = DucGlobalState<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucGlobalState<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_VIEW_BACKGROUND_COLOR: flatbuffers::VOffsetT = 6;
  pub const VT_MAIN_SCOPE: flatbuffers::VOffsetT = 8;
  pub const VT_DASH_SPACING_SCALE: flatbuffers::VOffsetT = 10;
  pub const VT_IS_DASH_SPACING_AFFECTED_BY_VIEWPORT_SCALE: flatbuffers::VOffsetT = 12;
  pub const VT_SCOPE_EXPONENT_THRESHOLD: flatbuffers::VOffsetT = 14;
  pub const VT_DIMENSIONS_ASSOCIATIVE_BY_DEFAULT: flatbuffers::VOffsetT = 16;
  pub const VT_USE_ANNOTATIVE_SCALING: flatbuffers::VOffsetT = 18;
  pub const VT_DISPLAY_PRECISION_LINEAR: flatbuffers::VOffsetT = 20;
  pub const VT_DISPLAY_PRECISION_ANGULAR: flatbuffers::VOffsetT = 22;
  pub const VT_PRUNING_LEVEL: flatbuffers::VOffsetT = 24;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucGlobalState { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucGlobalStateArgs<'args>
  ) -> flatbuffers::WIPOffset<DucGlobalState<'bldr>> {
    let mut builder = DucGlobalStateBuilder::new(_fbb);
    builder.add_display_precision_angular(args.display_precision_angular);
    builder.add_display_precision_linear(args.display_precision_linear);
    builder.add_dash_spacing_scale(args.dash_spacing_scale);
    if let Some(x) = args.main_scope { builder.add_main_scope(x); }
    if let Some(x) = args.view_background_color { builder.add_view_background_color(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    if let Some(x) = args.pruning_level { builder.add_pruning_level(x); }
    builder.add_use_annotative_scaling(args.use_annotative_scaling);
    builder.add_dimensions_associative_by_default(args.dimensions_associative_by_default);
    builder.add_scope_exponent_threshold(args.scope_exponent_threshold);
    builder.add_is_dash_spacing_affected_by_viewport_scale(args.is_dash_spacing_affected_by_viewport_scale);
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucGlobalState::VT_NAME, None)}
  }
  #[inline]
  pub fn view_background_color(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucGlobalState::VT_VIEW_BACKGROUND_COLOR, None)}
  }
  #[inline]
  pub fn main_scope(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucGlobalState::VT_MAIN_SCOPE, None)}
  }
  #[inline]
  pub fn dash_spacing_scale(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucGlobalState::VT_DASH_SPACING_SCALE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn is_dash_spacing_affected_by_viewport_scale(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucGlobalState::VT_IS_DASH_SPACING_AFFECTED_BY_VIEWPORT_SCALE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn scope_exponent_threshold(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(DucGlobalState::VT_SCOPE_EXPONENT_THRESHOLD, Some(0)).unwrap()}
  }
  #[inline]
  pub fn dimensions_associative_by_default(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucGlobalState::VT_DIMENSIONS_ASSOCIATIVE_BY_DEFAULT, Some(false)).unwrap()}
  }
  #[inline]
  pub fn use_annotative_scaling(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucGlobalState::VT_USE_ANNOTATIVE_SCALING, Some(false)).unwrap()}
  }
  #[inline]
  pub fn display_precision_linear(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DucGlobalState::VT_DISPLAY_PRECISION_LINEAR, Some(0)).unwrap()}
  }
  #[inline]
  pub fn display_precision_angular(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DucGlobalState::VT_DISPLAY_PRECISION_ANGULAR, Some(0)).unwrap()}
  }
  #[inline]
  pub fn pruning_level(&self) -> Option<PRUNING_LEVEL> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<PRUNING_LEVEL>(DucGlobalState::VT_PRUNING_LEVEL, None)}
  }
}

impl flatbuffers::Verifiable for DucGlobalState<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("view_background_color", Self::VT_VIEW_BACKGROUND_COLOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("main_scope", Self::VT_MAIN_SCOPE, false)?
     .visit_field::<f32>("dash_spacing_scale", Self::VT_DASH_SPACING_SCALE, false)?
     .visit_field::<bool>("is_dash_spacing_affected_by_viewport_scale", Self::VT_IS_DASH_SPACING_AFFECTED_BY_VIEWPORT_SCALE, false)?
     .visit_field::<i8>("scope_exponent_threshold", Self::VT_SCOPE_EXPONENT_THRESHOLD, false)?
     .visit_field::<bool>("dimensions_associative_by_default", Self::VT_DIMENSIONS_ASSOCIATIVE_BY_DEFAULT, false)?
     .visit_field::<bool>("use_annotative_scaling", Self::VT_USE_ANNOTATIVE_SCALING, false)?
     .visit_field::<i32>("display_precision_linear", Self::VT_DISPLAY_PRECISION_LINEAR, false)?
     .visit_field::<i32>("display_precision_angular", Self::VT_DISPLAY_PRECISION_ANGULAR, false)?
     .visit_field::<PRUNING_LEVEL>("pruning_level", Self::VT_PRUNING_LEVEL, false)?
     .finish();
    Ok(())
  }
}
pub struct DucGlobalStateArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub view_background_color: Option<flatbuffers::WIPOffset<&'a str>>,
    pub main_scope: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dash_spacing_scale: f32,
    pub is_dash_spacing_affected_by_viewport_scale: bool,
    pub scope_exponent_threshold: i8,
    pub dimensions_associative_by_default: bool,
    pub use_annotative_scaling: bool,
    pub display_precision_linear: i32,
    pub display_precision_angular: i32,
    pub pruning_level: Option<PRUNING_LEVEL>,
}
impl<'a> Default for DucGlobalStateArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucGlobalStateArgs {
      name: None,
      view_background_color: None,
      main_scope: None,
      dash_spacing_scale: 0.0,
      is_dash_spacing_affected_by_viewport_scale: false,
      scope_exponent_threshold: 0,
      dimensions_associative_by_default: false,
      use_annotative_scaling: false,
      display_precision_linear: 0,
      display_precision_angular: 0,
      pruning_level: None,
    }
  }
}

pub struct DucGlobalStateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucGlobalStateBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucGlobalState::VT_NAME, name);
  }
  #[inline]
  pub fn add_view_background_color(&mut self, view_background_color: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucGlobalState::VT_VIEW_BACKGROUND_COLOR, view_background_color);
  }
  #[inline]
  pub fn add_main_scope(&mut self, main_scope: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucGlobalState::VT_MAIN_SCOPE, main_scope);
  }
  #[inline]
  pub fn add_dash_spacing_scale(&mut self, dash_spacing_scale: f32) {
    self.fbb_.push_slot::<f32>(DucGlobalState::VT_DASH_SPACING_SCALE, dash_spacing_scale, 0.0);
  }
  #[inline]
  pub fn add_is_dash_spacing_affected_by_viewport_scale(&mut self, is_dash_spacing_affected_by_viewport_scale: bool) {
    self.fbb_.push_slot::<bool>(DucGlobalState::VT_IS_DASH_SPACING_AFFECTED_BY_VIEWPORT_SCALE, is_dash_spacing_affected_by_viewport_scale, false);
  }
  #[inline]
  pub fn add_scope_exponent_threshold(&mut self, scope_exponent_threshold: i8) {
    self.fbb_.push_slot::<i8>(DucGlobalState::VT_SCOPE_EXPONENT_THRESHOLD, scope_exponent_threshold, 0);
  }
  #[inline]
  pub fn add_dimensions_associative_by_default(&mut self, dimensions_associative_by_default: bool) {
    self.fbb_.push_slot::<bool>(DucGlobalState::VT_DIMENSIONS_ASSOCIATIVE_BY_DEFAULT, dimensions_associative_by_default, false);
  }
  #[inline]
  pub fn add_use_annotative_scaling(&mut self, use_annotative_scaling: bool) {
    self.fbb_.push_slot::<bool>(DucGlobalState::VT_USE_ANNOTATIVE_SCALING, use_annotative_scaling, false);
  }
  #[inline]
  pub fn add_display_precision_linear(&mut self, display_precision_linear: i32) {
    self.fbb_.push_slot::<i32>(DucGlobalState::VT_DISPLAY_PRECISION_LINEAR, display_precision_linear, 0);
  }
  #[inline]
  pub fn add_display_precision_angular(&mut self, display_precision_angular: i32) {
    self.fbb_.push_slot::<i32>(DucGlobalState::VT_DISPLAY_PRECISION_ANGULAR, display_precision_angular, 0);
  }
  #[inline]
  pub fn add_pruning_level(&mut self, pruning_level: PRUNING_LEVEL) {
    self.fbb_.push_slot_always::<PRUNING_LEVEL>(DucGlobalState::VT_PRUNING_LEVEL, pruning_level);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucGlobalStateBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucGlobalStateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucGlobalState<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucGlobalState<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucGlobalState");
      ds.field("name", &self.name());
      ds.field("view_background_color", &self.view_background_color());
      ds.field("main_scope", &self.main_scope());
      ds.field("dash_spacing_scale", &self.dash_spacing_scale());
      ds.field("is_dash_spacing_affected_by_viewport_scale", &self.is_dash_spacing_affected_by_viewport_scale());
      ds.field("scope_exponent_threshold", &self.scope_exponent_threshold());
      ds.field("dimensions_associative_by_default", &self.dimensions_associative_by_default());
      ds.field("use_annotative_scaling", &self.use_annotative_scaling());
      ds.field("display_precision_linear", &self.display_precision_linear());
      ds.field("display_precision_angular", &self.display_precision_angular());
      ds.field("pruning_level", &self.pruning_level());
      ds.finish()
  }
}
pub enum DucLocalStateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucLocalState<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucLocalState<'a> {
  type Inner = DucLocalState<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucLocalState<'a> {
  pub const VT_SCOPE: flatbuffers::VOffsetT = 4;
  pub const VT_ACTIVE_STANDARD_ID: flatbuffers::VOffsetT = 6;
  pub const VT_SCROLL_X: flatbuffers::VOffsetT = 8;
  pub const VT_SCROLL_Y: flatbuffers::VOffsetT = 10;
  pub const VT_ZOOM: flatbuffers::VOffsetT = 12;
  pub const VT_ACTIVE_GRID_SETTINGS: flatbuffers::VOffsetT = 14;
  pub const VT_ACTIVE_SNAP_SETTINGS: flatbuffers::VOffsetT = 16;
  pub const VT_IS_BINDING_ENABLED: flatbuffers::VOffsetT = 18;
  pub const VT_CURRENT_ITEM_STROKE: flatbuffers::VOffsetT = 20;
  pub const VT_CURRENT_ITEM_BACKGROUND: flatbuffers::VOffsetT = 22;
  pub const VT_CURRENT_ITEM_OPACITY: flatbuffers::VOffsetT = 24;
  pub const VT_CURRENT_ITEM_FONT_FAMILY: flatbuffers::VOffsetT = 26;
  pub const VT_CURRENT_ITEM_FONT_SIZE: flatbuffers::VOffsetT = 28;
  pub const VT_CURRENT_ITEM_TEXT_ALIGN: flatbuffers::VOffsetT = 30;
  pub const VT_CURRENT_ITEM_START_LINE_HEAD: flatbuffers::VOffsetT = 32;
  pub const VT_CURRENT_ITEM_END_LINE_HEAD: flatbuffers::VOffsetT = 34;
  pub const VT_CURRENT_ITEM_ROUNDNESS: flatbuffers::VOffsetT = 36;
  pub const VT_PEN_MODE: flatbuffers::VOffsetT = 38;
  pub const VT_VIEW_MODE_ENABLED: flatbuffers::VOffsetT = 40;
  pub const VT_OBJECTS_SNAP_MODE_ENABLED: flatbuffers::VOffsetT = 42;
  pub const VT_GRID_MODE_ENABLED: flatbuffers::VOffsetT = 44;
  pub const VT_OUTLINE_MODE_ENABLED: flatbuffers::VOffsetT = 46;
  pub const VT_MANUAL_SAVE_MODE: flatbuffers::VOffsetT = 48;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucLocalState { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucLocalStateArgs<'args>
  ) -> flatbuffers::WIPOffset<DucLocalState<'bldr>> {
    let mut builder = DucLocalStateBuilder::new(_fbb);
    builder.add_current_item_roundness(args.current_item_roundness);
    builder.add_current_item_font_size(args.current_item_font_size);
    builder.add_zoom(args.zoom);
    builder.add_scroll_y(args.scroll_y);
    builder.add_scroll_x(args.scroll_x);
    if let Some(x) = args.current_item_end_line_head { builder.add_current_item_end_line_head(x); }
    if let Some(x) = args.current_item_start_line_head { builder.add_current_item_start_line_head(x); }
    if let Some(x) = args.current_item_font_family { builder.add_current_item_font_family(x); }
    builder.add_current_item_opacity(args.current_item_opacity);
    if let Some(x) = args.current_item_background { builder.add_current_item_background(x); }
    if let Some(x) = args.current_item_stroke { builder.add_current_item_stroke(x); }
    if let Some(x) = args.active_snap_settings { builder.add_active_snap_settings(x); }
    if let Some(x) = args.active_grid_settings { builder.add_active_grid_settings(x); }
    if let Some(x) = args.active_standard_id { builder.add_active_standard_id(x); }
    if let Some(x) = args.scope { builder.add_scope(x); }
    builder.add_manual_save_mode(args.manual_save_mode);
    builder.add_outline_mode_enabled(args.outline_mode_enabled);
    builder.add_grid_mode_enabled(args.grid_mode_enabled);
    builder.add_objects_snap_mode_enabled(args.objects_snap_mode_enabled);
    builder.add_view_mode_enabled(args.view_mode_enabled);
    builder.add_pen_mode(args.pen_mode);
    if let Some(x) = args.current_item_text_align { builder.add_current_item_text_align(x); }
    builder.add_is_binding_enabled(args.is_binding_enabled);
    builder.finish()
  }


  #[inline]
  pub fn scope(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucLocalState::VT_SCOPE, None)}
  }
  #[inline]
  pub fn active_standard_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucLocalState::VT_ACTIVE_STANDARD_ID, None)}
  }
  #[inline]
  pub fn scroll_x(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucLocalState::VT_SCROLL_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn scroll_y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucLocalState::VT_SCROLL_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn zoom(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucLocalState::VT_ZOOM, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn active_grid_settings(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(DucLocalState::VT_ACTIVE_GRID_SETTINGS, None)}
  }
  #[inline]
  pub fn active_snap_settings(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucLocalState::VT_ACTIVE_SNAP_SETTINGS, None)}
  }
  #[inline]
  pub fn is_binding_enabled(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucLocalState::VT_IS_BINDING_ENABLED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn current_item_stroke(&self) -> Option<ElementStroke<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ElementStroke>>(DucLocalState::VT_CURRENT_ITEM_STROKE, None)}
  }
  #[inline]
  pub fn current_item_background(&self) -> Option<ElementBackground<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ElementBackground>>(DucLocalState::VT_CURRENT_ITEM_BACKGROUND, None)}
  }
  #[inline]
  pub fn current_item_opacity(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucLocalState::VT_CURRENT_ITEM_OPACITY, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn current_item_font_family(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucLocalState::VT_CURRENT_ITEM_FONT_FAMILY, None)}
  }
  #[inline]
  pub fn current_item_font_size(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucLocalState::VT_CURRENT_ITEM_FONT_SIZE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn current_item_text_align(&self) -> Option<TEXT_ALIGN> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<TEXT_ALIGN>(DucLocalState::VT_CURRENT_ITEM_TEXT_ALIGN, None)}
  }
  #[inline]
  pub fn current_item_start_line_head(&self) -> Option<DucHead<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucHead>>(DucLocalState::VT_CURRENT_ITEM_START_LINE_HEAD, None)}
  }
  #[inline]
  pub fn current_item_end_line_head(&self) -> Option<DucHead<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucHead>>(DucLocalState::VT_CURRENT_ITEM_END_LINE_HEAD, None)}
  }
  #[inline]
  pub fn current_item_roundness(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucLocalState::VT_CURRENT_ITEM_ROUNDNESS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn pen_mode(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucLocalState::VT_PEN_MODE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn view_mode_enabled(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucLocalState::VT_VIEW_MODE_ENABLED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn objects_snap_mode_enabled(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucLocalState::VT_OBJECTS_SNAP_MODE_ENABLED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn grid_mode_enabled(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucLocalState::VT_GRID_MODE_ENABLED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn outline_mode_enabled(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucLocalState::VT_OUTLINE_MODE_ENABLED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn manual_save_mode(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucLocalState::VT_MANUAL_SAVE_MODE, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DucLocalState<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("scope", Self::VT_SCOPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("active_standard_id", Self::VT_ACTIVE_STANDARD_ID, false)?
     .visit_field::<f64>("scroll_x", Self::VT_SCROLL_X, false)?
     .visit_field::<f64>("scroll_y", Self::VT_SCROLL_Y, false)?
     .visit_field::<f64>("zoom", Self::VT_ZOOM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("active_grid_settings", Self::VT_ACTIVE_GRID_SETTINGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("active_snap_settings", Self::VT_ACTIVE_SNAP_SETTINGS, false)?
     .visit_field::<bool>("is_binding_enabled", Self::VT_IS_BINDING_ENABLED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ElementStroke>>("current_item_stroke", Self::VT_CURRENT_ITEM_STROKE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ElementBackground>>("current_item_background", Self::VT_CURRENT_ITEM_BACKGROUND, false)?
     .visit_field::<f32>("current_item_opacity", Self::VT_CURRENT_ITEM_OPACITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("current_item_font_family", Self::VT_CURRENT_ITEM_FONT_FAMILY, false)?
     .visit_field::<f64>("current_item_font_size", Self::VT_CURRENT_ITEM_FONT_SIZE, false)?
     .visit_field::<TEXT_ALIGN>("current_item_text_align", Self::VT_CURRENT_ITEM_TEXT_ALIGN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucHead>>("current_item_start_line_head", Self::VT_CURRENT_ITEM_START_LINE_HEAD, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucHead>>("current_item_end_line_head", Self::VT_CURRENT_ITEM_END_LINE_HEAD, false)?
     .visit_field::<f64>("current_item_roundness", Self::VT_CURRENT_ITEM_ROUNDNESS, false)?
     .visit_field::<bool>("pen_mode", Self::VT_PEN_MODE, false)?
     .visit_field::<bool>("view_mode_enabled", Self::VT_VIEW_MODE_ENABLED, false)?
     .visit_field::<bool>("objects_snap_mode_enabled", Self::VT_OBJECTS_SNAP_MODE_ENABLED, false)?
     .visit_field::<bool>("grid_mode_enabled", Self::VT_GRID_MODE_ENABLED, false)?
     .visit_field::<bool>("outline_mode_enabled", Self::VT_OUTLINE_MODE_ENABLED, false)?
     .visit_field::<bool>("manual_save_mode", Self::VT_MANUAL_SAVE_MODE, false)?
     .finish();
    Ok(())
  }
}
pub struct DucLocalStateArgs<'a> {
    pub scope: Option<flatbuffers::WIPOffset<&'a str>>,
    pub active_standard_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub scroll_x: f64,
    pub scroll_y: f64,
    pub zoom: f64,
    pub active_grid_settings: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub active_snap_settings: Option<flatbuffers::WIPOffset<&'a str>>,
    pub is_binding_enabled: bool,
    pub current_item_stroke: Option<flatbuffers::WIPOffset<ElementStroke<'a>>>,
    pub current_item_background: Option<flatbuffers::WIPOffset<ElementBackground<'a>>>,
    pub current_item_opacity: f32,
    pub current_item_font_family: Option<flatbuffers::WIPOffset<&'a str>>,
    pub current_item_font_size: f64,
    pub current_item_text_align: Option<TEXT_ALIGN>,
    pub current_item_start_line_head: Option<flatbuffers::WIPOffset<DucHead<'a>>>,
    pub current_item_end_line_head: Option<flatbuffers::WIPOffset<DucHead<'a>>>,
    pub current_item_roundness: f64,
    pub pen_mode: bool,
    pub view_mode_enabled: bool,
    pub objects_snap_mode_enabled: bool,
    pub grid_mode_enabled: bool,
    pub outline_mode_enabled: bool,
    pub manual_save_mode: bool,
}
impl<'a> Default for DucLocalStateArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucLocalStateArgs {
      scope: None,
      active_standard_id: None,
      scroll_x: 0.0,
      scroll_y: 0.0,
      zoom: 0.0,
      active_grid_settings: None,
      active_snap_settings: None,
      is_binding_enabled: false,
      current_item_stroke: None,
      current_item_background: None,
      current_item_opacity: 0.0,
      current_item_font_family: None,
      current_item_font_size: 0.0,
      current_item_text_align: None,
      current_item_start_line_head: None,
      current_item_end_line_head: None,
      current_item_roundness: 0.0,
      pen_mode: false,
      view_mode_enabled: false,
      objects_snap_mode_enabled: false,
      grid_mode_enabled: false,
      outline_mode_enabled: false,
      manual_save_mode: false,
    }
  }
}

pub struct DucLocalStateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucLocalStateBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_scope(&mut self, scope: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucLocalState::VT_SCOPE, scope);
  }
  #[inline]
  pub fn add_active_standard_id(&mut self, active_standard_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucLocalState::VT_ACTIVE_STANDARD_ID, active_standard_id);
  }
  #[inline]
  pub fn add_scroll_x(&mut self, scroll_x: f64) {
    self.fbb_.push_slot::<f64>(DucLocalState::VT_SCROLL_X, scroll_x, 0.0);
  }
  #[inline]
  pub fn add_scroll_y(&mut self, scroll_y: f64) {
    self.fbb_.push_slot::<f64>(DucLocalState::VT_SCROLL_Y, scroll_y, 0.0);
  }
  #[inline]
  pub fn add_zoom(&mut self, zoom: f64) {
    self.fbb_.push_slot::<f64>(DucLocalState::VT_ZOOM, zoom, 0.0);
  }
  #[inline]
  pub fn add_active_grid_settings(&mut self, active_grid_settings: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucLocalState::VT_ACTIVE_GRID_SETTINGS, active_grid_settings);
  }
  #[inline]
  pub fn add_active_snap_settings(&mut self, active_snap_settings: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucLocalState::VT_ACTIVE_SNAP_SETTINGS, active_snap_settings);
  }
  #[inline]
  pub fn add_is_binding_enabled(&mut self, is_binding_enabled: bool) {
    self.fbb_.push_slot::<bool>(DucLocalState::VT_IS_BINDING_ENABLED, is_binding_enabled, false);
  }
  #[inline]
  pub fn add_current_item_stroke(&mut self, current_item_stroke: flatbuffers::WIPOffset<ElementStroke<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ElementStroke>>(DucLocalState::VT_CURRENT_ITEM_STROKE, current_item_stroke);
  }
  #[inline]
  pub fn add_current_item_background(&mut self, current_item_background: flatbuffers::WIPOffset<ElementBackground<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ElementBackground>>(DucLocalState::VT_CURRENT_ITEM_BACKGROUND, current_item_background);
  }
  #[inline]
  pub fn add_current_item_opacity(&mut self, current_item_opacity: f32) {
    self.fbb_.push_slot::<f32>(DucLocalState::VT_CURRENT_ITEM_OPACITY, current_item_opacity, 0.0);
  }
  #[inline]
  pub fn add_current_item_font_family(&mut self, current_item_font_family: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucLocalState::VT_CURRENT_ITEM_FONT_FAMILY, current_item_font_family);
  }
  #[inline]
  pub fn add_current_item_font_size(&mut self, current_item_font_size: f64) {
    self.fbb_.push_slot::<f64>(DucLocalState::VT_CURRENT_ITEM_FONT_SIZE, current_item_font_size, 0.0);
  }
  #[inline]
  pub fn add_current_item_text_align(&mut self, current_item_text_align: TEXT_ALIGN) {
    self.fbb_.push_slot_always::<TEXT_ALIGN>(DucLocalState::VT_CURRENT_ITEM_TEXT_ALIGN, current_item_text_align);
  }
  #[inline]
  pub fn add_current_item_start_line_head(&mut self, current_item_start_line_head: flatbuffers::WIPOffset<DucHead<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucHead>>(DucLocalState::VT_CURRENT_ITEM_START_LINE_HEAD, current_item_start_line_head);
  }
  #[inline]
  pub fn add_current_item_end_line_head(&mut self, current_item_end_line_head: flatbuffers::WIPOffset<DucHead<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucHead>>(DucLocalState::VT_CURRENT_ITEM_END_LINE_HEAD, current_item_end_line_head);
  }
  #[inline]
  pub fn add_current_item_roundness(&mut self, current_item_roundness: f64) {
    self.fbb_.push_slot::<f64>(DucLocalState::VT_CURRENT_ITEM_ROUNDNESS, current_item_roundness, 0.0);
  }
  #[inline]
  pub fn add_pen_mode(&mut self, pen_mode: bool) {
    self.fbb_.push_slot::<bool>(DucLocalState::VT_PEN_MODE, pen_mode, false);
  }
  #[inline]
  pub fn add_view_mode_enabled(&mut self, view_mode_enabled: bool) {
    self.fbb_.push_slot::<bool>(DucLocalState::VT_VIEW_MODE_ENABLED, view_mode_enabled, false);
  }
  #[inline]
  pub fn add_objects_snap_mode_enabled(&mut self, objects_snap_mode_enabled: bool) {
    self.fbb_.push_slot::<bool>(DucLocalState::VT_OBJECTS_SNAP_MODE_ENABLED, objects_snap_mode_enabled, false);
  }
  #[inline]
  pub fn add_grid_mode_enabled(&mut self, grid_mode_enabled: bool) {
    self.fbb_.push_slot::<bool>(DucLocalState::VT_GRID_MODE_ENABLED, grid_mode_enabled, false);
  }
  #[inline]
  pub fn add_outline_mode_enabled(&mut self, outline_mode_enabled: bool) {
    self.fbb_.push_slot::<bool>(DucLocalState::VT_OUTLINE_MODE_ENABLED, outline_mode_enabled, false);
  }
  #[inline]
  pub fn add_manual_save_mode(&mut self, manual_save_mode: bool) {
    self.fbb_.push_slot::<bool>(DucLocalState::VT_MANUAL_SAVE_MODE, manual_save_mode, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucLocalStateBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucLocalStateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucLocalState<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucLocalState<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucLocalState");
      ds.field("scope", &self.scope());
      ds.field("active_standard_id", &self.active_standard_id());
      ds.field("scroll_x", &self.scroll_x());
      ds.field("scroll_y", &self.scroll_y());
      ds.field("zoom", &self.zoom());
      ds.field("active_grid_settings", &self.active_grid_settings());
      ds.field("active_snap_settings", &self.active_snap_settings());
      ds.field("is_binding_enabled", &self.is_binding_enabled());
      ds.field("current_item_stroke", &self.current_item_stroke());
      ds.field("current_item_background", &self.current_item_background());
      ds.field("current_item_opacity", &self.current_item_opacity());
      ds.field("current_item_font_family", &self.current_item_font_family());
      ds.field("current_item_font_size", &self.current_item_font_size());
      ds.field("current_item_text_align", &self.current_item_text_align());
      ds.field("current_item_start_line_head", &self.current_item_start_line_head());
      ds.field("current_item_end_line_head", &self.current_item_end_line_head());
      ds.field("current_item_roundness", &self.current_item_roundness());
      ds.field("pen_mode", &self.pen_mode());
      ds.field("view_mode_enabled", &self.view_mode_enabled());
      ds.field("objects_snap_mode_enabled", &self.objects_snap_mode_enabled());
      ds.field("grid_mode_enabled", &self.grid_mode_enabled());
      ds.field("outline_mode_enabled", &self.outline_mode_enabled());
      ds.field("manual_save_mode", &self.manual_save_mode());
      ds.finish()
  }
}
pub enum DucGroupOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucGroup<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucGroup<'a> {
  type Inner = DucGroup<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucGroup<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_STACK_BASE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucGroup { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucGroupArgs<'args>
  ) -> flatbuffers::WIPOffset<DucGroup<'bldr>> {
    let mut builder = DucGroupBuilder::new(_fbb);
    if let Some(x) = args.stack_base { builder.add_stack_base(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucGroup::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &DucGroup) -> bool {
    self.id() < o.id()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.id();
    key.cmp(val)
  }
  #[inline]
  pub fn stack_base(&self) -> Option<_DucStackBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<_DucStackBase>>(DucGroup::VT_STACK_BASE, None)}
  }
}

impl flatbuffers::Verifiable for DucGroup<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<_DucStackBase>>("stack_base", Self::VT_STACK_BASE, false)?
     .finish();
    Ok(())
  }
}
pub struct DucGroupArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stack_base: Option<flatbuffers::WIPOffset<_DucStackBase<'a>>>,
}
impl<'a> Default for DucGroupArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucGroupArgs {
      id: None, // required field
      stack_base: None,
    }
  }
}

pub struct DucGroupBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucGroupBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucGroup::VT_ID, id);
  }
  #[inline]
  pub fn add_stack_base(&mut self, stack_base: flatbuffers::WIPOffset<_DucStackBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_DucStackBase>>(DucGroup::VT_STACK_BASE, stack_base);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucGroupBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucGroupBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucGroup<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, DucGroup::VT_ID,"id");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucGroup<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucGroup");
      ds.field("id", &self.id());
      ds.field("stack_base", &self.stack_base());
      ds.finish()
  }
}
pub enum DucRegionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucRegion<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucRegion<'a> {
  type Inner = DucRegion<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucRegion<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_STACK_BASE: flatbuffers::VOffsetT = 6;
  pub const VT_BOOLEAN_OPERATION: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucRegion { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucRegionArgs<'args>
  ) -> flatbuffers::WIPOffset<DucRegion<'bldr>> {
    let mut builder = DucRegionBuilder::new(_fbb);
    if let Some(x) = args.stack_base { builder.add_stack_base(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    if let Some(x) = args.boolean_operation { builder.add_boolean_operation(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucRegion::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &DucRegion) -> bool {
    self.id() < o.id()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.id();
    key.cmp(val)
  }
  #[inline]
  pub fn stack_base(&self) -> Option<_DucStackBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<_DucStackBase>>(DucRegion::VT_STACK_BASE, None)}
  }
  #[inline]
  pub fn boolean_operation(&self) -> Option<BOOLEAN_OPERATION> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<BOOLEAN_OPERATION>(DucRegion::VT_BOOLEAN_OPERATION, None)}
  }
}

impl flatbuffers::Verifiable for DucRegion<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<_DucStackBase>>("stack_base", Self::VT_STACK_BASE, false)?
     .visit_field::<BOOLEAN_OPERATION>("boolean_operation", Self::VT_BOOLEAN_OPERATION, false)?
     .finish();
    Ok(())
  }
}
pub struct DucRegionArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stack_base: Option<flatbuffers::WIPOffset<_DucStackBase<'a>>>,
    pub boolean_operation: Option<BOOLEAN_OPERATION>,
}
impl<'a> Default for DucRegionArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucRegionArgs {
      id: None, // required field
      stack_base: None,
      boolean_operation: None,
    }
  }
}

pub struct DucRegionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucRegionBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucRegion::VT_ID, id);
  }
  #[inline]
  pub fn add_stack_base(&mut self, stack_base: flatbuffers::WIPOffset<_DucStackBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_DucStackBase>>(DucRegion::VT_STACK_BASE, stack_base);
  }
  #[inline]
  pub fn add_boolean_operation(&mut self, boolean_operation: BOOLEAN_OPERATION) {
    self.fbb_.push_slot_always::<BOOLEAN_OPERATION>(DucRegion::VT_BOOLEAN_OPERATION, boolean_operation);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucRegionBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucRegionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucRegion<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, DucRegion::VT_ID,"id");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucRegion<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucRegion");
      ds.field("id", &self.id());
      ds.field("stack_base", &self.stack_base());
      ds.field("boolean_operation", &self.boolean_operation());
      ds.finish()
  }
}
pub enum DucLayerOverridesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucLayerOverrides<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucLayerOverrides<'a> {
  type Inner = DucLayerOverrides<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucLayerOverrides<'a> {
  pub const VT_STROKE: flatbuffers::VOffsetT = 4;
  pub const VT_BACKGROUND: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucLayerOverrides { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucLayerOverridesArgs<'args>
  ) -> flatbuffers::WIPOffset<DucLayerOverrides<'bldr>> {
    let mut builder = DucLayerOverridesBuilder::new(_fbb);
    if let Some(x) = args.background { builder.add_background(x); }
    if let Some(x) = args.stroke { builder.add_stroke(x); }
    builder.finish()
  }


  #[inline]
  pub fn stroke(&self) -> Option<ElementStroke<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ElementStroke>>(DucLayerOverrides::VT_STROKE, None)}
  }
  #[inline]
  pub fn background(&self) -> Option<ElementBackground<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ElementBackground>>(DucLayerOverrides::VT_BACKGROUND, None)}
  }
}

impl flatbuffers::Verifiable for DucLayerOverrides<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<ElementStroke>>("stroke", Self::VT_STROKE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ElementBackground>>("background", Self::VT_BACKGROUND, false)?
     .finish();
    Ok(())
  }
}
pub struct DucLayerOverridesArgs<'a> {
    pub stroke: Option<flatbuffers::WIPOffset<ElementStroke<'a>>>,
    pub background: Option<flatbuffers::WIPOffset<ElementBackground<'a>>>,
}
impl<'a> Default for DucLayerOverridesArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucLayerOverridesArgs {
      stroke: None,
      background: None,
    }
  }
}

pub struct DucLayerOverridesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucLayerOverridesBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_stroke(&mut self, stroke: flatbuffers::WIPOffset<ElementStroke<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ElementStroke>>(DucLayerOverrides::VT_STROKE, stroke);
  }
  #[inline]
  pub fn add_background(&mut self, background: flatbuffers::WIPOffset<ElementBackground<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ElementBackground>>(DucLayerOverrides::VT_BACKGROUND, background);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucLayerOverridesBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucLayerOverridesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucLayerOverrides<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucLayerOverrides<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucLayerOverrides");
      ds.field("stroke", &self.stroke());
      ds.field("background", &self.background());
      ds.finish()
  }
}
pub enum DucLayerOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucLayer<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucLayer<'a> {
  type Inner = DucLayer<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucLayer<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_STACK_BASE: flatbuffers::VOffsetT = 6;
  pub const VT_READONLY: flatbuffers::VOffsetT = 8;
  pub const VT_OVERRIDES: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucLayer { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucLayerArgs<'args>
  ) -> flatbuffers::WIPOffset<DucLayer<'bldr>> {
    let mut builder = DucLayerBuilder::new(_fbb);
    if let Some(x) = args.overrides { builder.add_overrides(x); }
    if let Some(x) = args.stack_base { builder.add_stack_base(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_readonly(args.readonly);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucLayer::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &DucLayer) -> bool {
    self.id() < o.id()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.id();
    key.cmp(val)
  }
  #[inline]
  pub fn stack_base(&self) -> Option<_DucStackBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<_DucStackBase>>(DucLayer::VT_STACK_BASE, None)}
  }
  #[inline]
  pub fn readonly(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucLayer::VT_READONLY, Some(false)).unwrap()}
  }
  #[inline]
  pub fn overrides(&self) -> Option<DucLayerOverrides<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucLayerOverrides>>(DucLayer::VT_OVERRIDES, None)}
  }
}

impl flatbuffers::Verifiable for DucLayer<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<_DucStackBase>>("stack_base", Self::VT_STACK_BASE, false)?
     .visit_field::<bool>("readonly", Self::VT_READONLY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucLayerOverrides>>("overrides", Self::VT_OVERRIDES, false)?
     .finish();
    Ok(())
  }
}
pub struct DucLayerArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stack_base: Option<flatbuffers::WIPOffset<_DucStackBase<'a>>>,
    pub readonly: bool,
    pub overrides: Option<flatbuffers::WIPOffset<DucLayerOverrides<'a>>>,
}
impl<'a> Default for DucLayerArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucLayerArgs {
      id: None, // required field
      stack_base: None,
      readonly: false,
      overrides: None,
    }
  }
}

pub struct DucLayerBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucLayerBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucLayer::VT_ID, id);
  }
  #[inline]
  pub fn add_stack_base(&mut self, stack_base: flatbuffers::WIPOffset<_DucStackBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_DucStackBase>>(DucLayer::VT_STACK_BASE, stack_base);
  }
  #[inline]
  pub fn add_readonly(&mut self, readonly: bool) {
    self.fbb_.push_slot::<bool>(DucLayer::VT_READONLY, readonly, false);
  }
  #[inline]
  pub fn add_overrides(&mut self, overrides: flatbuffers::WIPOffset<DucLayerOverrides<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucLayerOverrides>>(DucLayer::VT_OVERRIDES, overrides);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucLayerBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucLayerBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucLayer<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, DucLayer::VT_ID,"id");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucLayer<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucLayer");
      ds.field("id", &self.id());
      ds.field("stack_base", &self.stack_base());
      ds.field("readonly", &self.readonly());
      ds.field("overrides", &self.overrides());
      ds.finish()
  }
}
pub enum _UnitSystemBaseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct _UnitSystemBase<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for _UnitSystemBase<'a> {
  type Inner = _UnitSystemBase<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> _UnitSystemBase<'a> {
  pub const VT_SYSTEM: flatbuffers::VOffsetT = 4;
  pub const VT_PRECISION: flatbuffers::VOffsetT = 6;
  pub const VT_SUPPRESS_LEADING_ZEROS: flatbuffers::VOffsetT = 8;
  pub const VT_SUPPRESS_TRAILING_ZEROS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    _UnitSystemBase { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args _UnitSystemBaseArgs
  ) -> flatbuffers::WIPOffset<_UnitSystemBase<'bldr>> {
    let mut builder = _UnitSystemBaseBuilder::new(_fbb);
    builder.add_precision(args.precision);
    builder.add_suppress_trailing_zeros(args.suppress_trailing_zeros);
    builder.add_suppress_leading_zeros(args.suppress_leading_zeros);
    if let Some(x) = args.system { builder.add_system(x); }
    builder.finish()
  }


  #[inline]
  pub fn system(&self) -> Option<UNIT_SYSTEM> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<UNIT_SYSTEM>(_UnitSystemBase::VT_SYSTEM, None)}
  }
  #[inline]
  pub fn precision(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(_UnitSystemBase::VT_PRECISION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn suppress_leading_zeros(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(_UnitSystemBase::VT_SUPPRESS_LEADING_ZEROS, Some(false)).unwrap()}
  }
  #[inline]
  pub fn suppress_trailing_zeros(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(_UnitSystemBase::VT_SUPPRESS_TRAILING_ZEROS, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for _UnitSystemBase<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<UNIT_SYSTEM>("system", Self::VT_SYSTEM, false)?
     .visit_field::<i32>("precision", Self::VT_PRECISION, false)?
     .visit_field::<bool>("suppress_leading_zeros", Self::VT_SUPPRESS_LEADING_ZEROS, false)?
     .visit_field::<bool>("suppress_trailing_zeros", Self::VT_SUPPRESS_TRAILING_ZEROS, false)?
     .finish();
    Ok(())
  }
}
pub struct _UnitSystemBaseArgs {
    pub system: Option<UNIT_SYSTEM>,
    pub precision: i32,
    pub suppress_leading_zeros: bool,
    pub suppress_trailing_zeros: bool,
}
impl<'a> Default for _UnitSystemBaseArgs {
  #[inline]
  fn default() -> Self {
    _UnitSystemBaseArgs {
      system: None,
      precision: 0,
      suppress_leading_zeros: false,
      suppress_trailing_zeros: false,
    }
  }
}

pub struct _UnitSystemBaseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> _UnitSystemBaseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_system(&mut self, system: UNIT_SYSTEM) {
    self.fbb_.push_slot_always::<UNIT_SYSTEM>(_UnitSystemBase::VT_SYSTEM, system);
  }
  #[inline]
  pub fn add_precision(&mut self, precision: i32) {
    self.fbb_.push_slot::<i32>(_UnitSystemBase::VT_PRECISION, precision, 0);
  }
  #[inline]
  pub fn add_suppress_leading_zeros(&mut self, suppress_leading_zeros: bool) {
    self.fbb_.push_slot::<bool>(_UnitSystemBase::VT_SUPPRESS_LEADING_ZEROS, suppress_leading_zeros, false);
  }
  #[inline]
  pub fn add_suppress_trailing_zeros(&mut self, suppress_trailing_zeros: bool) {
    self.fbb_.push_slot::<bool>(_UnitSystemBase::VT_SUPPRESS_TRAILING_ZEROS, suppress_trailing_zeros, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> _UnitSystemBaseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    _UnitSystemBaseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<_UnitSystemBase<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for _UnitSystemBase<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("_UnitSystemBase");
      ds.field("system", &self.system());
      ds.field("precision", &self.precision());
      ds.field("suppress_leading_zeros", &self.suppress_leading_zeros());
      ds.field("suppress_trailing_zeros", &self.suppress_trailing_zeros());
      ds.finish()
  }
}
pub enum LinearUnitSystemOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LinearUnitSystem<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LinearUnitSystem<'a> {
  type Inner = LinearUnitSystem<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LinearUnitSystem<'a> {
  pub const VT_BASE: flatbuffers::VOffsetT = 4;
  pub const VT_FORMAT: flatbuffers::VOffsetT = 6;
  pub const VT_DECIMAL_SEPARATOR: flatbuffers::VOffsetT = 8;
  pub const VT_SUPPRESS_ZERO_FEET: flatbuffers::VOffsetT = 10;
  pub const VT_SUPPRESS_ZERO_INCHES: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LinearUnitSystem { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LinearUnitSystemArgs<'args>
  ) -> flatbuffers::WIPOffset<LinearUnitSystem<'bldr>> {
    let mut builder = LinearUnitSystemBuilder::new(_fbb);
    if let Some(x) = args.base { builder.add_base(x); }
    builder.add_suppress_zero_inches(args.suppress_zero_inches);
    builder.add_suppress_zero_feet(args.suppress_zero_feet);
    if let Some(x) = args.decimal_separator { builder.add_decimal_separator(x); }
    if let Some(x) = args.format { builder.add_format(x); }
    builder.finish()
  }


  #[inline]
  pub fn base(&self) -> Option<_UnitSystemBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<_UnitSystemBase>>(LinearUnitSystem::VT_BASE, None)}
  }
  #[inline]
  pub fn format(&self) -> Option<DIMENSION_UNITS_FORMAT> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DIMENSION_UNITS_FORMAT>(LinearUnitSystem::VT_FORMAT, None)}
  }
  #[inline]
  pub fn decimal_separator(&self) -> Option<DECIMAL_SEPARATOR> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DECIMAL_SEPARATOR>(LinearUnitSystem::VT_DECIMAL_SEPARATOR, None)}
  }
  #[inline]
  pub fn suppress_zero_feet(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(LinearUnitSystem::VT_SUPPRESS_ZERO_FEET, Some(false)).unwrap()}
  }
  #[inline]
  pub fn suppress_zero_inches(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(LinearUnitSystem::VT_SUPPRESS_ZERO_INCHES, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for LinearUnitSystem<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<_UnitSystemBase>>("base", Self::VT_BASE, false)?
     .visit_field::<DIMENSION_UNITS_FORMAT>("format", Self::VT_FORMAT, false)?
     .visit_field::<DECIMAL_SEPARATOR>("decimal_separator", Self::VT_DECIMAL_SEPARATOR, false)?
     .visit_field::<bool>("suppress_zero_feet", Self::VT_SUPPRESS_ZERO_FEET, false)?
     .visit_field::<bool>("suppress_zero_inches", Self::VT_SUPPRESS_ZERO_INCHES, false)?
     .finish();
    Ok(())
  }
}
pub struct LinearUnitSystemArgs<'a> {
    pub base: Option<flatbuffers::WIPOffset<_UnitSystemBase<'a>>>,
    pub format: Option<DIMENSION_UNITS_FORMAT>,
    pub decimal_separator: Option<DECIMAL_SEPARATOR>,
    pub suppress_zero_feet: bool,
    pub suppress_zero_inches: bool,
}
impl<'a> Default for LinearUnitSystemArgs<'a> {
  #[inline]
  fn default() -> Self {
    LinearUnitSystemArgs {
      base: None,
      format: None,
      decimal_separator: None,
      suppress_zero_feet: false,
      suppress_zero_inches: false,
    }
  }
}

pub struct LinearUnitSystemBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LinearUnitSystemBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_base(&mut self, base: flatbuffers::WIPOffset<_UnitSystemBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_UnitSystemBase>>(LinearUnitSystem::VT_BASE, base);
  }
  #[inline]
  pub fn add_format(&mut self, format: DIMENSION_UNITS_FORMAT) {
    self.fbb_.push_slot_always::<DIMENSION_UNITS_FORMAT>(LinearUnitSystem::VT_FORMAT, format);
  }
  #[inline]
  pub fn add_decimal_separator(&mut self, decimal_separator: DECIMAL_SEPARATOR) {
    self.fbb_.push_slot_always::<DECIMAL_SEPARATOR>(LinearUnitSystem::VT_DECIMAL_SEPARATOR, decimal_separator);
  }
  #[inline]
  pub fn add_suppress_zero_feet(&mut self, suppress_zero_feet: bool) {
    self.fbb_.push_slot::<bool>(LinearUnitSystem::VT_SUPPRESS_ZERO_FEET, suppress_zero_feet, false);
  }
  #[inline]
  pub fn add_suppress_zero_inches(&mut self, suppress_zero_inches: bool) {
    self.fbb_.push_slot::<bool>(LinearUnitSystem::VT_SUPPRESS_ZERO_INCHES, suppress_zero_inches, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LinearUnitSystemBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LinearUnitSystemBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LinearUnitSystem<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LinearUnitSystem<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LinearUnitSystem");
      ds.field("base", &self.base());
      ds.field("format", &self.format());
      ds.field("decimal_separator", &self.decimal_separator());
      ds.field("suppress_zero_feet", &self.suppress_zero_feet());
      ds.field("suppress_zero_inches", &self.suppress_zero_inches());
      ds.finish()
  }
}
pub enum AngularUnitSystemOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AngularUnitSystem<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AngularUnitSystem<'a> {
  type Inner = AngularUnitSystem<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AngularUnitSystem<'a> {
  pub const VT_BASE: flatbuffers::VOffsetT = 4;
  pub const VT_FORMAT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AngularUnitSystem { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AngularUnitSystemArgs<'args>
  ) -> flatbuffers::WIPOffset<AngularUnitSystem<'bldr>> {
    let mut builder = AngularUnitSystemBuilder::new(_fbb);
    if let Some(x) = args.base { builder.add_base(x); }
    if let Some(x) = args.format { builder.add_format(x); }
    builder.finish()
  }


  #[inline]
  pub fn base(&self) -> Option<_UnitSystemBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<_UnitSystemBase>>(AngularUnitSystem::VT_BASE, None)}
  }
  #[inline]
  pub fn format(&self) -> Option<ANGULAR_UNITS_FORMAT> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ANGULAR_UNITS_FORMAT>(AngularUnitSystem::VT_FORMAT, None)}
  }
}

impl flatbuffers::Verifiable for AngularUnitSystem<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<_UnitSystemBase>>("base", Self::VT_BASE, false)?
     .visit_field::<ANGULAR_UNITS_FORMAT>("format", Self::VT_FORMAT, false)?
     .finish();
    Ok(())
  }
}
pub struct AngularUnitSystemArgs<'a> {
    pub base: Option<flatbuffers::WIPOffset<_UnitSystemBase<'a>>>,
    pub format: Option<ANGULAR_UNITS_FORMAT>,
}
impl<'a> Default for AngularUnitSystemArgs<'a> {
  #[inline]
  fn default() -> Self {
    AngularUnitSystemArgs {
      base: None,
      format: None,
    }
  }
}

pub struct AngularUnitSystemBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AngularUnitSystemBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_base(&mut self, base: flatbuffers::WIPOffset<_UnitSystemBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_UnitSystemBase>>(AngularUnitSystem::VT_BASE, base);
  }
  #[inline]
  pub fn add_format(&mut self, format: ANGULAR_UNITS_FORMAT) {
    self.fbb_.push_slot_always::<ANGULAR_UNITS_FORMAT>(AngularUnitSystem::VT_FORMAT, format);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AngularUnitSystemBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AngularUnitSystemBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AngularUnitSystem<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AngularUnitSystem<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AngularUnitSystem");
      ds.field("base", &self.base());
      ds.field("format", &self.format());
      ds.finish()
  }
}
pub enum AlternateUnitsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AlternateUnits<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AlternateUnits<'a> {
  type Inner = AlternateUnits<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AlternateUnits<'a> {
  pub const VT_BASE: flatbuffers::VOffsetT = 4;
  pub const VT_FORMAT: flatbuffers::VOffsetT = 6;
  pub const VT_IS_VISIBLE: flatbuffers::VOffsetT = 8;
  pub const VT_MULTIPLIER: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AlternateUnits { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AlternateUnitsArgs<'args>
  ) -> flatbuffers::WIPOffset<AlternateUnits<'bldr>> {
    let mut builder = AlternateUnitsBuilder::new(_fbb);
    builder.add_multiplier(args.multiplier);
    if let Some(x) = args.base { builder.add_base(x); }
    builder.add_is_visible(args.is_visible);
    if let Some(x) = args.format { builder.add_format(x); }
    builder.finish()
  }


  #[inline]
  pub fn base(&self) -> Option<_UnitSystemBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<_UnitSystemBase>>(AlternateUnits::VT_BASE, None)}
  }
  #[inline]
  pub fn format(&self) -> Option<DIMENSION_UNITS_FORMAT> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DIMENSION_UNITS_FORMAT>(AlternateUnits::VT_FORMAT, None)}
  }
  #[inline]
  pub fn is_visible(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AlternateUnits::VT_IS_VISIBLE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn multiplier(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(AlternateUnits::VT_MULTIPLIER, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for AlternateUnits<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<_UnitSystemBase>>("base", Self::VT_BASE, false)?
     .visit_field::<DIMENSION_UNITS_FORMAT>("format", Self::VT_FORMAT, false)?
     .visit_field::<bool>("is_visible", Self::VT_IS_VISIBLE, false)?
     .visit_field::<f32>("multiplier", Self::VT_MULTIPLIER, false)?
     .finish();
    Ok(())
  }
}
pub struct AlternateUnitsArgs<'a> {
    pub base: Option<flatbuffers::WIPOffset<_UnitSystemBase<'a>>>,
    pub format: Option<DIMENSION_UNITS_FORMAT>,
    pub is_visible: bool,
    pub multiplier: f32,
}
impl<'a> Default for AlternateUnitsArgs<'a> {
  #[inline]
  fn default() -> Self {
    AlternateUnitsArgs {
      base: None,
      format: None,
      is_visible: false,
      multiplier: 0.0,
    }
  }
}

pub struct AlternateUnitsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AlternateUnitsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_base(&mut self, base: flatbuffers::WIPOffset<_UnitSystemBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_UnitSystemBase>>(AlternateUnits::VT_BASE, base);
  }
  #[inline]
  pub fn add_format(&mut self, format: DIMENSION_UNITS_FORMAT) {
    self.fbb_.push_slot_always::<DIMENSION_UNITS_FORMAT>(AlternateUnits::VT_FORMAT, format);
  }
  #[inline]
  pub fn add_is_visible(&mut self, is_visible: bool) {
    self.fbb_.push_slot::<bool>(AlternateUnits::VT_IS_VISIBLE, is_visible, false);
  }
  #[inline]
  pub fn add_multiplier(&mut self, multiplier: f32) {
    self.fbb_.push_slot::<f32>(AlternateUnits::VT_MULTIPLIER, multiplier, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AlternateUnitsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AlternateUnitsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AlternateUnits<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AlternateUnits<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AlternateUnits");
      ds.field("base", &self.base());
      ds.field("format", &self.format());
      ds.field("is_visible", &self.is_visible());
      ds.field("multiplier", &self.multiplier());
      ds.finish()
  }
}
pub enum PrimaryUnitsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PrimaryUnits<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PrimaryUnits<'a> {
  type Inner = PrimaryUnits<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PrimaryUnits<'a> {
  pub const VT_LINEAR: flatbuffers::VOffsetT = 4;
  pub const VT_ANGULAR: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PrimaryUnits { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PrimaryUnitsArgs<'args>
  ) -> flatbuffers::WIPOffset<PrimaryUnits<'bldr>> {
    let mut builder = PrimaryUnitsBuilder::new(_fbb);
    if let Some(x) = args.angular { builder.add_angular(x); }
    if let Some(x) = args.linear { builder.add_linear(x); }
    builder.finish()
  }


  #[inline]
  pub fn linear(&self) -> Option<LinearUnitSystem<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<LinearUnitSystem>>(PrimaryUnits::VT_LINEAR, None)}
  }
  #[inline]
  pub fn angular(&self) -> Option<AngularUnitSystem<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<AngularUnitSystem>>(PrimaryUnits::VT_ANGULAR, None)}
  }
}

impl flatbuffers::Verifiable for PrimaryUnits<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<LinearUnitSystem>>("linear", Self::VT_LINEAR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<AngularUnitSystem>>("angular", Self::VT_ANGULAR, false)?
     .finish();
    Ok(())
  }
}
pub struct PrimaryUnitsArgs<'a> {
    pub linear: Option<flatbuffers::WIPOffset<LinearUnitSystem<'a>>>,
    pub angular: Option<flatbuffers::WIPOffset<AngularUnitSystem<'a>>>,
}
impl<'a> Default for PrimaryUnitsArgs<'a> {
  #[inline]
  fn default() -> Self {
    PrimaryUnitsArgs {
      linear: None,
      angular: None,
    }
  }
}

pub struct PrimaryUnitsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PrimaryUnitsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_linear(&mut self, linear: flatbuffers::WIPOffset<LinearUnitSystem<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<LinearUnitSystem>>(PrimaryUnits::VT_LINEAR, linear);
  }
  #[inline]
  pub fn add_angular(&mut self, angular: flatbuffers::WIPOffset<AngularUnitSystem<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<AngularUnitSystem>>(PrimaryUnits::VT_ANGULAR, angular);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PrimaryUnitsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PrimaryUnitsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PrimaryUnits<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PrimaryUnits<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PrimaryUnits");
      ds.field("linear", &self.linear());
      ds.field("angular", &self.angular());
      ds.finish()
  }
}
pub enum StandardUnitsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct StandardUnits<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StandardUnits<'a> {
  type Inner = StandardUnits<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> StandardUnits<'a> {
  pub const VT_PRIMARY_UNITS: flatbuffers::VOffsetT = 4;
  pub const VT_ALTERNATE_UNITS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StandardUnits { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StandardUnitsArgs<'args>
  ) -> flatbuffers::WIPOffset<StandardUnits<'bldr>> {
    let mut builder = StandardUnitsBuilder::new(_fbb);
    if let Some(x) = args.alternate_units { builder.add_alternate_units(x); }
    if let Some(x) = args.primary_units { builder.add_primary_units(x); }
    builder.finish()
  }


  #[inline]
  pub fn primary_units(&self) -> Option<PrimaryUnits<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<PrimaryUnits>>(StandardUnits::VT_PRIMARY_UNITS, None)}
  }
  #[inline]
  pub fn alternate_units(&self) -> Option<AlternateUnits<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<AlternateUnits>>(StandardUnits::VT_ALTERNATE_UNITS, None)}
  }
}

impl flatbuffers::Verifiable for StandardUnits<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<PrimaryUnits>>("primary_units", Self::VT_PRIMARY_UNITS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<AlternateUnits>>("alternate_units", Self::VT_ALTERNATE_UNITS, false)?
     .finish();
    Ok(())
  }
}
pub struct StandardUnitsArgs<'a> {
    pub primary_units: Option<flatbuffers::WIPOffset<PrimaryUnits<'a>>>,
    pub alternate_units: Option<flatbuffers::WIPOffset<AlternateUnits<'a>>>,
}
impl<'a> Default for StandardUnitsArgs<'a> {
  #[inline]
  fn default() -> Self {
    StandardUnitsArgs {
      primary_units: None,
      alternate_units: None,
    }
  }
}

pub struct StandardUnitsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StandardUnitsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_primary_units(&mut self, primary_units: flatbuffers::WIPOffset<PrimaryUnits<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PrimaryUnits>>(StandardUnits::VT_PRIMARY_UNITS, primary_units);
  }
  #[inline]
  pub fn add_alternate_units(&mut self, alternate_units: flatbuffers::WIPOffset<AlternateUnits<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<AlternateUnits>>(StandardUnits::VT_ALTERNATE_UNITS, alternate_units);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StandardUnitsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StandardUnitsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StandardUnits<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StandardUnits<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StandardUnits");
      ds.field("primary_units", &self.primary_units());
      ds.field("alternate_units", &self.alternate_units());
      ds.finish()
  }
}
pub enum UnitPrecisionOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UnitPrecision<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UnitPrecision<'a> {
  type Inner = UnitPrecision<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> UnitPrecision<'a> {
  pub const VT_LINEAR: flatbuffers::VOffsetT = 4;
  pub const VT_ANGULAR: flatbuffers::VOffsetT = 6;
  pub const VT_AREA: flatbuffers::VOffsetT = 8;
  pub const VT_VOLUME: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    UnitPrecision { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args UnitPrecisionArgs
  ) -> flatbuffers::WIPOffset<UnitPrecision<'bldr>> {
    let mut builder = UnitPrecisionBuilder::new(_fbb);
    builder.add_volume(args.volume);
    builder.add_area(args.area);
    builder.add_angular(args.angular);
    builder.add_linear(args.linear);
    builder.finish()
  }


  #[inline]
  pub fn linear(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(UnitPrecision::VT_LINEAR, Some(0)).unwrap()}
  }
  #[inline]
  pub fn angular(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(UnitPrecision::VT_ANGULAR, Some(0)).unwrap()}
  }
  #[inline]
  pub fn area(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(UnitPrecision::VT_AREA, Some(0)).unwrap()}
  }
  #[inline]
  pub fn volume(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(UnitPrecision::VT_VOLUME, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for UnitPrecision<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("linear", Self::VT_LINEAR, false)?
     .visit_field::<i32>("angular", Self::VT_ANGULAR, false)?
     .visit_field::<i32>("area", Self::VT_AREA, false)?
     .visit_field::<i32>("volume", Self::VT_VOLUME, false)?
     .finish();
    Ok(())
  }
}
pub struct UnitPrecisionArgs {
    pub linear: i32,
    pub angular: i32,
    pub area: i32,
    pub volume: i32,
}
impl<'a> Default for UnitPrecisionArgs {
  #[inline]
  fn default() -> Self {
    UnitPrecisionArgs {
      linear: 0,
      angular: 0,
      area: 0,
      volume: 0,
    }
  }
}

pub struct UnitPrecisionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> UnitPrecisionBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_linear(&mut self, linear: i32) {
    self.fbb_.push_slot::<i32>(UnitPrecision::VT_LINEAR, linear, 0);
  }
  #[inline]
  pub fn add_angular(&mut self, angular: i32) {
    self.fbb_.push_slot::<i32>(UnitPrecision::VT_ANGULAR, angular, 0);
  }
  #[inline]
  pub fn add_area(&mut self, area: i32) {
    self.fbb_.push_slot::<i32>(UnitPrecision::VT_AREA, area, 0);
  }
  #[inline]
  pub fn add_volume(&mut self, volume: i32) {
    self.fbb_.push_slot::<i32>(UnitPrecision::VT_VOLUME, volume, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> UnitPrecisionBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    UnitPrecisionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UnitPrecision<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for UnitPrecision<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("UnitPrecision");
      ds.field("linear", &self.linear());
      ds.field("angular", &self.angular());
      ds.field("area", &self.area());
      ds.field("volume", &self.volume());
      ds.finish()
  }
}
pub enum StandardOverridesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct StandardOverrides<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StandardOverrides<'a> {
  type Inner = StandardOverrides<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> StandardOverrides<'a> {
  pub const VT_MAIN_SCOPE: flatbuffers::VOffsetT = 4;
  pub const VT_ELEMENTS_STROKE_WIDTH_OVERRIDE: flatbuffers::VOffsetT = 6;
  pub const VT_COMMON_STYLE_ID: flatbuffers::VOffsetT = 8;
  pub const VT_STACK_LIKE_STYLE_ID: flatbuffers::VOffsetT = 10;
  pub const VT_TEXT_STYLE_ID: flatbuffers::VOffsetT = 12;
  pub const VT_DIMENSION_STYLE_ID: flatbuffers::VOffsetT = 14;
  pub const VT_LEADER_STYLE_ID: flatbuffers::VOffsetT = 16;
  pub const VT_FEATURE_CONTROL_FRAME_STYLE_ID: flatbuffers::VOffsetT = 18;
  pub const VT_TABLE_STYLE_ID: flatbuffers::VOffsetT = 20;
  pub const VT_DOC_STYLE_ID: flatbuffers::VOffsetT = 22;
  pub const VT_VIEWPORT_STYLE_ID: flatbuffers::VOffsetT = 24;
  pub const VT_PLOT_STYLE_ID: flatbuffers::VOffsetT = 26;
  pub const VT_HATCH_STYLE_ID: flatbuffers::VOffsetT = 28;
  pub const VT_ACTIVE_GRID_SETTINGS_ID: flatbuffers::VOffsetT = 30;
  pub const VT_ACTIVE_SNAP_SETTINGS_ID: flatbuffers::VOffsetT = 32;
  pub const VT_DASH_LINE_OVERRIDE: flatbuffers::VOffsetT = 34;
  pub const VT_UNIT_PRECISION: flatbuffers::VOffsetT = 36;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StandardOverrides { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StandardOverridesArgs<'args>
  ) -> flatbuffers::WIPOffset<StandardOverrides<'bldr>> {
    let mut builder = StandardOverridesBuilder::new(_fbb);
    builder.add_elements_stroke_width_override(args.elements_stroke_width_override);
    if let Some(x) = args.unit_precision { builder.add_unit_precision(x); }
    if let Some(x) = args.dash_line_override { builder.add_dash_line_override(x); }
    if let Some(x) = args.active_snap_settings_id { builder.add_active_snap_settings_id(x); }
    if let Some(x) = args.active_grid_settings_id { builder.add_active_grid_settings_id(x); }
    if let Some(x) = args.hatch_style_id { builder.add_hatch_style_id(x); }
    if let Some(x) = args.plot_style_id { builder.add_plot_style_id(x); }
    if let Some(x) = args.viewport_style_id { builder.add_viewport_style_id(x); }
    if let Some(x) = args.doc_style_id { builder.add_doc_style_id(x); }
    if let Some(x) = args.table_style_id { builder.add_table_style_id(x); }
    if let Some(x) = args.feature_control_frame_style_id { builder.add_feature_control_frame_style_id(x); }
    if let Some(x) = args.leader_style_id { builder.add_leader_style_id(x); }
    if let Some(x) = args.dimension_style_id { builder.add_dimension_style_id(x); }
    if let Some(x) = args.text_style_id { builder.add_text_style_id(x); }
    if let Some(x) = args.stack_like_style_id { builder.add_stack_like_style_id(x); }
    if let Some(x) = args.common_style_id { builder.add_common_style_id(x); }
    if let Some(x) = args.main_scope { builder.add_main_scope(x); }
    builder.finish()
  }


  #[inline]
  pub fn main_scope(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StandardOverrides::VT_MAIN_SCOPE, None)}
  }
  #[inline]
  pub fn elements_stroke_width_override(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StandardOverrides::VT_ELEMENTS_STROKE_WIDTH_OVERRIDE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn common_style_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StandardOverrides::VT_COMMON_STYLE_ID, None)}
  }
  #[inline]
  pub fn stack_like_style_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StandardOverrides::VT_STACK_LIKE_STYLE_ID, None)}
  }
  #[inline]
  pub fn text_style_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StandardOverrides::VT_TEXT_STYLE_ID, None)}
  }
  #[inline]
  pub fn dimension_style_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StandardOverrides::VT_DIMENSION_STYLE_ID, None)}
  }
  #[inline]
  pub fn leader_style_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StandardOverrides::VT_LEADER_STYLE_ID, None)}
  }
  #[inline]
  pub fn feature_control_frame_style_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StandardOverrides::VT_FEATURE_CONTROL_FRAME_STYLE_ID, None)}
  }
  #[inline]
  pub fn table_style_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StandardOverrides::VT_TABLE_STYLE_ID, None)}
  }
  #[inline]
  pub fn doc_style_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StandardOverrides::VT_DOC_STYLE_ID, None)}
  }
  #[inline]
  pub fn viewport_style_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StandardOverrides::VT_VIEWPORT_STYLE_ID, None)}
  }
  #[inline]
  pub fn plot_style_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StandardOverrides::VT_PLOT_STYLE_ID, None)}
  }
  #[inline]
  pub fn hatch_style_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StandardOverrides::VT_HATCH_STYLE_ID, None)}
  }
  #[inline]
  pub fn active_grid_settings_id(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(StandardOverrides::VT_ACTIVE_GRID_SETTINGS_ID, None)}
  }
  #[inline]
  pub fn active_snap_settings_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StandardOverrides::VT_ACTIVE_SNAP_SETTINGS_ID, None)}
  }
  #[inline]
  pub fn dash_line_override(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StandardOverrides::VT_DASH_LINE_OVERRIDE, None)}
  }
  #[inline]
  pub fn unit_precision(&self) -> Option<UnitPrecision<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<UnitPrecision>>(StandardOverrides::VT_UNIT_PRECISION, None)}
  }
}

impl flatbuffers::Verifiable for StandardOverrides<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("main_scope", Self::VT_MAIN_SCOPE, false)?
     .visit_field::<f64>("elements_stroke_width_override", Self::VT_ELEMENTS_STROKE_WIDTH_OVERRIDE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("common_style_id", Self::VT_COMMON_STYLE_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stack_like_style_id", Self::VT_STACK_LIKE_STYLE_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("text_style_id", Self::VT_TEXT_STYLE_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("dimension_style_id", Self::VT_DIMENSION_STYLE_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("leader_style_id", Self::VT_LEADER_STYLE_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("feature_control_frame_style_id", Self::VT_FEATURE_CONTROL_FRAME_STYLE_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("table_style_id", Self::VT_TABLE_STYLE_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("doc_style_id", Self::VT_DOC_STYLE_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("viewport_style_id", Self::VT_VIEWPORT_STYLE_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("plot_style_id", Self::VT_PLOT_STYLE_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("hatch_style_id", Self::VT_HATCH_STYLE_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("active_grid_settings_id", Self::VT_ACTIVE_GRID_SETTINGS_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("active_snap_settings_id", Self::VT_ACTIVE_SNAP_SETTINGS_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("dash_line_override", Self::VT_DASH_LINE_OVERRIDE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<UnitPrecision>>("unit_precision", Self::VT_UNIT_PRECISION, false)?
     .finish();
    Ok(())
  }
}
pub struct StandardOverridesArgs<'a> {
    pub main_scope: Option<flatbuffers::WIPOffset<&'a str>>,
    pub elements_stroke_width_override: f64,
    pub common_style_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stack_like_style_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub text_style_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dimension_style_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub leader_style_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub feature_control_frame_style_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub table_style_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub doc_style_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub viewport_style_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub plot_style_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub hatch_style_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub active_grid_settings_id: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub active_snap_settings_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub dash_line_override: Option<flatbuffers::WIPOffset<&'a str>>,
    pub unit_precision: Option<flatbuffers::WIPOffset<UnitPrecision<'a>>>,
}
impl<'a> Default for StandardOverridesArgs<'a> {
  #[inline]
  fn default() -> Self {
    StandardOverridesArgs {
      main_scope: None,
      elements_stroke_width_override: 0.0,
      common_style_id: None,
      stack_like_style_id: None,
      text_style_id: None,
      dimension_style_id: None,
      leader_style_id: None,
      feature_control_frame_style_id: None,
      table_style_id: None,
      doc_style_id: None,
      viewport_style_id: None,
      plot_style_id: None,
      hatch_style_id: None,
      active_grid_settings_id: None,
      active_snap_settings_id: None,
      dash_line_override: None,
      unit_precision: None,
    }
  }
}

pub struct StandardOverridesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StandardOverridesBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_main_scope(&mut self, main_scope: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StandardOverrides::VT_MAIN_SCOPE, main_scope);
  }
  #[inline]
  pub fn add_elements_stroke_width_override(&mut self, elements_stroke_width_override: f64) {
    self.fbb_.push_slot::<f64>(StandardOverrides::VT_ELEMENTS_STROKE_WIDTH_OVERRIDE, elements_stroke_width_override, 0.0);
  }
  #[inline]
  pub fn add_common_style_id(&mut self, common_style_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StandardOverrides::VT_COMMON_STYLE_ID, common_style_id);
  }
  #[inline]
  pub fn add_stack_like_style_id(&mut self, stack_like_style_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StandardOverrides::VT_STACK_LIKE_STYLE_ID, stack_like_style_id);
  }
  #[inline]
  pub fn add_text_style_id(&mut self, text_style_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StandardOverrides::VT_TEXT_STYLE_ID, text_style_id);
  }
  #[inline]
  pub fn add_dimension_style_id(&mut self, dimension_style_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StandardOverrides::VT_DIMENSION_STYLE_ID, dimension_style_id);
  }
  #[inline]
  pub fn add_leader_style_id(&mut self, leader_style_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StandardOverrides::VT_LEADER_STYLE_ID, leader_style_id);
  }
  #[inline]
  pub fn add_feature_control_frame_style_id(&mut self, feature_control_frame_style_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StandardOverrides::VT_FEATURE_CONTROL_FRAME_STYLE_ID, feature_control_frame_style_id);
  }
  #[inline]
  pub fn add_table_style_id(&mut self, table_style_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StandardOverrides::VT_TABLE_STYLE_ID, table_style_id);
  }
  #[inline]
  pub fn add_doc_style_id(&mut self, doc_style_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StandardOverrides::VT_DOC_STYLE_ID, doc_style_id);
  }
  #[inline]
  pub fn add_viewport_style_id(&mut self, viewport_style_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StandardOverrides::VT_VIEWPORT_STYLE_ID, viewport_style_id);
  }
  #[inline]
  pub fn add_plot_style_id(&mut self, plot_style_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StandardOverrides::VT_PLOT_STYLE_ID, plot_style_id);
  }
  #[inline]
  pub fn add_hatch_style_id(&mut self, hatch_style_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StandardOverrides::VT_HATCH_STYLE_ID, hatch_style_id);
  }
  #[inline]
  pub fn add_active_grid_settings_id(&mut self, active_grid_settings_id: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StandardOverrides::VT_ACTIVE_GRID_SETTINGS_ID, active_grid_settings_id);
  }
  #[inline]
  pub fn add_active_snap_settings_id(&mut self, active_snap_settings_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StandardOverrides::VT_ACTIVE_SNAP_SETTINGS_ID, active_snap_settings_id);
  }
  #[inline]
  pub fn add_dash_line_override(&mut self, dash_line_override: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StandardOverrides::VT_DASH_LINE_OVERRIDE, dash_line_override);
  }
  #[inline]
  pub fn add_unit_precision(&mut self, unit_precision: flatbuffers::WIPOffset<UnitPrecision<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<UnitPrecision>>(StandardOverrides::VT_UNIT_PRECISION, unit_precision);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StandardOverridesBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StandardOverridesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StandardOverrides<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StandardOverrides<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StandardOverrides");
      ds.field("main_scope", &self.main_scope());
      ds.field("elements_stroke_width_override", &self.elements_stroke_width_override());
      ds.field("common_style_id", &self.common_style_id());
      ds.field("stack_like_style_id", &self.stack_like_style_id());
      ds.field("text_style_id", &self.text_style_id());
      ds.field("dimension_style_id", &self.dimension_style_id());
      ds.field("leader_style_id", &self.leader_style_id());
      ds.field("feature_control_frame_style_id", &self.feature_control_frame_style_id());
      ds.field("table_style_id", &self.table_style_id());
      ds.field("doc_style_id", &self.doc_style_id());
      ds.field("viewport_style_id", &self.viewport_style_id());
      ds.field("plot_style_id", &self.plot_style_id());
      ds.field("hatch_style_id", &self.hatch_style_id());
      ds.field("active_grid_settings_id", &self.active_grid_settings_id());
      ds.field("active_snap_settings_id", &self.active_snap_settings_id());
      ds.field("dash_line_override", &self.dash_line_override());
      ds.field("unit_precision", &self.unit_precision());
      ds.finish()
  }
}
pub enum DucCommonStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucCommonStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucCommonStyle<'a> {
  type Inner = DucCommonStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucCommonStyle<'a> {
  pub const VT_BACKGROUND: flatbuffers::VOffsetT = 4;
  pub const VT_STROKE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucCommonStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucCommonStyleArgs<'args>
  ) -> flatbuffers::WIPOffset<DucCommonStyle<'bldr>> {
    let mut builder = DucCommonStyleBuilder::new(_fbb);
    if let Some(x) = args.stroke { builder.add_stroke(x); }
    if let Some(x) = args.background { builder.add_background(x); }
    builder.finish()
  }


  #[inline]
  pub fn background(&self) -> Option<ElementBackground<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ElementBackground>>(DucCommonStyle::VT_BACKGROUND, None)}
  }
  #[inline]
  pub fn stroke(&self) -> Option<ElementStroke<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ElementStroke>>(DucCommonStyle::VT_STROKE, None)}
  }
}

impl flatbuffers::Verifiable for DucCommonStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<ElementBackground>>("background", Self::VT_BACKGROUND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ElementStroke>>("stroke", Self::VT_STROKE, false)?
     .finish();
    Ok(())
  }
}
pub struct DucCommonStyleArgs<'a> {
    pub background: Option<flatbuffers::WIPOffset<ElementBackground<'a>>>,
    pub stroke: Option<flatbuffers::WIPOffset<ElementStroke<'a>>>,
}
impl<'a> Default for DucCommonStyleArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucCommonStyleArgs {
      background: None,
      stroke: None,
    }
  }
}

pub struct DucCommonStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucCommonStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_background(&mut self, background: flatbuffers::WIPOffset<ElementBackground<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ElementBackground>>(DucCommonStyle::VT_BACKGROUND, background);
  }
  #[inline]
  pub fn add_stroke(&mut self, stroke: flatbuffers::WIPOffset<ElementStroke<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ElementStroke>>(DucCommonStyle::VT_STROKE, stroke);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucCommonStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucCommonStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucCommonStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucCommonStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucCommonStyle");
      ds.field("background", &self.background());
      ds.field("stroke", &self.stroke());
      ds.finish()
  }
}
pub enum IdentifiedCommonStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct IdentifiedCommonStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IdentifiedCommonStyle<'a> {
  type Inner = IdentifiedCommonStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> IdentifiedCommonStyle<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_STYLE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    IdentifiedCommonStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args IdentifiedCommonStyleArgs<'args>
  ) -> flatbuffers::WIPOffset<IdentifiedCommonStyle<'bldr>> {
    let mut builder = IdentifiedCommonStyleBuilder::new(_fbb);
    if let Some(x) = args.style { builder.add_style(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<Identifier<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Identifier>>(IdentifiedCommonStyle::VT_ID, None)}
  }
  #[inline]
  pub fn style(&self) -> Option<DucCommonStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucCommonStyle>>(IdentifiedCommonStyle::VT_STYLE, None)}
  }
}

impl flatbuffers::Verifiable for IdentifiedCommonStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Identifier>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucCommonStyle>>("style", Self::VT_STYLE, false)?
     .finish();
    Ok(())
  }
}
pub struct IdentifiedCommonStyleArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
    pub style: Option<flatbuffers::WIPOffset<DucCommonStyle<'a>>>,
}
impl<'a> Default for IdentifiedCommonStyleArgs<'a> {
  #[inline]
  fn default() -> Self {
    IdentifiedCommonStyleArgs {
      id: None,
      style: None,
    }
  }
}

pub struct IdentifiedCommonStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> IdentifiedCommonStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<Identifier<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Identifier>>(IdentifiedCommonStyle::VT_ID, id);
  }
  #[inline]
  pub fn add_style(&mut self, style: flatbuffers::WIPOffset<DucCommonStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucCommonStyle>>(IdentifiedCommonStyle::VT_STYLE, style);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> IdentifiedCommonStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    IdentifiedCommonStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IdentifiedCommonStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for IdentifiedCommonStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("IdentifiedCommonStyle");
      ds.field("id", &self.id());
      ds.field("style", &self.style());
      ds.finish()
  }
}
pub enum IdentifiedStackLikeStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct IdentifiedStackLikeStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IdentifiedStackLikeStyle<'a> {
  type Inner = IdentifiedStackLikeStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> IdentifiedStackLikeStyle<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_STYLE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    IdentifiedStackLikeStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args IdentifiedStackLikeStyleArgs<'args>
  ) -> flatbuffers::WIPOffset<IdentifiedStackLikeStyle<'bldr>> {
    let mut builder = IdentifiedStackLikeStyleBuilder::new(_fbb);
    if let Some(x) = args.style { builder.add_style(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<Identifier<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Identifier>>(IdentifiedStackLikeStyle::VT_ID, None)}
  }
  #[inline]
  pub fn style(&self) -> Option<DucStackLikeStyles<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucStackLikeStyles>>(IdentifiedStackLikeStyle::VT_STYLE, None)}
  }
}

impl flatbuffers::Verifiable for IdentifiedStackLikeStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Identifier>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucStackLikeStyles>>("style", Self::VT_STYLE, false)?
     .finish();
    Ok(())
  }
}
pub struct IdentifiedStackLikeStyleArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
    pub style: Option<flatbuffers::WIPOffset<DucStackLikeStyles<'a>>>,
}
impl<'a> Default for IdentifiedStackLikeStyleArgs<'a> {
  #[inline]
  fn default() -> Self {
    IdentifiedStackLikeStyleArgs {
      id: None,
      style: None,
    }
  }
}

pub struct IdentifiedStackLikeStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> IdentifiedStackLikeStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<Identifier<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Identifier>>(IdentifiedStackLikeStyle::VT_ID, id);
  }
  #[inline]
  pub fn add_style(&mut self, style: flatbuffers::WIPOffset<DucStackLikeStyles<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucStackLikeStyles>>(IdentifiedStackLikeStyle::VT_STYLE, style);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> IdentifiedStackLikeStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    IdentifiedStackLikeStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IdentifiedStackLikeStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for IdentifiedStackLikeStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("IdentifiedStackLikeStyle");
      ds.field("id", &self.id());
      ds.field("style", &self.style());
      ds.finish()
  }
}
pub enum IdentifiedTextStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct IdentifiedTextStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IdentifiedTextStyle<'a> {
  type Inner = IdentifiedTextStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> IdentifiedTextStyle<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_STYLE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    IdentifiedTextStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args IdentifiedTextStyleArgs<'args>
  ) -> flatbuffers::WIPOffset<IdentifiedTextStyle<'bldr>> {
    let mut builder = IdentifiedTextStyleBuilder::new(_fbb);
    if let Some(x) = args.style { builder.add_style(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<Identifier<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Identifier>>(IdentifiedTextStyle::VT_ID, None)}
  }
  #[inline]
  pub fn style(&self) -> Option<DucTextStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucTextStyle>>(IdentifiedTextStyle::VT_STYLE, None)}
  }
}

impl flatbuffers::Verifiable for IdentifiedTextStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Identifier>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucTextStyle>>("style", Self::VT_STYLE, false)?
     .finish();
    Ok(())
  }
}
pub struct IdentifiedTextStyleArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
    pub style: Option<flatbuffers::WIPOffset<DucTextStyle<'a>>>,
}
impl<'a> Default for IdentifiedTextStyleArgs<'a> {
  #[inline]
  fn default() -> Self {
    IdentifiedTextStyleArgs {
      id: None,
      style: None,
    }
  }
}

pub struct IdentifiedTextStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> IdentifiedTextStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<Identifier<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Identifier>>(IdentifiedTextStyle::VT_ID, id);
  }
  #[inline]
  pub fn add_style(&mut self, style: flatbuffers::WIPOffset<DucTextStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucTextStyle>>(IdentifiedTextStyle::VT_STYLE, style);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> IdentifiedTextStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    IdentifiedTextStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IdentifiedTextStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for IdentifiedTextStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("IdentifiedTextStyle");
      ds.field("id", &self.id());
      ds.field("style", &self.style());
      ds.finish()
  }
}
pub enum IdentifiedDimensionStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct IdentifiedDimensionStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IdentifiedDimensionStyle<'a> {
  type Inner = IdentifiedDimensionStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> IdentifiedDimensionStyle<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_STYLE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    IdentifiedDimensionStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args IdentifiedDimensionStyleArgs<'args>
  ) -> flatbuffers::WIPOffset<IdentifiedDimensionStyle<'bldr>> {
    let mut builder = IdentifiedDimensionStyleBuilder::new(_fbb);
    if let Some(x) = args.style { builder.add_style(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<Identifier<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Identifier>>(IdentifiedDimensionStyle::VT_ID, None)}
  }
  #[inline]
  pub fn style(&self) -> Option<DucDimensionStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucDimensionStyle>>(IdentifiedDimensionStyle::VT_STYLE, None)}
  }
}

impl flatbuffers::Verifiable for IdentifiedDimensionStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Identifier>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucDimensionStyle>>("style", Self::VT_STYLE, false)?
     .finish();
    Ok(())
  }
}
pub struct IdentifiedDimensionStyleArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
    pub style: Option<flatbuffers::WIPOffset<DucDimensionStyle<'a>>>,
}
impl<'a> Default for IdentifiedDimensionStyleArgs<'a> {
  #[inline]
  fn default() -> Self {
    IdentifiedDimensionStyleArgs {
      id: None,
      style: None,
    }
  }
}

pub struct IdentifiedDimensionStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> IdentifiedDimensionStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<Identifier<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Identifier>>(IdentifiedDimensionStyle::VT_ID, id);
  }
  #[inline]
  pub fn add_style(&mut self, style: flatbuffers::WIPOffset<DucDimensionStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucDimensionStyle>>(IdentifiedDimensionStyle::VT_STYLE, style);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> IdentifiedDimensionStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    IdentifiedDimensionStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IdentifiedDimensionStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for IdentifiedDimensionStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("IdentifiedDimensionStyle");
      ds.field("id", &self.id());
      ds.field("style", &self.style());
      ds.finish()
  }
}
pub enum IdentifiedLeaderStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct IdentifiedLeaderStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IdentifiedLeaderStyle<'a> {
  type Inner = IdentifiedLeaderStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> IdentifiedLeaderStyle<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_STYLE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    IdentifiedLeaderStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args IdentifiedLeaderStyleArgs<'args>
  ) -> flatbuffers::WIPOffset<IdentifiedLeaderStyle<'bldr>> {
    let mut builder = IdentifiedLeaderStyleBuilder::new(_fbb);
    if let Some(x) = args.style { builder.add_style(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<Identifier<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Identifier>>(IdentifiedLeaderStyle::VT_ID, None)}
  }
  #[inline]
  pub fn style(&self) -> Option<DucLeaderStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucLeaderStyle>>(IdentifiedLeaderStyle::VT_STYLE, None)}
  }
}

impl flatbuffers::Verifiable for IdentifiedLeaderStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Identifier>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucLeaderStyle>>("style", Self::VT_STYLE, false)?
     .finish();
    Ok(())
  }
}
pub struct IdentifiedLeaderStyleArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
    pub style: Option<flatbuffers::WIPOffset<DucLeaderStyle<'a>>>,
}
impl<'a> Default for IdentifiedLeaderStyleArgs<'a> {
  #[inline]
  fn default() -> Self {
    IdentifiedLeaderStyleArgs {
      id: None,
      style: None,
    }
  }
}

pub struct IdentifiedLeaderStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> IdentifiedLeaderStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<Identifier<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Identifier>>(IdentifiedLeaderStyle::VT_ID, id);
  }
  #[inline]
  pub fn add_style(&mut self, style: flatbuffers::WIPOffset<DucLeaderStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucLeaderStyle>>(IdentifiedLeaderStyle::VT_STYLE, style);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> IdentifiedLeaderStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    IdentifiedLeaderStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IdentifiedLeaderStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for IdentifiedLeaderStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("IdentifiedLeaderStyle");
      ds.field("id", &self.id());
      ds.field("style", &self.style());
      ds.finish()
  }
}
pub enum IdentifiedFCFStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct IdentifiedFCFStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IdentifiedFCFStyle<'a> {
  type Inner = IdentifiedFCFStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> IdentifiedFCFStyle<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_STYLE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    IdentifiedFCFStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args IdentifiedFCFStyleArgs<'args>
  ) -> flatbuffers::WIPOffset<IdentifiedFCFStyle<'bldr>> {
    let mut builder = IdentifiedFCFStyleBuilder::new(_fbb);
    if let Some(x) = args.style { builder.add_style(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<Identifier<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Identifier>>(IdentifiedFCFStyle::VT_ID, None)}
  }
  #[inline]
  pub fn style(&self) -> Option<DucFeatureControlFrameStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucFeatureControlFrameStyle>>(IdentifiedFCFStyle::VT_STYLE, None)}
  }
}

impl flatbuffers::Verifiable for IdentifiedFCFStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Identifier>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucFeatureControlFrameStyle>>("style", Self::VT_STYLE, false)?
     .finish();
    Ok(())
  }
}
pub struct IdentifiedFCFStyleArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
    pub style: Option<flatbuffers::WIPOffset<DucFeatureControlFrameStyle<'a>>>,
}
impl<'a> Default for IdentifiedFCFStyleArgs<'a> {
  #[inline]
  fn default() -> Self {
    IdentifiedFCFStyleArgs {
      id: None,
      style: None,
    }
  }
}

pub struct IdentifiedFCFStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> IdentifiedFCFStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<Identifier<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Identifier>>(IdentifiedFCFStyle::VT_ID, id);
  }
  #[inline]
  pub fn add_style(&mut self, style: flatbuffers::WIPOffset<DucFeatureControlFrameStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucFeatureControlFrameStyle>>(IdentifiedFCFStyle::VT_STYLE, style);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> IdentifiedFCFStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    IdentifiedFCFStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IdentifiedFCFStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for IdentifiedFCFStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("IdentifiedFCFStyle");
      ds.field("id", &self.id());
      ds.field("style", &self.style());
      ds.finish()
  }
}
pub enum IdentifiedTableStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct IdentifiedTableStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IdentifiedTableStyle<'a> {
  type Inner = IdentifiedTableStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> IdentifiedTableStyle<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_STYLE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    IdentifiedTableStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args IdentifiedTableStyleArgs<'args>
  ) -> flatbuffers::WIPOffset<IdentifiedTableStyle<'bldr>> {
    let mut builder = IdentifiedTableStyleBuilder::new(_fbb);
    if let Some(x) = args.style { builder.add_style(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<Identifier<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Identifier>>(IdentifiedTableStyle::VT_ID, None)}
  }
  #[inline]
  pub fn style(&self) -> Option<DucTableStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucTableStyle>>(IdentifiedTableStyle::VT_STYLE, None)}
  }
}

impl flatbuffers::Verifiable for IdentifiedTableStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Identifier>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucTableStyle>>("style", Self::VT_STYLE, false)?
     .finish();
    Ok(())
  }
}
pub struct IdentifiedTableStyleArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
    pub style: Option<flatbuffers::WIPOffset<DucTableStyle<'a>>>,
}
impl<'a> Default for IdentifiedTableStyleArgs<'a> {
  #[inline]
  fn default() -> Self {
    IdentifiedTableStyleArgs {
      id: None,
      style: None,
    }
  }
}

pub struct IdentifiedTableStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> IdentifiedTableStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<Identifier<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Identifier>>(IdentifiedTableStyle::VT_ID, id);
  }
  #[inline]
  pub fn add_style(&mut self, style: flatbuffers::WIPOffset<DucTableStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucTableStyle>>(IdentifiedTableStyle::VT_STYLE, style);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> IdentifiedTableStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    IdentifiedTableStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IdentifiedTableStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for IdentifiedTableStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("IdentifiedTableStyle");
      ds.field("id", &self.id());
      ds.field("style", &self.style());
      ds.finish()
  }
}
pub enum IdentifiedDocStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct IdentifiedDocStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IdentifiedDocStyle<'a> {
  type Inner = IdentifiedDocStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> IdentifiedDocStyle<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_STYLE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    IdentifiedDocStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args IdentifiedDocStyleArgs<'args>
  ) -> flatbuffers::WIPOffset<IdentifiedDocStyle<'bldr>> {
    let mut builder = IdentifiedDocStyleBuilder::new(_fbb);
    if let Some(x) = args.style { builder.add_style(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<Identifier<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Identifier>>(IdentifiedDocStyle::VT_ID, None)}
  }
  #[inline]
  pub fn style(&self) -> Option<DucDocStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucDocStyle>>(IdentifiedDocStyle::VT_STYLE, None)}
  }
}

impl flatbuffers::Verifiable for IdentifiedDocStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Identifier>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucDocStyle>>("style", Self::VT_STYLE, false)?
     .finish();
    Ok(())
  }
}
pub struct IdentifiedDocStyleArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
    pub style: Option<flatbuffers::WIPOffset<DucDocStyle<'a>>>,
}
impl<'a> Default for IdentifiedDocStyleArgs<'a> {
  #[inline]
  fn default() -> Self {
    IdentifiedDocStyleArgs {
      id: None,
      style: None,
    }
  }
}

pub struct IdentifiedDocStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> IdentifiedDocStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<Identifier<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Identifier>>(IdentifiedDocStyle::VT_ID, id);
  }
  #[inline]
  pub fn add_style(&mut self, style: flatbuffers::WIPOffset<DucDocStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucDocStyle>>(IdentifiedDocStyle::VT_STYLE, style);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> IdentifiedDocStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    IdentifiedDocStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IdentifiedDocStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for IdentifiedDocStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("IdentifiedDocStyle");
      ds.field("id", &self.id());
      ds.field("style", &self.style());
      ds.finish()
  }
}
pub enum IdentifiedViewportStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct IdentifiedViewportStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IdentifiedViewportStyle<'a> {
  type Inner = IdentifiedViewportStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> IdentifiedViewportStyle<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_STYLE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    IdentifiedViewportStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args IdentifiedViewportStyleArgs<'args>
  ) -> flatbuffers::WIPOffset<IdentifiedViewportStyle<'bldr>> {
    let mut builder = IdentifiedViewportStyleBuilder::new(_fbb);
    if let Some(x) = args.style { builder.add_style(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<Identifier<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Identifier>>(IdentifiedViewportStyle::VT_ID, None)}
  }
  #[inline]
  pub fn style(&self) -> Option<DucViewportStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucViewportStyle>>(IdentifiedViewportStyle::VT_STYLE, None)}
  }
}

impl flatbuffers::Verifiable for IdentifiedViewportStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Identifier>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucViewportStyle>>("style", Self::VT_STYLE, false)?
     .finish();
    Ok(())
  }
}
pub struct IdentifiedViewportStyleArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
    pub style: Option<flatbuffers::WIPOffset<DucViewportStyle<'a>>>,
}
impl<'a> Default for IdentifiedViewportStyleArgs<'a> {
  #[inline]
  fn default() -> Self {
    IdentifiedViewportStyleArgs {
      id: None,
      style: None,
    }
  }
}

pub struct IdentifiedViewportStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> IdentifiedViewportStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<Identifier<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Identifier>>(IdentifiedViewportStyle::VT_ID, id);
  }
  #[inline]
  pub fn add_style(&mut self, style: flatbuffers::WIPOffset<DucViewportStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucViewportStyle>>(IdentifiedViewportStyle::VT_STYLE, style);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> IdentifiedViewportStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    IdentifiedViewportStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IdentifiedViewportStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for IdentifiedViewportStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("IdentifiedViewportStyle");
      ds.field("id", &self.id());
      ds.field("style", &self.style());
      ds.finish()
  }
}
pub enum IdentifiedHatchStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct IdentifiedHatchStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IdentifiedHatchStyle<'a> {
  type Inner = IdentifiedHatchStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> IdentifiedHatchStyle<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_STYLE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    IdentifiedHatchStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args IdentifiedHatchStyleArgs<'args>
  ) -> flatbuffers::WIPOffset<IdentifiedHatchStyle<'bldr>> {
    let mut builder = IdentifiedHatchStyleBuilder::new(_fbb);
    if let Some(x) = args.style { builder.add_style(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<Identifier<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Identifier>>(IdentifiedHatchStyle::VT_ID, None)}
  }
  #[inline]
  pub fn style(&self) -> Option<DucHatchStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucHatchStyle>>(IdentifiedHatchStyle::VT_STYLE, None)}
  }
}

impl flatbuffers::Verifiable for IdentifiedHatchStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Identifier>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucHatchStyle>>("style", Self::VT_STYLE, false)?
     .finish();
    Ok(())
  }
}
pub struct IdentifiedHatchStyleArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
    pub style: Option<flatbuffers::WIPOffset<DucHatchStyle<'a>>>,
}
impl<'a> Default for IdentifiedHatchStyleArgs<'a> {
  #[inline]
  fn default() -> Self {
    IdentifiedHatchStyleArgs {
      id: None,
      style: None,
    }
  }
}

pub struct IdentifiedHatchStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> IdentifiedHatchStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<Identifier<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Identifier>>(IdentifiedHatchStyle::VT_ID, id);
  }
  #[inline]
  pub fn add_style(&mut self, style: flatbuffers::WIPOffset<DucHatchStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucHatchStyle>>(IdentifiedHatchStyle::VT_STYLE, style);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> IdentifiedHatchStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    IdentifiedHatchStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IdentifiedHatchStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for IdentifiedHatchStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("IdentifiedHatchStyle");
      ds.field("id", &self.id());
      ds.field("style", &self.style());
      ds.finish()
  }
}
pub enum IdentifiedXRayStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct IdentifiedXRayStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IdentifiedXRayStyle<'a> {
  type Inner = IdentifiedXRayStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> IdentifiedXRayStyle<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_STYLE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    IdentifiedXRayStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args IdentifiedXRayStyleArgs<'args>
  ) -> flatbuffers::WIPOffset<IdentifiedXRayStyle<'bldr>> {
    let mut builder = IdentifiedXRayStyleBuilder::new(_fbb);
    if let Some(x) = args.style { builder.add_style(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<Identifier<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Identifier>>(IdentifiedXRayStyle::VT_ID, None)}
  }
  #[inline]
  pub fn style(&self) -> Option<DucXRayStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucXRayStyle>>(IdentifiedXRayStyle::VT_STYLE, None)}
  }
}

impl flatbuffers::Verifiable for IdentifiedXRayStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Identifier>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucXRayStyle>>("style", Self::VT_STYLE, false)?
     .finish();
    Ok(())
  }
}
pub struct IdentifiedXRayStyleArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
    pub style: Option<flatbuffers::WIPOffset<DucXRayStyle<'a>>>,
}
impl<'a> Default for IdentifiedXRayStyleArgs<'a> {
  #[inline]
  fn default() -> Self {
    IdentifiedXRayStyleArgs {
      id: None,
      style: None,
    }
  }
}

pub struct IdentifiedXRayStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> IdentifiedXRayStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<Identifier<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Identifier>>(IdentifiedXRayStyle::VT_ID, id);
  }
  #[inline]
  pub fn add_style(&mut self, style: flatbuffers::WIPOffset<DucXRayStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucXRayStyle>>(IdentifiedXRayStyle::VT_STYLE, style);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> IdentifiedXRayStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    IdentifiedXRayStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IdentifiedXRayStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for IdentifiedXRayStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("IdentifiedXRayStyle");
      ds.field("id", &self.id());
      ds.field("style", &self.style());
      ds.finish()
  }
}
pub enum StandardStylesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct StandardStyles<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StandardStyles<'a> {
  type Inner = StandardStyles<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> StandardStyles<'a> {
  pub const VT_COMMON_STYLES: flatbuffers::VOffsetT = 4;
  pub const VT_STACK_LIKE_STYLES: flatbuffers::VOffsetT = 6;
  pub const VT_TEXT_STYLES: flatbuffers::VOffsetT = 8;
  pub const VT_DIMENSION_STYLES: flatbuffers::VOffsetT = 10;
  pub const VT_LEADER_STYLES: flatbuffers::VOffsetT = 12;
  pub const VT_FEATURE_CONTROL_FRAME_STYLES: flatbuffers::VOffsetT = 14;
  pub const VT_TABLE_STYLES: flatbuffers::VOffsetT = 16;
  pub const VT_DOC_STYLES: flatbuffers::VOffsetT = 18;
  pub const VT_VIEWPORT_STYLES: flatbuffers::VOffsetT = 20;
  pub const VT_HATCH_STYLES: flatbuffers::VOffsetT = 22;
  pub const VT_XRAY_STYLES: flatbuffers::VOffsetT = 24;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StandardStyles { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StandardStylesArgs<'args>
  ) -> flatbuffers::WIPOffset<StandardStyles<'bldr>> {
    let mut builder = StandardStylesBuilder::new(_fbb);
    if let Some(x) = args.xray_styles { builder.add_xray_styles(x); }
    if let Some(x) = args.hatch_styles { builder.add_hatch_styles(x); }
    if let Some(x) = args.viewport_styles { builder.add_viewport_styles(x); }
    if let Some(x) = args.doc_styles { builder.add_doc_styles(x); }
    if let Some(x) = args.table_styles { builder.add_table_styles(x); }
    if let Some(x) = args.feature_control_frame_styles { builder.add_feature_control_frame_styles(x); }
    if let Some(x) = args.leader_styles { builder.add_leader_styles(x); }
    if let Some(x) = args.dimension_styles { builder.add_dimension_styles(x); }
    if let Some(x) = args.text_styles { builder.add_text_styles(x); }
    if let Some(x) = args.stack_like_styles { builder.add_stack_like_styles(x); }
    if let Some(x) = args.common_styles { builder.add_common_styles(x); }
    builder.finish()
  }


  #[inline]
  pub fn common_styles(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedCommonStyle<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedCommonStyle>>>>(StandardStyles::VT_COMMON_STYLES, None)}
  }
  #[inline]
  pub fn stack_like_styles(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedStackLikeStyle<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedStackLikeStyle>>>>(StandardStyles::VT_STACK_LIKE_STYLES, None)}
  }
  #[inline]
  pub fn text_styles(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedTextStyle<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedTextStyle>>>>(StandardStyles::VT_TEXT_STYLES, None)}
  }
  #[inline]
  pub fn dimension_styles(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedDimensionStyle<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedDimensionStyle>>>>(StandardStyles::VT_DIMENSION_STYLES, None)}
  }
  #[inline]
  pub fn leader_styles(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedLeaderStyle<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedLeaderStyle>>>>(StandardStyles::VT_LEADER_STYLES, None)}
  }
  #[inline]
  pub fn feature_control_frame_styles(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedFCFStyle<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedFCFStyle>>>>(StandardStyles::VT_FEATURE_CONTROL_FRAME_STYLES, None)}
  }
  #[inline]
  pub fn table_styles(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedTableStyle<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedTableStyle>>>>(StandardStyles::VT_TABLE_STYLES, None)}
  }
  #[inline]
  pub fn doc_styles(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedDocStyle<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedDocStyle>>>>(StandardStyles::VT_DOC_STYLES, None)}
  }
  #[inline]
  pub fn viewport_styles(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedViewportStyle<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedViewportStyle>>>>(StandardStyles::VT_VIEWPORT_STYLES, None)}
  }
  #[inline]
  pub fn hatch_styles(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedHatchStyle<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedHatchStyle>>>>(StandardStyles::VT_HATCH_STYLES, None)}
  }
  #[inline]
  pub fn xray_styles(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedXRayStyle<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedXRayStyle>>>>(StandardStyles::VT_XRAY_STYLES, None)}
  }
}

impl flatbuffers::Verifiable for StandardStyles<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<IdentifiedCommonStyle>>>>("common_styles", Self::VT_COMMON_STYLES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<IdentifiedStackLikeStyle>>>>("stack_like_styles", Self::VT_STACK_LIKE_STYLES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<IdentifiedTextStyle>>>>("text_styles", Self::VT_TEXT_STYLES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<IdentifiedDimensionStyle>>>>("dimension_styles", Self::VT_DIMENSION_STYLES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<IdentifiedLeaderStyle>>>>("leader_styles", Self::VT_LEADER_STYLES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<IdentifiedFCFStyle>>>>("feature_control_frame_styles", Self::VT_FEATURE_CONTROL_FRAME_STYLES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<IdentifiedTableStyle>>>>("table_styles", Self::VT_TABLE_STYLES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<IdentifiedDocStyle>>>>("doc_styles", Self::VT_DOC_STYLES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<IdentifiedViewportStyle>>>>("viewport_styles", Self::VT_VIEWPORT_STYLES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<IdentifiedHatchStyle>>>>("hatch_styles", Self::VT_HATCH_STYLES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<IdentifiedXRayStyle>>>>("xray_styles", Self::VT_XRAY_STYLES, false)?
     .finish();
    Ok(())
  }
}
pub struct StandardStylesArgs<'a> {
    pub common_styles: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedCommonStyle<'a>>>>>,
    pub stack_like_styles: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedStackLikeStyle<'a>>>>>,
    pub text_styles: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedTextStyle<'a>>>>>,
    pub dimension_styles: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedDimensionStyle<'a>>>>>,
    pub leader_styles: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedLeaderStyle<'a>>>>>,
    pub feature_control_frame_styles: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedFCFStyle<'a>>>>>,
    pub table_styles: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedTableStyle<'a>>>>>,
    pub doc_styles: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedDocStyle<'a>>>>>,
    pub viewport_styles: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedViewportStyle<'a>>>>>,
    pub hatch_styles: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedHatchStyle<'a>>>>>,
    pub xray_styles: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedXRayStyle<'a>>>>>,
}
impl<'a> Default for StandardStylesArgs<'a> {
  #[inline]
  fn default() -> Self {
    StandardStylesArgs {
      common_styles: None,
      stack_like_styles: None,
      text_styles: None,
      dimension_styles: None,
      leader_styles: None,
      feature_control_frame_styles: None,
      table_styles: None,
      doc_styles: None,
      viewport_styles: None,
      hatch_styles: None,
      xray_styles: None,
    }
  }
}

pub struct StandardStylesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StandardStylesBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_common_styles(&mut self, common_styles: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<IdentifiedCommonStyle<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StandardStyles::VT_COMMON_STYLES, common_styles);
  }
  #[inline]
  pub fn add_stack_like_styles(&mut self, stack_like_styles: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<IdentifiedStackLikeStyle<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StandardStyles::VT_STACK_LIKE_STYLES, stack_like_styles);
  }
  #[inline]
  pub fn add_text_styles(&mut self, text_styles: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<IdentifiedTextStyle<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StandardStyles::VT_TEXT_STYLES, text_styles);
  }
  #[inline]
  pub fn add_dimension_styles(&mut self, dimension_styles: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<IdentifiedDimensionStyle<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StandardStyles::VT_DIMENSION_STYLES, dimension_styles);
  }
  #[inline]
  pub fn add_leader_styles(&mut self, leader_styles: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<IdentifiedLeaderStyle<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StandardStyles::VT_LEADER_STYLES, leader_styles);
  }
  #[inline]
  pub fn add_feature_control_frame_styles(&mut self, feature_control_frame_styles: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<IdentifiedFCFStyle<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StandardStyles::VT_FEATURE_CONTROL_FRAME_STYLES, feature_control_frame_styles);
  }
  #[inline]
  pub fn add_table_styles(&mut self, table_styles: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<IdentifiedTableStyle<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StandardStyles::VT_TABLE_STYLES, table_styles);
  }
  #[inline]
  pub fn add_doc_styles(&mut self, doc_styles: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<IdentifiedDocStyle<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StandardStyles::VT_DOC_STYLES, doc_styles);
  }
  #[inline]
  pub fn add_viewport_styles(&mut self, viewport_styles: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<IdentifiedViewportStyle<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StandardStyles::VT_VIEWPORT_STYLES, viewport_styles);
  }
  #[inline]
  pub fn add_hatch_styles(&mut self, hatch_styles: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<IdentifiedHatchStyle<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StandardStyles::VT_HATCH_STYLES, hatch_styles);
  }
  #[inline]
  pub fn add_xray_styles(&mut self, xray_styles: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<IdentifiedXRayStyle<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StandardStyles::VT_XRAY_STYLES, xray_styles);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StandardStylesBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StandardStylesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StandardStyles<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StandardStyles<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StandardStyles");
      ds.field("common_styles", &self.common_styles());
      ds.field("stack_like_styles", &self.stack_like_styles());
      ds.field("text_styles", &self.text_styles());
      ds.field("dimension_styles", &self.dimension_styles());
      ds.field("leader_styles", &self.leader_styles());
      ds.field("feature_control_frame_styles", &self.feature_control_frame_styles());
      ds.field("table_styles", &self.table_styles());
      ds.field("doc_styles", &self.doc_styles());
      ds.field("viewport_styles", &self.viewport_styles());
      ds.field("hatch_styles", &self.hatch_styles());
      ds.field("xray_styles", &self.xray_styles());
      ds.finish()
  }
}
pub enum GridStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GridStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GridStyle<'a> {
  type Inner = GridStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GridStyle<'a> {
  pub const VT_COLOR: flatbuffers::VOffsetT = 4;
  pub const VT_OPACITY: flatbuffers::VOffsetT = 6;
  pub const VT_DASH_PATTERN: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GridStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GridStyleArgs<'args>
  ) -> flatbuffers::WIPOffset<GridStyle<'bldr>> {
    let mut builder = GridStyleBuilder::new(_fbb);
    builder.add_opacity(args.opacity);
    if let Some(x) = args.dash_pattern { builder.add_dash_pattern(x); }
    if let Some(x) = args.color { builder.add_color(x); }
    builder.finish()
  }


  #[inline]
  pub fn color(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GridStyle::VT_COLOR, None)}
  }
  #[inline]
  pub fn opacity(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GridStyle::VT_OPACITY, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn dash_pattern(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(GridStyle::VT_DASH_PATTERN, None)}
  }
}

impl flatbuffers::Verifiable for GridStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("color", Self::VT_COLOR, false)?
     .visit_field::<f64>("opacity", Self::VT_OPACITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("dash_pattern", Self::VT_DASH_PATTERN, false)?
     .finish();
    Ok(())
  }
}
pub struct GridStyleArgs<'a> {
    pub color: Option<flatbuffers::WIPOffset<&'a str>>,
    pub opacity: f64,
    pub dash_pattern: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
}
impl<'a> Default for GridStyleArgs<'a> {
  #[inline]
  fn default() -> Self {
    GridStyleArgs {
      color: None,
      opacity: 0.0,
      dash_pattern: None,
    }
  }
}

pub struct GridStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GridStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_color(&mut self, color: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GridStyle::VT_COLOR, color);
  }
  #[inline]
  pub fn add_opacity(&mut self, opacity: f64) {
    self.fbb_.push_slot::<f64>(GridStyle::VT_OPACITY, opacity, 0.0);
  }
  #[inline]
  pub fn add_dash_pattern(&mut self, dash_pattern: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GridStyle::VT_DASH_PATTERN, dash_pattern);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GridStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GridStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GridStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GridStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GridStyle");
      ds.field("color", &self.color());
      ds.field("opacity", &self.opacity());
      ds.field("dash_pattern", &self.dash_pattern());
      ds.finish()
  }
}
pub enum PolarGridSettingsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PolarGridSettings<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PolarGridSettings<'a> {
  type Inner = PolarGridSettings<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PolarGridSettings<'a> {
  pub const VT_RADIAL_DIVISIONS: flatbuffers::VOffsetT = 4;
  pub const VT_RADIAL_SPACING: flatbuffers::VOffsetT = 6;
  pub const VT_SHOW_LABELS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PolarGridSettings { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PolarGridSettingsArgs
  ) -> flatbuffers::WIPOffset<PolarGridSettings<'bldr>> {
    let mut builder = PolarGridSettingsBuilder::new(_fbb);
    builder.add_radial_spacing(args.radial_spacing);
    builder.add_radial_divisions(args.radial_divisions);
    builder.add_show_labels(args.show_labels);
    builder.finish()
  }


  #[inline]
  pub fn radial_divisions(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PolarGridSettings::VT_RADIAL_DIVISIONS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn radial_spacing(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(PolarGridSettings::VT_RADIAL_SPACING, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn show_labels(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(PolarGridSettings::VT_SHOW_LABELS, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for PolarGridSettings<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("radial_divisions", Self::VT_RADIAL_DIVISIONS, false)?
     .visit_field::<f64>("radial_spacing", Self::VT_RADIAL_SPACING, false)?
     .visit_field::<bool>("show_labels", Self::VT_SHOW_LABELS, false)?
     .finish();
    Ok(())
  }
}
pub struct PolarGridSettingsArgs {
    pub radial_divisions: i32,
    pub radial_spacing: f64,
    pub show_labels: bool,
}
impl<'a> Default for PolarGridSettingsArgs {
  #[inline]
  fn default() -> Self {
    PolarGridSettingsArgs {
      radial_divisions: 0,
      radial_spacing: 0.0,
      show_labels: false,
    }
  }
}

pub struct PolarGridSettingsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PolarGridSettingsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_radial_divisions(&mut self, radial_divisions: i32) {
    self.fbb_.push_slot::<i32>(PolarGridSettings::VT_RADIAL_DIVISIONS, radial_divisions, 0);
  }
  #[inline]
  pub fn add_radial_spacing(&mut self, radial_spacing: f64) {
    self.fbb_.push_slot::<f64>(PolarGridSettings::VT_RADIAL_SPACING, radial_spacing, 0.0);
  }
  #[inline]
  pub fn add_show_labels(&mut self, show_labels: bool) {
    self.fbb_.push_slot::<bool>(PolarGridSettings::VT_SHOW_LABELS, show_labels, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PolarGridSettingsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PolarGridSettingsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PolarGridSettings<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PolarGridSettings<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PolarGridSettings");
      ds.field("radial_divisions", &self.radial_divisions());
      ds.field("radial_spacing", &self.radial_spacing());
      ds.field("show_labels", &self.show_labels());
      ds.finish()
  }
}
pub enum IsometricGridSettingsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct IsometricGridSettings<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IsometricGridSettings<'a> {
  type Inner = IsometricGridSettings<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> IsometricGridSettings<'a> {
  pub const VT_LEFT_ANGLE: flatbuffers::VOffsetT = 4;
  pub const VT_RIGHT_ANGLE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    IsometricGridSettings { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args IsometricGridSettingsArgs
  ) -> flatbuffers::WIPOffset<IsometricGridSettings<'bldr>> {
    let mut builder = IsometricGridSettingsBuilder::new(_fbb);
    builder.add_right_angle(args.right_angle);
    builder.add_left_angle(args.left_angle);
    builder.finish()
  }


  #[inline]
  pub fn left_angle(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IsometricGridSettings::VT_LEFT_ANGLE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn right_angle(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(IsometricGridSettings::VT_RIGHT_ANGLE, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for IsometricGridSettings<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("left_angle", Self::VT_LEFT_ANGLE, false)?
     .visit_field::<f64>("right_angle", Self::VT_RIGHT_ANGLE, false)?
     .finish();
    Ok(())
  }
}
pub struct IsometricGridSettingsArgs {
    pub left_angle: f64,
    pub right_angle: f64,
}
impl<'a> Default for IsometricGridSettingsArgs {
  #[inline]
  fn default() -> Self {
    IsometricGridSettingsArgs {
      left_angle: 0.0,
      right_angle: 0.0,
    }
  }
}

pub struct IsometricGridSettingsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> IsometricGridSettingsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_left_angle(&mut self, left_angle: f64) {
    self.fbb_.push_slot::<f64>(IsometricGridSettings::VT_LEFT_ANGLE, left_angle, 0.0);
  }
  #[inline]
  pub fn add_right_angle(&mut self, right_angle: f64) {
    self.fbb_.push_slot::<f64>(IsometricGridSettings::VT_RIGHT_ANGLE, right_angle, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> IsometricGridSettingsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    IsometricGridSettingsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IsometricGridSettings<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for IsometricGridSettings<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("IsometricGridSettings");
      ds.field("left_angle", &self.left_angle());
      ds.field("right_angle", &self.right_angle());
      ds.finish()
  }
}
pub enum GridSettingsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GridSettings<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GridSettings<'a> {
  type Inner = GridSettings<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GridSettings<'a> {
  pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
  pub const VT_READONLY: flatbuffers::VOffsetT = 6;
  pub const VT_DISPLAY_TYPE: flatbuffers::VOffsetT = 8;
  pub const VT_IS_ADAPTIVE: flatbuffers::VOffsetT = 10;
  pub const VT_X_SPACING: flatbuffers::VOffsetT = 12;
  pub const VT_Y_SPACING: flatbuffers::VOffsetT = 14;
  pub const VT_SUBDIVISIONS: flatbuffers::VOffsetT = 16;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 18;
  pub const VT_ROTATION: flatbuffers::VOffsetT = 20;
  pub const VT_FOLLOW_UCS: flatbuffers::VOffsetT = 22;
  pub const VT_MAJOR_STYLE: flatbuffers::VOffsetT = 24;
  pub const VT_MINOR_STYLE: flatbuffers::VOffsetT = 26;
  pub const VT_SHOW_MINOR: flatbuffers::VOffsetT = 28;
  pub const VT_MIN_ZOOM: flatbuffers::VOffsetT = 30;
  pub const VT_MAX_ZOOM: flatbuffers::VOffsetT = 32;
  pub const VT_AUTO_HIDE: flatbuffers::VOffsetT = 34;
  pub const VT_POLAR_SETTINGS: flatbuffers::VOffsetT = 36;
  pub const VT_ISOMETRIC_SETTINGS: flatbuffers::VOffsetT = 38;
  pub const VT_ENABLE_SNAPPING: flatbuffers::VOffsetT = 40;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GridSettings { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GridSettingsArgs<'args>
  ) -> flatbuffers::WIPOffset<GridSettings<'bldr>> {
    let mut builder = GridSettingsBuilder::new(_fbb);
    builder.add_max_zoom(args.max_zoom);
    builder.add_min_zoom(args.min_zoom);
    builder.add_rotation(args.rotation);
    builder.add_y_spacing(args.y_spacing);
    builder.add_x_spacing(args.x_spacing);
    if let Some(x) = args.isometric_settings { builder.add_isometric_settings(x); }
    if let Some(x) = args.polar_settings { builder.add_polar_settings(x); }
    if let Some(x) = args.minor_style { builder.add_minor_style(x); }
    if let Some(x) = args.major_style { builder.add_major_style(x); }
    if let Some(x) = args.origin { builder.add_origin(x); }
    builder.add_subdivisions(args.subdivisions);
    builder.add_enable_snapping(args.enable_snapping);
    builder.add_auto_hide(args.auto_hide);
    builder.add_show_minor(args.show_minor);
    builder.add_follow_ucs(args.follow_ucs);
    builder.add_is_adaptive(args.is_adaptive);
    if let Some(x) = args.display_type { builder.add_display_type(x); }
    builder.add_readonly(args.readonly);
    if let Some(x) = args.type_ { builder.add_type_(x); }
    builder.finish()
  }


  #[inline]
  pub fn type_(&self) -> Option<GRID_TYPE> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<GRID_TYPE>(GridSettings::VT_TYPE_, None)}
  }
  #[inline]
  pub fn readonly(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GridSettings::VT_READONLY, Some(false)).unwrap()}
  }
  #[inline]
  pub fn display_type(&self) -> Option<GRID_DISPLAY_TYPE> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<GRID_DISPLAY_TYPE>(GridSettings::VT_DISPLAY_TYPE, None)}
  }
  #[inline]
  pub fn is_adaptive(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GridSettings::VT_IS_ADAPTIVE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn x_spacing(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GridSettings::VT_X_SPACING, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn y_spacing(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GridSettings::VT_Y_SPACING, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn subdivisions(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(GridSettings::VT_SUBDIVISIONS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn origin(&self) -> Option<&'a GeometricPoint> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<GeometricPoint>(GridSettings::VT_ORIGIN, None)}
  }
  #[inline]
  pub fn rotation(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GridSettings::VT_ROTATION, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn follow_ucs(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GridSettings::VT_FOLLOW_UCS, Some(false)).unwrap()}
  }
  #[inline]
  pub fn major_style(&self) -> Option<GridStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<GridStyle>>(GridSettings::VT_MAJOR_STYLE, None)}
  }
  #[inline]
  pub fn minor_style(&self) -> Option<GridStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<GridStyle>>(GridSettings::VT_MINOR_STYLE, None)}
  }
  #[inline]
  pub fn show_minor(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GridSettings::VT_SHOW_MINOR, Some(false)).unwrap()}
  }
  #[inline]
  pub fn min_zoom(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GridSettings::VT_MIN_ZOOM, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn max_zoom(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(GridSettings::VT_MAX_ZOOM, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn auto_hide(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GridSettings::VT_AUTO_HIDE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn polar_settings(&self) -> Option<PolarGridSettings<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<PolarGridSettings>>(GridSettings::VT_POLAR_SETTINGS, None)}
  }
  #[inline]
  pub fn isometric_settings(&self) -> Option<IsometricGridSettings<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<IsometricGridSettings>>(GridSettings::VT_ISOMETRIC_SETTINGS, None)}
  }
  #[inline]
  pub fn enable_snapping(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(GridSettings::VT_ENABLE_SNAPPING, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GridSettings<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<GRID_TYPE>("type_", Self::VT_TYPE_, false)?
     .visit_field::<bool>("readonly", Self::VT_READONLY, false)?
     .visit_field::<GRID_DISPLAY_TYPE>("display_type", Self::VT_DISPLAY_TYPE, false)?
     .visit_field::<bool>("is_adaptive", Self::VT_IS_ADAPTIVE, false)?
     .visit_field::<f64>("x_spacing", Self::VT_X_SPACING, false)?
     .visit_field::<f64>("y_spacing", Self::VT_Y_SPACING, false)?
     .visit_field::<i32>("subdivisions", Self::VT_SUBDIVISIONS, false)?
     .visit_field::<GeometricPoint>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<f64>("rotation", Self::VT_ROTATION, false)?
     .visit_field::<bool>("follow_ucs", Self::VT_FOLLOW_UCS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<GridStyle>>("major_style", Self::VT_MAJOR_STYLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<GridStyle>>("minor_style", Self::VT_MINOR_STYLE, false)?
     .visit_field::<bool>("show_minor", Self::VT_SHOW_MINOR, false)?
     .visit_field::<f64>("min_zoom", Self::VT_MIN_ZOOM, false)?
     .visit_field::<f64>("max_zoom", Self::VT_MAX_ZOOM, false)?
     .visit_field::<bool>("auto_hide", Self::VT_AUTO_HIDE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<PolarGridSettings>>("polar_settings", Self::VT_POLAR_SETTINGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<IsometricGridSettings>>("isometric_settings", Self::VT_ISOMETRIC_SETTINGS, false)?
     .visit_field::<bool>("enable_snapping", Self::VT_ENABLE_SNAPPING, false)?
     .finish();
    Ok(())
  }
}
pub struct GridSettingsArgs<'a> {
    pub type_: Option<GRID_TYPE>,
    pub readonly: bool,
    pub display_type: Option<GRID_DISPLAY_TYPE>,
    pub is_adaptive: bool,
    pub x_spacing: f64,
    pub y_spacing: f64,
    pub subdivisions: i32,
    pub origin: Option<&'a GeometricPoint>,
    pub rotation: f64,
    pub follow_ucs: bool,
    pub major_style: Option<flatbuffers::WIPOffset<GridStyle<'a>>>,
    pub minor_style: Option<flatbuffers::WIPOffset<GridStyle<'a>>>,
    pub show_minor: bool,
    pub min_zoom: f64,
    pub max_zoom: f64,
    pub auto_hide: bool,
    pub polar_settings: Option<flatbuffers::WIPOffset<PolarGridSettings<'a>>>,
    pub isometric_settings: Option<flatbuffers::WIPOffset<IsometricGridSettings<'a>>>,
    pub enable_snapping: bool,
}
impl<'a> Default for GridSettingsArgs<'a> {
  #[inline]
  fn default() -> Self {
    GridSettingsArgs {
      type_: None,
      readonly: false,
      display_type: None,
      is_adaptive: false,
      x_spacing: 0.0,
      y_spacing: 0.0,
      subdivisions: 0,
      origin: None,
      rotation: 0.0,
      follow_ucs: false,
      major_style: None,
      minor_style: None,
      show_minor: false,
      min_zoom: 0.0,
      max_zoom: 0.0,
      auto_hide: false,
      polar_settings: None,
      isometric_settings: None,
      enable_snapping: false,
    }
  }
}

pub struct GridSettingsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GridSettingsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_type_(&mut self, type_: GRID_TYPE) {
    self.fbb_.push_slot_always::<GRID_TYPE>(GridSettings::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_readonly(&mut self, readonly: bool) {
    self.fbb_.push_slot::<bool>(GridSettings::VT_READONLY, readonly, false);
  }
  #[inline]
  pub fn add_display_type(&mut self, display_type: GRID_DISPLAY_TYPE) {
    self.fbb_.push_slot_always::<GRID_DISPLAY_TYPE>(GridSettings::VT_DISPLAY_TYPE, display_type);
  }
  #[inline]
  pub fn add_is_adaptive(&mut self, is_adaptive: bool) {
    self.fbb_.push_slot::<bool>(GridSettings::VT_IS_ADAPTIVE, is_adaptive, false);
  }
  #[inline]
  pub fn add_x_spacing(&mut self, x_spacing: f64) {
    self.fbb_.push_slot::<f64>(GridSettings::VT_X_SPACING, x_spacing, 0.0);
  }
  #[inline]
  pub fn add_y_spacing(&mut self, y_spacing: f64) {
    self.fbb_.push_slot::<f64>(GridSettings::VT_Y_SPACING, y_spacing, 0.0);
  }
  #[inline]
  pub fn add_subdivisions(&mut self, subdivisions: i32) {
    self.fbb_.push_slot::<i32>(GridSettings::VT_SUBDIVISIONS, subdivisions, 0);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: &GeometricPoint) {
    self.fbb_.push_slot_always::<&GeometricPoint>(GridSettings::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_rotation(&mut self, rotation: f64) {
    self.fbb_.push_slot::<f64>(GridSettings::VT_ROTATION, rotation, 0.0);
  }
  #[inline]
  pub fn add_follow_ucs(&mut self, follow_ucs: bool) {
    self.fbb_.push_slot::<bool>(GridSettings::VT_FOLLOW_UCS, follow_ucs, false);
  }
  #[inline]
  pub fn add_major_style(&mut self, major_style: flatbuffers::WIPOffset<GridStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<GridStyle>>(GridSettings::VT_MAJOR_STYLE, major_style);
  }
  #[inline]
  pub fn add_minor_style(&mut self, minor_style: flatbuffers::WIPOffset<GridStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<GridStyle>>(GridSettings::VT_MINOR_STYLE, minor_style);
  }
  #[inline]
  pub fn add_show_minor(&mut self, show_minor: bool) {
    self.fbb_.push_slot::<bool>(GridSettings::VT_SHOW_MINOR, show_minor, false);
  }
  #[inline]
  pub fn add_min_zoom(&mut self, min_zoom: f64) {
    self.fbb_.push_slot::<f64>(GridSettings::VT_MIN_ZOOM, min_zoom, 0.0);
  }
  #[inline]
  pub fn add_max_zoom(&mut self, max_zoom: f64) {
    self.fbb_.push_slot::<f64>(GridSettings::VT_MAX_ZOOM, max_zoom, 0.0);
  }
  #[inline]
  pub fn add_auto_hide(&mut self, auto_hide: bool) {
    self.fbb_.push_slot::<bool>(GridSettings::VT_AUTO_HIDE, auto_hide, false);
  }
  #[inline]
  pub fn add_polar_settings(&mut self, polar_settings: flatbuffers::WIPOffset<PolarGridSettings<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PolarGridSettings>>(GridSettings::VT_POLAR_SETTINGS, polar_settings);
  }
  #[inline]
  pub fn add_isometric_settings(&mut self, isometric_settings: flatbuffers::WIPOffset<IsometricGridSettings<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<IsometricGridSettings>>(GridSettings::VT_ISOMETRIC_SETTINGS, isometric_settings);
  }
  #[inline]
  pub fn add_enable_snapping(&mut self, enable_snapping: bool) {
    self.fbb_.push_slot::<bool>(GridSettings::VT_ENABLE_SNAPPING, enable_snapping, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GridSettingsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GridSettingsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GridSettings<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GridSettings<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GridSettings");
      ds.field("type_", &self.type_());
      ds.field("readonly", &self.readonly());
      ds.field("display_type", &self.display_type());
      ds.field("is_adaptive", &self.is_adaptive());
      ds.field("x_spacing", &self.x_spacing());
      ds.field("y_spacing", &self.y_spacing());
      ds.field("subdivisions", &self.subdivisions());
      ds.field("origin", &self.origin());
      ds.field("rotation", &self.rotation());
      ds.field("follow_ucs", &self.follow_ucs());
      ds.field("major_style", &self.major_style());
      ds.field("minor_style", &self.minor_style());
      ds.field("show_minor", &self.show_minor());
      ds.field("min_zoom", &self.min_zoom());
      ds.field("max_zoom", &self.max_zoom());
      ds.field("auto_hide", &self.auto_hide());
      ds.field("polar_settings", &self.polar_settings());
      ds.field("isometric_settings", &self.isometric_settings());
      ds.field("enable_snapping", &self.enable_snapping());
      ds.finish()
  }
}
pub enum SnapOverrideOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SnapOverride<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SnapOverride<'a> {
  type Inner = SnapOverride<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SnapOverride<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_BEHAVIOR: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SnapOverride { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SnapOverrideArgs<'args>
  ) -> flatbuffers::WIPOffset<SnapOverride<'bldr>> {
    let mut builder = SnapOverrideBuilder::new(_fbb);
    if let Some(x) = args.key { builder.add_key(x); }
    if let Some(x) = args.behavior { builder.add_behavior(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SnapOverride::VT_KEY, None)}
  }
  #[inline]
  pub fn behavior(&self) -> Option<SNAP_OVERRIDE_BEHAVIOR> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SNAP_OVERRIDE_BEHAVIOR>(SnapOverride::VT_BEHAVIOR, None)}
  }
}

impl flatbuffers::Verifiable for SnapOverride<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
     .visit_field::<SNAP_OVERRIDE_BEHAVIOR>("behavior", Self::VT_BEHAVIOR, false)?
     .finish();
    Ok(())
  }
}
pub struct SnapOverrideArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub behavior: Option<SNAP_OVERRIDE_BEHAVIOR>,
}
impl<'a> Default for SnapOverrideArgs<'a> {
  #[inline]
  fn default() -> Self {
    SnapOverrideArgs {
      key: None,
      behavior: None,
    }
  }
}

pub struct SnapOverrideBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SnapOverrideBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SnapOverride::VT_KEY, key);
  }
  #[inline]
  pub fn add_behavior(&mut self, behavior: SNAP_OVERRIDE_BEHAVIOR) {
    self.fbb_.push_slot_always::<SNAP_OVERRIDE_BEHAVIOR>(SnapOverride::VT_BEHAVIOR, behavior);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SnapOverrideBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SnapOverrideBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SnapOverride<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SnapOverride<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SnapOverride");
      ds.field("key", &self.key());
      ds.field("behavior", &self.behavior());
      ds.finish()
  }
}
pub enum DynamicSnapSettingsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DynamicSnapSettings<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DynamicSnapSettings<'a> {
  type Inner = DynamicSnapSettings<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DynamicSnapSettings<'a> {
  pub const VT_ENABLED_DURING_DRAG: flatbuffers::VOffsetT = 4;
  pub const VT_ENABLED_DURING_ROTATION: flatbuffers::VOffsetT = 6;
  pub const VT_ENABLED_DURING_SCALE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DynamicSnapSettings { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DynamicSnapSettingsArgs
  ) -> flatbuffers::WIPOffset<DynamicSnapSettings<'bldr>> {
    let mut builder = DynamicSnapSettingsBuilder::new(_fbb);
    builder.add_enabled_during_scale(args.enabled_during_scale);
    builder.add_enabled_during_rotation(args.enabled_during_rotation);
    builder.add_enabled_during_drag(args.enabled_during_drag);
    builder.finish()
  }


  #[inline]
  pub fn enabled_during_drag(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DynamicSnapSettings::VT_ENABLED_DURING_DRAG, Some(false)).unwrap()}
  }
  #[inline]
  pub fn enabled_during_rotation(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DynamicSnapSettings::VT_ENABLED_DURING_ROTATION, Some(false)).unwrap()}
  }
  #[inline]
  pub fn enabled_during_scale(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DynamicSnapSettings::VT_ENABLED_DURING_SCALE, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DynamicSnapSettings<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("enabled_during_drag", Self::VT_ENABLED_DURING_DRAG, false)?
     .visit_field::<bool>("enabled_during_rotation", Self::VT_ENABLED_DURING_ROTATION, false)?
     .visit_field::<bool>("enabled_during_scale", Self::VT_ENABLED_DURING_SCALE, false)?
     .finish();
    Ok(())
  }
}
pub struct DynamicSnapSettingsArgs {
    pub enabled_during_drag: bool,
    pub enabled_during_rotation: bool,
    pub enabled_during_scale: bool,
}
impl<'a> Default for DynamicSnapSettingsArgs {
  #[inline]
  fn default() -> Self {
    DynamicSnapSettingsArgs {
      enabled_during_drag: false,
      enabled_during_rotation: false,
      enabled_during_scale: false,
    }
  }
}

pub struct DynamicSnapSettingsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DynamicSnapSettingsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_enabled_during_drag(&mut self, enabled_during_drag: bool) {
    self.fbb_.push_slot::<bool>(DynamicSnapSettings::VT_ENABLED_DURING_DRAG, enabled_during_drag, false);
  }
  #[inline]
  pub fn add_enabled_during_rotation(&mut self, enabled_during_rotation: bool) {
    self.fbb_.push_slot::<bool>(DynamicSnapSettings::VT_ENABLED_DURING_ROTATION, enabled_during_rotation, false);
  }
  #[inline]
  pub fn add_enabled_during_scale(&mut self, enabled_during_scale: bool) {
    self.fbb_.push_slot::<bool>(DynamicSnapSettings::VT_ENABLED_DURING_SCALE, enabled_during_scale, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DynamicSnapSettingsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DynamicSnapSettingsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DynamicSnapSettings<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DynamicSnapSettings<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DynamicSnapSettings");
      ds.field("enabled_during_drag", &self.enabled_during_drag());
      ds.field("enabled_during_rotation", &self.enabled_during_rotation());
      ds.field("enabled_during_scale", &self.enabled_during_scale());
      ds.finish()
  }
}
pub enum PolarTrackingSettingsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PolarTrackingSettings<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PolarTrackingSettings<'a> {
  type Inner = PolarTrackingSettings<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PolarTrackingSettings<'a> {
  pub const VT_ENABLED: flatbuffers::VOffsetT = 4;
  pub const VT_ANGLES: flatbuffers::VOffsetT = 6;
  pub const VT_INCREMENT_ANGLE: flatbuffers::VOffsetT = 8;
  pub const VT_TRACK_FROM_LAST_POINT: flatbuffers::VOffsetT = 10;
  pub const VT_SHOW_POLAR_COORDINATES: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PolarTrackingSettings { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PolarTrackingSettingsArgs<'args>
  ) -> flatbuffers::WIPOffset<PolarTrackingSettings<'bldr>> {
    let mut builder = PolarTrackingSettingsBuilder::new(_fbb);
    builder.add_increment_angle(args.increment_angle);
    if let Some(x) = args.angles { builder.add_angles(x); }
    builder.add_show_polar_coordinates(args.show_polar_coordinates);
    builder.add_track_from_last_point(args.track_from_last_point);
    builder.add_enabled(args.enabled);
    builder.finish()
  }


  #[inline]
  pub fn enabled(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(PolarTrackingSettings::VT_ENABLED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn angles(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(PolarTrackingSettings::VT_ANGLES, None)}
  }
  #[inline]
  pub fn increment_angle(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(PolarTrackingSettings::VT_INCREMENT_ANGLE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn track_from_last_point(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(PolarTrackingSettings::VT_TRACK_FROM_LAST_POINT, Some(false)).unwrap()}
  }
  #[inline]
  pub fn show_polar_coordinates(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(PolarTrackingSettings::VT_SHOW_POLAR_COORDINATES, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for PolarTrackingSettings<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("enabled", Self::VT_ENABLED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("angles", Self::VT_ANGLES, false)?
     .visit_field::<f64>("increment_angle", Self::VT_INCREMENT_ANGLE, false)?
     .visit_field::<bool>("track_from_last_point", Self::VT_TRACK_FROM_LAST_POINT, false)?
     .visit_field::<bool>("show_polar_coordinates", Self::VT_SHOW_POLAR_COORDINATES, false)?
     .finish();
    Ok(())
  }
}
pub struct PolarTrackingSettingsArgs<'a> {
    pub enabled: bool,
    pub angles: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub increment_angle: f64,
    pub track_from_last_point: bool,
    pub show_polar_coordinates: bool,
}
impl<'a> Default for PolarTrackingSettingsArgs<'a> {
  #[inline]
  fn default() -> Self {
    PolarTrackingSettingsArgs {
      enabled: false,
      angles: None,
      increment_angle: 0.0,
      track_from_last_point: false,
      show_polar_coordinates: false,
    }
  }
}

pub struct PolarTrackingSettingsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PolarTrackingSettingsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_enabled(&mut self, enabled: bool) {
    self.fbb_.push_slot::<bool>(PolarTrackingSettings::VT_ENABLED, enabled, false);
  }
  #[inline]
  pub fn add_angles(&mut self, angles: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PolarTrackingSettings::VT_ANGLES, angles);
  }
  #[inline]
  pub fn add_increment_angle(&mut self, increment_angle: f64) {
    self.fbb_.push_slot::<f64>(PolarTrackingSettings::VT_INCREMENT_ANGLE, increment_angle, 0.0);
  }
  #[inline]
  pub fn add_track_from_last_point(&mut self, track_from_last_point: bool) {
    self.fbb_.push_slot::<bool>(PolarTrackingSettings::VT_TRACK_FROM_LAST_POINT, track_from_last_point, false);
  }
  #[inline]
  pub fn add_show_polar_coordinates(&mut self, show_polar_coordinates: bool) {
    self.fbb_.push_slot::<bool>(PolarTrackingSettings::VT_SHOW_POLAR_COORDINATES, show_polar_coordinates, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PolarTrackingSettingsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PolarTrackingSettingsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PolarTrackingSettings<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PolarTrackingSettings<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PolarTrackingSettings");
      ds.field("enabled", &self.enabled());
      ds.field("angles", &self.angles());
      ds.field("increment_angle", &self.increment_angle());
      ds.field("track_from_last_point", &self.track_from_last_point());
      ds.field("show_polar_coordinates", &self.show_polar_coordinates());
      ds.finish()
  }
}
pub enum TrackingLineStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TrackingLineStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TrackingLineStyle<'a> {
  type Inner = TrackingLineStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TrackingLineStyle<'a> {
  pub const VT_COLOR: flatbuffers::VOffsetT = 4;
  pub const VT_OPACITY: flatbuffers::VOffsetT = 6;
  pub const VT_DASH_PATTERN: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TrackingLineStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TrackingLineStyleArgs<'args>
  ) -> flatbuffers::WIPOffset<TrackingLineStyle<'bldr>> {
    let mut builder = TrackingLineStyleBuilder::new(_fbb);
    builder.add_opacity(args.opacity);
    if let Some(x) = args.dash_pattern { builder.add_dash_pattern(x); }
    if let Some(x) = args.color { builder.add_color(x); }
    builder.finish()
  }


  #[inline]
  pub fn color(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TrackingLineStyle::VT_COLOR, None)}
  }
  #[inline]
  pub fn opacity(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TrackingLineStyle::VT_OPACITY, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn dash_pattern(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(TrackingLineStyle::VT_DASH_PATTERN, None)}
  }
}

impl flatbuffers::Verifiable for TrackingLineStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("color", Self::VT_COLOR, false)?
     .visit_field::<f64>("opacity", Self::VT_OPACITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("dash_pattern", Self::VT_DASH_PATTERN, false)?
     .finish();
    Ok(())
  }
}
pub struct TrackingLineStyleArgs<'a> {
    pub color: Option<flatbuffers::WIPOffset<&'a str>>,
    pub opacity: f64,
    pub dash_pattern: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
}
impl<'a> Default for TrackingLineStyleArgs<'a> {
  #[inline]
  fn default() -> Self {
    TrackingLineStyleArgs {
      color: None,
      opacity: 0.0,
      dash_pattern: None,
    }
  }
}

pub struct TrackingLineStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TrackingLineStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_color(&mut self, color: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackingLineStyle::VT_COLOR, color);
  }
  #[inline]
  pub fn add_opacity(&mut self, opacity: f64) {
    self.fbb_.push_slot::<f64>(TrackingLineStyle::VT_OPACITY, opacity, 0.0);
  }
  #[inline]
  pub fn add_dash_pattern(&mut self, dash_pattern: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TrackingLineStyle::VT_DASH_PATTERN, dash_pattern);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TrackingLineStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TrackingLineStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TrackingLineStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TrackingLineStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TrackingLineStyle");
      ds.field("color", &self.color());
      ds.field("opacity", &self.opacity());
      ds.field("dash_pattern", &self.dash_pattern());
      ds.finish()
  }
}
pub enum LayerSnapFiltersOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LayerSnapFilters<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LayerSnapFilters<'a> {
  type Inner = LayerSnapFilters<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LayerSnapFilters<'a> {
  pub const VT_INCLUDE_LAYERS: flatbuffers::VOffsetT = 4;
  pub const VT_EXCLUDE_LAYERS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LayerSnapFilters { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LayerSnapFiltersArgs<'args>
  ) -> flatbuffers::WIPOffset<LayerSnapFilters<'bldr>> {
    let mut builder = LayerSnapFiltersBuilder::new(_fbb);
    if let Some(x) = args.exclude_layers { builder.add_exclude_layers(x); }
    if let Some(x) = args.include_layers { builder.add_include_layers(x); }
    builder.finish()
  }


  #[inline]
  pub fn include_layers(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(LayerSnapFilters::VT_INCLUDE_LAYERS, None)}
  }
  #[inline]
  pub fn exclude_layers(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(LayerSnapFilters::VT_EXCLUDE_LAYERS, None)}
  }
}

impl flatbuffers::Verifiable for LayerSnapFilters<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("include_layers", Self::VT_INCLUDE_LAYERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("exclude_layers", Self::VT_EXCLUDE_LAYERS, false)?
     .finish();
    Ok(())
  }
}
pub struct LayerSnapFiltersArgs<'a> {
    pub include_layers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub exclude_layers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for LayerSnapFiltersArgs<'a> {
  #[inline]
  fn default() -> Self {
    LayerSnapFiltersArgs {
      include_layers: None,
      exclude_layers: None,
    }
  }
}

pub struct LayerSnapFiltersBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LayerSnapFiltersBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_include_layers(&mut self, include_layers: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LayerSnapFilters::VT_INCLUDE_LAYERS, include_layers);
  }
  #[inline]
  pub fn add_exclude_layers(&mut self, exclude_layers: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LayerSnapFilters::VT_EXCLUDE_LAYERS, exclude_layers);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LayerSnapFiltersBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LayerSnapFiltersBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LayerSnapFilters<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LayerSnapFilters<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LayerSnapFilters");
      ds.field("include_layers", &self.include_layers());
      ds.field("exclude_layers", &self.exclude_layers());
      ds.finish()
  }
}
pub enum SnapMarkerStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SnapMarkerStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SnapMarkerStyle<'a> {
  type Inner = SnapMarkerStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SnapMarkerStyle<'a> {
  pub const VT_SHAPE: flatbuffers::VOffsetT = 4;
  pub const VT_COLOR: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SnapMarkerStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SnapMarkerStyleArgs<'args>
  ) -> flatbuffers::WIPOffset<SnapMarkerStyle<'bldr>> {
    let mut builder = SnapMarkerStyleBuilder::new(_fbb);
    if let Some(x) = args.color { builder.add_color(x); }
    if let Some(x) = args.shape { builder.add_shape(x); }
    builder.finish()
  }


  #[inline]
  pub fn shape(&self) -> Option<SNAP_MARKER_SHAPE> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SNAP_MARKER_SHAPE>(SnapMarkerStyle::VT_SHAPE, None)}
  }
  #[inline]
  pub fn color(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SnapMarkerStyle::VT_COLOR, None)}
  }
}

impl flatbuffers::Verifiable for SnapMarkerStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<SNAP_MARKER_SHAPE>("shape", Self::VT_SHAPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("color", Self::VT_COLOR, false)?
     .finish();
    Ok(())
  }
}
pub struct SnapMarkerStyleArgs<'a> {
    pub shape: Option<SNAP_MARKER_SHAPE>,
    pub color: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SnapMarkerStyleArgs<'a> {
  #[inline]
  fn default() -> Self {
    SnapMarkerStyleArgs {
      shape: None,
      color: None,
    }
  }
}

pub struct SnapMarkerStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SnapMarkerStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_shape(&mut self, shape: SNAP_MARKER_SHAPE) {
    self.fbb_.push_slot_always::<SNAP_MARKER_SHAPE>(SnapMarkerStyle::VT_SHAPE, shape);
  }
  #[inline]
  pub fn add_color(&mut self, color: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SnapMarkerStyle::VT_COLOR, color);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SnapMarkerStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SnapMarkerStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SnapMarkerStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SnapMarkerStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SnapMarkerStyle");
      ds.field("shape", &self.shape());
      ds.field("color", &self.color());
      ds.finish()
  }
}
pub enum SnapMarkerStyleEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SnapMarkerStyleEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SnapMarkerStyleEntry<'a> {
  type Inner = SnapMarkerStyleEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SnapMarkerStyleEntry<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SnapMarkerStyleEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SnapMarkerStyleEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<SnapMarkerStyleEntry<'bldr>> {
    let mut builder = SnapMarkerStyleEntryBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> Option<OBJECT_SNAP_MODE> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<OBJECT_SNAP_MODE>(SnapMarkerStyleEntry::VT_KEY, None)}
  }
  #[inline]
  pub fn value(&self) -> Option<SnapMarkerStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SnapMarkerStyle>>(SnapMarkerStyleEntry::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for SnapMarkerStyleEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<OBJECT_SNAP_MODE>("key", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SnapMarkerStyle>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct SnapMarkerStyleEntryArgs<'a> {
    pub key: Option<OBJECT_SNAP_MODE>,
    pub value: Option<flatbuffers::WIPOffset<SnapMarkerStyle<'a>>>,
}
impl<'a> Default for SnapMarkerStyleEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    SnapMarkerStyleEntryArgs {
      key: None,
      value: None,
    }
  }
}

pub struct SnapMarkerStyleEntryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SnapMarkerStyleEntryBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: OBJECT_SNAP_MODE) {
    self.fbb_.push_slot_always::<OBJECT_SNAP_MODE>(SnapMarkerStyleEntry::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<SnapMarkerStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SnapMarkerStyle>>(SnapMarkerStyleEntry::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SnapMarkerStyleEntryBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SnapMarkerStyleEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SnapMarkerStyleEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SnapMarkerStyleEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SnapMarkerStyleEntry");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum SnapMarkerSettingsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SnapMarkerSettings<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SnapMarkerSettings<'a> {
  type Inner = SnapMarkerSettings<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SnapMarkerSettings<'a> {
  pub const VT_ENABLED: flatbuffers::VOffsetT = 4;
  pub const VT_SIZE: flatbuffers::VOffsetT = 6;
  pub const VT_DURATION: flatbuffers::VOffsetT = 8;
  pub const VT_STYLES: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SnapMarkerSettings { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SnapMarkerSettingsArgs<'args>
  ) -> flatbuffers::WIPOffset<SnapMarkerSettings<'bldr>> {
    let mut builder = SnapMarkerSettingsBuilder::new(_fbb);
    if let Some(x) = args.styles { builder.add_styles(x); }
    builder.add_duration(args.duration);
    builder.add_size(args.size);
    builder.add_enabled(args.enabled);
    builder.finish()
  }


  #[inline]
  pub fn enabled(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SnapMarkerSettings::VT_ENABLED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn size(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SnapMarkerSettings::VT_SIZE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn duration(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SnapMarkerSettings::VT_DURATION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn styles(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SnapMarkerStyleEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SnapMarkerStyleEntry>>>>(SnapMarkerSettings::VT_STYLES, None)}
  }
}

impl flatbuffers::Verifiable for SnapMarkerSettings<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("enabled", Self::VT_ENABLED, false)?
     .visit_field::<i32>("size", Self::VT_SIZE, false)?
     .visit_field::<i32>("duration", Self::VT_DURATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SnapMarkerStyleEntry>>>>("styles", Self::VT_STYLES, false)?
     .finish();
    Ok(())
  }
}
pub struct SnapMarkerSettingsArgs<'a> {
    pub enabled: bool,
    pub size: i32,
    pub duration: i32,
    pub styles: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SnapMarkerStyleEntry<'a>>>>>,
}
impl<'a> Default for SnapMarkerSettingsArgs<'a> {
  #[inline]
  fn default() -> Self {
    SnapMarkerSettingsArgs {
      enabled: false,
      size: 0,
      duration: 0,
      styles: None,
    }
  }
}

pub struct SnapMarkerSettingsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SnapMarkerSettingsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_enabled(&mut self, enabled: bool) {
    self.fbb_.push_slot::<bool>(SnapMarkerSettings::VT_ENABLED, enabled, false);
  }
  #[inline]
  pub fn add_size(&mut self, size: i32) {
    self.fbb_.push_slot::<i32>(SnapMarkerSettings::VT_SIZE, size, 0);
  }
  #[inline]
  pub fn add_duration(&mut self, duration: i32) {
    self.fbb_.push_slot::<i32>(SnapMarkerSettings::VT_DURATION, duration, 0);
  }
  #[inline]
  pub fn add_styles(&mut self, styles: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<SnapMarkerStyleEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SnapMarkerSettings::VT_STYLES, styles);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SnapMarkerSettingsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SnapMarkerSettingsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SnapMarkerSettings<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SnapMarkerSettings<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SnapMarkerSettings");
      ds.field("enabled", &self.enabled());
      ds.field("size", &self.size());
      ds.field("duration", &self.duration());
      ds.field("styles", &self.styles());
      ds.finish()
  }
}
pub enum SnapSettingsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SnapSettings<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SnapSettings<'a> {
  type Inner = SnapSettings<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SnapSettings<'a> {
  pub const VT_READONLY: flatbuffers::VOffsetT = 4;
  pub const VT_TWIST_ANGLE: flatbuffers::VOffsetT = 6;
  pub const VT_SNAP_TOLERANCE: flatbuffers::VOffsetT = 8;
  pub const VT_OBJECT_SNAP_APERTURE: flatbuffers::VOffsetT = 10;
  pub const VT_IS_ORTHO_MODE_ON: flatbuffers::VOffsetT = 12;
  pub const VT_POLAR_TRACKING: flatbuffers::VOffsetT = 14;
  pub const VT_IS_OBJECT_SNAP_ON: flatbuffers::VOffsetT = 16;
  pub const VT_ACTIVE_OBJECT_SNAP_MODES: flatbuffers::VOffsetT = 18;
  pub const VT_SNAP_PRIORITY: flatbuffers::VOffsetT = 20;
  pub const VT_SHOW_TRACKING_LINES: flatbuffers::VOffsetT = 22;
  pub const VT_TRACKING_LINE_STYLE: flatbuffers::VOffsetT = 24;
  pub const VT_DYNAMIC_SNAP: flatbuffers::VOffsetT = 26;
  pub const VT_TEMPORARY_OVERRIDES: flatbuffers::VOffsetT = 28;
  pub const VT_INCREMENTAL_DISTANCE: flatbuffers::VOffsetT = 30;
  pub const VT_MAGNETIC_STRENGTH: flatbuffers::VOffsetT = 32;
  pub const VT_LAYER_SNAP_FILTERS: flatbuffers::VOffsetT = 34;
  pub const VT_ELEMENT_TYPE_FILTERS: flatbuffers::VOffsetT = 36;
  pub const VT_SNAP_MODE: flatbuffers::VOffsetT = 38;
  pub const VT_SNAP_MARKERS: flatbuffers::VOffsetT = 40;
  pub const VT_CONSTRUCTION_SNAP_ENABLED: flatbuffers::VOffsetT = 42;
  pub const VT_SNAP_TO_GRID_INTERSECTIONS: flatbuffers::VOffsetT = 44;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SnapSettings { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SnapSettingsArgs<'args>
  ) -> flatbuffers::WIPOffset<SnapSettings<'bldr>> {
    let mut builder = SnapSettingsBuilder::new(_fbb);
    builder.add_magnetic_strength(args.magnetic_strength);
    builder.add_incremental_distance(args.incremental_distance);
    builder.add_twist_angle(args.twist_angle);
    if let Some(x) = args.snap_markers { builder.add_snap_markers(x); }
    if let Some(x) = args.element_type_filters { builder.add_element_type_filters(x); }
    if let Some(x) = args.layer_snap_filters { builder.add_layer_snap_filters(x); }
    if let Some(x) = args.temporary_overrides { builder.add_temporary_overrides(x); }
    if let Some(x) = args.dynamic_snap { builder.add_dynamic_snap(x); }
    if let Some(x) = args.tracking_line_style { builder.add_tracking_line_style(x); }
    if let Some(x) = args.snap_priority { builder.add_snap_priority(x); }
    if let Some(x) = args.active_object_snap_modes { builder.add_active_object_snap_modes(x); }
    if let Some(x) = args.polar_tracking { builder.add_polar_tracking(x); }
    builder.add_object_snap_aperture(args.object_snap_aperture);
    builder.add_snap_tolerance(args.snap_tolerance);
    builder.add_snap_to_grid_intersections(args.snap_to_grid_intersections);
    builder.add_construction_snap_enabled(args.construction_snap_enabled);
    if let Some(x) = args.snap_mode { builder.add_snap_mode(x); }
    builder.add_show_tracking_lines(args.show_tracking_lines);
    builder.add_is_object_snap_on(args.is_object_snap_on);
    builder.add_is_ortho_mode_on(args.is_ortho_mode_on);
    builder.add_readonly(args.readonly);
    builder.finish()
  }


  #[inline]
  pub fn readonly(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SnapSettings::VT_READONLY, Some(false)).unwrap()}
  }
  #[inline]
  pub fn twist_angle(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SnapSettings::VT_TWIST_ANGLE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn snap_tolerance(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SnapSettings::VT_SNAP_TOLERANCE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn object_snap_aperture(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SnapSettings::VT_OBJECT_SNAP_APERTURE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn is_ortho_mode_on(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SnapSettings::VT_IS_ORTHO_MODE_ON, Some(false)).unwrap()}
  }
  #[inline]
  pub fn polar_tracking(&self) -> Option<PolarTrackingSettings<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<PolarTrackingSettings>>(SnapSettings::VT_POLAR_TRACKING, None)}
  }
  #[inline]
  pub fn is_object_snap_on(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SnapSettings::VT_IS_OBJECT_SNAP_ON, Some(false)).unwrap()}
  }
  #[inline]
  pub fn active_object_snap_modes(&self) -> Option<flatbuffers::Vector<'a, OBJECT_SNAP_MODE>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, OBJECT_SNAP_MODE>>>(SnapSettings::VT_ACTIVE_OBJECT_SNAP_MODES, None)}
  }
  #[inline]
  pub fn snap_priority(&self) -> Option<flatbuffers::Vector<'a, OBJECT_SNAP_MODE>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, OBJECT_SNAP_MODE>>>(SnapSettings::VT_SNAP_PRIORITY, None)}
  }
  #[inline]
  pub fn show_tracking_lines(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SnapSettings::VT_SHOW_TRACKING_LINES, Some(false)).unwrap()}
  }
  #[inline]
  pub fn tracking_line_style(&self) -> Option<TrackingLineStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<TrackingLineStyle>>(SnapSettings::VT_TRACKING_LINE_STYLE, None)}
  }
  #[inline]
  pub fn dynamic_snap(&self) -> Option<DynamicSnapSettings<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DynamicSnapSettings>>(SnapSettings::VT_DYNAMIC_SNAP, None)}
  }
  #[inline]
  pub fn temporary_overrides(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SnapOverride<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SnapOverride>>>>(SnapSettings::VT_TEMPORARY_OVERRIDES, None)}
  }
  #[inline]
  pub fn incremental_distance(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SnapSettings::VT_INCREMENTAL_DISTANCE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn magnetic_strength(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SnapSettings::VT_MAGNETIC_STRENGTH, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn layer_snap_filters(&self) -> Option<LayerSnapFilters<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<LayerSnapFilters>>(SnapSettings::VT_LAYER_SNAP_FILTERS, None)}
  }
  #[inline]
  pub fn element_type_filters(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SnapSettings::VT_ELEMENT_TYPE_FILTERS, None)}
  }
  #[inline]
  pub fn snap_mode(&self) -> Option<SNAP_MODE> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<SNAP_MODE>(SnapSettings::VT_SNAP_MODE, None)}
  }
  #[inline]
  pub fn snap_markers(&self) -> Option<SnapMarkerSettings<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SnapMarkerSettings>>(SnapSettings::VT_SNAP_MARKERS, None)}
  }
  #[inline]
  pub fn construction_snap_enabled(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SnapSettings::VT_CONSTRUCTION_SNAP_ENABLED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn snap_to_grid_intersections(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SnapSettings::VT_SNAP_TO_GRID_INTERSECTIONS, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for SnapSettings<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("readonly", Self::VT_READONLY, false)?
     .visit_field::<f64>("twist_angle", Self::VT_TWIST_ANGLE, false)?
     .visit_field::<i32>("snap_tolerance", Self::VT_SNAP_TOLERANCE, false)?
     .visit_field::<i32>("object_snap_aperture", Self::VT_OBJECT_SNAP_APERTURE, false)?
     .visit_field::<bool>("is_ortho_mode_on", Self::VT_IS_ORTHO_MODE_ON, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<PolarTrackingSettings>>("polar_tracking", Self::VT_POLAR_TRACKING, false)?
     .visit_field::<bool>("is_object_snap_on", Self::VT_IS_OBJECT_SNAP_ON, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, OBJECT_SNAP_MODE>>>("active_object_snap_modes", Self::VT_ACTIVE_OBJECT_SNAP_MODES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, OBJECT_SNAP_MODE>>>("snap_priority", Self::VT_SNAP_PRIORITY, false)?
     .visit_field::<bool>("show_tracking_lines", Self::VT_SHOW_TRACKING_LINES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<TrackingLineStyle>>("tracking_line_style", Self::VT_TRACKING_LINE_STYLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DynamicSnapSettings>>("dynamic_snap", Self::VT_DYNAMIC_SNAP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<SnapOverride>>>>("temporary_overrides", Self::VT_TEMPORARY_OVERRIDES, false)?
     .visit_field::<f64>("incremental_distance", Self::VT_INCREMENTAL_DISTANCE, false)?
     .visit_field::<f64>("magnetic_strength", Self::VT_MAGNETIC_STRENGTH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<LayerSnapFilters>>("layer_snap_filters", Self::VT_LAYER_SNAP_FILTERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("element_type_filters", Self::VT_ELEMENT_TYPE_FILTERS, false)?
     .visit_field::<SNAP_MODE>("snap_mode", Self::VT_SNAP_MODE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SnapMarkerSettings>>("snap_markers", Self::VT_SNAP_MARKERS, false)?
     .visit_field::<bool>("construction_snap_enabled", Self::VT_CONSTRUCTION_SNAP_ENABLED, false)?
     .visit_field::<bool>("snap_to_grid_intersections", Self::VT_SNAP_TO_GRID_INTERSECTIONS, false)?
     .finish();
    Ok(())
  }
}
pub struct SnapSettingsArgs<'a> {
    pub readonly: bool,
    pub twist_angle: f64,
    pub snap_tolerance: i32,
    pub object_snap_aperture: i32,
    pub is_ortho_mode_on: bool,
    pub polar_tracking: Option<flatbuffers::WIPOffset<PolarTrackingSettings<'a>>>,
    pub is_object_snap_on: bool,
    pub active_object_snap_modes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, OBJECT_SNAP_MODE>>>,
    pub snap_priority: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, OBJECT_SNAP_MODE>>>,
    pub show_tracking_lines: bool,
    pub tracking_line_style: Option<flatbuffers::WIPOffset<TrackingLineStyle<'a>>>,
    pub dynamic_snap: Option<flatbuffers::WIPOffset<DynamicSnapSettings<'a>>>,
    pub temporary_overrides: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<SnapOverride<'a>>>>>,
    pub incremental_distance: f64,
    pub magnetic_strength: f64,
    pub layer_snap_filters: Option<flatbuffers::WIPOffset<LayerSnapFilters<'a>>>,
    pub element_type_filters: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub snap_mode: Option<SNAP_MODE>,
    pub snap_markers: Option<flatbuffers::WIPOffset<SnapMarkerSettings<'a>>>,
    pub construction_snap_enabled: bool,
    pub snap_to_grid_intersections: bool,
}
impl<'a> Default for SnapSettingsArgs<'a> {
  #[inline]
  fn default() -> Self {
    SnapSettingsArgs {
      readonly: false,
      twist_angle: 0.0,
      snap_tolerance: 0,
      object_snap_aperture: 0,
      is_ortho_mode_on: false,
      polar_tracking: None,
      is_object_snap_on: false,
      active_object_snap_modes: None,
      snap_priority: None,
      show_tracking_lines: false,
      tracking_line_style: None,
      dynamic_snap: None,
      temporary_overrides: None,
      incremental_distance: 0.0,
      magnetic_strength: 0.0,
      layer_snap_filters: None,
      element_type_filters: None,
      snap_mode: None,
      snap_markers: None,
      construction_snap_enabled: false,
      snap_to_grid_intersections: false,
    }
  }
}

pub struct SnapSettingsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SnapSettingsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_readonly(&mut self, readonly: bool) {
    self.fbb_.push_slot::<bool>(SnapSettings::VT_READONLY, readonly, false);
  }
  #[inline]
  pub fn add_twist_angle(&mut self, twist_angle: f64) {
    self.fbb_.push_slot::<f64>(SnapSettings::VT_TWIST_ANGLE, twist_angle, 0.0);
  }
  #[inline]
  pub fn add_snap_tolerance(&mut self, snap_tolerance: i32) {
    self.fbb_.push_slot::<i32>(SnapSettings::VT_SNAP_TOLERANCE, snap_tolerance, 0);
  }
  #[inline]
  pub fn add_object_snap_aperture(&mut self, object_snap_aperture: i32) {
    self.fbb_.push_slot::<i32>(SnapSettings::VT_OBJECT_SNAP_APERTURE, object_snap_aperture, 0);
  }
  #[inline]
  pub fn add_is_ortho_mode_on(&mut self, is_ortho_mode_on: bool) {
    self.fbb_.push_slot::<bool>(SnapSettings::VT_IS_ORTHO_MODE_ON, is_ortho_mode_on, false);
  }
  #[inline]
  pub fn add_polar_tracking(&mut self, polar_tracking: flatbuffers::WIPOffset<PolarTrackingSettings<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PolarTrackingSettings>>(SnapSettings::VT_POLAR_TRACKING, polar_tracking);
  }
  #[inline]
  pub fn add_is_object_snap_on(&mut self, is_object_snap_on: bool) {
    self.fbb_.push_slot::<bool>(SnapSettings::VT_IS_OBJECT_SNAP_ON, is_object_snap_on, false);
  }
  #[inline]
  pub fn add_active_object_snap_modes(&mut self, active_object_snap_modes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , OBJECT_SNAP_MODE>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SnapSettings::VT_ACTIVE_OBJECT_SNAP_MODES, active_object_snap_modes);
  }
  #[inline]
  pub fn add_snap_priority(&mut self, snap_priority: flatbuffers::WIPOffset<flatbuffers::Vector<'b , OBJECT_SNAP_MODE>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SnapSettings::VT_SNAP_PRIORITY, snap_priority);
  }
  #[inline]
  pub fn add_show_tracking_lines(&mut self, show_tracking_lines: bool) {
    self.fbb_.push_slot::<bool>(SnapSettings::VT_SHOW_TRACKING_LINES, show_tracking_lines, false);
  }
  #[inline]
  pub fn add_tracking_line_style(&mut self, tracking_line_style: flatbuffers::WIPOffset<TrackingLineStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<TrackingLineStyle>>(SnapSettings::VT_TRACKING_LINE_STYLE, tracking_line_style);
  }
  #[inline]
  pub fn add_dynamic_snap(&mut self, dynamic_snap: flatbuffers::WIPOffset<DynamicSnapSettings<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DynamicSnapSettings>>(SnapSettings::VT_DYNAMIC_SNAP, dynamic_snap);
  }
  #[inline]
  pub fn add_temporary_overrides(&mut self, temporary_overrides: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<SnapOverride<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SnapSettings::VT_TEMPORARY_OVERRIDES, temporary_overrides);
  }
  #[inline]
  pub fn add_incremental_distance(&mut self, incremental_distance: f64) {
    self.fbb_.push_slot::<f64>(SnapSettings::VT_INCREMENTAL_DISTANCE, incremental_distance, 0.0);
  }
  #[inline]
  pub fn add_magnetic_strength(&mut self, magnetic_strength: f64) {
    self.fbb_.push_slot::<f64>(SnapSettings::VT_MAGNETIC_STRENGTH, magnetic_strength, 0.0);
  }
  #[inline]
  pub fn add_layer_snap_filters(&mut self, layer_snap_filters: flatbuffers::WIPOffset<LayerSnapFilters<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<LayerSnapFilters>>(SnapSettings::VT_LAYER_SNAP_FILTERS, layer_snap_filters);
  }
  #[inline]
  pub fn add_element_type_filters(&mut self, element_type_filters: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SnapSettings::VT_ELEMENT_TYPE_FILTERS, element_type_filters);
  }
  #[inline]
  pub fn add_snap_mode(&mut self, snap_mode: SNAP_MODE) {
    self.fbb_.push_slot_always::<SNAP_MODE>(SnapSettings::VT_SNAP_MODE, snap_mode);
  }
  #[inline]
  pub fn add_snap_markers(&mut self, snap_markers: flatbuffers::WIPOffset<SnapMarkerSettings<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SnapMarkerSettings>>(SnapSettings::VT_SNAP_MARKERS, snap_markers);
  }
  #[inline]
  pub fn add_construction_snap_enabled(&mut self, construction_snap_enabled: bool) {
    self.fbb_.push_slot::<bool>(SnapSettings::VT_CONSTRUCTION_SNAP_ENABLED, construction_snap_enabled, false);
  }
  #[inline]
  pub fn add_snap_to_grid_intersections(&mut self, snap_to_grid_intersections: bool) {
    self.fbb_.push_slot::<bool>(SnapSettings::VT_SNAP_TO_GRID_INTERSECTIONS, snap_to_grid_intersections, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SnapSettingsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SnapSettingsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SnapSettings<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SnapSettings<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SnapSettings");
      ds.field("readonly", &self.readonly());
      ds.field("twist_angle", &self.twist_angle());
      ds.field("snap_tolerance", &self.snap_tolerance());
      ds.field("object_snap_aperture", &self.object_snap_aperture());
      ds.field("is_ortho_mode_on", &self.is_ortho_mode_on());
      ds.field("polar_tracking", &self.polar_tracking());
      ds.field("is_object_snap_on", &self.is_object_snap_on());
      ds.field("active_object_snap_modes", &self.active_object_snap_modes());
      ds.field("snap_priority", &self.snap_priority());
      ds.field("show_tracking_lines", &self.show_tracking_lines());
      ds.field("tracking_line_style", &self.tracking_line_style());
      ds.field("dynamic_snap", &self.dynamic_snap());
      ds.field("temporary_overrides", &self.temporary_overrides());
      ds.field("incremental_distance", &self.incremental_distance());
      ds.field("magnetic_strength", &self.magnetic_strength());
      ds.field("layer_snap_filters", &self.layer_snap_filters());
      ds.field("element_type_filters", &self.element_type_filters());
      ds.field("snap_mode", &self.snap_mode());
      ds.field("snap_markers", &self.snap_markers());
      ds.field("construction_snap_enabled", &self.construction_snap_enabled());
      ds.field("snap_to_grid_intersections", &self.snap_to_grid_intersections());
      ds.finish()
  }
}
pub enum IdentifiedGridSettingsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct IdentifiedGridSettings<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IdentifiedGridSettings<'a> {
  type Inner = IdentifiedGridSettings<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> IdentifiedGridSettings<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_SETTINGS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    IdentifiedGridSettings { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args IdentifiedGridSettingsArgs<'args>
  ) -> flatbuffers::WIPOffset<IdentifiedGridSettings<'bldr>> {
    let mut builder = IdentifiedGridSettingsBuilder::new(_fbb);
    if let Some(x) = args.settings { builder.add_settings(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<Identifier<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Identifier>>(IdentifiedGridSettings::VT_ID, None)}
  }
  #[inline]
  pub fn settings(&self) -> Option<GridSettings<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<GridSettings>>(IdentifiedGridSettings::VT_SETTINGS, None)}
  }
}

impl flatbuffers::Verifiable for IdentifiedGridSettings<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Identifier>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<GridSettings>>("settings", Self::VT_SETTINGS, false)?
     .finish();
    Ok(())
  }
}
pub struct IdentifiedGridSettingsArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
    pub settings: Option<flatbuffers::WIPOffset<GridSettings<'a>>>,
}
impl<'a> Default for IdentifiedGridSettingsArgs<'a> {
  #[inline]
  fn default() -> Self {
    IdentifiedGridSettingsArgs {
      id: None,
      settings: None,
    }
  }
}

pub struct IdentifiedGridSettingsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> IdentifiedGridSettingsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<Identifier<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Identifier>>(IdentifiedGridSettings::VT_ID, id);
  }
  #[inline]
  pub fn add_settings(&mut self, settings: flatbuffers::WIPOffset<GridSettings<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<GridSettings>>(IdentifiedGridSettings::VT_SETTINGS, settings);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> IdentifiedGridSettingsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    IdentifiedGridSettingsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IdentifiedGridSettings<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for IdentifiedGridSettings<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("IdentifiedGridSettings");
      ds.field("id", &self.id());
      ds.field("settings", &self.settings());
      ds.finish()
  }
}
pub enum IdentifiedSnapSettingsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct IdentifiedSnapSettings<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IdentifiedSnapSettings<'a> {
  type Inner = IdentifiedSnapSettings<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> IdentifiedSnapSettings<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_SETTINGS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    IdentifiedSnapSettings { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args IdentifiedSnapSettingsArgs<'args>
  ) -> flatbuffers::WIPOffset<IdentifiedSnapSettings<'bldr>> {
    let mut builder = IdentifiedSnapSettingsBuilder::new(_fbb);
    if let Some(x) = args.settings { builder.add_settings(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<Identifier<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Identifier>>(IdentifiedSnapSettings::VT_ID, None)}
  }
  #[inline]
  pub fn settings(&self) -> Option<SnapSettings<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SnapSettings>>(IdentifiedSnapSettings::VT_SETTINGS, None)}
  }
}

impl flatbuffers::Verifiable for IdentifiedSnapSettings<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Identifier>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SnapSettings>>("settings", Self::VT_SETTINGS, false)?
     .finish();
    Ok(())
  }
}
pub struct IdentifiedSnapSettingsArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
    pub settings: Option<flatbuffers::WIPOffset<SnapSettings<'a>>>,
}
impl<'a> Default for IdentifiedSnapSettingsArgs<'a> {
  #[inline]
  fn default() -> Self {
    IdentifiedSnapSettingsArgs {
      id: None,
      settings: None,
    }
  }
}

pub struct IdentifiedSnapSettingsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> IdentifiedSnapSettingsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<Identifier<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Identifier>>(IdentifiedSnapSettings::VT_ID, id);
  }
  #[inline]
  pub fn add_settings(&mut self, settings: flatbuffers::WIPOffset<SnapSettings<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SnapSettings>>(IdentifiedSnapSettings::VT_SETTINGS, settings);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> IdentifiedSnapSettingsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    IdentifiedSnapSettingsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IdentifiedSnapSettings<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for IdentifiedSnapSettings<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("IdentifiedSnapSettings");
      ds.field("id", &self.id());
      ds.field("settings", &self.settings());
      ds.finish()
  }
}
pub enum IdentifiedUcsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct IdentifiedUcs<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IdentifiedUcs<'a> {
  type Inner = IdentifiedUcs<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> IdentifiedUcs<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_UCS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    IdentifiedUcs { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args IdentifiedUcsArgs<'args>
  ) -> flatbuffers::WIPOffset<IdentifiedUcs<'bldr>> {
    let mut builder = IdentifiedUcsBuilder::new(_fbb);
    if let Some(x) = args.ucs { builder.add_ucs(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<Identifier<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Identifier>>(IdentifiedUcs::VT_ID, None)}
  }
  #[inline]
  pub fn ucs(&self) -> Option<DucUcs<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucUcs>>(IdentifiedUcs::VT_UCS, None)}
  }
}

impl flatbuffers::Verifiable for IdentifiedUcs<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Identifier>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucUcs>>("ucs", Self::VT_UCS, false)?
     .finish();
    Ok(())
  }
}
pub struct IdentifiedUcsArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
    pub ucs: Option<flatbuffers::WIPOffset<DucUcs<'a>>>,
}
impl<'a> Default for IdentifiedUcsArgs<'a> {
  #[inline]
  fn default() -> Self {
    IdentifiedUcsArgs {
      id: None,
      ucs: None,
    }
  }
}

pub struct IdentifiedUcsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> IdentifiedUcsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<Identifier<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Identifier>>(IdentifiedUcs::VT_ID, id);
  }
  #[inline]
  pub fn add_ucs(&mut self, ucs: flatbuffers::WIPOffset<DucUcs<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucUcs>>(IdentifiedUcs::VT_UCS, ucs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> IdentifiedUcsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    IdentifiedUcsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IdentifiedUcs<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for IdentifiedUcs<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("IdentifiedUcs");
      ds.field("id", &self.id());
      ds.field("ucs", &self.ucs());
      ds.finish()
  }
}
pub enum IdentifiedViewOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct IdentifiedView<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for IdentifiedView<'a> {
  type Inner = IdentifiedView<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> IdentifiedView<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_VIEW: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    IdentifiedView { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args IdentifiedViewArgs<'args>
  ) -> flatbuffers::WIPOffset<IdentifiedView<'bldr>> {
    let mut builder = IdentifiedViewBuilder::new(_fbb);
    if let Some(x) = args.view { builder.add_view(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<Identifier<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Identifier>>(IdentifiedView::VT_ID, None)}
  }
  #[inline]
  pub fn view(&self) -> Option<DucView<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucView>>(IdentifiedView::VT_VIEW, None)}
  }
}

impl flatbuffers::Verifiable for IdentifiedView<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Identifier>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucView>>("view", Self::VT_VIEW, false)?
     .finish();
    Ok(())
  }
}
pub struct IdentifiedViewArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
    pub view: Option<flatbuffers::WIPOffset<DucView<'a>>>,
}
impl<'a> Default for IdentifiedViewArgs<'a> {
  #[inline]
  fn default() -> Self {
    IdentifiedViewArgs {
      id: None,
      view: None,
    }
  }
}

pub struct IdentifiedViewBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> IdentifiedViewBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<Identifier<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Identifier>>(IdentifiedView::VT_ID, id);
  }
  #[inline]
  pub fn add_view(&mut self, view: flatbuffers::WIPOffset<DucView<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucView>>(IdentifiedView::VT_VIEW, view);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> IdentifiedViewBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    IdentifiedViewBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<IdentifiedView<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for IdentifiedView<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("IdentifiedView");
      ds.field("id", &self.id());
      ds.field("view", &self.view());
      ds.finish()
  }
}
pub enum StandardViewSettingsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct StandardViewSettings<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StandardViewSettings<'a> {
  type Inner = StandardViewSettings<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> StandardViewSettings<'a> {
  pub const VT_VIEWS: flatbuffers::VOffsetT = 4;
  pub const VT_UCS: flatbuffers::VOffsetT = 6;
  pub const VT_GRID_SETTINGS: flatbuffers::VOffsetT = 8;
  pub const VT_SNAP_SETTINGS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StandardViewSettings { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StandardViewSettingsArgs<'args>
  ) -> flatbuffers::WIPOffset<StandardViewSettings<'bldr>> {
    let mut builder = StandardViewSettingsBuilder::new(_fbb);
    if let Some(x) = args.snap_settings { builder.add_snap_settings(x); }
    if let Some(x) = args.grid_settings { builder.add_grid_settings(x); }
    if let Some(x) = args.ucs { builder.add_ucs(x); }
    if let Some(x) = args.views { builder.add_views(x); }
    builder.finish()
  }


  #[inline]
  pub fn views(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedView<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedView>>>>(StandardViewSettings::VT_VIEWS, None)}
  }
  #[inline]
  pub fn ucs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedUcs<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedUcs>>>>(StandardViewSettings::VT_UCS, None)}
  }
  #[inline]
  pub fn grid_settings(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedGridSettings<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedGridSettings>>>>(StandardViewSettings::VT_GRID_SETTINGS, None)}
  }
  #[inline]
  pub fn snap_settings(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedSnapSettings<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedSnapSettings>>>>(StandardViewSettings::VT_SNAP_SETTINGS, None)}
  }
}

impl flatbuffers::Verifiable for StandardViewSettings<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<IdentifiedView>>>>("views", Self::VT_VIEWS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<IdentifiedUcs>>>>("ucs", Self::VT_UCS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<IdentifiedGridSettings>>>>("grid_settings", Self::VT_GRID_SETTINGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<IdentifiedSnapSettings>>>>("snap_settings", Self::VT_SNAP_SETTINGS, false)?
     .finish();
    Ok(())
  }
}
pub struct StandardViewSettingsArgs<'a> {
    pub views: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedView<'a>>>>>,
    pub ucs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedUcs<'a>>>>>,
    pub grid_settings: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedGridSettings<'a>>>>>,
    pub snap_settings: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<IdentifiedSnapSettings<'a>>>>>,
}
impl<'a> Default for StandardViewSettingsArgs<'a> {
  #[inline]
  fn default() -> Self {
    StandardViewSettingsArgs {
      views: None,
      ucs: None,
      grid_settings: None,
      snap_settings: None,
    }
  }
}

pub struct StandardViewSettingsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StandardViewSettingsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_views(&mut self, views: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<IdentifiedView<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StandardViewSettings::VT_VIEWS, views);
  }
  #[inline]
  pub fn add_ucs(&mut self, ucs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<IdentifiedUcs<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StandardViewSettings::VT_UCS, ucs);
  }
  #[inline]
  pub fn add_grid_settings(&mut self, grid_settings: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<IdentifiedGridSettings<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StandardViewSettings::VT_GRID_SETTINGS, grid_settings);
  }
  #[inline]
  pub fn add_snap_settings(&mut self, snap_settings: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<IdentifiedSnapSettings<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StandardViewSettings::VT_SNAP_SETTINGS, snap_settings);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StandardViewSettingsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StandardViewSettingsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StandardViewSettings<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StandardViewSettings<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StandardViewSettings");
      ds.field("views", &self.views());
      ds.field("ucs", &self.ucs());
      ds.field("grid_settings", &self.grid_settings());
      ds.field("snap_settings", &self.snap_settings());
      ds.finish()
  }
}
pub enum DimensionValidationRulesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DimensionValidationRules<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DimensionValidationRules<'a> {
  type Inner = DimensionValidationRules<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DimensionValidationRules<'a> {
  pub const VT_MIN_TEXT_HEIGHT: flatbuffers::VOffsetT = 4;
  pub const VT_MAX_TEXT_HEIGHT: flatbuffers::VOffsetT = 6;
  pub const VT_ALLOWED_PRECISIONS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DimensionValidationRules { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DimensionValidationRulesArgs<'args>
  ) -> flatbuffers::WIPOffset<DimensionValidationRules<'bldr>> {
    let mut builder = DimensionValidationRulesBuilder::new(_fbb);
    builder.add_max_text_height(args.max_text_height);
    builder.add_min_text_height(args.min_text_height);
    if let Some(x) = args.allowed_precisions { builder.add_allowed_precisions(x); }
    builder.finish()
  }


  #[inline]
  pub fn min_text_height(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DimensionValidationRules::VT_MIN_TEXT_HEIGHT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn max_text_height(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DimensionValidationRules::VT_MAX_TEXT_HEIGHT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn allowed_precisions(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(DimensionValidationRules::VT_ALLOWED_PRECISIONS, None)}
  }
}

impl flatbuffers::Verifiable for DimensionValidationRules<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("min_text_height", Self::VT_MIN_TEXT_HEIGHT, false)?
     .visit_field::<f64>("max_text_height", Self::VT_MAX_TEXT_HEIGHT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("allowed_precisions", Self::VT_ALLOWED_PRECISIONS, false)?
     .finish();
    Ok(())
  }
}
pub struct DimensionValidationRulesArgs<'a> {
    pub min_text_height: f64,
    pub max_text_height: f64,
    pub allowed_precisions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for DimensionValidationRulesArgs<'a> {
  #[inline]
  fn default() -> Self {
    DimensionValidationRulesArgs {
      min_text_height: 0.0,
      max_text_height: 0.0,
      allowed_precisions: None,
    }
  }
}

pub struct DimensionValidationRulesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DimensionValidationRulesBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_min_text_height(&mut self, min_text_height: f64) {
    self.fbb_.push_slot::<f64>(DimensionValidationRules::VT_MIN_TEXT_HEIGHT, min_text_height, 0.0);
  }
  #[inline]
  pub fn add_max_text_height(&mut self, max_text_height: f64) {
    self.fbb_.push_slot::<f64>(DimensionValidationRules::VT_MAX_TEXT_HEIGHT, max_text_height, 0.0);
  }
  #[inline]
  pub fn add_allowed_precisions(&mut self, allowed_precisions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DimensionValidationRules::VT_ALLOWED_PRECISIONS, allowed_precisions);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DimensionValidationRulesBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DimensionValidationRulesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DimensionValidationRules<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DimensionValidationRules<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DimensionValidationRules");
      ds.field("min_text_height", &self.min_text_height());
      ds.field("max_text_height", &self.max_text_height());
      ds.field("allowed_precisions", &self.allowed_precisions());
      ds.finish()
  }
}
pub enum LayerValidationRulesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LayerValidationRules<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LayerValidationRules<'a> {
  type Inner = LayerValidationRules<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LayerValidationRules<'a> {
  pub const VT_PROHIBITED_LAYER_NAMES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LayerValidationRules { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LayerValidationRulesArgs<'args>
  ) -> flatbuffers::WIPOffset<LayerValidationRules<'bldr>> {
    let mut builder = LayerValidationRulesBuilder::new(_fbb);
    if let Some(x) = args.prohibited_layer_names { builder.add_prohibited_layer_names(x); }
    builder.finish()
  }


  #[inline]
  pub fn prohibited_layer_names(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(LayerValidationRules::VT_PROHIBITED_LAYER_NAMES, None)}
  }
}

impl flatbuffers::Verifiable for LayerValidationRules<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("prohibited_layer_names", Self::VT_PROHIBITED_LAYER_NAMES, false)?
     .finish();
    Ok(())
  }
}
pub struct LayerValidationRulesArgs<'a> {
    pub prohibited_layer_names: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for LayerValidationRulesArgs<'a> {
  #[inline]
  fn default() -> Self {
    LayerValidationRulesArgs {
      prohibited_layer_names: None,
    }
  }
}

pub struct LayerValidationRulesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LayerValidationRulesBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_prohibited_layer_names(&mut self, prohibited_layer_names: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LayerValidationRules::VT_PROHIBITED_LAYER_NAMES, prohibited_layer_names);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LayerValidationRulesBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LayerValidationRulesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LayerValidationRules<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LayerValidationRules<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LayerValidationRules");
      ds.field("prohibited_layer_names", &self.prohibited_layer_names());
      ds.finish()
  }
}
pub enum StandardValidationOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct StandardValidation<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StandardValidation<'a> {
  type Inner = StandardValidation<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> StandardValidation<'a> {
  pub const VT_DIMENSION_RULES: flatbuffers::VOffsetT = 4;
  pub const VT_LAYER_RULES: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StandardValidation { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StandardValidationArgs<'args>
  ) -> flatbuffers::WIPOffset<StandardValidation<'bldr>> {
    let mut builder = StandardValidationBuilder::new(_fbb);
    if let Some(x) = args.layer_rules { builder.add_layer_rules(x); }
    if let Some(x) = args.dimension_rules { builder.add_dimension_rules(x); }
    builder.finish()
  }


  #[inline]
  pub fn dimension_rules(&self) -> Option<DimensionValidationRules<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DimensionValidationRules>>(StandardValidation::VT_DIMENSION_RULES, None)}
  }
  #[inline]
  pub fn layer_rules(&self) -> Option<LayerValidationRules<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<LayerValidationRules>>(StandardValidation::VT_LAYER_RULES, None)}
  }
}

impl flatbuffers::Verifiable for StandardValidation<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<DimensionValidationRules>>("dimension_rules", Self::VT_DIMENSION_RULES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<LayerValidationRules>>("layer_rules", Self::VT_LAYER_RULES, false)?
     .finish();
    Ok(())
  }
}
pub struct StandardValidationArgs<'a> {
    pub dimension_rules: Option<flatbuffers::WIPOffset<DimensionValidationRules<'a>>>,
    pub layer_rules: Option<flatbuffers::WIPOffset<LayerValidationRules<'a>>>,
}
impl<'a> Default for StandardValidationArgs<'a> {
  #[inline]
  fn default() -> Self {
    StandardValidationArgs {
      dimension_rules: None,
      layer_rules: None,
    }
  }
}

pub struct StandardValidationBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StandardValidationBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_dimension_rules(&mut self, dimension_rules: flatbuffers::WIPOffset<DimensionValidationRules<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DimensionValidationRules>>(StandardValidation::VT_DIMENSION_RULES, dimension_rules);
  }
  #[inline]
  pub fn add_layer_rules(&mut self, layer_rules: flatbuffers::WIPOffset<LayerValidationRules<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<LayerValidationRules>>(StandardValidation::VT_LAYER_RULES, layer_rules);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StandardValidationBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StandardValidationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StandardValidation<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StandardValidation<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StandardValidation");
      ds.field("dimension_rules", &self.dimension_rules());
      ds.field("layer_rules", &self.layer_rules());
      ds.finish()
  }
}
pub enum StandardOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Standard<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Standard<'a> {
  type Inner = Standard<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Standard<'a> {
  pub const VT_IDENTIFIER: flatbuffers::VOffsetT = 4;
  pub const VT_VERSION: flatbuffers::VOffsetT = 6;
  pub const VT_READONLY: flatbuffers::VOffsetT = 8;
  pub const VT_OVERRIDES: flatbuffers::VOffsetT = 10;
  pub const VT_STYLES: flatbuffers::VOffsetT = 12;
  pub const VT_VIEW_SETTINGS: flatbuffers::VOffsetT = 14;
  pub const VT_UNITS: flatbuffers::VOffsetT = 16;
  pub const VT_VALIDATION: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Standard { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StandardArgs<'args>
  ) -> flatbuffers::WIPOffset<Standard<'bldr>> {
    let mut builder = StandardBuilder::new(_fbb);
    if let Some(x) = args.validation { builder.add_validation(x); }
    if let Some(x) = args.units { builder.add_units(x); }
    if let Some(x) = args.view_settings { builder.add_view_settings(x); }
    if let Some(x) = args.styles { builder.add_styles(x); }
    if let Some(x) = args.overrides { builder.add_overrides(x); }
    if let Some(x) = args.version { builder.add_version(x); }
    if let Some(x) = args.identifier { builder.add_identifier(x); }
    builder.add_readonly(args.readonly);
    builder.finish()
  }


  #[inline]
  pub fn identifier(&self) -> Option<Identifier<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Identifier>>(Standard::VT_IDENTIFIER, None)}
  }
  #[inline]
  pub fn version(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Standard::VT_VERSION, None)}
  }
  #[inline]
  pub fn readonly(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Standard::VT_READONLY, Some(false)).unwrap()}
  }
  #[inline]
  pub fn overrides(&self) -> Option<StandardOverrides<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<StandardOverrides>>(Standard::VT_OVERRIDES, None)}
  }
  #[inline]
  pub fn styles(&self) -> Option<StandardStyles<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<StandardStyles>>(Standard::VT_STYLES, None)}
  }
  #[inline]
  pub fn view_settings(&self) -> Option<StandardViewSettings<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<StandardViewSettings>>(Standard::VT_VIEW_SETTINGS, None)}
  }
  #[inline]
  pub fn units(&self) -> Option<StandardUnits<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<StandardUnits>>(Standard::VT_UNITS, None)}
  }
  #[inline]
  pub fn validation(&self) -> Option<StandardValidation<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<StandardValidation>>(Standard::VT_VALIDATION, None)}
  }
}

impl flatbuffers::Verifiable for Standard<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Identifier>>("identifier", Self::VT_IDENTIFIER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("version", Self::VT_VERSION, false)?
     .visit_field::<bool>("readonly", Self::VT_READONLY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<StandardOverrides>>("overrides", Self::VT_OVERRIDES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<StandardStyles>>("styles", Self::VT_STYLES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<StandardViewSettings>>("view_settings", Self::VT_VIEW_SETTINGS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<StandardUnits>>("units", Self::VT_UNITS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<StandardValidation>>("validation", Self::VT_VALIDATION, false)?
     .finish();
    Ok(())
  }
}
pub struct StandardArgs<'a> {
    pub identifier: Option<flatbuffers::WIPOffset<Identifier<'a>>>,
    pub version: Option<flatbuffers::WIPOffset<&'a str>>,
    pub readonly: bool,
    pub overrides: Option<flatbuffers::WIPOffset<StandardOverrides<'a>>>,
    pub styles: Option<flatbuffers::WIPOffset<StandardStyles<'a>>>,
    pub view_settings: Option<flatbuffers::WIPOffset<StandardViewSettings<'a>>>,
    pub units: Option<flatbuffers::WIPOffset<StandardUnits<'a>>>,
    pub validation: Option<flatbuffers::WIPOffset<StandardValidation<'a>>>,
}
impl<'a> Default for StandardArgs<'a> {
  #[inline]
  fn default() -> Self {
    StandardArgs {
      identifier: None,
      version: None,
      readonly: false,
      overrides: None,
      styles: None,
      view_settings: None,
      units: None,
      validation: None,
    }
  }
}

pub struct StandardBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StandardBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_identifier(&mut self, identifier: flatbuffers::WIPOffset<Identifier<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Identifier>>(Standard::VT_IDENTIFIER, identifier);
  }
  #[inline]
  pub fn add_version(&mut self, version: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Standard::VT_VERSION, version);
  }
  #[inline]
  pub fn add_readonly(&mut self, readonly: bool) {
    self.fbb_.push_slot::<bool>(Standard::VT_READONLY, readonly, false);
  }
  #[inline]
  pub fn add_overrides(&mut self, overrides: flatbuffers::WIPOffset<StandardOverrides<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<StandardOverrides>>(Standard::VT_OVERRIDES, overrides);
  }
  #[inline]
  pub fn add_styles(&mut self, styles: flatbuffers::WIPOffset<StandardStyles<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<StandardStyles>>(Standard::VT_STYLES, styles);
  }
  #[inline]
  pub fn add_view_settings(&mut self, view_settings: flatbuffers::WIPOffset<StandardViewSettings<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<StandardViewSettings>>(Standard::VT_VIEW_SETTINGS, view_settings);
  }
  #[inline]
  pub fn add_units(&mut self, units: flatbuffers::WIPOffset<StandardUnits<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<StandardUnits>>(Standard::VT_UNITS, units);
  }
  #[inline]
  pub fn add_validation(&mut self, validation: flatbuffers::WIPOffset<StandardValidation<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<StandardValidation>>(Standard::VT_VALIDATION, validation);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StandardBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StandardBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Standard<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Standard<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Standard");
      ds.field("identifier", &self.identifier());
      ds.field("version", &self.version());
      ds.field("readonly", &self.readonly());
      ds.field("overrides", &self.overrides());
      ds.field("styles", &self.styles());
      ds.field("view_settings", &self.view_settings());
      ds.field("units", &self.units());
      ds.field("validation", &self.validation());
      ds.finish()
  }
}
pub enum VersionBaseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct VersionBase<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for VersionBase<'a> {
  type Inner = VersionBase<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> VersionBase<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_PARENT_ID: flatbuffers::VOffsetT = 6;
  pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 8;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 10;
  pub const VT_IS_MANUAL_SAVE: flatbuffers::VOffsetT = 12;
  pub const VT_USER_ID: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    VersionBase { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args VersionBaseArgs<'args>
  ) -> flatbuffers::WIPOffset<VersionBase<'bldr>> {
    let mut builder = VersionBaseBuilder::new(_fbb);
    builder.add_timestamp(args.timestamp);
    if let Some(x) = args.user_id { builder.add_user_id(x); }
    if let Some(x) = args.description { builder.add_description(x); }
    if let Some(x) = args.parent_id { builder.add_parent_id(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_is_manual_save(args.is_manual_save);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(VersionBase::VT_ID, None)}
  }
  #[inline]
  pub fn parent_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(VersionBase::VT_PARENT_ID, None)}
  }
  #[inline]
  pub fn timestamp(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(VersionBase::VT_TIMESTAMP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn description(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(VersionBase::VT_DESCRIPTION, None)}
  }
  #[inline]
  pub fn is_manual_save(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(VersionBase::VT_IS_MANUAL_SAVE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn user_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(VersionBase::VT_USER_ID, None)}
  }
}

impl flatbuffers::Verifiable for VersionBase<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("parent_id", Self::VT_PARENT_ID, false)?
     .visit_field::<i64>("timestamp", Self::VT_TIMESTAMP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("description", Self::VT_DESCRIPTION, false)?
     .visit_field::<bool>("is_manual_save", Self::VT_IS_MANUAL_SAVE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("user_id", Self::VT_USER_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct VersionBaseArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub parent_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub timestamp: i64,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub is_manual_save: bool,
    pub user_id: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for VersionBaseArgs<'a> {
  #[inline]
  fn default() -> Self {
    VersionBaseArgs {
      id: None,
      parent_id: None,
      timestamp: 0,
      description: None,
      is_manual_save: false,
      user_id: None,
    }
  }
}

pub struct VersionBaseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> VersionBaseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(VersionBase::VT_ID, id);
  }
  #[inline]
  pub fn add_parent_id(&mut self, parent_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(VersionBase::VT_PARENT_ID, parent_id);
  }
  #[inline]
  pub fn add_timestamp(&mut self, timestamp: i64) {
    self.fbb_.push_slot::<i64>(VersionBase::VT_TIMESTAMP, timestamp, 0);
  }
  #[inline]
  pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(VersionBase::VT_DESCRIPTION, description);
  }
  #[inline]
  pub fn add_is_manual_save(&mut self, is_manual_save: bool) {
    self.fbb_.push_slot::<bool>(VersionBase::VT_IS_MANUAL_SAVE, is_manual_save, false);
  }
  #[inline]
  pub fn add_user_id(&mut self, user_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(VersionBase::VT_USER_ID, user_id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> VersionBaseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    VersionBaseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<VersionBase<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for VersionBase<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("VersionBase");
      ds.field("id", &self.id());
      ds.field("parent_id", &self.parent_id());
      ds.field("timestamp", &self.timestamp());
      ds.field("description", &self.description());
      ds.field("is_manual_save", &self.is_manual_save());
      ds.field("user_id", &self.user_id());
      ds.finish()
  }
}
pub enum CheckpointOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Checkpoint<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Checkpoint<'a> {
  type Inner = Checkpoint<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Checkpoint<'a> {
  pub const VT_BASE: flatbuffers::VOffsetT = 4;
  pub const VT_DATA: flatbuffers::VOffsetT = 6;
  pub const VT_SIZE_BYTES: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Checkpoint { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CheckpointArgs<'args>
  ) -> flatbuffers::WIPOffset<Checkpoint<'bldr>> {
    let mut builder = CheckpointBuilder::new(_fbb);
    builder.add_size_bytes(args.size_bytes);
    if let Some(x) = args.data { builder.add_data(x); }
    if let Some(x) = args.base { builder.add_base(x); }
    builder.finish()
  }


  #[inline]
  pub fn base(&self) -> Option<VersionBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<VersionBase>>(Checkpoint::VT_BASE, None)}
  }
  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Checkpoint::VT_DATA, None)}
  }
  #[inline]
  pub fn size_bytes(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(Checkpoint::VT_SIZE_BYTES, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Checkpoint<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<VersionBase>>("base", Self::VT_BASE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("data", Self::VT_DATA, false)?
     .visit_field::<i64>("size_bytes", Self::VT_SIZE_BYTES, false)?
     .finish();
    Ok(())
  }
}
pub struct CheckpointArgs<'a> {
    pub base: Option<flatbuffers::WIPOffset<VersionBase<'a>>>,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub size_bytes: i64,
}
impl<'a> Default for CheckpointArgs<'a> {
  #[inline]
  fn default() -> Self {
    CheckpointArgs {
      base: None,
      data: None,
      size_bytes: 0,
    }
  }
}

pub struct CheckpointBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CheckpointBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_base(&mut self, base: flatbuffers::WIPOffset<VersionBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<VersionBase>>(Checkpoint::VT_BASE, base);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Checkpoint::VT_DATA, data);
  }
  #[inline]
  pub fn add_size_bytes(&mut self, size_bytes: i64) {
    self.fbb_.push_slot::<i64>(Checkpoint::VT_SIZE_BYTES, size_bytes, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CheckpointBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CheckpointBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Checkpoint<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Checkpoint<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Checkpoint");
      ds.field("base", &self.base());
      ds.field("data", &self.data());
      ds.field("size_bytes", &self.size_bytes());
      ds.finish()
  }
}
pub enum JSONPatchOperationOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct JSONPatchOperation<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for JSONPatchOperation<'a> {
  type Inner = JSONPatchOperation<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> JSONPatchOperation<'a> {
  pub const VT_OP: flatbuffers::VOffsetT = 4;
  pub const VT_PATH: flatbuffers::VOffsetT = 6;
  pub const VT_FROM: flatbuffers::VOffsetT = 8;
  pub const VT_VALUE: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    JSONPatchOperation { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args JSONPatchOperationArgs<'args>
  ) -> flatbuffers::WIPOffset<JSONPatchOperation<'bldr>> {
    let mut builder = JSONPatchOperationBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.from { builder.add_from(x); }
    if let Some(x) = args.path { builder.add_path(x); }
    if let Some(x) = args.op { builder.add_op(x); }
    builder.finish()
  }


  #[inline]
  pub fn op(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(JSONPatchOperation::VT_OP, None)}
  }
  #[inline]
  pub fn path(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(JSONPatchOperation::VT_PATH, None)}
  }
  #[inline]
  pub fn from(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(JSONPatchOperation::VT_FROM, None)}
  }
  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(JSONPatchOperation::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for JSONPatchOperation<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("op", Self::VT_OP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("path", Self::VT_PATH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("from", Self::VT_FROM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct JSONPatchOperationArgs<'a> {
    pub op: Option<flatbuffers::WIPOffset<&'a str>>,
    pub path: Option<flatbuffers::WIPOffset<&'a str>>,
    pub from: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for JSONPatchOperationArgs<'a> {
  #[inline]
  fn default() -> Self {
    JSONPatchOperationArgs {
      op: None,
      path: None,
      from: None,
      value: None,
    }
  }
}

pub struct JSONPatchOperationBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> JSONPatchOperationBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_op(&mut self, op: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(JSONPatchOperation::VT_OP, op);
  }
  #[inline]
  pub fn add_path(&mut self, path: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(JSONPatchOperation::VT_PATH, path);
  }
  #[inline]
  pub fn add_from(&mut self, from: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(JSONPatchOperation::VT_FROM, from);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(JSONPatchOperation::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> JSONPatchOperationBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    JSONPatchOperationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<JSONPatchOperation<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for JSONPatchOperation<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("JSONPatchOperation");
      ds.field("op", &self.op());
      ds.field("path", &self.path());
      ds.field("from", &self.from());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum DeltaOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Delta<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Delta<'a> {
  type Inner = Delta<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Delta<'a> {
  pub const VT_BASE: flatbuffers::VOffsetT = 4;
  pub const VT_PATCH: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Delta { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DeltaArgs<'args>
  ) -> flatbuffers::WIPOffset<Delta<'bldr>> {
    let mut builder = DeltaBuilder::new(_fbb);
    if let Some(x) = args.patch { builder.add_patch(x); }
    if let Some(x) = args.base { builder.add_base(x); }
    builder.finish()
  }


  #[inline]
  pub fn base(&self) -> Option<VersionBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<VersionBase>>(Delta::VT_BASE, None)}
  }
  #[inline]
  pub fn patch(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<JSONPatchOperation<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<JSONPatchOperation>>>>(Delta::VT_PATCH, None)}
  }
}

impl flatbuffers::Verifiable for Delta<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<VersionBase>>("base", Self::VT_BASE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<JSONPatchOperation>>>>("patch", Self::VT_PATCH, false)?
     .finish();
    Ok(())
  }
}
pub struct DeltaArgs<'a> {
    pub base: Option<flatbuffers::WIPOffset<VersionBase<'a>>>,
    pub patch: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<JSONPatchOperation<'a>>>>>,
}
impl<'a> Default for DeltaArgs<'a> {
  #[inline]
  fn default() -> Self {
    DeltaArgs {
      base: None,
      patch: None,
    }
  }
}

pub struct DeltaBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DeltaBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_base(&mut self, base: flatbuffers::WIPOffset<VersionBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<VersionBase>>(Delta::VT_BASE, base);
  }
  #[inline]
  pub fn add_patch(&mut self, patch: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<JSONPatchOperation<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Delta::VT_PATCH, patch);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DeltaBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DeltaBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Delta<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Delta<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Delta");
      ds.field("base", &self.base());
      ds.field("patch", &self.patch());
      ds.finish()
  }
}
pub enum VersionGraphMetadataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct VersionGraphMetadata<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for VersionGraphMetadata<'a> {
  type Inner = VersionGraphMetadata<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> VersionGraphMetadata<'a> {
  pub const VT_LAST_PRUNED: flatbuffers::VOffsetT = 4;
  pub const VT_TOTAL_SIZE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    VersionGraphMetadata { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args VersionGraphMetadataArgs
  ) -> flatbuffers::WIPOffset<VersionGraphMetadata<'bldr>> {
    let mut builder = VersionGraphMetadataBuilder::new(_fbb);
    builder.add_total_size(args.total_size);
    builder.add_last_pruned(args.last_pruned);
    builder.finish()
  }


  #[inline]
  pub fn last_pruned(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(VersionGraphMetadata::VT_LAST_PRUNED, Some(0)).unwrap()}
  }
  #[inline]
  pub fn total_size(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(VersionGraphMetadata::VT_TOTAL_SIZE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for VersionGraphMetadata<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("last_pruned", Self::VT_LAST_PRUNED, false)?
     .visit_field::<i64>("total_size", Self::VT_TOTAL_SIZE, false)?
     .finish();
    Ok(())
  }
}
pub struct VersionGraphMetadataArgs {
    pub last_pruned: i64,
    pub total_size: i64,
}
impl<'a> Default for VersionGraphMetadataArgs {
  #[inline]
  fn default() -> Self {
    VersionGraphMetadataArgs {
      last_pruned: 0,
      total_size: 0,
    }
  }
}

pub struct VersionGraphMetadataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> VersionGraphMetadataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_last_pruned(&mut self, last_pruned: i64) {
    self.fbb_.push_slot::<i64>(VersionGraphMetadata::VT_LAST_PRUNED, last_pruned, 0);
  }
  #[inline]
  pub fn add_total_size(&mut self, total_size: i64) {
    self.fbb_.push_slot::<i64>(VersionGraphMetadata::VT_TOTAL_SIZE, total_size, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> VersionGraphMetadataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    VersionGraphMetadataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<VersionGraphMetadata<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for VersionGraphMetadata<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("VersionGraphMetadata");
      ds.field("last_pruned", &self.last_pruned());
      ds.field("total_size", &self.total_size());
      ds.finish()
  }
}
pub enum VersionGraphOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct VersionGraph<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for VersionGraph<'a> {
  type Inner = VersionGraph<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> VersionGraph<'a> {
  pub const VT_USER_CHECKPOINT_VERSION_ID: flatbuffers::VOffsetT = 4;
  pub const VT_LATEST_VERSION_ID: flatbuffers::VOffsetT = 6;
  pub const VT_CHECKPOINTS: flatbuffers::VOffsetT = 8;
  pub const VT_DELTAS: flatbuffers::VOffsetT = 10;
  pub const VT_METADATA: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    VersionGraph { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args VersionGraphArgs<'args>
  ) -> flatbuffers::WIPOffset<VersionGraph<'bldr>> {
    let mut builder = VersionGraphBuilder::new(_fbb);
    if let Some(x) = args.metadata { builder.add_metadata(x); }
    if let Some(x) = args.deltas { builder.add_deltas(x); }
    if let Some(x) = args.checkpoints { builder.add_checkpoints(x); }
    if let Some(x) = args.latest_version_id { builder.add_latest_version_id(x); }
    if let Some(x) = args.user_checkpoint_version_id { builder.add_user_checkpoint_version_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn user_checkpoint_version_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(VersionGraph::VT_USER_CHECKPOINT_VERSION_ID, None)}
  }
  #[inline]
  pub fn latest_version_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(VersionGraph::VT_LATEST_VERSION_ID, None)}
  }
  #[inline]
  pub fn checkpoints(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Checkpoint<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Checkpoint>>>>(VersionGraph::VT_CHECKPOINTS, None)}
  }
  #[inline]
  pub fn deltas(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Delta<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Delta>>>>(VersionGraph::VT_DELTAS, None)}
  }
  #[inline]
  pub fn metadata(&self) -> Option<VersionGraphMetadata<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<VersionGraphMetadata>>(VersionGraph::VT_METADATA, None)}
  }
}

impl flatbuffers::Verifiable for VersionGraph<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("user_checkpoint_version_id", Self::VT_USER_CHECKPOINT_VERSION_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("latest_version_id", Self::VT_LATEST_VERSION_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Checkpoint>>>>("checkpoints", Self::VT_CHECKPOINTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Delta>>>>("deltas", Self::VT_DELTAS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<VersionGraphMetadata>>("metadata", Self::VT_METADATA, false)?
     .finish();
    Ok(())
  }
}
pub struct VersionGraphArgs<'a> {
    pub user_checkpoint_version_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub latest_version_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub checkpoints: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Checkpoint<'a>>>>>,
    pub deltas: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Delta<'a>>>>>,
    pub metadata: Option<flatbuffers::WIPOffset<VersionGraphMetadata<'a>>>,
}
impl<'a> Default for VersionGraphArgs<'a> {
  #[inline]
  fn default() -> Self {
    VersionGraphArgs {
      user_checkpoint_version_id: None,
      latest_version_id: None,
      checkpoints: None,
      deltas: None,
      metadata: None,
    }
  }
}

pub struct VersionGraphBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> VersionGraphBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_user_checkpoint_version_id(&mut self, user_checkpoint_version_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(VersionGraph::VT_USER_CHECKPOINT_VERSION_ID, user_checkpoint_version_id);
  }
  #[inline]
  pub fn add_latest_version_id(&mut self, latest_version_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(VersionGraph::VT_LATEST_VERSION_ID, latest_version_id);
  }
  #[inline]
  pub fn add_checkpoints(&mut self, checkpoints: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Checkpoint<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(VersionGraph::VT_CHECKPOINTS, checkpoints);
  }
  #[inline]
  pub fn add_deltas(&mut self, deltas: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Delta<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(VersionGraph::VT_DELTAS, deltas);
  }
  #[inline]
  pub fn add_metadata(&mut self, metadata: flatbuffers::WIPOffset<VersionGraphMetadata<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<VersionGraphMetadata>>(VersionGraph::VT_METADATA, metadata);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> VersionGraphBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    VersionGraphBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<VersionGraph<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for VersionGraph<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("VersionGraph");
      ds.field("user_checkpoint_version_id", &self.user_checkpoint_version_id());
      ds.field("latest_version_id", &self.latest_version_id());
      ds.field("checkpoints", &self.checkpoints());
      ds.field("deltas", &self.deltas());
      ds.field("metadata", &self.metadata());
      ds.finish()
  }
}
pub enum DucExternalFileDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucExternalFileData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucExternalFileData<'a> {
  type Inner = DucExternalFileData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucExternalFileData<'a> {
  pub const VT_MIME_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_ID: flatbuffers::VOffsetT = 6;
  pub const VT_DATA: flatbuffers::VOffsetT = 8;
  pub const VT_CREATED: flatbuffers::VOffsetT = 10;
  pub const VT_LAST_RETRIEVED: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucExternalFileData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucExternalFileDataArgs<'args>
  ) -> flatbuffers::WIPOffset<DucExternalFileData<'bldr>> {
    let mut builder = DucExternalFileDataBuilder::new(_fbb);
    if let Some(x) = args.last_retrieved { builder.add_last_retrieved(x); }
    builder.add_created(args.created);
    if let Some(x) = args.data { builder.add_data(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    if let Some(x) = args.mime_type { builder.add_mime_type(x); }
    builder.finish()
  }


  #[inline]
  pub fn mime_type(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucExternalFileData::VT_MIME_TYPE, None)}
  }
  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucExternalFileData::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &DucExternalFileData) -> bool {
    self.id() < o.id()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.id();
    key.cmp(val)
  }
  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(DucExternalFileData::VT_DATA, None)}
  }
  #[inline]
  pub fn created(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(DucExternalFileData::VT_CREATED, Some(0)).unwrap()}
  }
  #[inline]
  pub fn last_retrieved(&self) -> Option<i64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(DucExternalFileData::VT_LAST_RETRIEVED, None)}
  }
}

impl flatbuffers::Verifiable for DucExternalFileData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("mime_type", Self::VT_MIME_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("data", Self::VT_DATA, false)?
     .visit_field::<i64>("created", Self::VT_CREATED, false)?
     .visit_field::<i64>("last_retrieved", Self::VT_LAST_RETRIEVED, false)?
     .finish();
    Ok(())
  }
}
pub struct DucExternalFileDataArgs<'a> {
    pub mime_type: Option<flatbuffers::WIPOffset<&'a str>>,
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub created: i64,
    pub last_retrieved: Option<i64>,
}
impl<'a> Default for DucExternalFileDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucExternalFileDataArgs {
      mime_type: None,
      id: None, // required field
      data: None,
      created: 0,
      last_retrieved: None,
    }
  }
}

pub struct DucExternalFileDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucExternalFileDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_mime_type(&mut self, mime_type: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucExternalFileData::VT_MIME_TYPE, mime_type);
  }
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucExternalFileData::VT_ID, id);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucExternalFileData::VT_DATA, data);
  }
  #[inline]
  pub fn add_created(&mut self, created: i64) {
    self.fbb_.push_slot::<i64>(DucExternalFileData::VT_CREATED, created, 0);
  }
  #[inline]
  pub fn add_last_retrieved(&mut self, last_retrieved: i64) {
    self.fbb_.push_slot_always::<i64>(DucExternalFileData::VT_LAST_RETRIEVED, last_retrieved);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucExternalFileDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucExternalFileDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucExternalFileData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, DucExternalFileData::VT_ID,"id");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucExternalFileData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucExternalFileData");
      ds.field("mime_type", &self.mime_type());
      ds.field("id", &self.id());
      ds.field("data", &self.data());
      ds.field("created", &self.created());
      ds.field("last_retrieved", &self.last_retrieved());
      ds.finish()
  }
}
pub enum DucExternalFileEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucExternalFileEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucExternalFileEntry<'a> {
  type Inner = DucExternalFileEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucExternalFileEntry<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucExternalFileEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucExternalFileEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<DucExternalFileEntry<'bldr>> {
    let mut builder = DucExternalFileEntryBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucExternalFileEntry::VT_KEY, None).unwrap()}
  }
  #[inline]
  pub fn key_compare_less_than(&self, o: &DucExternalFileEntry) -> bool {
    self.key() < o.key()
  }

  #[inline]
  pub fn key_compare_with_value(&self, val: & str) -> ::core::cmp::Ordering {
    let key = self.key();
    key.cmp(val)
  }
  #[inline]
  pub fn value(&self) -> Option<DucExternalFileData<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucExternalFileData>>(DucExternalFileEntry::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for DucExternalFileEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucExternalFileData>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct DucExternalFileEntryArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<DucExternalFileData<'a>>>,
}
impl<'a> Default for DucExternalFileEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucExternalFileEntryArgs {
      key: None, // required field
      value: None,
    }
  }
}

pub struct DucExternalFileEntryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucExternalFileEntryBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucExternalFileEntry::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<DucExternalFileData<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucExternalFileData>>(DucExternalFileEntry::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucExternalFileEntryBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucExternalFileEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucExternalFileEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, DucExternalFileEntry::VT_KEY,"key");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucExternalFileEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucExternalFileEntry");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum ExportedDataStateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ExportedDataState<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExportedDataState<'a> {
  type Inner = ExportedDataState<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ExportedDataState<'a> {
  pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
  pub const VT_VERSION_LEGACY: flatbuffers::VOffsetT = 6;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 8;
  pub const VT_VERSION: flatbuffers::VOffsetT = 10;
  pub const VT_THUMBNAIL: flatbuffers::VOffsetT = 12;
  pub const VT_DICTIONARY: flatbuffers::VOffsetT = 14;
  pub const VT_ELEMENTS: flatbuffers::VOffsetT = 16;
  pub const VT_BLOCKS: flatbuffers::VOffsetT = 18;
  pub const VT_GROUPS: flatbuffers::VOffsetT = 20;
  pub const VT_REGIONS: flatbuffers::VOffsetT = 22;
  pub const VT_LAYERS: flatbuffers::VOffsetT = 24;
  pub const VT_STANDARDS: flatbuffers::VOffsetT = 26;
  pub const VT_DUC_LOCAL_STATE: flatbuffers::VOffsetT = 28;
  pub const VT_DUC_GLOBAL_STATE: flatbuffers::VOffsetT = 30;
  pub const VT_EXTERNAL_FILES: flatbuffers::VOffsetT = 32;
  pub const VT_VERSION_GRAPH: flatbuffers::VOffsetT = 34;
  pub const VT_ID: flatbuffers::VOffsetT = 36;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ExportedDataState { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ExportedDataStateArgs<'args>
  ) -> flatbuffers::WIPOffset<ExportedDataState<'bldr>> {
    let mut builder = ExportedDataStateBuilder::new(_fbb);
    if let Some(x) = args.id { builder.add_id(x); }
    if let Some(x) = args.version_graph { builder.add_version_graph(x); }
    if let Some(x) = args.external_files { builder.add_external_files(x); }
    if let Some(x) = args.duc_global_state { builder.add_duc_global_state(x); }
    if let Some(x) = args.duc_local_state { builder.add_duc_local_state(x); }
    if let Some(x) = args.standards { builder.add_standards(x); }
    if let Some(x) = args.layers { builder.add_layers(x); }
    if let Some(x) = args.regions { builder.add_regions(x); }
    if let Some(x) = args.groups { builder.add_groups(x); }
    if let Some(x) = args.blocks { builder.add_blocks(x); }
    if let Some(x) = args.elements { builder.add_elements(x); }
    if let Some(x) = args.dictionary { builder.add_dictionary(x); }
    if let Some(x) = args.thumbnail { builder.add_thumbnail(x); }
    if let Some(x) = args.version { builder.add_version(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    builder.add_version_legacy(args.version_legacy);
    if let Some(x) = args.type_ { builder.add_type_(x); }
    builder.finish()
  }


  #[inline]
  pub fn type_(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ExportedDataState::VT_TYPE_, None)}
  }
  #[inline]
  pub fn version_legacy(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ExportedDataState::VT_VERSION_LEGACY, Some(0)).unwrap()}
  }
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ExportedDataState::VT_SOURCE, None)}
  }
  #[inline]
  pub fn version(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ExportedDataState::VT_VERSION, None)}
  }
  #[inline]
  pub fn thumbnail(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(ExportedDataState::VT_THUMBNAIL, None)}
  }
  #[inline]
  pub fn dictionary(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DictionaryEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DictionaryEntry>>>>(ExportedDataState::VT_DICTIONARY, None)}
  }
  #[inline]
  pub fn elements(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ElementWrapper<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ElementWrapper>>>>(ExportedDataState::VT_ELEMENTS, None)}
  }
  #[inline]
  pub fn blocks(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucBlock<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucBlock>>>>(ExportedDataState::VT_BLOCKS, None)}
  }
  #[inline]
  pub fn groups(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucGroup<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucGroup>>>>(ExportedDataState::VT_GROUPS, None)}
  }
  #[inline]
  pub fn regions(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucRegion<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucRegion>>>>(ExportedDataState::VT_REGIONS, None)}
  }
  #[inline]
  pub fn layers(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucLayer<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucLayer>>>>(ExportedDataState::VT_LAYERS, None)}
  }
  #[inline]
  pub fn standards(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Standard<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Standard>>>>(ExportedDataState::VT_STANDARDS, None)}
  }
  #[inline]
  pub fn duc_local_state(&self) -> Option<DucLocalState<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucLocalState>>(ExportedDataState::VT_DUC_LOCAL_STATE, None)}
  }
  #[inline]
  pub fn duc_global_state(&self) -> Option<DucGlobalState<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<DucGlobalState>>(ExportedDataState::VT_DUC_GLOBAL_STATE, None)}
  }
  #[inline]
  pub fn external_files(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucExternalFileEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucExternalFileEntry>>>>(ExportedDataState::VT_EXTERNAL_FILES, None)}
  }
  #[inline]
  pub fn version_graph(&self) -> Option<VersionGraph<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<VersionGraph>>(ExportedDataState::VT_VERSION_GRAPH, None)}
  }
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ExportedDataState::VT_ID, None)}
  }
}

impl flatbuffers::Verifiable for ExportedDataState<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, false)?
     .visit_field::<i32>("version_legacy", Self::VT_VERSION_LEGACY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("version", Self::VT_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("thumbnail", Self::VT_THUMBNAIL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DictionaryEntry>>>>("dictionary", Self::VT_DICTIONARY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ElementWrapper>>>>("elements", Self::VT_ELEMENTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DucBlock>>>>("blocks", Self::VT_BLOCKS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DucGroup>>>>("groups", Self::VT_GROUPS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DucRegion>>>>("regions", Self::VT_REGIONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DucLayer>>>>("layers", Self::VT_LAYERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Standard>>>>("standards", Self::VT_STANDARDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucLocalState>>("duc_local_state", Self::VT_DUC_LOCAL_STATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<DucGlobalState>>("duc_global_state", Self::VT_DUC_GLOBAL_STATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DucExternalFileEntry>>>>("external_files", Self::VT_EXTERNAL_FILES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<VersionGraph>>("version_graph", Self::VT_VERSION_GRAPH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct ExportedDataStateArgs<'a> {
    pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
    pub version_legacy: i32,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub version: Option<flatbuffers::WIPOffset<&'a str>>,
    pub thumbnail: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub dictionary: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DictionaryEntry<'a>>>>>,
    pub elements: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ElementWrapper<'a>>>>>,
    pub blocks: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucBlock<'a>>>>>,
    pub groups: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucGroup<'a>>>>>,
    pub regions: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucRegion<'a>>>>>,
    pub layers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucLayer<'a>>>>>,
    pub standards: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Standard<'a>>>>>,
    pub duc_local_state: Option<flatbuffers::WIPOffset<DucLocalState<'a>>>,
    pub duc_global_state: Option<flatbuffers::WIPOffset<DucGlobalState<'a>>>,
    pub external_files: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucExternalFileEntry<'a>>>>>,
    pub version_graph: Option<flatbuffers::WIPOffset<VersionGraph<'a>>>,
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ExportedDataStateArgs<'a> {
  #[inline]
  fn default() -> Self {
    ExportedDataStateArgs {
      type_: None,
      version_legacy: 0,
      source: None,
      version: None,
      thumbnail: None,
      dictionary: None,
      elements: None,
      blocks: None,
      groups: None,
      regions: None,
      layers: None,
      standards: None,
      duc_local_state: None,
      duc_global_state: None,
      external_files: None,
      version_graph: None,
      id: None,
    }
  }
}

pub struct ExportedDataStateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ExportedDataStateBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ExportedDataState::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_version_legacy(&mut self, version_legacy: i32) {
    self.fbb_.push_slot::<i32>(ExportedDataState::VT_VERSION_LEGACY, version_legacy, 0);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ExportedDataState::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_version(&mut self, version: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ExportedDataState::VT_VERSION, version);
  }
  #[inline]
  pub fn add_thumbnail(&mut self, thumbnail: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ExportedDataState::VT_THUMBNAIL, thumbnail);
  }
  #[inline]
  pub fn add_dictionary(&mut self, dictionary: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DictionaryEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ExportedDataState::VT_DICTIONARY, dictionary);
  }
  #[inline]
  pub fn add_elements(&mut self, elements: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ElementWrapper<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ExportedDataState::VT_ELEMENTS, elements);
  }
  #[inline]
  pub fn add_blocks(&mut self, blocks: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DucBlock<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ExportedDataState::VT_BLOCKS, blocks);
  }
  #[inline]
  pub fn add_groups(&mut self, groups: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DucGroup<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ExportedDataState::VT_GROUPS, groups);
  }
  #[inline]
  pub fn add_regions(&mut self, regions: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DucRegion<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ExportedDataState::VT_REGIONS, regions);
  }
  #[inline]
  pub fn add_layers(&mut self, layers: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DucLayer<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ExportedDataState::VT_LAYERS, layers);
  }
  #[inline]
  pub fn add_standards(&mut self, standards: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Standard<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ExportedDataState::VT_STANDARDS, standards);
  }
  #[inline]
  pub fn add_duc_local_state(&mut self, duc_local_state: flatbuffers::WIPOffset<DucLocalState<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucLocalState>>(ExportedDataState::VT_DUC_LOCAL_STATE, duc_local_state);
  }
  #[inline]
  pub fn add_duc_global_state(&mut self, duc_global_state: flatbuffers::WIPOffset<DucGlobalState<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DucGlobalState>>(ExportedDataState::VT_DUC_GLOBAL_STATE, duc_global_state);
  }
  #[inline]
  pub fn add_external_files(&mut self, external_files: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DucExternalFileEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ExportedDataState::VT_EXTERNAL_FILES, external_files);
  }
  #[inline]
  pub fn add_version_graph(&mut self, version_graph: flatbuffers::WIPOffset<VersionGraph<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<VersionGraph>>(ExportedDataState::VT_VERSION_GRAPH, version_graph);
  }
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ExportedDataState::VT_ID, id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ExportedDataStateBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ExportedDataStateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ExportedDataState<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ExportedDataState<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ExportedDataState");
      ds.field("type_", &self.type_());
      ds.field("version_legacy", &self.version_legacy());
      ds.field("source", &self.source());
      ds.field("version", &self.version());
      ds.field("thumbnail", &self.thumbnail());
      ds.field("dictionary", &self.dictionary());
      ds.field("elements", &self.elements());
      ds.field("blocks", &self.blocks());
      ds.field("groups", &self.groups());
      ds.field("regions", &self.regions());
      ds.field("layers", &self.layers());
      ds.field("standards", &self.standards());
      ds.field("duc_local_state", &self.duc_local_state());
      ds.field("duc_global_state", &self.duc_global_state());
      ds.field("external_files", &self.external_files());
      ds.field("version_graph", &self.version_graph());
      ds.field("id", &self.id());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `ExportedDataState`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_exported_data_state_unchecked`.
pub fn root_as_exported_data_state(buf: &[u8]) -> Result<ExportedDataState, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<ExportedDataState>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `ExportedDataState` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_exported_data_state_unchecked`.
pub fn size_prefixed_root_as_exported_data_state(buf: &[u8]) -> Result<ExportedDataState, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<ExportedDataState>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `ExportedDataState` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_exported_data_state_unchecked`.
pub fn root_as_exported_data_state_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ExportedDataState<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<ExportedDataState<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `ExportedDataState` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_exported_data_state_unchecked`.
pub fn size_prefixed_root_as_exported_data_state_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ExportedDataState<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<ExportedDataState<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a ExportedDataState and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `ExportedDataState`.
pub unsafe fn root_as_exported_data_state_unchecked(buf: &[u8]) -> ExportedDataState {
  flatbuffers::root_unchecked::<ExportedDataState>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed ExportedDataState and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `ExportedDataState`.
pub unsafe fn size_prefixed_root_as_exported_data_state_unchecked(buf: &[u8]) -> ExportedDataState {
  flatbuffers::size_prefixed_root_unchecked::<ExportedDataState>(buf)
}
pub const EXPORTED_DATA_STATE_IDENTIFIER: &str = "DUC_";

#[inline]
pub fn exported_data_state_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, EXPORTED_DATA_STATE_IDENTIFIER, false)
}

#[inline]
pub fn exported_data_state_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, EXPORTED_DATA_STATE_IDENTIFIER, true)
}

#[inline]
pub fn finish_exported_data_state_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<ExportedDataState<'a>>) {
  fbb.finish(root, Some(EXPORTED_DATA_STATE_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_exported_data_state_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<ExportedDataState<'a>>) {
  fbb.finish_size_prefixed(root, Some(EXPORTED_DATA_STATE_IDENTIFIER));
}
}  // pub mod Duc

