// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod duc {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

pub enum PointOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Point<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Point<'a> {
  type Inner = Point<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Point<'a> {
  pub const VT_X_V2: flatbuffers::VOffsetT = 4;
  pub const VT_Y_V2: flatbuffers::VOffsetT = 6;
  pub const VT_IS_CURVE: flatbuffers::VOffsetT = 8;
  pub const VT_MIRRORING: flatbuffers::VOffsetT = 10;
  pub const VT_BORDER_RADIUS: flatbuffers::VOffsetT = 12;
  pub const VT_HANDLE_IN: flatbuffers::VOffsetT = 14;
  pub const VT_HANDLE_OUT: flatbuffers::VOffsetT = 16;
  pub const VT_X_V3: flatbuffers::VOffsetT = 18;
  pub const VT_Y_V3: flatbuffers::VOffsetT = 20;
  pub const VT_PEER: flatbuffers::VOffsetT = 22;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Point { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PointArgs<'args>
  ) -> flatbuffers::WIPOffset<Point<'bldr>> {
    let mut builder = PointBuilder::new(_fbb);
    builder.add_y_v3(args.y_v3);
    builder.add_x_v3(args.x_v3);
    if let Some(x) = args.border_radius { builder.add_border_radius(x); }
    builder.add_peer(args.peer);
    if let Some(x) = args.handle_out { builder.add_handle_out(x); }
    if let Some(x) = args.handle_in { builder.add_handle_in(x); }
    if let Some(x) = args.y_v2 { builder.add_y_v2(x); }
    if let Some(x) = args.x_v2 { builder.add_x_v2(x); }
    if let Some(x) = args.mirroring { builder.add_mirroring(x); }
    if let Some(x) = args.is_curve { builder.add_is_curve(x); }
    builder.finish()
  }


  #[inline]
  pub fn x_v2(&self) -> Option<f32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Point::VT_X_V2, None)}
  }
  #[inline]
  pub fn y_v2(&self) -> Option<f32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(Point::VT_Y_V2, None)}
  }
  #[inline]
  pub fn is_curve(&self) -> Option<bool> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Point::VT_IS_CURVE, None)}
  }
  #[inline]
  pub fn mirroring(&self) -> Option<i8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(Point::VT_MIRRORING, None)}
  }
  #[inline]
  pub fn border_radius(&self) -> Option<f64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Point::VT_BORDER_RADIUS, None)}
  }
  #[inline]
  pub fn handle_in(&self) -> Option<SimplePoint<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SimplePoint>>(Point::VT_HANDLE_IN, None)}
  }
  #[inline]
  pub fn handle_out(&self) -> Option<SimplePoint<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SimplePoint>>(Point::VT_HANDLE_OUT, None)}
  }
  #[inline]
  pub fn x_v3(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Point::VT_X_V3, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn y_v3(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(Point::VT_Y_V3, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn peer(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Point::VT_PEER, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for Point<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("x_v2", Self::VT_X_V2, false)?
     .visit_field::<f32>("y_v2", Self::VT_Y_V2, false)?
     .visit_field::<bool>("is_curve", Self::VT_IS_CURVE, false)?
     .visit_field::<i8>("mirroring", Self::VT_MIRRORING, false)?
     .visit_field::<f64>("border_radius", Self::VT_BORDER_RADIUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SimplePoint>>("handle_in", Self::VT_HANDLE_IN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SimplePoint>>("handle_out", Self::VT_HANDLE_OUT, false)?
     .visit_field::<f64>("x_v3", Self::VT_X_V3, false)?
     .visit_field::<f64>("y_v3", Self::VT_Y_V3, false)?
     .visit_field::<i32>("peer", Self::VT_PEER, false)?
     .finish();
    Ok(())
  }
}
pub struct PointArgs<'a> {
    pub x_v2: Option<f32>,
    pub y_v2: Option<f32>,
    pub is_curve: Option<bool>,
    pub mirroring: Option<i8>,
    pub border_radius: Option<f64>,
    pub handle_in: Option<flatbuffers::WIPOffset<SimplePoint<'a>>>,
    pub handle_out: Option<flatbuffers::WIPOffset<SimplePoint<'a>>>,
    pub x_v3: f64,
    pub y_v3: f64,
    pub peer: i32,
}
impl<'a> Default for PointArgs<'a> {
  #[inline]
  fn default() -> Self {
    PointArgs {
      x_v2: None,
      y_v2: None,
      is_curve: None,
      mirroring: None,
      border_radius: None,
      handle_in: None,
      handle_out: None,
      x_v3: 0.0,
      y_v3: 0.0,
      peer: 0,
    }
  }
}

pub struct PointBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PointBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_x_v2(&mut self, x_v2: f32) {
    self.fbb_.push_slot_always::<f32>(Point::VT_X_V2, x_v2);
  }
  #[inline]
  pub fn add_y_v2(&mut self, y_v2: f32) {
    self.fbb_.push_slot_always::<f32>(Point::VT_Y_V2, y_v2);
  }
  #[inline]
  pub fn add_is_curve(&mut self, is_curve: bool) {
    self.fbb_.push_slot_always::<bool>(Point::VT_IS_CURVE, is_curve);
  }
  #[inline]
  pub fn add_mirroring(&mut self, mirroring: i8) {
    self.fbb_.push_slot_always::<i8>(Point::VT_MIRRORING, mirroring);
  }
  #[inline]
  pub fn add_border_radius(&mut self, border_radius: f64) {
    self.fbb_.push_slot_always::<f64>(Point::VT_BORDER_RADIUS, border_radius);
  }
  #[inline]
  pub fn add_handle_in(&mut self, handle_in: flatbuffers::WIPOffset<SimplePoint<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SimplePoint>>(Point::VT_HANDLE_IN, handle_in);
  }
  #[inline]
  pub fn add_handle_out(&mut self, handle_out: flatbuffers::WIPOffset<SimplePoint<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SimplePoint>>(Point::VT_HANDLE_OUT, handle_out);
  }
  #[inline]
  pub fn add_x_v3(&mut self, x_v3: f64) {
    self.fbb_.push_slot::<f64>(Point::VT_X_V3, x_v3, 0.0);
  }
  #[inline]
  pub fn add_y_v3(&mut self, y_v3: f64) {
    self.fbb_.push_slot::<f64>(Point::VT_Y_V3, y_v3, 0.0);
  }
  #[inline]
  pub fn add_peer(&mut self, peer: i32) {
    self.fbb_.push_slot::<i32>(Point::VT_PEER, peer, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PointBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PointBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Point<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Point<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Point");
      ds.field("x_v2", &self.x_v2());
      ds.field("y_v2", &self.y_v2());
      ds.field("is_curve", &self.is_curve());
      ds.field("mirroring", &self.mirroring());
      ds.field("border_radius", &self.border_radius());
      ds.field("handle_in", &self.handle_in());
      ds.field("handle_out", &self.handle_out());
      ds.field("x_v3", &self.x_v3());
      ds.field("y_v3", &self.y_v3());
      ds.field("peer", &self.peer());
      ds.finish()
  }
}
pub enum PointBindingOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PointBinding<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PointBinding<'a> {
  type Inner = PointBinding<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PointBinding<'a> {
  pub const VT_ELEMENT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_FOCUS: flatbuffers::VOffsetT = 6;
  pub const VT_GAP: flatbuffers::VOffsetT = 8;
  pub const VT_FIXED_POINT: flatbuffers::VOffsetT = 10;
  pub const VT_POINT: flatbuffers::VOffsetT = 12;
  pub const VT_HEAD: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PointBinding { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PointBindingArgs<'args>
  ) -> flatbuffers::WIPOffset<PointBinding<'bldr>> {
    let mut builder = PointBindingBuilder::new(_fbb);
    if let Some(x) = args.point { builder.add_point(x); }
    if let Some(x) = args.fixed_point { builder.add_fixed_point(x); }
    builder.add_gap(args.gap);
    builder.add_focus(args.focus);
    if let Some(x) = args.element_id { builder.add_element_id(x); }
    builder.add_head(args.head);
    builder.finish()
  }


  #[inline]
  pub fn element_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(PointBinding::VT_ELEMENT_ID, None)}
  }
  #[inline]
  pub fn focus(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(PointBinding::VT_FOCUS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn gap(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(PointBinding::VT_GAP, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn fixed_point(&self) -> Option<Point<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Point>>(PointBinding::VT_FIXED_POINT, None)}
  }
  #[inline]
  pub fn point(&self) -> Option<BindingPoint<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<BindingPoint>>(PointBinding::VT_POINT, None)}
  }
  #[inline]
  pub fn head(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(PointBinding::VT_HEAD, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for PointBinding<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("element_id", Self::VT_ELEMENT_ID, false)?
     .visit_field::<f32>("focus", Self::VT_FOCUS, false)?
     .visit_field::<f32>("gap", Self::VT_GAP, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Point>>("fixed_point", Self::VT_FIXED_POINT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<BindingPoint>>("point", Self::VT_POINT, false)?
     .visit_field::<i8>("head", Self::VT_HEAD, false)?
     .finish();
    Ok(())
  }
}
pub struct PointBindingArgs<'a> {
    pub element_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub focus: f32,
    pub gap: f32,
    pub fixed_point: Option<flatbuffers::WIPOffset<Point<'a>>>,
    pub point: Option<flatbuffers::WIPOffset<BindingPoint<'a>>>,
    pub head: i8,
}
impl<'a> Default for PointBindingArgs<'a> {
  #[inline]
  fn default() -> Self {
    PointBindingArgs {
      element_id: None,
      focus: 0.0,
      gap: 0.0,
      fixed_point: None,
      point: None,
      head: 0,
    }
  }
}

pub struct PointBindingBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PointBindingBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_element_id(&mut self, element_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PointBinding::VT_ELEMENT_ID, element_id);
  }
  #[inline]
  pub fn add_focus(&mut self, focus: f32) {
    self.fbb_.push_slot::<f32>(PointBinding::VT_FOCUS, focus, 0.0);
  }
  #[inline]
  pub fn add_gap(&mut self, gap: f32) {
    self.fbb_.push_slot::<f32>(PointBinding::VT_GAP, gap, 0.0);
  }
  #[inline]
  pub fn add_fixed_point(&mut self, fixed_point: flatbuffers::WIPOffset<Point<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Point>>(PointBinding::VT_FIXED_POINT, fixed_point);
  }
  #[inline]
  pub fn add_point(&mut self, point: flatbuffers::WIPOffset<BindingPoint<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<BindingPoint>>(PointBinding::VT_POINT, point);
  }
  #[inline]
  pub fn add_head(&mut self, head: i8) {
    self.fbb_.push_slot::<i8>(PointBinding::VT_HEAD, head, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PointBindingBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PointBindingBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PointBinding<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PointBinding<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PointBinding");
      ds.field("element_id", &self.element_id());
      ds.field("focus", &self.focus());
      ds.field("gap", &self.gap());
      ds.field("fixed_point", &self.fixed_point());
      ds.field("point", &self.point());
      ds.field("head", &self.head());
      ds.finish()
  }
}
pub enum BindingPointOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BindingPoint<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BindingPoint<'a> {
  type Inner = BindingPoint<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BindingPoint<'a> {
  pub const VT_INDEX: flatbuffers::VOffsetT = 4;
  pub const VT_OFFSET: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BindingPoint { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BindingPointArgs
  ) -> flatbuffers::WIPOffset<BindingPoint<'bldr>> {
    let mut builder = BindingPointBuilder::new(_fbb);
    builder.add_offset(args.offset);
    builder.add_index(args.index);
    builder.finish()
  }


  #[inline]
  pub fn index(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(BindingPoint::VT_INDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn offset(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(BindingPoint::VT_OFFSET, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for BindingPoint<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i32>("index", Self::VT_INDEX, false)?
     .visit_field::<f32>("offset", Self::VT_OFFSET, false)?
     .finish();
    Ok(())
  }
}
pub struct BindingPointArgs {
    pub index: i32,
    pub offset: f32,
}
impl<'a> Default for BindingPointArgs {
  #[inline]
  fn default() -> Self {
    BindingPointArgs {
      index: 0,
      offset: 0.0,
    }
  }
}

pub struct BindingPointBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BindingPointBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_index(&mut self, index: i32) {
    self.fbb_.push_slot::<i32>(BindingPoint::VT_INDEX, index, 0);
  }
  #[inline]
  pub fn add_offset(&mut self, offset: f32) {
    self.fbb_.push_slot::<f32>(BindingPoint::VT_OFFSET, offset, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BindingPointBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BindingPointBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BindingPoint<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BindingPoint<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BindingPoint");
      ds.field("index", &self.index());
      ds.field("offset", &self.offset());
      ds.finish()
  }
}
pub enum SimplePointOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SimplePoint<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SimplePoint<'a> {
  type Inner = SimplePoint<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SimplePoint<'a> {
  pub const VT_X: flatbuffers::VOffsetT = 4;
  pub const VT_Y: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SimplePoint { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SimplePointArgs
  ) -> flatbuffers::WIPOffset<SimplePoint<'bldr>> {
    let mut builder = SimplePointBuilder::new(_fbb);
    builder.add_y(args.y);
    builder.add_x(args.x);
    builder.finish()
  }


  #[inline]
  pub fn x(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SimplePoint::VT_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(SimplePoint::VT_Y, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for SimplePoint<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("x", Self::VT_X, false)?
     .visit_field::<f64>("y", Self::VT_Y, false)?
     .finish();
    Ok(())
  }
}
pub struct SimplePointArgs {
    pub x: f64,
    pub y: f64,
}
impl<'a> Default for SimplePointArgs {
  #[inline]
  fn default() -> Self {
    SimplePointArgs {
      x: 0.0,
      y: 0.0,
    }
  }
}

pub struct SimplePointBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SimplePointBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_x(&mut self, x: f64) {
    self.fbb_.push_slot::<f64>(SimplePoint::VT_X, x, 0.0);
  }
  #[inline]
  pub fn add_y(&mut self, y: f64) {
    self.fbb_.push_slot::<f64>(SimplePoint::VT_Y, y, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SimplePointBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SimplePointBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SimplePoint<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SimplePoint<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SimplePoint");
      ds.field("x", &self.x());
      ds.field("y", &self.y());
      ds.finish()
  }
}
pub enum TilingPropertiesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TilingProperties<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TilingProperties<'a> {
  type Inner = TilingProperties<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> TilingProperties<'a> {
  pub const VT_SIZE_IN_PERCENT: flatbuffers::VOffsetT = 4;
  pub const VT_ANGLE: flatbuffers::VOffsetT = 6;
  pub const VT_SPACING: flatbuffers::VOffsetT = 8;
  pub const VT_OFFSET_X: flatbuffers::VOffsetT = 10;
  pub const VT_OFFSET_Y: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    TilingProperties { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TilingPropertiesArgs
  ) -> flatbuffers::WIPOffset<TilingProperties<'bldr>> {
    let mut builder = TilingPropertiesBuilder::new(_fbb);
    if let Some(x) = args.offset_y { builder.add_offset_y(x); }
    if let Some(x) = args.offset_x { builder.add_offset_x(x); }
    if let Some(x) = args.spacing { builder.add_spacing(x); }
    builder.add_angle(args.angle);
    builder.add_size_in_percent(args.size_in_percent);
    builder.finish()
  }


  #[inline]
  pub fn size_in_percent(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TilingProperties::VT_SIZE_IN_PERCENT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn angle(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TilingProperties::VT_ANGLE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn spacing(&self) -> Option<f64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TilingProperties::VT_SPACING, None)}
  }
  #[inline]
  pub fn offset_x(&self) -> Option<f64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TilingProperties::VT_OFFSET_X, None)}
  }
  #[inline]
  pub fn offset_y(&self) -> Option<f64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(TilingProperties::VT_OFFSET_Y, None)}
  }
}

impl flatbuffers::Verifiable for TilingProperties<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("size_in_percent", Self::VT_SIZE_IN_PERCENT, false)?
     .visit_field::<f64>("angle", Self::VT_ANGLE, false)?
     .visit_field::<f64>("spacing", Self::VT_SPACING, false)?
     .visit_field::<f64>("offset_x", Self::VT_OFFSET_X, false)?
     .visit_field::<f64>("offset_y", Self::VT_OFFSET_Y, false)?
     .finish();
    Ok(())
  }
}
pub struct TilingPropertiesArgs {
    pub size_in_percent: f64,
    pub angle: f64,
    pub spacing: Option<f64>,
    pub offset_x: Option<f64>,
    pub offset_y: Option<f64>,
}
impl<'a> Default for TilingPropertiesArgs {
  #[inline]
  fn default() -> Self {
    TilingPropertiesArgs {
      size_in_percent: 0.0,
      angle: 0.0,
      spacing: None,
      offset_x: None,
      offset_y: None,
    }
  }
}

pub struct TilingPropertiesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TilingPropertiesBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_size_in_percent(&mut self, size_in_percent: f64) {
    self.fbb_.push_slot::<f64>(TilingProperties::VT_SIZE_IN_PERCENT, size_in_percent, 0.0);
  }
  #[inline]
  pub fn add_angle(&mut self, angle: f64) {
    self.fbb_.push_slot::<f64>(TilingProperties::VT_ANGLE, angle, 0.0);
  }
  #[inline]
  pub fn add_spacing(&mut self, spacing: f64) {
    self.fbb_.push_slot_always::<f64>(TilingProperties::VT_SPACING, spacing);
  }
  #[inline]
  pub fn add_offset_x(&mut self, offset_x: f64) {
    self.fbb_.push_slot_always::<f64>(TilingProperties::VT_OFFSET_X, offset_x);
  }
  #[inline]
  pub fn add_offset_y(&mut self, offset_y: f64) {
    self.fbb_.push_slot_always::<f64>(TilingProperties::VT_OFFSET_Y, offset_y);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> TilingPropertiesBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TilingPropertiesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<TilingProperties<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for TilingProperties<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("TilingProperties");
      ds.field("size_in_percent", &self.size_in_percent());
      ds.field("angle", &self.angle());
      ds.field("spacing", &self.spacing());
      ds.field("offset_x", &self.offset_x());
      ds.field("offset_y", &self.offset_y());
      ds.finish()
  }
}
pub enum ElementContentBaseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ElementContentBase<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ElementContentBase<'a> {
  type Inner = ElementContentBase<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ElementContentBase<'a> {
  pub const VT_PREFERENCE: flatbuffers::VOffsetT = 4;
  pub const VT_SRC: flatbuffers::VOffsetT = 6;
  pub const VT_VISIBLE: flatbuffers::VOffsetT = 8;
  pub const VT_OPACITY: flatbuffers::VOffsetT = 10;
  pub const VT_TILING: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ElementContentBase { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ElementContentBaseArgs<'args>
  ) -> flatbuffers::WIPOffset<ElementContentBase<'bldr>> {
    let mut builder = ElementContentBaseBuilder::new(_fbb);
    builder.add_opacity(args.opacity);
    if let Some(x) = args.tiling { builder.add_tiling(x); }
    if let Some(x) = args.src { builder.add_src(x); }
    builder.add_visible(args.visible);
    builder.add_preference(args.preference);
    builder.finish()
  }


  #[inline]
  pub fn preference(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(ElementContentBase::VT_PREFERENCE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn src(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ElementContentBase::VT_SRC, None)}
  }
  #[inline]
  pub fn visible(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(ElementContentBase::VT_VISIBLE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn opacity(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ElementContentBase::VT_OPACITY, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn tiling(&self) -> Option<TilingProperties<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<TilingProperties>>(ElementContentBase::VT_TILING, None)}
  }
}

impl flatbuffers::Verifiable for ElementContentBase<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i8>("preference", Self::VT_PREFERENCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("src", Self::VT_SRC, false)?
     .visit_field::<bool>("visible", Self::VT_VISIBLE, false)?
     .visit_field::<f64>("opacity", Self::VT_OPACITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<TilingProperties>>("tiling", Self::VT_TILING, false)?
     .finish();
    Ok(())
  }
}
pub struct ElementContentBaseArgs<'a> {
    pub preference: i8,
    pub src: Option<flatbuffers::WIPOffset<&'a str>>,
    pub visible: bool,
    pub opacity: f64,
    pub tiling: Option<flatbuffers::WIPOffset<TilingProperties<'a>>>,
}
impl<'a> Default for ElementContentBaseArgs<'a> {
  #[inline]
  fn default() -> Self {
    ElementContentBaseArgs {
      preference: 0,
      src: None,
      visible: false,
      opacity: 0.0,
      tiling: None,
    }
  }
}

pub struct ElementContentBaseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ElementContentBaseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_preference(&mut self, preference: i8) {
    self.fbb_.push_slot::<i8>(ElementContentBase::VT_PREFERENCE, preference, 0);
  }
  #[inline]
  pub fn add_src(&mut self, src: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ElementContentBase::VT_SRC, src);
  }
  #[inline]
  pub fn add_visible(&mut self, visible: bool) {
    self.fbb_.push_slot::<bool>(ElementContentBase::VT_VISIBLE, visible, false);
  }
  #[inline]
  pub fn add_opacity(&mut self, opacity: f64) {
    self.fbb_.push_slot::<f64>(ElementContentBase::VT_OPACITY, opacity, 0.0);
  }
  #[inline]
  pub fn add_tiling(&mut self, tiling: flatbuffers::WIPOffset<TilingProperties<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<TilingProperties>>(ElementContentBase::VT_TILING, tiling);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ElementContentBaseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ElementContentBaseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ElementContentBase<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ElementContentBase<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ElementContentBase");
      ds.field("preference", &self.preference());
      ds.field("src", &self.src());
      ds.field("visible", &self.visible());
      ds.field("opacity", &self.opacity());
      ds.field("tiling", &self.tiling());
      ds.finish()
  }
}
pub enum StrokeStyleOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct StrokeStyle<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StrokeStyle<'a> {
  type Inner = StrokeStyle<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> StrokeStyle<'a> {
  pub const VT_PREFERENCE: flatbuffers::VOffsetT = 4;
  pub const VT_CAP: flatbuffers::VOffsetT = 6;
  pub const VT_JOIN: flatbuffers::VOffsetT = 8;
  pub const VT_DASH: flatbuffers::VOffsetT = 10;
  pub const VT_DASH_CAP: flatbuffers::VOffsetT = 12;
  pub const VT_MITER_LIMIT: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StrokeStyle { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StrokeStyleArgs<'args>
  ) -> flatbuffers::WIPOffset<StrokeStyle<'bldr>> {
    let mut builder = StrokeStyleBuilder::new(_fbb);
    if let Some(x) = args.miter_limit { builder.add_miter_limit(x); }
    if let Some(x) = args.dash { builder.add_dash(x); }
    if let Some(x) = args.dash_cap { builder.add_dash_cap(x); }
    if let Some(x) = args.join { builder.add_join(x); }
    if let Some(x) = args.cap { builder.add_cap(x); }
    builder.add_preference(args.preference);
    builder.finish()
  }


  #[inline]
  pub fn preference(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(StrokeStyle::VT_PREFERENCE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn cap(&self) -> Option<i8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(StrokeStyle::VT_CAP, None)}
  }
  #[inline]
  pub fn join(&self) -> Option<i8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(StrokeStyle::VT_JOIN, None)}
  }
  #[inline]
  pub fn dash(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(StrokeStyle::VT_DASH, None)}
  }
  #[inline]
  pub fn dash_cap(&self) -> Option<i8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(StrokeStyle::VT_DASH_CAP, None)}
  }
  #[inline]
  pub fn miter_limit(&self) -> Option<f64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(StrokeStyle::VT_MITER_LIMIT, None)}
  }
}

impl flatbuffers::Verifiable for StrokeStyle<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i8>("preference", Self::VT_PREFERENCE, false)?
     .visit_field::<i8>("cap", Self::VT_CAP, false)?
     .visit_field::<i8>("join", Self::VT_JOIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("dash", Self::VT_DASH, false)?
     .visit_field::<i8>("dash_cap", Self::VT_DASH_CAP, false)?
     .visit_field::<f64>("miter_limit", Self::VT_MITER_LIMIT, false)?
     .finish();
    Ok(())
  }
}
pub struct StrokeStyleArgs<'a> {
    pub preference: i8,
    pub cap: Option<i8>,
    pub join: Option<i8>,
    pub dash: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub dash_cap: Option<i8>,
    pub miter_limit: Option<f64>,
}
impl<'a> Default for StrokeStyleArgs<'a> {
  #[inline]
  fn default() -> Self {
    StrokeStyleArgs {
      preference: 0,
      cap: None,
      join: None,
      dash: None,
      dash_cap: None,
      miter_limit: None,
    }
  }
}

pub struct StrokeStyleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StrokeStyleBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_preference(&mut self, preference: i8) {
    self.fbb_.push_slot::<i8>(StrokeStyle::VT_PREFERENCE, preference, 0);
  }
  #[inline]
  pub fn add_cap(&mut self, cap: i8) {
    self.fbb_.push_slot_always::<i8>(StrokeStyle::VT_CAP, cap);
  }
  #[inline]
  pub fn add_join(&mut self, join: i8) {
    self.fbb_.push_slot_always::<i8>(StrokeStyle::VT_JOIN, join);
  }
  #[inline]
  pub fn add_dash(&mut self, dash: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StrokeStyle::VT_DASH, dash);
  }
  #[inline]
  pub fn add_dash_cap(&mut self, dash_cap: i8) {
    self.fbb_.push_slot_always::<i8>(StrokeStyle::VT_DASH_CAP, dash_cap);
  }
  #[inline]
  pub fn add_miter_limit(&mut self, miter_limit: f64) {
    self.fbb_.push_slot_always::<f64>(StrokeStyle::VT_MITER_LIMIT, miter_limit);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StrokeStyleBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StrokeStyleBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StrokeStyle<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StrokeStyle<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StrokeStyle");
      ds.field("preference", &self.preference());
      ds.field("cap", &self.cap());
      ds.field("join", &self.join());
      ds.field("dash", &self.dash());
      ds.field("dash_cap", &self.dash_cap());
      ds.field("miter_limit", &self.miter_limit());
      ds.finish()
  }
}
pub enum StrokeSidesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct StrokeSides<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StrokeSides<'a> {
  type Inner = StrokeSides<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> StrokeSides<'a> {
  pub const VT_PREFERENCE: flatbuffers::VOffsetT = 4;
  pub const VT_VALUES: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StrokeSides { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StrokeSidesArgs<'args>
  ) -> flatbuffers::WIPOffset<StrokeSides<'bldr>> {
    let mut builder = StrokeSidesBuilder::new(_fbb);
    if let Some(x) = args.values { builder.add_values(x); }
    builder.add_preference(args.preference);
    builder.finish()
  }


  #[inline]
  pub fn preference(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(StrokeSides::VT_PREFERENCE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn values(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(StrokeSides::VT_VALUES, None)}
  }
}

impl flatbuffers::Verifiable for StrokeSides<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i8>("preference", Self::VT_PREFERENCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("values", Self::VT_VALUES, false)?
     .finish();
    Ok(())
  }
}
pub struct StrokeSidesArgs<'a> {
    pub preference: i8,
    pub values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
}
impl<'a> Default for StrokeSidesArgs<'a> {
  #[inline]
  fn default() -> Self {
    StrokeSidesArgs {
      preference: 0,
      values: None,
    }
  }
}

pub struct StrokeSidesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StrokeSidesBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_preference(&mut self, preference: i8) {
    self.fbb_.push_slot::<i8>(StrokeSides::VT_PREFERENCE, preference, 0);
  }
  #[inline]
  pub fn add_values(&mut self, values: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StrokeSides::VT_VALUES, values);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StrokeSidesBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StrokeSidesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StrokeSides<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StrokeSides<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StrokeSides");
      ds.field("preference", &self.preference());
      ds.field("values", &self.values());
      ds.finish()
  }
}
pub enum ElementStrokeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ElementStroke<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ElementStroke<'a> {
  type Inner = ElementStroke<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ElementStroke<'a> {
  pub const VT_CONTENT: flatbuffers::VOffsetT = 4;
  pub const VT_WIDTH: flatbuffers::VOffsetT = 6;
  pub const VT_STYLE: flatbuffers::VOffsetT = 8;
  pub const VT_PLACEMENT: flatbuffers::VOffsetT = 10;
  pub const VT_STROKE_SIDES: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ElementStroke { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ElementStrokeArgs<'args>
  ) -> flatbuffers::WIPOffset<ElementStroke<'bldr>> {
    let mut builder = ElementStrokeBuilder::new(_fbb);
    builder.add_width(args.width);
    if let Some(x) = args.stroke_sides { builder.add_stroke_sides(x); }
    if let Some(x) = args.style { builder.add_style(x); }
    if let Some(x) = args.content { builder.add_content(x); }
    builder.add_placement(args.placement);
    builder.finish()
  }


  #[inline]
  pub fn content(&self) -> Option<ElementContentBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ElementContentBase>>(ElementStroke::VT_CONTENT, None)}
  }
  #[inline]
  pub fn width(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ElementStroke::VT_WIDTH, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn style(&self) -> Option<StrokeStyle<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<StrokeStyle>>(ElementStroke::VT_STYLE, None)}
  }
  #[inline]
  pub fn placement(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(ElementStroke::VT_PLACEMENT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn stroke_sides(&self) -> Option<StrokeSides<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<StrokeSides>>(ElementStroke::VT_STROKE_SIDES, None)}
  }
}

impl flatbuffers::Verifiable for ElementStroke<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<ElementContentBase>>("content", Self::VT_CONTENT, false)?
     .visit_field::<f64>("width", Self::VT_WIDTH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<StrokeStyle>>("style", Self::VT_STYLE, false)?
     .visit_field::<i8>("placement", Self::VT_PLACEMENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<StrokeSides>>("stroke_sides", Self::VT_STROKE_SIDES, false)?
     .finish();
    Ok(())
  }
}
pub struct ElementStrokeArgs<'a> {
    pub content: Option<flatbuffers::WIPOffset<ElementContentBase<'a>>>,
    pub width: f64,
    pub style: Option<flatbuffers::WIPOffset<StrokeStyle<'a>>>,
    pub placement: i8,
    pub stroke_sides: Option<flatbuffers::WIPOffset<StrokeSides<'a>>>,
}
impl<'a> Default for ElementStrokeArgs<'a> {
  #[inline]
  fn default() -> Self {
    ElementStrokeArgs {
      content: None,
      width: 0.0,
      style: None,
      placement: 0,
      stroke_sides: None,
    }
  }
}

pub struct ElementStrokeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ElementStrokeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_content(&mut self, content: flatbuffers::WIPOffset<ElementContentBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ElementContentBase>>(ElementStroke::VT_CONTENT, content);
  }
  #[inline]
  pub fn add_width(&mut self, width: f64) {
    self.fbb_.push_slot::<f64>(ElementStroke::VT_WIDTH, width, 0.0);
  }
  #[inline]
  pub fn add_style(&mut self, style: flatbuffers::WIPOffset<StrokeStyle<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<StrokeStyle>>(ElementStroke::VT_STYLE, style);
  }
  #[inline]
  pub fn add_placement(&mut self, placement: i8) {
    self.fbb_.push_slot::<i8>(ElementStroke::VT_PLACEMENT, placement, 0);
  }
  #[inline]
  pub fn add_stroke_sides(&mut self, stroke_sides: flatbuffers::WIPOffset<StrokeSides<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<StrokeSides>>(ElementStroke::VT_STROKE_SIDES, stroke_sides);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ElementStrokeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ElementStrokeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ElementStroke<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ElementStroke<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ElementStroke");
      ds.field("content", &self.content());
      ds.field("width", &self.width());
      ds.field("style", &self.style());
      ds.field("placement", &self.placement());
      ds.field("stroke_sides", &self.stroke_sides());
      ds.finish()
  }
}
pub enum ElementBackgroundOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ElementBackground<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ElementBackground<'a> {
  type Inner = ElementBackground<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ElementBackground<'a> {
  pub const VT_CONTENT: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ElementBackground { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ElementBackgroundArgs<'args>
  ) -> flatbuffers::WIPOffset<ElementBackground<'bldr>> {
    let mut builder = ElementBackgroundBuilder::new(_fbb);
    if let Some(x) = args.content { builder.add_content(x); }
    builder.finish()
  }


  #[inline]
  pub fn content(&self) -> Option<ElementContentBase<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ElementContentBase>>(ElementBackground::VT_CONTENT, None)}
  }
}

impl flatbuffers::Verifiable for ElementBackground<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<ElementContentBase>>("content", Self::VT_CONTENT, false)?
     .finish();
    Ok(())
  }
}
pub struct ElementBackgroundArgs<'a> {
    pub content: Option<flatbuffers::WIPOffset<ElementContentBase<'a>>>,
}
impl<'a> Default for ElementBackgroundArgs<'a> {
  #[inline]
  fn default() -> Self {
    ElementBackgroundArgs {
      content: None,
    }
  }
}

pub struct ElementBackgroundBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ElementBackgroundBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_content(&mut self, content: flatbuffers::WIPOffset<ElementContentBase<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ElementContentBase>>(ElementBackground::VT_CONTENT, content);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ElementBackgroundBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ElementBackgroundBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ElementBackground<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ElementBackground<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ElementBackground");
      ds.field("content", &self.content());
      ds.finish()
  }
}
pub enum ImageCropOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ImageCrop<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ImageCrop<'a> {
  type Inner = ImageCrop<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ImageCrop<'a> {
  pub const VT_X: flatbuffers::VOffsetT = 4;
  pub const VT_Y: flatbuffers::VOffsetT = 6;
  pub const VT_WIDTH: flatbuffers::VOffsetT = 8;
  pub const VT_HEIGHT: flatbuffers::VOffsetT = 10;
  pub const VT_NATURAL_WIDTH: flatbuffers::VOffsetT = 12;
  pub const VT_NATURAL_HEIGHT: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ImageCrop { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ImageCropArgs
  ) -> flatbuffers::WIPOffset<ImageCrop<'bldr>> {
    let mut builder = ImageCropBuilder::new(_fbb);
    builder.add_natural_height(args.natural_height);
    builder.add_natural_width(args.natural_width);
    builder.add_height(args.height);
    builder.add_width(args.width);
    builder.add_y(args.y);
    builder.add_x(args.x);
    builder.finish()
  }


  #[inline]
  pub fn x(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ImageCrop::VT_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn y(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ImageCrop::VT_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn width(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ImageCrop::VT_WIDTH, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn height(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ImageCrop::VT_HEIGHT, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn natural_width(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ImageCrop::VT_NATURAL_WIDTH, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn natural_height(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(ImageCrop::VT_NATURAL_HEIGHT, Some(0.0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ImageCrop<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f64>("x", Self::VT_X, false)?
     .visit_field::<f64>("y", Self::VT_Y, false)?
     .visit_field::<f64>("width", Self::VT_WIDTH, false)?
     .visit_field::<f64>("height", Self::VT_HEIGHT, false)?
     .visit_field::<f64>("natural_width", Self::VT_NATURAL_WIDTH, false)?
     .visit_field::<f64>("natural_height", Self::VT_NATURAL_HEIGHT, false)?
     .finish();
    Ok(())
  }
}
pub struct ImageCropArgs {
    pub x: f64,
    pub y: f64,
    pub width: f64,
    pub height: f64,
    pub natural_width: f64,
    pub natural_height: f64,
}
impl<'a> Default for ImageCropArgs {
  #[inline]
  fn default() -> Self {
    ImageCropArgs {
      x: 0.0,
      y: 0.0,
      width: 0.0,
      height: 0.0,
      natural_width: 0.0,
      natural_height: 0.0,
    }
  }
}

pub struct ImageCropBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ImageCropBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_x(&mut self, x: f64) {
    self.fbb_.push_slot::<f64>(ImageCrop::VT_X, x, 0.0);
  }
  #[inline]
  pub fn add_y(&mut self, y: f64) {
    self.fbb_.push_slot::<f64>(ImageCrop::VT_Y, y, 0.0);
  }
  #[inline]
  pub fn add_width(&mut self, width: f64) {
    self.fbb_.push_slot::<f64>(ImageCrop::VT_WIDTH, width, 0.0);
  }
  #[inline]
  pub fn add_height(&mut self, height: f64) {
    self.fbb_.push_slot::<f64>(ImageCrop::VT_HEIGHT, height, 0.0);
  }
  #[inline]
  pub fn add_natural_width(&mut self, natural_width: f64) {
    self.fbb_.push_slot::<f64>(ImageCrop::VT_NATURAL_WIDTH, natural_width, 0.0);
  }
  #[inline]
  pub fn add_natural_height(&mut self, natural_height: f64) {
    self.fbb_.push_slot::<f64>(ImageCrop::VT_NATURAL_HEIGHT, natural_height, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ImageCropBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ImageCropBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ImageCrop<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ImageCrop<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ImageCrop");
      ds.field("x", &self.x());
      ds.field("y", &self.y());
      ds.field("width", &self.width());
      ds.field("height", &self.height());
      ds.field("natural_width", &self.natural_width());
      ds.field("natural_height", &self.natural_height());
      ds.finish()
  }
}
pub enum DucElementOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucElement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucElement<'a> {
  type Inner = DucElement<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucElement<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
  pub const VT_X_V2: flatbuffers::VOffsetT = 8;
  pub const VT_Y_V2: flatbuffers::VOffsetT = 10;
  pub const VT_SCOPE: flatbuffers::VOffsetT = 14;
  pub const VT_LABEL: flatbuffers::VOffsetT = 18;
  pub const VT_IS_VISIBLE: flatbuffers::VOffsetT = 20;
  pub const VT_BACKGROUND_COLOR_V3: flatbuffers::VOffsetT = 26;
  pub const VT_STROKE_COLOR_V3: flatbuffers::VOffsetT = 28;
  pub const VT_OPACITY: flatbuffers::VOffsetT = 38;
  pub const VT_WIDTH_V2: flatbuffers::VOffsetT = 40;
  pub const VT_HEIGHT_V2: flatbuffers::VOffsetT = 42;
  pub const VT_ANGLE_V2: flatbuffers::VOffsetT = 44;
  pub const VT_IS_DELETED: flatbuffers::VOffsetT = 46;
  pub const VT_GROUP_IDS: flatbuffers::VOffsetT = 48;
  pub const VT_FRAME_ID: flatbuffers::VOffsetT = 50;
  pub const VT_BOUND_ELEMENTS: flatbuffers::VOffsetT = 52;
  pub const VT_LINK: flatbuffers::VOffsetT = 54;
  pub const VT_LOCKED: flatbuffers::VOffsetT = 56;
  pub const VT_FONT_SIZE_V2: flatbuffers::VOffsetT = 64;
  pub const VT_FONT_FAMILY: flatbuffers::VOffsetT = 66;
  pub const VT_TEXT: flatbuffers::VOffsetT = 68;
  pub const VT_CONTAINER_ID: flatbuffers::VOffsetT = 74;
  pub const VT_LINE_HEIGHT_V2: flatbuffers::VOffsetT = 78;
  pub const VT_AUTO_RESIZE: flatbuffers::VOffsetT = 80;
  pub const VT_POINTS: flatbuffers::VOffsetT = 82;
  pub const VT_LAST_COMMITTED_POINT: flatbuffers::VOffsetT = 84;
  pub const VT_START_BINDING: flatbuffers::VOffsetT = 86;
  pub const VT_END_BINDING: flatbuffers::VOffsetT = 88;
  pub const VT_ELBOWED: flatbuffers::VOffsetT = 94;
  pub const VT_SIMULATE_PRESSURE: flatbuffers::VOffsetT = 98;
  pub const VT_FILE_ID: flatbuffers::VOffsetT = 100;
  pub const VT_STATUS: flatbuffers::VOffsetT = 102;
  pub const VT_IS_COLLAPSED: flatbuffers::VOffsetT = 106;
  pub const VT_NAME: flatbuffers::VOffsetT = 108;
  pub const VT_GROUP_ID_REF: flatbuffers::VOffsetT = 110;
  pub const VT_STROKE_STYLE_V3: flatbuffers::VOffsetT = 112;
  pub const VT_FILL_STYLE_V3: flatbuffers::VOffsetT = 114;
  pub const VT_TEXT_ALIGN_V3: flatbuffers::VOffsetT = 116;
  pub const VT_VERTICAL_ALIGN_V3: flatbuffers::VOffsetT = 118;
  pub const VT_X_V3: flatbuffers::VOffsetT = 120;
  pub const VT_Y_V3: flatbuffers::VOffsetT = 122;
  pub const VT_SCALE_V3: flatbuffers::VOffsetT = 124;
  pub const VT_PRESSURES_V3: flatbuffers::VOffsetT = 126;
  pub const VT_STROKE_WIDTH_V3: flatbuffers::VOffsetT = 128;
  pub const VT_ANGLE_V3: flatbuffers::VOffsetT = 130;
  pub const VT_ROUNDNESS: flatbuffers::VOffsetT = 132;
  pub const VT_WIDTH_V3: flatbuffers::VOffsetT = 134;
  pub const VT_HEIGHT_V3: flatbuffers::VOffsetT = 136;
  pub const VT_FONT_SIZE_V3: flatbuffers::VOffsetT = 138;
  pub const VT_LINE_HEIGHT_V3: flatbuffers::VOffsetT = 140;
  pub const VT_BLENDING: flatbuffers::VOffsetT = 142;
  pub const VT_BACKGROUND: flatbuffers::VOffsetT = 144;
  pub const VT_STROKE: flatbuffers::VOffsetT = 146;
  pub const VT_CROP: flatbuffers::VOffsetT = 148;
  pub const VT_CLIP: flatbuffers::VOffsetT = 150;
  pub const VT_SUBSET: flatbuffers::VOffsetT = 152;
  pub const VT_Z_INDEX: flatbuffers::VOffsetT = 154;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucElement { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucElementArgs<'args>
  ) -> flatbuffers::WIPOffset<DucElement<'bldr>> {
    let mut builder = DucElementBuilder::new(_fbb);
    if let Some(x) = args.line_height_v3 { builder.add_line_height_v3(x); }
    if let Some(x) = args.font_size_v3 { builder.add_font_size_v3(x); }
    builder.add_height_v3(args.height_v3);
    builder.add_width_v3(args.width_v3);
    builder.add_roundness(args.roundness);
    builder.add_angle_v3(args.angle_v3);
    builder.add_stroke_width_v3(args.stroke_width_v3);
    builder.add_y_v3(args.y_v3);
    builder.add_x_v3(args.x_v3);
    builder.add_z_index(args.z_index);
    if let Some(x) = args.crop { builder.add_crop(x); }
    if let Some(x) = args.stroke { builder.add_stroke(x); }
    if let Some(x) = args.background { builder.add_background(x); }
    if let Some(x) = args.pressures_v3 { builder.add_pressures_v3(x); }
    if let Some(x) = args.scale_v3 { builder.add_scale_v3(x); }
    if let Some(x) = args.group_id_ref { builder.add_group_id_ref(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    if let Some(x) = args.status { builder.add_status(x); }
    if let Some(x) = args.file_id { builder.add_file_id(x); }
    if let Some(x) = args.end_binding { builder.add_end_binding(x); }
    if let Some(x) = args.start_binding { builder.add_start_binding(x); }
    if let Some(x) = args.last_committed_point { builder.add_last_committed_point(x); }
    if let Some(x) = args.points { builder.add_points(x); }
    if let Some(x) = args.line_height_v2 { builder.add_line_height_v2(x); }
    if let Some(x) = args.container_id { builder.add_container_id(x); }
    if let Some(x) = args.text { builder.add_text(x); }
    if let Some(x) = args.font_family { builder.add_font_family(x); }
    if let Some(x) = args.font_size_v2 { builder.add_font_size_v2(x); }
    if let Some(x) = args.link { builder.add_link(x); }
    if let Some(x) = args.bound_elements { builder.add_bound_elements(x); }
    if let Some(x) = args.frame_id { builder.add_frame_id(x); }
    if let Some(x) = args.group_ids { builder.add_group_ids(x); }
    if let Some(x) = args.angle_v2 { builder.add_angle_v2(x); }
    if let Some(x) = args.height_v2 { builder.add_height_v2(x); }
    if let Some(x) = args.width_v2 { builder.add_width_v2(x); }
    builder.add_opacity(args.opacity);
    if let Some(x) = args.stroke_color_v3 { builder.add_stroke_color_v3(x); }
    if let Some(x) = args.background_color_v3 { builder.add_background_color_v3(x); }
    if let Some(x) = args.label { builder.add_label(x); }
    if let Some(x) = args.scope { builder.add_scope(x); }
    if let Some(x) = args.y_v2 { builder.add_y_v2(x); }
    if let Some(x) = args.x_v2 { builder.add_x_v2(x); }
    if let Some(x) = args.type_ { builder.add_type_(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    if let Some(x) = args.subset { builder.add_subset(x); }
    if let Some(x) = args.clip { builder.add_clip(x); }
    if let Some(x) = args.blending { builder.add_blending(x); }
    builder.add_vertical_align_v3(args.vertical_align_v3);
    if let Some(x) = args.text_align_v3 { builder.add_text_align_v3(x); }
    builder.add_fill_style_v3(args.fill_style_v3);
    builder.add_stroke_style_v3(args.stroke_style_v3);
    if let Some(x) = args.is_collapsed { builder.add_is_collapsed(x); }
    if let Some(x) = args.simulate_pressure { builder.add_simulate_pressure(x); }
    if let Some(x) = args.elbowed { builder.add_elbowed(x); }
    if let Some(x) = args.auto_resize { builder.add_auto_resize(x); }
    builder.add_locked(args.locked);
    builder.add_is_deleted(args.is_deleted);
    builder.add_is_visible(args.is_visible);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_ID, None)}
  }
  #[inline]
  pub fn type_(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_TYPE_, None)}
  }
  #[inline]
  pub fn x_v2(&self) -> Option<f32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucElement::VT_X_V2, None)}
  }
  #[inline]
  pub fn y_v2(&self) -> Option<f32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucElement::VT_Y_V2, None)}
  }
  #[inline]
  pub fn scope(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_SCOPE, None)}
  }
  #[inline]
  pub fn label(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_LABEL, None)}
  }
  #[inline]
  pub fn is_visible(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucElement::VT_IS_VISIBLE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn background_color_v3(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_BACKGROUND_COLOR_V3, None)}
  }
  #[inline]
  pub fn stroke_color_v3(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_STROKE_COLOR_V3, None)}
  }
  #[inline]
  pub fn opacity(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucElement::VT_OPACITY, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn width_v2(&self) -> Option<f32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucElement::VT_WIDTH_V2, None)}
  }
  #[inline]
  pub fn height_v2(&self) -> Option<f32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucElement::VT_HEIGHT_V2, None)}
  }
  #[inline]
  pub fn angle_v2(&self) -> Option<f32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucElement::VT_ANGLE_V2, None)}
  }
  #[inline]
  pub fn is_deleted(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucElement::VT_IS_DELETED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn group_ids(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(DucElement::VT_GROUP_IDS, None)}
  }
  #[inline]
  pub fn frame_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_FRAME_ID, None)}
  }
  #[inline]
  pub fn bound_elements(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BoundElement<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BoundElement>>>>(DucElement::VT_BOUND_ELEMENTS, None)}
  }
  #[inline]
  pub fn link(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_LINK, None)}
  }
  #[inline]
  pub fn locked(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucElement::VT_LOCKED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn font_size_v2(&self) -> Option<i32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DucElement::VT_FONT_SIZE_V2, None)}
  }
  #[inline]
  pub fn font_family(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_FONT_FAMILY, None)}
  }
  #[inline]
  pub fn text(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_TEXT, None)}
  }
  #[inline]
  pub fn container_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_CONTAINER_ID, None)}
  }
  #[inline]
  pub fn line_height_v2(&self) -> Option<f32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(DucElement::VT_LINE_HEIGHT_V2, None)}
  }
  #[inline]
  pub fn auto_resize(&self) -> Option<bool> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucElement::VT_AUTO_RESIZE, None)}
  }
  #[inline]
  pub fn points(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Point<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Point>>>>(DucElement::VT_POINTS, None)}
  }
  #[inline]
  pub fn last_committed_point(&self) -> Option<Point<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Point>>(DucElement::VT_LAST_COMMITTED_POINT, None)}
  }
  #[inline]
  pub fn start_binding(&self) -> Option<PointBinding<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<PointBinding>>(DucElement::VT_START_BINDING, None)}
  }
  #[inline]
  pub fn end_binding(&self) -> Option<PointBinding<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<PointBinding>>(DucElement::VT_END_BINDING, None)}
  }
  #[inline]
  pub fn elbowed(&self) -> Option<bool> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucElement::VT_ELBOWED, None)}
  }
  #[inline]
  pub fn simulate_pressure(&self) -> Option<bool> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucElement::VT_SIMULATE_PRESSURE, None)}
  }
  #[inline]
  pub fn file_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_FILE_ID, None)}
  }
  #[inline]
  pub fn status(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_STATUS, None)}
  }
  #[inline]
  pub fn is_collapsed(&self) -> Option<bool> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucElement::VT_IS_COLLAPSED, None)}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_NAME, None)}
  }
  #[inline]
  pub fn group_id_ref(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucElement::VT_GROUP_ID_REF, None)}
  }
  #[inline]
  pub fn stroke_style_v3(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(DucElement::VT_STROKE_STYLE_V3, Some(0)).unwrap()}
  }
  #[inline]
  pub fn fill_style_v3(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(DucElement::VT_FILL_STYLE_V3, Some(0)).unwrap()}
  }
  #[inline]
  pub fn text_align_v3(&self) -> Option<i8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(DucElement::VT_TEXT_ALIGN_V3, None)}
  }
  #[inline]
  pub fn vertical_align_v3(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(DucElement::VT_VERTICAL_ALIGN_V3, Some(0)).unwrap()}
  }
  #[inline]
  pub fn x_v3(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucElement::VT_X_V3, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn y_v3(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucElement::VT_Y_V3, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn scale_v3(&self) -> Option<SimplePoint<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SimplePoint>>(DucElement::VT_SCALE_V3, None)}
  }
  #[inline]
  pub fn pressures_v3(&self) -> Option<flatbuffers::Vector<'a, f64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(DucElement::VT_PRESSURES_V3, None)}
  }
  #[inline]
  pub fn stroke_width_v3(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucElement::VT_STROKE_WIDTH_V3, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn angle_v3(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucElement::VT_ANGLE_V3, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn roundness(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucElement::VT_ROUNDNESS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn width_v3(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucElement::VT_WIDTH_V3, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn height_v3(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucElement::VT_HEIGHT_V3, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn font_size_v3(&self) -> Option<f64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucElement::VT_FONT_SIZE_V3, None)}
  }
  #[inline]
  pub fn line_height_v3(&self) -> Option<f64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(DucElement::VT_LINE_HEIGHT_V3, None)}
  }
  #[inline]
  pub fn blending(&self) -> Option<i8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(DucElement::VT_BLENDING, None)}
  }
  #[inline]
  pub fn background(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ElementBackground<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ElementBackground>>>>(DucElement::VT_BACKGROUND, None)}
  }
  #[inline]
  pub fn stroke(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ElementStroke<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ElementStroke>>>>(DucElement::VT_STROKE, None)}
  }
  #[inline]
  pub fn crop(&self) -> Option<ImageCrop<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ImageCrop>>(DucElement::VT_CROP, None)}
  }
  #[inline]
  pub fn clip(&self) -> Option<bool> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucElement::VT_CLIP, None)}
  }
  #[inline]
  pub fn subset(&self) -> Option<i8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(DucElement::VT_SUBSET, None)}
  }
  #[inline]
  pub fn z_index(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(DucElement::VT_Z_INDEX, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for DucElement<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, false)?
     .visit_field::<f32>("x_v2", Self::VT_X_V2, false)?
     .visit_field::<f32>("y_v2", Self::VT_Y_V2, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("scope", Self::VT_SCOPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("label", Self::VT_LABEL, false)?
     .visit_field::<bool>("is_visible", Self::VT_IS_VISIBLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("background_color_v3", Self::VT_BACKGROUND_COLOR_V3, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("stroke_color_v3", Self::VT_STROKE_COLOR_V3, false)?
     .visit_field::<f32>("opacity", Self::VT_OPACITY, false)?
     .visit_field::<f32>("width_v2", Self::VT_WIDTH_V2, false)?
     .visit_field::<f32>("height_v2", Self::VT_HEIGHT_V2, false)?
     .visit_field::<f32>("angle_v2", Self::VT_ANGLE_V2, false)?
     .visit_field::<bool>("is_deleted", Self::VT_IS_DELETED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("group_ids", Self::VT_GROUP_IDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("frame_id", Self::VT_FRAME_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BoundElement>>>>("bound_elements", Self::VT_BOUND_ELEMENTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("link", Self::VT_LINK, false)?
     .visit_field::<bool>("locked", Self::VT_LOCKED, false)?
     .visit_field::<i32>("font_size_v2", Self::VT_FONT_SIZE_V2, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("font_family", Self::VT_FONT_FAMILY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("text", Self::VT_TEXT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("container_id", Self::VT_CONTAINER_ID, false)?
     .visit_field::<f32>("line_height_v2", Self::VT_LINE_HEIGHT_V2, false)?
     .visit_field::<bool>("auto_resize", Self::VT_AUTO_RESIZE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Point>>>>("points", Self::VT_POINTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Point>>("last_committed_point", Self::VT_LAST_COMMITTED_POINT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<PointBinding>>("start_binding", Self::VT_START_BINDING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<PointBinding>>("end_binding", Self::VT_END_BINDING, false)?
     .visit_field::<bool>("elbowed", Self::VT_ELBOWED, false)?
     .visit_field::<bool>("simulate_pressure", Self::VT_SIMULATE_PRESSURE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("file_id", Self::VT_FILE_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("status", Self::VT_STATUS, false)?
     .visit_field::<bool>("is_collapsed", Self::VT_IS_COLLAPSED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("group_id_ref", Self::VT_GROUP_ID_REF, false)?
     .visit_field::<i8>("stroke_style_v3", Self::VT_STROKE_STYLE_V3, false)?
     .visit_field::<i8>("fill_style_v3", Self::VT_FILL_STYLE_V3, false)?
     .visit_field::<i8>("text_align_v3", Self::VT_TEXT_ALIGN_V3, false)?
     .visit_field::<i8>("vertical_align_v3", Self::VT_VERTICAL_ALIGN_V3, false)?
     .visit_field::<f64>("x_v3", Self::VT_X_V3, false)?
     .visit_field::<f64>("y_v3", Self::VT_Y_V3, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SimplePoint>>("scale_v3", Self::VT_SCALE_V3, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>("pressures_v3", Self::VT_PRESSURES_V3, false)?
     .visit_field::<f64>("stroke_width_v3", Self::VT_STROKE_WIDTH_V3, false)?
     .visit_field::<f64>("angle_v3", Self::VT_ANGLE_V3, false)?
     .visit_field::<f64>("roundness", Self::VT_ROUNDNESS, false)?
     .visit_field::<f64>("width_v3", Self::VT_WIDTH_V3, false)?
     .visit_field::<f64>("height_v3", Self::VT_HEIGHT_V3, false)?
     .visit_field::<f64>("font_size_v3", Self::VT_FONT_SIZE_V3, false)?
     .visit_field::<f64>("line_height_v3", Self::VT_LINE_HEIGHT_V3, false)?
     .visit_field::<i8>("blending", Self::VT_BLENDING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ElementBackground>>>>("background", Self::VT_BACKGROUND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ElementStroke>>>>("stroke", Self::VT_STROKE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ImageCrop>>("crop", Self::VT_CROP, false)?
     .visit_field::<bool>("clip", Self::VT_CLIP, false)?
     .visit_field::<i8>("subset", Self::VT_SUBSET, false)?
     .visit_field::<i32>("z_index", Self::VT_Z_INDEX, false)?
     .finish();
    Ok(())
  }
}
pub struct DucElementArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
    pub x_v2: Option<f32>,
    pub y_v2: Option<f32>,
    pub scope: Option<flatbuffers::WIPOffset<&'a str>>,
    pub label: Option<flatbuffers::WIPOffset<&'a str>>,
    pub is_visible: bool,
    pub background_color_v3: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stroke_color_v3: Option<flatbuffers::WIPOffset<&'a str>>,
    pub opacity: f32,
    pub width_v2: Option<f32>,
    pub height_v2: Option<f32>,
    pub angle_v2: Option<f32>,
    pub is_deleted: bool,
    pub group_ids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub frame_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub bound_elements: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BoundElement<'a>>>>>,
    pub link: Option<flatbuffers::WIPOffset<&'a str>>,
    pub locked: bool,
    pub font_size_v2: Option<i32>,
    pub font_family: Option<flatbuffers::WIPOffset<&'a str>>,
    pub text: Option<flatbuffers::WIPOffset<&'a str>>,
    pub container_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub line_height_v2: Option<f32>,
    pub auto_resize: Option<bool>,
    pub points: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Point<'a>>>>>,
    pub last_committed_point: Option<flatbuffers::WIPOffset<Point<'a>>>,
    pub start_binding: Option<flatbuffers::WIPOffset<PointBinding<'a>>>,
    pub end_binding: Option<flatbuffers::WIPOffset<PointBinding<'a>>>,
    pub elbowed: Option<bool>,
    pub simulate_pressure: Option<bool>,
    pub file_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub status: Option<flatbuffers::WIPOffset<&'a str>>,
    pub is_collapsed: Option<bool>,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub group_id_ref: Option<flatbuffers::WIPOffset<&'a str>>,
    pub stroke_style_v3: i8,
    pub fill_style_v3: i8,
    pub text_align_v3: Option<i8>,
    pub vertical_align_v3: i8,
    pub x_v3: f64,
    pub y_v3: f64,
    pub scale_v3: Option<flatbuffers::WIPOffset<SimplePoint<'a>>>,
    pub pressures_v3: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
    pub stroke_width_v3: f64,
    pub angle_v3: f64,
    pub roundness: f64,
    pub width_v3: f64,
    pub height_v3: f64,
    pub font_size_v3: Option<f64>,
    pub line_height_v3: Option<f64>,
    pub blending: Option<i8>,
    pub background: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ElementBackground<'a>>>>>,
    pub stroke: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ElementStroke<'a>>>>>,
    pub crop: Option<flatbuffers::WIPOffset<ImageCrop<'a>>>,
    pub clip: Option<bool>,
    pub subset: Option<i8>,
    pub z_index: i32,
}
impl<'a> Default for DucElementArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucElementArgs {
      id: None,
      type_: None,
      x_v2: None,
      y_v2: None,
      scope: None,
      label: None,
      is_visible: false,
      background_color_v3: None,
      stroke_color_v3: None,
      opacity: 0.0,
      width_v2: None,
      height_v2: None,
      angle_v2: None,
      is_deleted: false,
      group_ids: None,
      frame_id: None,
      bound_elements: None,
      link: None,
      locked: false,
      font_size_v2: None,
      font_family: None,
      text: None,
      container_id: None,
      line_height_v2: None,
      auto_resize: None,
      points: None,
      last_committed_point: None,
      start_binding: None,
      end_binding: None,
      elbowed: None,
      simulate_pressure: None,
      file_id: None,
      status: None,
      is_collapsed: None,
      name: None,
      group_id_ref: None,
      stroke_style_v3: 0,
      fill_style_v3: 0,
      text_align_v3: None,
      vertical_align_v3: 0,
      x_v3: 0.0,
      y_v3: 0.0,
      scale_v3: None,
      pressures_v3: None,
      stroke_width_v3: 0.0,
      angle_v3: 0.0,
      roundness: 0.0,
      width_v3: 0.0,
      height_v3: 0.0,
      font_size_v3: None,
      line_height_v3: None,
      blending: None,
      background: None,
      stroke: None,
      crop: None,
      clip: None,
      subset: None,
      z_index: 0,
    }
  }
}

pub struct DucElementBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucElementBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_ID, id);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_x_v2(&mut self, x_v2: f32) {
    self.fbb_.push_slot_always::<f32>(DucElement::VT_X_V2, x_v2);
  }
  #[inline]
  pub fn add_y_v2(&mut self, y_v2: f32) {
    self.fbb_.push_slot_always::<f32>(DucElement::VT_Y_V2, y_v2);
  }
  #[inline]
  pub fn add_scope(&mut self, scope: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_SCOPE, scope);
  }
  #[inline]
  pub fn add_label(&mut self, label: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_LABEL, label);
  }
  #[inline]
  pub fn add_is_visible(&mut self, is_visible: bool) {
    self.fbb_.push_slot::<bool>(DucElement::VT_IS_VISIBLE, is_visible, false);
  }
  #[inline]
  pub fn add_background_color_v3(&mut self, background_color_v3: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_BACKGROUND_COLOR_V3, background_color_v3);
  }
  #[inline]
  pub fn add_stroke_color_v3(&mut self, stroke_color_v3: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_STROKE_COLOR_V3, stroke_color_v3);
  }
  #[inline]
  pub fn add_opacity(&mut self, opacity: f32) {
    self.fbb_.push_slot::<f32>(DucElement::VT_OPACITY, opacity, 0.0);
  }
  #[inline]
  pub fn add_width_v2(&mut self, width_v2: f32) {
    self.fbb_.push_slot_always::<f32>(DucElement::VT_WIDTH_V2, width_v2);
  }
  #[inline]
  pub fn add_height_v2(&mut self, height_v2: f32) {
    self.fbb_.push_slot_always::<f32>(DucElement::VT_HEIGHT_V2, height_v2);
  }
  #[inline]
  pub fn add_angle_v2(&mut self, angle_v2: f32) {
    self.fbb_.push_slot_always::<f32>(DucElement::VT_ANGLE_V2, angle_v2);
  }
  #[inline]
  pub fn add_is_deleted(&mut self, is_deleted: bool) {
    self.fbb_.push_slot::<bool>(DucElement::VT_IS_DELETED, is_deleted, false);
  }
  #[inline]
  pub fn add_group_ids(&mut self, group_ids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_GROUP_IDS, group_ids);
  }
  #[inline]
  pub fn add_frame_id(&mut self, frame_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_FRAME_ID, frame_id);
  }
  #[inline]
  pub fn add_bound_elements(&mut self, bound_elements: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BoundElement<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_BOUND_ELEMENTS, bound_elements);
  }
  #[inline]
  pub fn add_link(&mut self, link: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_LINK, link);
  }
  #[inline]
  pub fn add_locked(&mut self, locked: bool) {
    self.fbb_.push_slot::<bool>(DucElement::VT_LOCKED, locked, false);
  }
  #[inline]
  pub fn add_font_size_v2(&mut self, font_size_v2: i32) {
    self.fbb_.push_slot_always::<i32>(DucElement::VT_FONT_SIZE_V2, font_size_v2);
  }
  #[inline]
  pub fn add_font_family(&mut self, font_family: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_FONT_FAMILY, font_family);
  }
  #[inline]
  pub fn add_text(&mut self, text: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_TEXT, text);
  }
  #[inline]
  pub fn add_container_id(&mut self, container_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_CONTAINER_ID, container_id);
  }
  #[inline]
  pub fn add_line_height_v2(&mut self, line_height_v2: f32) {
    self.fbb_.push_slot_always::<f32>(DucElement::VT_LINE_HEIGHT_V2, line_height_v2);
  }
  #[inline]
  pub fn add_auto_resize(&mut self, auto_resize: bool) {
    self.fbb_.push_slot_always::<bool>(DucElement::VT_AUTO_RESIZE, auto_resize);
  }
  #[inline]
  pub fn add_points(&mut self, points: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Point<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_POINTS, points);
  }
  #[inline]
  pub fn add_last_committed_point(&mut self, last_committed_point: flatbuffers::WIPOffset<Point<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Point>>(DucElement::VT_LAST_COMMITTED_POINT, last_committed_point);
  }
  #[inline]
  pub fn add_start_binding(&mut self, start_binding: flatbuffers::WIPOffset<PointBinding<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PointBinding>>(DucElement::VT_START_BINDING, start_binding);
  }
  #[inline]
  pub fn add_end_binding(&mut self, end_binding: flatbuffers::WIPOffset<PointBinding<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PointBinding>>(DucElement::VT_END_BINDING, end_binding);
  }
  #[inline]
  pub fn add_elbowed(&mut self, elbowed: bool) {
    self.fbb_.push_slot_always::<bool>(DucElement::VT_ELBOWED, elbowed);
  }
  #[inline]
  pub fn add_simulate_pressure(&mut self, simulate_pressure: bool) {
    self.fbb_.push_slot_always::<bool>(DucElement::VT_SIMULATE_PRESSURE, simulate_pressure);
  }
  #[inline]
  pub fn add_file_id(&mut self, file_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_FILE_ID, file_id);
  }
  #[inline]
  pub fn add_status(&mut self, status: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_STATUS, status);
  }
  #[inline]
  pub fn add_is_collapsed(&mut self, is_collapsed: bool) {
    self.fbb_.push_slot_always::<bool>(DucElement::VT_IS_COLLAPSED, is_collapsed);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_NAME, name);
  }
  #[inline]
  pub fn add_group_id_ref(&mut self, group_id_ref: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_GROUP_ID_REF, group_id_ref);
  }
  #[inline]
  pub fn add_stroke_style_v3(&mut self, stroke_style_v3: i8) {
    self.fbb_.push_slot::<i8>(DucElement::VT_STROKE_STYLE_V3, stroke_style_v3, 0);
  }
  #[inline]
  pub fn add_fill_style_v3(&mut self, fill_style_v3: i8) {
    self.fbb_.push_slot::<i8>(DucElement::VT_FILL_STYLE_V3, fill_style_v3, 0);
  }
  #[inline]
  pub fn add_text_align_v3(&mut self, text_align_v3: i8) {
    self.fbb_.push_slot_always::<i8>(DucElement::VT_TEXT_ALIGN_V3, text_align_v3);
  }
  #[inline]
  pub fn add_vertical_align_v3(&mut self, vertical_align_v3: i8) {
    self.fbb_.push_slot::<i8>(DucElement::VT_VERTICAL_ALIGN_V3, vertical_align_v3, 0);
  }
  #[inline]
  pub fn add_x_v3(&mut self, x_v3: f64) {
    self.fbb_.push_slot::<f64>(DucElement::VT_X_V3, x_v3, 0.0);
  }
  #[inline]
  pub fn add_y_v3(&mut self, y_v3: f64) {
    self.fbb_.push_slot::<f64>(DucElement::VT_Y_V3, y_v3, 0.0);
  }
  #[inline]
  pub fn add_scale_v3(&mut self, scale_v3: flatbuffers::WIPOffset<SimplePoint<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SimplePoint>>(DucElement::VT_SCALE_V3, scale_v3);
  }
  #[inline]
  pub fn add_pressures_v3(&mut self, pressures_v3: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_PRESSURES_V3, pressures_v3);
  }
  #[inline]
  pub fn add_stroke_width_v3(&mut self, stroke_width_v3: f64) {
    self.fbb_.push_slot::<f64>(DucElement::VT_STROKE_WIDTH_V3, stroke_width_v3, 0.0);
  }
  #[inline]
  pub fn add_angle_v3(&mut self, angle_v3: f64) {
    self.fbb_.push_slot::<f64>(DucElement::VT_ANGLE_V3, angle_v3, 0.0);
  }
  #[inline]
  pub fn add_roundness(&mut self, roundness: f64) {
    self.fbb_.push_slot::<f64>(DucElement::VT_ROUNDNESS, roundness, 0.0);
  }
  #[inline]
  pub fn add_width_v3(&mut self, width_v3: f64) {
    self.fbb_.push_slot::<f64>(DucElement::VT_WIDTH_V3, width_v3, 0.0);
  }
  #[inline]
  pub fn add_height_v3(&mut self, height_v3: f64) {
    self.fbb_.push_slot::<f64>(DucElement::VT_HEIGHT_V3, height_v3, 0.0);
  }
  #[inline]
  pub fn add_font_size_v3(&mut self, font_size_v3: f64) {
    self.fbb_.push_slot_always::<f64>(DucElement::VT_FONT_SIZE_V3, font_size_v3);
  }
  #[inline]
  pub fn add_line_height_v3(&mut self, line_height_v3: f64) {
    self.fbb_.push_slot_always::<f64>(DucElement::VT_LINE_HEIGHT_V3, line_height_v3);
  }
  #[inline]
  pub fn add_blending(&mut self, blending: i8) {
    self.fbb_.push_slot_always::<i8>(DucElement::VT_BLENDING, blending);
  }
  #[inline]
  pub fn add_background(&mut self, background: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ElementBackground<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_BACKGROUND, background);
  }
  #[inline]
  pub fn add_stroke(&mut self, stroke: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ElementStroke<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucElement::VT_STROKE, stroke);
  }
  #[inline]
  pub fn add_crop(&mut self, crop: flatbuffers::WIPOffset<ImageCrop<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ImageCrop>>(DucElement::VT_CROP, crop);
  }
  #[inline]
  pub fn add_clip(&mut self, clip: bool) {
    self.fbb_.push_slot_always::<bool>(DucElement::VT_CLIP, clip);
  }
  #[inline]
  pub fn add_subset(&mut self, subset: i8) {
    self.fbb_.push_slot_always::<i8>(DucElement::VT_SUBSET, subset);
  }
  #[inline]
  pub fn add_z_index(&mut self, z_index: i32) {
    self.fbb_.push_slot::<i32>(DucElement::VT_Z_INDEX, z_index, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucElementBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucElementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucElement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucElement<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucElement");
      ds.field("id", &self.id());
      ds.field("type_", &self.type_());
      ds.field("x_v2", &self.x_v2());
      ds.field("y_v2", &self.y_v2());
      ds.field("scope", &self.scope());
      ds.field("label", &self.label());
      ds.field("is_visible", &self.is_visible());
      ds.field("background_color_v3", &self.background_color_v3());
      ds.field("stroke_color_v3", &self.stroke_color_v3());
      ds.field("opacity", &self.opacity());
      ds.field("width_v2", &self.width_v2());
      ds.field("height_v2", &self.height_v2());
      ds.field("angle_v2", &self.angle_v2());
      ds.field("is_deleted", &self.is_deleted());
      ds.field("group_ids", &self.group_ids());
      ds.field("frame_id", &self.frame_id());
      ds.field("bound_elements", &self.bound_elements());
      ds.field("link", &self.link());
      ds.field("locked", &self.locked());
      ds.field("font_size_v2", &self.font_size_v2());
      ds.field("font_family", &self.font_family());
      ds.field("text", &self.text());
      ds.field("container_id", &self.container_id());
      ds.field("line_height_v2", &self.line_height_v2());
      ds.field("auto_resize", &self.auto_resize());
      ds.field("points", &self.points());
      ds.field("last_committed_point", &self.last_committed_point());
      ds.field("start_binding", &self.start_binding());
      ds.field("end_binding", &self.end_binding());
      ds.field("elbowed", &self.elbowed());
      ds.field("simulate_pressure", &self.simulate_pressure());
      ds.field("file_id", &self.file_id());
      ds.field("status", &self.status());
      ds.field("is_collapsed", &self.is_collapsed());
      ds.field("name", &self.name());
      ds.field("group_id_ref", &self.group_id_ref());
      ds.field("stroke_style_v3", &self.stroke_style_v3());
      ds.field("fill_style_v3", &self.fill_style_v3());
      ds.field("text_align_v3", &self.text_align_v3());
      ds.field("vertical_align_v3", &self.vertical_align_v3());
      ds.field("x_v3", &self.x_v3());
      ds.field("y_v3", &self.y_v3());
      ds.field("scale_v3", &self.scale_v3());
      ds.field("pressures_v3", &self.pressures_v3());
      ds.field("stroke_width_v3", &self.stroke_width_v3());
      ds.field("angle_v3", &self.angle_v3());
      ds.field("roundness", &self.roundness());
      ds.field("width_v3", &self.width_v3());
      ds.field("height_v3", &self.height_v3());
      ds.field("font_size_v3", &self.font_size_v3());
      ds.field("line_height_v3", &self.line_height_v3());
      ds.field("blending", &self.blending());
      ds.field("background", &self.background());
      ds.field("stroke", &self.stroke());
      ds.field("crop", &self.crop());
      ds.field("clip", &self.clip());
      ds.field("subset", &self.subset());
      ds.field("z_index", &self.z_index());
      ds.finish()
  }
}
pub enum BoundElementOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BoundElement<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BoundElement<'a> {
  type Inner = BoundElement<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BoundElement<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BoundElement { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BoundElementArgs<'args>
  ) -> flatbuffers::WIPOffset<BoundElement<'bldr>> {
    let mut builder = BoundElementBuilder::new(_fbb);
    if let Some(x) = args.type_ { builder.add_type_(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BoundElement::VT_ID, None)}
  }
  #[inline]
  pub fn type_(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BoundElement::VT_TYPE_, None)}
  }
}

impl flatbuffers::Verifiable for BoundElement<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, false)?
     .finish();
    Ok(())
  }
}
pub struct BoundElementArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for BoundElementArgs<'a> {
  #[inline]
  fn default() -> Self {
    BoundElementArgs {
      id: None,
      type_: None,
    }
  }
}

pub struct BoundElementBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BoundElementBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BoundElement::VT_ID, id);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BoundElement::VT_TYPE_, type_);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BoundElementBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BoundElementBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BoundElement<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BoundElement<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BoundElement");
      ds.field("id", &self.id());
      ds.field("type_", &self.type_());
      ds.finish()
  }
}
pub enum SegmentMidpointStateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SegmentMidpointState<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SegmentMidpointState<'a> {
  type Inner = SegmentMidpointState<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SegmentMidpointState<'a> {
  pub const VT_VALUE: flatbuffers::VOffsetT = 4;
  pub const VT_INDEX: flatbuffers::VOffsetT = 6;
  pub const VT_ADDED: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SegmentMidpointState { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SegmentMidpointStateArgs<'args>
  ) -> flatbuffers::WIPOffset<SegmentMidpointState<'bldr>> {
    let mut builder = SegmentMidpointStateBuilder::new(_fbb);
    builder.add_index(args.index);
    if let Some(x) = args.value { builder.add_value(x); }
    builder.add_added(args.added);
    builder.finish()
  }


  #[inline]
  pub fn value(&self) -> Option<Point<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Point>>(SegmentMidpointState::VT_VALUE, None)}
  }
  #[inline]
  pub fn index(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(SegmentMidpointState::VT_INDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn added(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SegmentMidpointState::VT_ADDED, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for SegmentMidpointState<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<Point>>("value", Self::VT_VALUE, false)?
     .visit_field::<i32>("index", Self::VT_INDEX, false)?
     .visit_field::<bool>("added", Self::VT_ADDED, false)?
     .finish();
    Ok(())
  }
}
pub struct SegmentMidpointStateArgs<'a> {
    pub value: Option<flatbuffers::WIPOffset<Point<'a>>>,
    pub index: i32,
    pub added: bool,
}
impl<'a> Default for SegmentMidpointStateArgs<'a> {
  #[inline]
  fn default() -> Self {
    SegmentMidpointStateArgs {
      value: None,
      index: 0,
      added: false,
    }
  }
}

pub struct SegmentMidpointStateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SegmentMidpointStateBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<Point<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Point>>(SegmentMidpointState::VT_VALUE, value);
  }
  #[inline]
  pub fn add_index(&mut self, index: i32) {
    self.fbb_.push_slot::<i32>(SegmentMidpointState::VT_INDEX, index, 0);
  }
  #[inline]
  pub fn add_added(&mut self, added: bool) {
    self.fbb_.push_slot::<bool>(SegmentMidpointState::VT_ADDED, added, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SegmentMidpointStateBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SegmentMidpointStateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SegmentMidpointState<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SegmentMidpointState<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SegmentMidpointState");
      ds.field("value", &self.value());
      ds.field("index", &self.index());
      ds.field("added", &self.added());
      ds.finish()
  }
}
pub enum PointerDownStateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PointerDownState<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PointerDownState<'a> {
  type Inner = PointerDownState<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PointerDownState<'a> {
  pub const VT_PREV_SELECTED_POINTS_INDICES: flatbuffers::VOffsetT = 4;
  pub const VT_LAST_CLICKED_POINT: flatbuffers::VOffsetT = 6;
  pub const VT_LAST_CLICKED_IS_END_POINT: flatbuffers::VOffsetT = 8;
  pub const VT_ORIGIN: flatbuffers::VOffsetT = 10;
  pub const VT_SEGMENT_MIDPOINT: flatbuffers::VOffsetT = 12;
  pub const VT_HANDLE_TYPE: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PointerDownState { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PointerDownStateArgs<'args>
  ) -> flatbuffers::WIPOffset<PointerDownState<'bldr>> {
    let mut builder = PointerDownStateBuilder::new(_fbb);
    if let Some(x) = args.segment_midpoint { builder.add_segment_midpoint(x); }
    if let Some(x) = args.origin { builder.add_origin(x); }
    builder.add_last_clicked_point(args.last_clicked_point);
    if let Some(x) = args.prev_selected_points_indices { builder.add_prev_selected_points_indices(x); }
    if let Some(x) = args.handle_type { builder.add_handle_type(x); }
    builder.add_last_clicked_is_end_point(args.last_clicked_is_end_point);
    builder.finish()
  }


  #[inline]
  pub fn prev_selected_points_indices(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(PointerDownState::VT_PREV_SELECTED_POINTS_INDICES, None)}
  }
  #[inline]
  pub fn last_clicked_point(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(PointerDownState::VT_LAST_CLICKED_POINT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn last_clicked_is_end_point(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(PointerDownState::VT_LAST_CLICKED_IS_END_POINT, Some(false)).unwrap()}
  }
  #[inline]
  pub fn origin(&self) -> Option<SimplePoint<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SimplePoint>>(PointerDownState::VT_ORIGIN, None)}
  }
  #[inline]
  pub fn segment_midpoint(&self) -> Option<SegmentMidpointState<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SegmentMidpointState>>(PointerDownState::VT_SEGMENT_MIDPOINT, None)}
  }
  #[inline]
  pub fn handle_type(&self) -> Option<i8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(PointerDownState::VT_HANDLE_TYPE, None)}
  }
}

impl flatbuffers::Verifiable for PointerDownState<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("prev_selected_points_indices", Self::VT_PREV_SELECTED_POINTS_INDICES, false)?
     .visit_field::<i32>("last_clicked_point", Self::VT_LAST_CLICKED_POINT, false)?
     .visit_field::<bool>("last_clicked_is_end_point", Self::VT_LAST_CLICKED_IS_END_POINT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SimplePoint>>("origin", Self::VT_ORIGIN, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SegmentMidpointState>>("segment_midpoint", Self::VT_SEGMENT_MIDPOINT, false)?
     .visit_field::<i8>("handle_type", Self::VT_HANDLE_TYPE, false)?
     .finish();
    Ok(())
  }
}
pub struct PointerDownStateArgs<'a> {
    pub prev_selected_points_indices: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub last_clicked_point: i32,
    pub last_clicked_is_end_point: bool,
    pub origin: Option<flatbuffers::WIPOffset<SimplePoint<'a>>>,
    pub segment_midpoint: Option<flatbuffers::WIPOffset<SegmentMidpointState<'a>>>,
    pub handle_type: Option<i8>,
}
impl<'a> Default for PointerDownStateArgs<'a> {
  #[inline]
  fn default() -> Self {
    PointerDownStateArgs {
      prev_selected_points_indices: None,
      last_clicked_point: 0,
      last_clicked_is_end_point: false,
      origin: None,
      segment_midpoint: None,
      handle_type: None,
    }
  }
}

pub struct PointerDownStateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PointerDownStateBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_prev_selected_points_indices(&mut self, prev_selected_points_indices: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(PointerDownState::VT_PREV_SELECTED_POINTS_INDICES, prev_selected_points_indices);
  }
  #[inline]
  pub fn add_last_clicked_point(&mut self, last_clicked_point: i32) {
    self.fbb_.push_slot::<i32>(PointerDownState::VT_LAST_CLICKED_POINT, last_clicked_point, 0);
  }
  #[inline]
  pub fn add_last_clicked_is_end_point(&mut self, last_clicked_is_end_point: bool) {
    self.fbb_.push_slot::<bool>(PointerDownState::VT_LAST_CLICKED_IS_END_POINT, last_clicked_is_end_point, false);
  }
  #[inline]
  pub fn add_origin(&mut self, origin: flatbuffers::WIPOffset<SimplePoint<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SimplePoint>>(PointerDownState::VT_ORIGIN, origin);
  }
  #[inline]
  pub fn add_segment_midpoint(&mut self, segment_midpoint: flatbuffers::WIPOffset<SegmentMidpointState<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SegmentMidpointState>>(PointerDownState::VT_SEGMENT_MIDPOINT, segment_midpoint);
  }
  #[inline]
  pub fn add_handle_type(&mut self, handle_type: i8) {
    self.fbb_.push_slot_always::<i8>(PointerDownState::VT_HANDLE_TYPE, handle_type);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PointerDownStateBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PointerDownStateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PointerDownState<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PointerDownState<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PointerDownState");
      ds.field("prev_selected_points_indices", &self.prev_selected_points_indices());
      ds.field("last_clicked_point", &self.last_clicked_point());
      ds.field("last_clicked_is_end_point", &self.last_clicked_is_end_point());
      ds.field("origin", &self.origin());
      ds.field("segment_midpoint", &self.segment_midpoint());
      ds.field("handle_type", &self.handle_type());
      ds.finish()
  }
}
pub enum LinearElementEditorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LinearElementEditor<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LinearElementEditor<'a> {
  type Inner = LinearElementEditor<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LinearElementEditor<'a> {
  pub const VT_ELEMENT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_SELECTED_POINTS_INDICES: flatbuffers::VOffsetT = 6;
  pub const VT_POINTER_DOWN_STATE: flatbuffers::VOffsetT = 8;
  pub const VT_IS_DRAGGING: flatbuffers::VOffsetT = 10;
  pub const VT_LAST_UNCOMMITTED_POINT: flatbuffers::VOffsetT = 12;
  pub const VT_POINTER_OFFSET: flatbuffers::VOffsetT = 14;
  pub const VT_START_BINDING_ELEMENT: flatbuffers::VOffsetT = 16;
  pub const VT_END_BINDING_ELEMENT: flatbuffers::VOffsetT = 18;
  pub const VT_HOVER_POINT_INDEX: flatbuffers::VOffsetT = 20;
  pub const VT_SEGMENT_MID_POINT_HOVERED_COORDS: flatbuffers::VOffsetT = 22;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LinearElementEditor { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LinearElementEditorArgs<'args>
  ) -> flatbuffers::WIPOffset<LinearElementEditor<'bldr>> {
    let mut builder = LinearElementEditorBuilder::new(_fbb);
    if let Some(x) = args.segment_mid_point_hovered_coords { builder.add_segment_mid_point_hovered_coords(x); }
    builder.add_hover_point_index(args.hover_point_index);
    if let Some(x) = args.end_binding_element { builder.add_end_binding_element(x); }
    if let Some(x) = args.start_binding_element { builder.add_start_binding_element(x); }
    if let Some(x) = args.pointer_offset { builder.add_pointer_offset(x); }
    if let Some(x) = args.last_uncommitted_point { builder.add_last_uncommitted_point(x); }
    if let Some(x) = args.pointer_down_state { builder.add_pointer_down_state(x); }
    if let Some(x) = args.selected_points_indices { builder.add_selected_points_indices(x); }
    if let Some(x) = args.element_id { builder.add_element_id(x); }
    builder.add_is_dragging(args.is_dragging);
    builder.finish()
  }


  #[inline]
  pub fn element_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LinearElementEditor::VT_ELEMENT_ID, None)}
  }
  #[inline]
  pub fn selected_points_indices(&self) -> Option<flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(LinearElementEditor::VT_SELECTED_POINTS_INDICES, None)}
  }
  #[inline]
  pub fn pointer_down_state(&self) -> Option<PointerDownState<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<PointerDownState>>(LinearElementEditor::VT_POINTER_DOWN_STATE, None)}
  }
  #[inline]
  pub fn is_dragging(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(LinearElementEditor::VT_IS_DRAGGING, Some(false)).unwrap()}
  }
  #[inline]
  pub fn last_uncommitted_point(&self) -> Option<Point<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Point>>(LinearElementEditor::VT_LAST_UNCOMMITTED_POINT, None)}
  }
  #[inline]
  pub fn pointer_offset(&self) -> Option<SimplePoint<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<SimplePoint>>(LinearElementEditor::VT_POINTER_OFFSET, None)}
  }
  #[inline]
  pub fn start_binding_element(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LinearElementEditor::VT_START_BINDING_ELEMENT, None)}
  }
  #[inline]
  pub fn end_binding_element(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LinearElementEditor::VT_END_BINDING_ELEMENT, None)}
  }
  #[inline]
  pub fn hover_point_index(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(LinearElementEditor::VT_HOVER_POINT_INDEX, Some(0)).unwrap()}
  }
  #[inline]
  pub fn segment_mid_point_hovered_coords(&self) -> Option<Point<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<Point>>(LinearElementEditor::VT_SEGMENT_MID_POINT_HOVERED_COORDS, None)}
  }
}

impl flatbuffers::Verifiable for LinearElementEditor<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("element_id", Self::VT_ELEMENT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>("selected_points_indices", Self::VT_SELECTED_POINTS_INDICES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<PointerDownState>>("pointer_down_state", Self::VT_POINTER_DOWN_STATE, false)?
     .visit_field::<bool>("is_dragging", Self::VT_IS_DRAGGING, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Point>>("last_uncommitted_point", Self::VT_LAST_UNCOMMITTED_POINT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<SimplePoint>>("pointer_offset", Self::VT_POINTER_OFFSET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("start_binding_element", Self::VT_START_BINDING_ELEMENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("end_binding_element", Self::VT_END_BINDING_ELEMENT, false)?
     .visit_field::<i32>("hover_point_index", Self::VT_HOVER_POINT_INDEX, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<Point>>("segment_mid_point_hovered_coords", Self::VT_SEGMENT_MID_POINT_HOVERED_COORDS, false)?
     .finish();
    Ok(())
  }
}
pub struct LinearElementEditorArgs<'a> {
    pub element_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub selected_points_indices: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
    pub pointer_down_state: Option<flatbuffers::WIPOffset<PointerDownState<'a>>>,
    pub is_dragging: bool,
    pub last_uncommitted_point: Option<flatbuffers::WIPOffset<Point<'a>>>,
    pub pointer_offset: Option<flatbuffers::WIPOffset<SimplePoint<'a>>>,
    pub start_binding_element: Option<flatbuffers::WIPOffset<&'a str>>,
    pub end_binding_element: Option<flatbuffers::WIPOffset<&'a str>>,
    pub hover_point_index: i32,
    pub segment_mid_point_hovered_coords: Option<flatbuffers::WIPOffset<Point<'a>>>,
}
impl<'a> Default for LinearElementEditorArgs<'a> {
  #[inline]
  fn default() -> Self {
    LinearElementEditorArgs {
      element_id: None,
      selected_points_indices: None,
      pointer_down_state: None,
      is_dragging: false,
      last_uncommitted_point: None,
      pointer_offset: None,
      start_binding_element: None,
      end_binding_element: None,
      hover_point_index: 0,
      segment_mid_point_hovered_coords: None,
    }
  }
}

pub struct LinearElementEditorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LinearElementEditorBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_element_id(&mut self, element_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinearElementEditor::VT_ELEMENT_ID, element_id);
  }
  #[inline]
  pub fn add_selected_points_indices(&mut self, selected_points_indices: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinearElementEditor::VT_SELECTED_POINTS_INDICES, selected_points_indices);
  }
  #[inline]
  pub fn add_pointer_down_state(&mut self, pointer_down_state: flatbuffers::WIPOffset<PointerDownState<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<PointerDownState>>(LinearElementEditor::VT_POINTER_DOWN_STATE, pointer_down_state);
  }
  #[inline]
  pub fn add_is_dragging(&mut self, is_dragging: bool) {
    self.fbb_.push_slot::<bool>(LinearElementEditor::VT_IS_DRAGGING, is_dragging, false);
  }
  #[inline]
  pub fn add_last_uncommitted_point(&mut self, last_uncommitted_point: flatbuffers::WIPOffset<Point<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Point>>(LinearElementEditor::VT_LAST_UNCOMMITTED_POINT, last_uncommitted_point);
  }
  #[inline]
  pub fn add_pointer_offset(&mut self, pointer_offset: flatbuffers::WIPOffset<SimplePoint<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<SimplePoint>>(LinearElementEditor::VT_POINTER_OFFSET, pointer_offset);
  }
  #[inline]
  pub fn add_start_binding_element(&mut self, start_binding_element: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinearElementEditor::VT_START_BINDING_ELEMENT, start_binding_element);
  }
  #[inline]
  pub fn add_end_binding_element(&mut self, end_binding_element: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LinearElementEditor::VT_END_BINDING_ELEMENT, end_binding_element);
  }
  #[inline]
  pub fn add_hover_point_index(&mut self, hover_point_index: i32) {
    self.fbb_.push_slot::<i32>(LinearElementEditor::VT_HOVER_POINT_INDEX, hover_point_index, 0);
  }
  #[inline]
  pub fn add_segment_mid_point_hovered_coords(&mut self, segment_mid_point_hovered_coords: flatbuffers::WIPOffset<Point<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Point>>(LinearElementEditor::VT_SEGMENT_MID_POINT_HOVERED_COORDS, segment_mid_point_hovered_coords);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LinearElementEditorBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LinearElementEditorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LinearElementEditor<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LinearElementEditor<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LinearElementEditor");
      ds.field("element_id", &self.element_id());
      ds.field("selected_points_indices", &self.selected_points_indices());
      ds.field("pointer_down_state", &self.pointer_down_state());
      ds.field("is_dragging", &self.is_dragging());
      ds.field("last_uncommitted_point", &self.last_uncommitted_point());
      ds.field("pointer_offset", &self.pointer_offset());
      ds.field("start_binding_element", &self.start_binding_element());
      ds.field("end_binding_element", &self.end_binding_element());
      ds.field("hover_point_index", &self.hover_point_index());
      ds.field("segment_mid_point_hovered_coords", &self.segment_mid_point_hovered_coords());
      ds.finish()
  }
}
pub enum DucGroupOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DucGroup<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DucGroup<'a> {
  type Inner = DucGroup<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> DucGroup<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
  pub const VT_IS_COLLAPSED: flatbuffers::VOffsetT = 8;
  pub const VT_LABEL: flatbuffers::VOffsetT = 10;
  pub const VT_SCOPE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    DucGroup { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args DucGroupArgs<'args>
  ) -> flatbuffers::WIPOffset<DucGroup<'bldr>> {
    let mut builder = DucGroupBuilder::new(_fbb);
    if let Some(x) = args.scope { builder.add_scope(x); }
    if let Some(x) = args.label { builder.add_label(x); }
    if let Some(x) = args.type_ { builder.add_type_(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_is_collapsed(args.is_collapsed);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucGroup::VT_ID, None)}
  }
  #[inline]
  pub fn type_(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucGroup::VT_TYPE_, None)}
  }
  #[inline]
  pub fn is_collapsed(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(DucGroup::VT_IS_COLLAPSED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn label(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucGroup::VT_LABEL, None)}
  }
  #[inline]
  pub fn scope(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(DucGroup::VT_SCOPE, None)}
  }
}

impl flatbuffers::Verifiable for DucGroup<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, false)?
     .visit_field::<bool>("is_collapsed", Self::VT_IS_COLLAPSED, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("label", Self::VT_LABEL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("scope", Self::VT_SCOPE, false)?
     .finish();
    Ok(())
  }
}
pub struct DucGroupArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
    pub is_collapsed: bool,
    pub label: Option<flatbuffers::WIPOffset<&'a str>>,
    pub scope: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for DucGroupArgs<'a> {
  #[inline]
  fn default() -> Self {
    DucGroupArgs {
      id: None,
      type_: None,
      is_collapsed: false,
      label: None,
      scope: None,
    }
  }
}

pub struct DucGroupBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DucGroupBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucGroup::VT_ID, id);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucGroup::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_is_collapsed(&mut self, is_collapsed: bool) {
    self.fbb_.push_slot::<bool>(DucGroup::VT_IS_COLLAPSED, is_collapsed, false);
  }
  #[inline]
  pub fn add_label(&mut self, label: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucGroup::VT_LABEL, label);
  }
  #[inline]
  pub fn add_scope(&mut self, scope: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(DucGroup::VT_SCOPE, scope);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DucGroupBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    DucGroupBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<DucGroup<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for DucGroup<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("DucGroup");
      ds.field("id", &self.id());
      ds.field("type_", &self.type_());
      ds.field("is_collapsed", &self.is_collapsed());
      ds.field("label", &self.label());
      ds.field("scope", &self.scope());
      ds.finish()
  }
}
pub enum AppStateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AppState<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AppState<'a> {
  type Inner = AppState<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AppState<'a> {
  pub const VT_FRAME_RENDERING_ENABLED: flatbuffers::VOffsetT = 18;
  pub const VT_FRAME_RENDERING_NAME: flatbuffers::VOffsetT = 20;
  pub const VT_FRAME_RENDERING_OUTLINE: flatbuffers::VOffsetT = 22;
  pub const VT_FRAME_RENDERING_CLIP: flatbuffers::VOffsetT = 24;
  pub const VT_CURRENT_ITEM_OPACITY: flatbuffers::VOffsetT = 46;
  pub const VT_VIEW_BACKGROUND_COLOR: flatbuffers::VOffsetT = 60;
  pub const VT_SCOPE: flatbuffers::VOffsetT = 62;
  pub const VT_GROUPS: flatbuffers::VOffsetT = 66;
  pub const VT_SCROLL_X: flatbuffers::VOffsetT = 68;
  pub const VT_SCROLL_Y: flatbuffers::VOffsetT = 70;
  pub const VT_CURSOR_BUTTON: flatbuffers::VOffsetT = 72;
  pub const VT_SCROLLED_OUTSIDE: flatbuffers::VOffsetT = 74;
  pub const VT_NAME: flatbuffers::VOffsetT = 76;
  pub const VT_ZOOM: flatbuffers::VOffsetT = 78;
  pub const VT_LAST_POINTER_DOWN_WITH: flatbuffers::VOffsetT = 80;
  pub const VT_SELECTED_ELEMENT_IDS: flatbuffers::VOffsetT = 82;
  pub const VT_GRID_SIZE: flatbuffers::VOffsetT = 90;
  pub const VT_SCALE_RATIO_LOCKED: flatbuffers::VOffsetT = 100;
  pub const VT_DISPLAY_ALL_POINT_DISTANCES: flatbuffers::VOffsetT = 102;
  pub const VT_DISPLAY_DISTANCE_ON_DRAWING: flatbuffers::VOffsetT = 104;
  pub const VT_DISPLAY_ALL_POINT_COORDINATES: flatbuffers::VOffsetT = 106;
  pub const VT_DISPLAY_ALL_POINT_INFO_SELECTED: flatbuffers::VOffsetT = 108;
  pub const VT_DISPLAY_ROOT_AXIS: flatbuffers::VOffsetT = 110;
  pub const VT_CURRENT_ITEM_TEXT_ALIGN_V3: flatbuffers::VOffsetT = 122;
  pub const VT_LINE_BENDING_MODE: flatbuffers::VOffsetT = 124;
  pub const VT_CURRENT_ITEM_FONT_SIZE_V3: flatbuffers::VOffsetT = 130;
  pub const VT_COORD_DECIMAL_PLACES_V3: flatbuffers::VOffsetT = 132;
  pub const VT_CURRENT_ITEM_STROKE: flatbuffers::VOffsetT = 134;
  pub const VT_CURRENT_ITEM_BACKGROUND: flatbuffers::VOffsetT = 136;
  pub const VT_MAIN_SCOPE: flatbuffers::VOffsetT = 138;
  pub const VT_STANDARD: flatbuffers::VOffsetT = 140;
  pub const VT_CURRENT_ITEM_START_LINE_HEAD: flatbuffers::VOffsetT = 142;
  pub const VT_CURRENT_ITEM_END_LINE_HEAD: flatbuffers::VOffsetT = 144;
  pub const VT_CURRENT_ITEM_ROUNDNESS_V3: flatbuffers::VOffsetT = 146;
  pub const VT_ANTI_ALIASING: flatbuffers::VOffsetT = 148;
  pub const VT_V_SYNC: flatbuffers::VOffsetT = 150;
  pub const VT_CURRENT_ITEM_FONT_FAMILY_V2: flatbuffers::VOffsetT = 152;
  pub const VT_DEBUG_RENDERING: flatbuffers::VOffsetT = 154;
  pub const VT_CURRENT_ITEM_SUBSET: flatbuffers::VOffsetT = 156;
  pub const VT_EDITING_LINEAR_ELEMENT: flatbuffers::VOffsetT = 158;
  pub const VT_GRID_MODE_ENABLED: flatbuffers::VOffsetT = 160;
  pub const VT_GRID_STEP: flatbuffers::VOffsetT = 162;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AppState { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args AppStateArgs<'args>
  ) -> flatbuffers::WIPOffset<AppState<'bldr>> {
    let mut builder = AppStateBuilder::new(_fbb);
    builder.add_current_item_roundness_v3(args.current_item_roundness_v3);
    builder.add_current_item_font_size_v3(args.current_item_font_size_v3);
    builder.add_grid_step(args.grid_step);
    if let Some(x) = args.editing_linear_element { builder.add_editing_linear_element(x); }
    if let Some(x) = args.current_item_font_family_v2 { builder.add_current_item_font_family_v2(x); }
    if let Some(x) = args.main_scope { builder.add_main_scope(x); }
    if let Some(x) = args.current_item_background { builder.add_current_item_background(x); }
    if let Some(x) = args.current_item_stroke { builder.add_current_item_stroke(x); }
    builder.add_grid_size(args.grid_size);
    if let Some(x) = args.selected_element_ids { builder.add_selected_element_ids(x); }
    if let Some(x) = args.last_pointer_down_with { builder.add_last_pointer_down_with(x); }
    builder.add_zoom(args.zoom);
    if let Some(x) = args.name { builder.add_name(x); }
    if let Some(x) = args.cursor_button { builder.add_cursor_button(x); }
    builder.add_scroll_y(args.scroll_y);
    builder.add_scroll_x(args.scroll_x);
    if let Some(x) = args.groups { builder.add_groups(x); }
    if let Some(x) = args.scope { builder.add_scope(x); }
    if let Some(x) = args.view_background_color { builder.add_view_background_color(x); }
    builder.add_current_item_opacity(args.current_item_opacity);
    builder.add_grid_mode_enabled(args.grid_mode_enabled);
    if let Some(x) = args.current_item_subset { builder.add_current_item_subset(x); }
    builder.add_debug_rendering(args.debug_rendering);
    builder.add_v_sync(args.v_sync);
    builder.add_anti_aliasing(args.anti_aliasing);
    if let Some(x) = args.current_item_end_line_head { builder.add_current_item_end_line_head(x); }
    if let Some(x) = args.current_item_start_line_head { builder.add_current_item_start_line_head(x); }
    builder.add_standard(args.standard);
    builder.add_coord_decimal_places_v3(args.coord_decimal_places_v3);
    builder.add_line_bending_mode(args.line_bending_mode);
    builder.add_current_item_text_align_v3(args.current_item_text_align_v3);
    builder.add_display_root_axis(args.display_root_axis);
    builder.add_display_all_point_info_selected(args.display_all_point_info_selected);
    builder.add_display_all_point_coordinates(args.display_all_point_coordinates);
    builder.add_display_distance_on_drawing(args.display_distance_on_drawing);
    builder.add_display_all_point_distances(args.display_all_point_distances);
    builder.add_scale_ratio_locked(args.scale_ratio_locked);
    builder.add_scrolled_outside(args.scrolled_outside);
    builder.add_frame_rendering_clip(args.frame_rendering_clip);
    builder.add_frame_rendering_outline(args.frame_rendering_outline);
    builder.add_frame_rendering_name(args.frame_rendering_name);
    builder.add_frame_rendering_enabled(args.frame_rendering_enabled);
    builder.finish()
  }


  #[inline]
  pub fn frame_rendering_enabled(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_FRAME_RENDERING_ENABLED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn frame_rendering_name(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_FRAME_RENDERING_NAME, Some(false)).unwrap()}
  }
  #[inline]
  pub fn frame_rendering_outline(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_FRAME_RENDERING_OUTLINE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn frame_rendering_clip(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_FRAME_RENDERING_CLIP, Some(false)).unwrap()}
  }
  #[inline]
  pub fn current_item_opacity(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(AppState::VT_CURRENT_ITEM_OPACITY, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn view_background_color(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_VIEW_BACKGROUND_COLOR, None)}
  }
  #[inline]
  pub fn scope(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_SCOPE, None)}
  }
  #[inline]
  pub fn groups(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucGroup<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucGroup>>>>(AppState::VT_GROUPS, None)}
  }
  #[inline]
  pub fn scroll_x(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(AppState::VT_SCROLL_X, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn scroll_y(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(AppState::VT_SCROLL_Y, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn cursor_button(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_CURSOR_BUTTON, None)}
  }
  #[inline]
  pub fn scrolled_outside(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_SCROLLED_OUTSIDE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_NAME, None)}
  }
  #[inline]
  pub fn zoom(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(AppState::VT_ZOOM, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn last_pointer_down_with(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_LAST_POINTER_DOWN_WITH, None)}
  }
  #[inline]
  pub fn selected_element_ids(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(AppState::VT_SELECTED_ELEMENT_IDS, None)}
  }
  #[inline]
  pub fn grid_size(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AppState::VT_GRID_SIZE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn scale_ratio_locked(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_SCALE_RATIO_LOCKED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn display_all_point_distances(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_DISPLAY_ALL_POINT_DISTANCES, Some(false)).unwrap()}
  }
  #[inline]
  pub fn display_distance_on_drawing(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_DISPLAY_DISTANCE_ON_DRAWING, Some(false)).unwrap()}
  }
  #[inline]
  pub fn display_all_point_coordinates(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_DISPLAY_ALL_POINT_COORDINATES, Some(false)).unwrap()}
  }
  #[inline]
  pub fn display_all_point_info_selected(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_DISPLAY_ALL_POINT_INFO_SELECTED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn display_root_axis(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_DISPLAY_ROOT_AXIS, Some(false)).unwrap()}
  }
  #[inline]
  pub fn current_item_text_align_v3(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(AppState::VT_CURRENT_ITEM_TEXT_ALIGN_V3, Some(0)).unwrap()}
  }
  #[inline]
  pub fn line_bending_mode(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_LINE_BENDING_MODE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn current_item_font_size_v3(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AppState::VT_CURRENT_ITEM_FONT_SIZE_V3, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn coord_decimal_places_v3(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(AppState::VT_COORD_DECIMAL_PLACES_V3, Some(0)).unwrap()}
  }
  #[inline]
  pub fn current_item_stroke(&self) -> Option<ElementStroke<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ElementStroke>>(AppState::VT_CURRENT_ITEM_STROKE, None)}
  }
  #[inline]
  pub fn current_item_background(&self) -> Option<ElementBackground<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ElementBackground>>(AppState::VT_CURRENT_ITEM_BACKGROUND, None)}
  }
  #[inline]
  pub fn main_scope(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_MAIN_SCOPE, None)}
  }
  #[inline]
  pub fn standard(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(AppState::VT_STANDARD, Some(0)).unwrap()}
  }
  #[inline]
  pub fn current_item_start_line_head(&self) -> Option<i8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(AppState::VT_CURRENT_ITEM_START_LINE_HEAD, None)}
  }
  #[inline]
  pub fn current_item_end_line_head(&self) -> Option<i8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(AppState::VT_CURRENT_ITEM_END_LINE_HEAD, None)}
  }
  #[inline]
  pub fn current_item_roundness_v3(&self) -> f64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f64>(AppState::VT_CURRENT_ITEM_ROUNDNESS_V3, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn anti_aliasing(&self) -> i8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(AppState::VT_ANTI_ALIASING, Some(0)).unwrap()}
  }
  #[inline]
  pub fn v_sync(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_V_SYNC, Some(false)).unwrap()}
  }
  #[inline]
  pub fn current_item_font_family_v2(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(AppState::VT_CURRENT_ITEM_FONT_FAMILY_V2, None)}
  }
  #[inline]
  pub fn debug_rendering(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_DEBUG_RENDERING, Some(false)).unwrap()}
  }
  #[inline]
  pub fn current_item_subset(&self) -> Option<i8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i8>(AppState::VT_CURRENT_ITEM_SUBSET, None)}
  }
  #[inline]
  pub fn editing_linear_element(&self) -> Option<LinearElementEditor<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<LinearElementEditor>>(AppState::VT_EDITING_LINEAR_ELEMENT, None)}
  }
  #[inline]
  pub fn grid_mode_enabled(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(AppState::VT_GRID_MODE_ENABLED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn grid_step(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(AppState::VT_GRID_STEP, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for AppState<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("frame_rendering_enabled", Self::VT_FRAME_RENDERING_ENABLED, false)?
     .visit_field::<bool>("frame_rendering_name", Self::VT_FRAME_RENDERING_NAME, false)?
     .visit_field::<bool>("frame_rendering_outline", Self::VT_FRAME_RENDERING_OUTLINE, false)?
     .visit_field::<bool>("frame_rendering_clip", Self::VT_FRAME_RENDERING_CLIP, false)?
     .visit_field::<f32>("current_item_opacity", Self::VT_CURRENT_ITEM_OPACITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("view_background_color", Self::VT_VIEW_BACKGROUND_COLOR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("scope", Self::VT_SCOPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DucGroup>>>>("groups", Self::VT_GROUPS, false)?
     .visit_field::<f32>("scroll_x", Self::VT_SCROLL_X, false)?
     .visit_field::<f32>("scroll_y", Self::VT_SCROLL_Y, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("cursor_button", Self::VT_CURSOR_BUTTON, false)?
     .visit_field::<bool>("scrolled_outside", Self::VT_SCROLLED_OUTSIDE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<f32>("zoom", Self::VT_ZOOM, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("last_pointer_down_with", Self::VT_LAST_POINTER_DOWN_WITH, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("selected_element_ids", Self::VT_SELECTED_ELEMENT_IDS, false)?
     .visit_field::<i32>("grid_size", Self::VT_GRID_SIZE, false)?
     .visit_field::<bool>("scale_ratio_locked", Self::VT_SCALE_RATIO_LOCKED, false)?
     .visit_field::<bool>("display_all_point_distances", Self::VT_DISPLAY_ALL_POINT_DISTANCES, false)?
     .visit_field::<bool>("display_distance_on_drawing", Self::VT_DISPLAY_DISTANCE_ON_DRAWING, false)?
     .visit_field::<bool>("display_all_point_coordinates", Self::VT_DISPLAY_ALL_POINT_COORDINATES, false)?
     .visit_field::<bool>("display_all_point_info_selected", Self::VT_DISPLAY_ALL_POINT_INFO_SELECTED, false)?
     .visit_field::<bool>("display_root_axis", Self::VT_DISPLAY_ROOT_AXIS, false)?
     .visit_field::<i8>("current_item_text_align_v3", Self::VT_CURRENT_ITEM_TEXT_ALIGN_V3, false)?
     .visit_field::<bool>("line_bending_mode", Self::VT_LINE_BENDING_MODE, false)?
     .visit_field::<f64>("current_item_font_size_v3", Self::VT_CURRENT_ITEM_FONT_SIZE_V3, false)?
     .visit_field::<i8>("coord_decimal_places_v3", Self::VT_COORD_DECIMAL_PLACES_V3, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ElementStroke>>("current_item_stroke", Self::VT_CURRENT_ITEM_STROKE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<ElementBackground>>("current_item_background", Self::VT_CURRENT_ITEM_BACKGROUND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("main_scope", Self::VT_MAIN_SCOPE, false)?
     .visit_field::<i8>("standard", Self::VT_STANDARD, false)?
     .visit_field::<i8>("current_item_start_line_head", Self::VT_CURRENT_ITEM_START_LINE_HEAD, false)?
     .visit_field::<i8>("current_item_end_line_head", Self::VT_CURRENT_ITEM_END_LINE_HEAD, false)?
     .visit_field::<f64>("current_item_roundness_v3", Self::VT_CURRENT_ITEM_ROUNDNESS_V3, false)?
     .visit_field::<i8>("anti_aliasing", Self::VT_ANTI_ALIASING, false)?
     .visit_field::<bool>("v_sync", Self::VT_V_SYNC, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("current_item_font_family_v2", Self::VT_CURRENT_ITEM_FONT_FAMILY_V2, false)?
     .visit_field::<bool>("debug_rendering", Self::VT_DEBUG_RENDERING, false)?
     .visit_field::<i8>("current_item_subset", Self::VT_CURRENT_ITEM_SUBSET, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<LinearElementEditor>>("editing_linear_element", Self::VT_EDITING_LINEAR_ELEMENT, false)?
     .visit_field::<bool>("grid_mode_enabled", Self::VT_GRID_MODE_ENABLED, false)?
     .visit_field::<i32>("grid_step", Self::VT_GRID_STEP, false)?
     .finish();
    Ok(())
  }
}
pub struct AppStateArgs<'a> {
    pub frame_rendering_enabled: bool,
    pub frame_rendering_name: bool,
    pub frame_rendering_outline: bool,
    pub frame_rendering_clip: bool,
    pub current_item_opacity: f32,
    pub view_background_color: Option<flatbuffers::WIPOffset<&'a str>>,
    pub scope: Option<flatbuffers::WIPOffset<&'a str>>,
    pub groups: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucGroup<'a>>>>>,
    pub scroll_x: f32,
    pub scroll_y: f32,
    pub cursor_button: Option<flatbuffers::WIPOffset<&'a str>>,
    pub scrolled_outside: bool,
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub zoom: f32,
    pub last_pointer_down_with: Option<flatbuffers::WIPOffset<&'a str>>,
    pub selected_element_ids: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub grid_size: i32,
    pub scale_ratio_locked: bool,
    pub display_all_point_distances: bool,
    pub display_distance_on_drawing: bool,
    pub display_all_point_coordinates: bool,
    pub display_all_point_info_selected: bool,
    pub display_root_axis: bool,
    pub current_item_text_align_v3: i8,
    pub line_bending_mode: bool,
    pub current_item_font_size_v3: f64,
    pub coord_decimal_places_v3: i8,
    pub current_item_stroke: Option<flatbuffers::WIPOffset<ElementStroke<'a>>>,
    pub current_item_background: Option<flatbuffers::WIPOffset<ElementBackground<'a>>>,
    pub main_scope: Option<flatbuffers::WIPOffset<&'a str>>,
    pub standard: i8,
    pub current_item_start_line_head: Option<i8>,
    pub current_item_end_line_head: Option<i8>,
    pub current_item_roundness_v3: f64,
    pub anti_aliasing: i8,
    pub v_sync: bool,
    pub current_item_font_family_v2: Option<flatbuffers::WIPOffset<&'a str>>,
    pub debug_rendering: bool,
    pub current_item_subset: Option<i8>,
    pub editing_linear_element: Option<flatbuffers::WIPOffset<LinearElementEditor<'a>>>,
    pub grid_mode_enabled: bool,
    pub grid_step: i32,
}
impl<'a> Default for AppStateArgs<'a> {
  #[inline]
  fn default() -> Self {
    AppStateArgs {
      frame_rendering_enabled: false,
      frame_rendering_name: false,
      frame_rendering_outline: false,
      frame_rendering_clip: false,
      current_item_opacity: 0.0,
      view_background_color: None,
      scope: None,
      groups: None,
      scroll_x: 0.0,
      scroll_y: 0.0,
      cursor_button: None,
      scrolled_outside: false,
      name: None,
      zoom: 0.0,
      last_pointer_down_with: None,
      selected_element_ids: None,
      grid_size: 0,
      scale_ratio_locked: false,
      display_all_point_distances: false,
      display_distance_on_drawing: false,
      display_all_point_coordinates: false,
      display_all_point_info_selected: false,
      display_root_axis: false,
      current_item_text_align_v3: 0,
      line_bending_mode: false,
      current_item_font_size_v3: 0.0,
      coord_decimal_places_v3: 0,
      current_item_stroke: None,
      current_item_background: None,
      main_scope: None,
      standard: 0,
      current_item_start_line_head: None,
      current_item_end_line_head: None,
      current_item_roundness_v3: 0.0,
      anti_aliasing: 0,
      v_sync: false,
      current_item_font_family_v2: None,
      debug_rendering: false,
      current_item_subset: None,
      editing_linear_element: None,
      grid_mode_enabled: false,
      grid_step: 0,
    }
  }
}

pub struct AppStateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AppStateBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_frame_rendering_enabled(&mut self, frame_rendering_enabled: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_FRAME_RENDERING_ENABLED, frame_rendering_enabled, false);
  }
  #[inline]
  pub fn add_frame_rendering_name(&mut self, frame_rendering_name: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_FRAME_RENDERING_NAME, frame_rendering_name, false);
  }
  #[inline]
  pub fn add_frame_rendering_outline(&mut self, frame_rendering_outline: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_FRAME_RENDERING_OUTLINE, frame_rendering_outline, false);
  }
  #[inline]
  pub fn add_frame_rendering_clip(&mut self, frame_rendering_clip: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_FRAME_RENDERING_CLIP, frame_rendering_clip, false);
  }
  #[inline]
  pub fn add_current_item_opacity(&mut self, current_item_opacity: f32) {
    self.fbb_.push_slot::<f32>(AppState::VT_CURRENT_ITEM_OPACITY, current_item_opacity, 0.0);
  }
  #[inline]
  pub fn add_view_background_color(&mut self, view_background_color: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_VIEW_BACKGROUND_COLOR, view_background_color);
  }
  #[inline]
  pub fn add_scope(&mut self, scope: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_SCOPE, scope);
  }
  #[inline]
  pub fn add_groups(&mut self, groups: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DucGroup<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_GROUPS, groups);
  }
  #[inline]
  pub fn add_scroll_x(&mut self, scroll_x: f32) {
    self.fbb_.push_slot::<f32>(AppState::VT_SCROLL_X, scroll_x, 0.0);
  }
  #[inline]
  pub fn add_scroll_y(&mut self, scroll_y: f32) {
    self.fbb_.push_slot::<f32>(AppState::VT_SCROLL_Y, scroll_y, 0.0);
  }
  #[inline]
  pub fn add_cursor_button(&mut self, cursor_button: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_CURSOR_BUTTON, cursor_button);
  }
  #[inline]
  pub fn add_scrolled_outside(&mut self, scrolled_outside: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_SCROLLED_OUTSIDE, scrolled_outside, false);
  }
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_NAME, name);
  }
  #[inline]
  pub fn add_zoom(&mut self, zoom: f32) {
    self.fbb_.push_slot::<f32>(AppState::VT_ZOOM, zoom, 0.0);
  }
  #[inline]
  pub fn add_last_pointer_down_with(&mut self, last_pointer_down_with: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_LAST_POINTER_DOWN_WITH, last_pointer_down_with);
  }
  #[inline]
  pub fn add_selected_element_ids(&mut self, selected_element_ids: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_SELECTED_ELEMENT_IDS, selected_element_ids);
  }
  #[inline]
  pub fn add_grid_size(&mut self, grid_size: i32) {
    self.fbb_.push_slot::<i32>(AppState::VT_GRID_SIZE, grid_size, 0);
  }
  #[inline]
  pub fn add_scale_ratio_locked(&mut self, scale_ratio_locked: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_SCALE_RATIO_LOCKED, scale_ratio_locked, false);
  }
  #[inline]
  pub fn add_display_all_point_distances(&mut self, display_all_point_distances: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_DISPLAY_ALL_POINT_DISTANCES, display_all_point_distances, false);
  }
  #[inline]
  pub fn add_display_distance_on_drawing(&mut self, display_distance_on_drawing: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_DISPLAY_DISTANCE_ON_DRAWING, display_distance_on_drawing, false);
  }
  #[inline]
  pub fn add_display_all_point_coordinates(&mut self, display_all_point_coordinates: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_DISPLAY_ALL_POINT_COORDINATES, display_all_point_coordinates, false);
  }
  #[inline]
  pub fn add_display_all_point_info_selected(&mut self, display_all_point_info_selected: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_DISPLAY_ALL_POINT_INFO_SELECTED, display_all_point_info_selected, false);
  }
  #[inline]
  pub fn add_display_root_axis(&mut self, display_root_axis: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_DISPLAY_ROOT_AXIS, display_root_axis, false);
  }
  #[inline]
  pub fn add_current_item_text_align_v3(&mut self, current_item_text_align_v3: i8) {
    self.fbb_.push_slot::<i8>(AppState::VT_CURRENT_ITEM_TEXT_ALIGN_V3, current_item_text_align_v3, 0);
  }
  #[inline]
  pub fn add_line_bending_mode(&mut self, line_bending_mode: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_LINE_BENDING_MODE, line_bending_mode, false);
  }
  #[inline]
  pub fn add_current_item_font_size_v3(&mut self, current_item_font_size_v3: f64) {
    self.fbb_.push_slot::<f64>(AppState::VT_CURRENT_ITEM_FONT_SIZE_V3, current_item_font_size_v3, 0.0);
  }
  #[inline]
  pub fn add_coord_decimal_places_v3(&mut self, coord_decimal_places_v3: i8) {
    self.fbb_.push_slot::<i8>(AppState::VT_COORD_DECIMAL_PLACES_V3, coord_decimal_places_v3, 0);
  }
  #[inline]
  pub fn add_current_item_stroke(&mut self, current_item_stroke: flatbuffers::WIPOffset<ElementStroke<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ElementStroke>>(AppState::VT_CURRENT_ITEM_STROKE, current_item_stroke);
  }
  #[inline]
  pub fn add_current_item_background(&mut self, current_item_background: flatbuffers::WIPOffset<ElementBackground<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ElementBackground>>(AppState::VT_CURRENT_ITEM_BACKGROUND, current_item_background);
  }
  #[inline]
  pub fn add_main_scope(&mut self, main_scope: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_MAIN_SCOPE, main_scope);
  }
  #[inline]
  pub fn add_standard(&mut self, standard: i8) {
    self.fbb_.push_slot::<i8>(AppState::VT_STANDARD, standard, 0);
  }
  #[inline]
  pub fn add_current_item_start_line_head(&mut self, current_item_start_line_head: i8) {
    self.fbb_.push_slot_always::<i8>(AppState::VT_CURRENT_ITEM_START_LINE_HEAD, current_item_start_line_head);
  }
  #[inline]
  pub fn add_current_item_end_line_head(&mut self, current_item_end_line_head: i8) {
    self.fbb_.push_slot_always::<i8>(AppState::VT_CURRENT_ITEM_END_LINE_HEAD, current_item_end_line_head);
  }
  #[inline]
  pub fn add_current_item_roundness_v3(&mut self, current_item_roundness_v3: f64) {
    self.fbb_.push_slot::<f64>(AppState::VT_CURRENT_ITEM_ROUNDNESS_V3, current_item_roundness_v3, 0.0);
  }
  #[inline]
  pub fn add_anti_aliasing(&mut self, anti_aliasing: i8) {
    self.fbb_.push_slot::<i8>(AppState::VT_ANTI_ALIASING, anti_aliasing, 0);
  }
  #[inline]
  pub fn add_v_sync(&mut self, v_sync: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_V_SYNC, v_sync, false);
  }
  #[inline]
  pub fn add_current_item_font_family_v2(&mut self, current_item_font_family_v2: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(AppState::VT_CURRENT_ITEM_FONT_FAMILY_V2, current_item_font_family_v2);
  }
  #[inline]
  pub fn add_debug_rendering(&mut self, debug_rendering: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_DEBUG_RENDERING, debug_rendering, false);
  }
  #[inline]
  pub fn add_current_item_subset(&mut self, current_item_subset: i8) {
    self.fbb_.push_slot_always::<i8>(AppState::VT_CURRENT_ITEM_SUBSET, current_item_subset);
  }
  #[inline]
  pub fn add_editing_linear_element(&mut self, editing_linear_element: flatbuffers::WIPOffset<LinearElementEditor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<LinearElementEditor>>(AppState::VT_EDITING_LINEAR_ELEMENT, editing_linear_element);
  }
  #[inline]
  pub fn add_grid_mode_enabled(&mut self, grid_mode_enabled: bool) {
    self.fbb_.push_slot::<bool>(AppState::VT_GRID_MODE_ENABLED, grid_mode_enabled, false);
  }
  #[inline]
  pub fn add_grid_step(&mut self, grid_step: i32) {
    self.fbb_.push_slot::<i32>(AppState::VT_GRID_STEP, grid_step, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> AppStateBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    AppStateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AppState<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AppState<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AppState");
      ds.field("frame_rendering_enabled", &self.frame_rendering_enabled());
      ds.field("frame_rendering_name", &self.frame_rendering_name());
      ds.field("frame_rendering_outline", &self.frame_rendering_outline());
      ds.field("frame_rendering_clip", &self.frame_rendering_clip());
      ds.field("current_item_opacity", &self.current_item_opacity());
      ds.field("view_background_color", &self.view_background_color());
      ds.field("scope", &self.scope());
      ds.field("groups", &self.groups());
      ds.field("scroll_x", &self.scroll_x());
      ds.field("scroll_y", &self.scroll_y());
      ds.field("cursor_button", &self.cursor_button());
      ds.field("scrolled_outside", &self.scrolled_outside());
      ds.field("name", &self.name());
      ds.field("zoom", &self.zoom());
      ds.field("last_pointer_down_with", &self.last_pointer_down_with());
      ds.field("selected_element_ids", &self.selected_element_ids());
      ds.field("grid_size", &self.grid_size());
      ds.field("scale_ratio_locked", &self.scale_ratio_locked());
      ds.field("display_all_point_distances", &self.display_all_point_distances());
      ds.field("display_distance_on_drawing", &self.display_distance_on_drawing());
      ds.field("display_all_point_coordinates", &self.display_all_point_coordinates());
      ds.field("display_all_point_info_selected", &self.display_all_point_info_selected());
      ds.field("display_root_axis", &self.display_root_axis());
      ds.field("current_item_text_align_v3", &self.current_item_text_align_v3());
      ds.field("line_bending_mode", &self.line_bending_mode());
      ds.field("current_item_font_size_v3", &self.current_item_font_size_v3());
      ds.field("coord_decimal_places_v3", &self.coord_decimal_places_v3());
      ds.field("current_item_stroke", &self.current_item_stroke());
      ds.field("current_item_background", &self.current_item_background());
      ds.field("main_scope", &self.main_scope());
      ds.field("standard", &self.standard());
      ds.field("current_item_start_line_head", &self.current_item_start_line_head());
      ds.field("current_item_end_line_head", &self.current_item_end_line_head());
      ds.field("current_item_roundness_v3", &self.current_item_roundness_v3());
      ds.field("anti_aliasing", &self.anti_aliasing());
      ds.field("v_sync", &self.v_sync());
      ds.field("current_item_font_family_v2", &self.current_item_font_family_v2());
      ds.field("debug_rendering", &self.debug_rendering());
      ds.field("current_item_subset", &self.current_item_subset());
      ds.field("editing_linear_element", &self.editing_linear_element());
      ds.field("grid_mode_enabled", &self.grid_mode_enabled());
      ds.field("grid_step", &self.grid_step());
      ds.finish()
  }
}
pub enum BinaryFileDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BinaryFileData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BinaryFileData<'a> {
  type Inner = BinaryFileData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BinaryFileData<'a> {
  pub const VT_MIME_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_ID: flatbuffers::VOffsetT = 6;
  pub const VT_DATA: flatbuffers::VOffsetT = 8;
  pub const VT_CREATED: flatbuffers::VOffsetT = 10;
  pub const VT_LAST_RETRIEVED: flatbuffers::VOffsetT = 12;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BinaryFileData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BinaryFileDataArgs<'args>
  ) -> flatbuffers::WIPOffset<BinaryFileData<'bldr>> {
    let mut builder = BinaryFileDataBuilder::new(_fbb);
    builder.add_last_retrieved(args.last_retrieved);
    builder.add_created(args.created);
    if let Some(x) = args.data { builder.add_data(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    if let Some(x) = args.mime_type { builder.add_mime_type(x); }
    builder.finish()
  }


  #[inline]
  pub fn mime_type(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BinaryFileData::VT_MIME_TYPE, None)}
  }
  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BinaryFileData::VT_ID, None)}
  }
  #[inline]
  pub fn data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(BinaryFileData::VT_DATA, None)}
  }
  #[inline]
  pub fn created(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(BinaryFileData::VT_CREATED, Some(0)).unwrap()}
  }
  #[inline]
  pub fn last_retrieved(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(BinaryFileData::VT_LAST_RETRIEVED, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for BinaryFileData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("mime_type", Self::VT_MIME_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("data", Self::VT_DATA, false)?
     .visit_field::<i64>("created", Self::VT_CREATED, false)?
     .visit_field::<i64>("last_retrieved", Self::VT_LAST_RETRIEVED, false)?
     .finish();
    Ok(())
  }
}
pub struct BinaryFileDataArgs<'a> {
    pub mime_type: Option<flatbuffers::WIPOffset<&'a str>>,
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub created: i64,
    pub last_retrieved: i64,
}
impl<'a> Default for BinaryFileDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    BinaryFileDataArgs {
      mime_type: None,
      id: None,
      data: None,
      created: 0,
      last_retrieved: 0,
    }
  }
}

pub struct BinaryFileDataBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BinaryFileDataBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_mime_type(&mut self, mime_type: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryFileData::VT_MIME_TYPE, mime_type);
  }
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryFileData::VT_ID, id);
  }
  #[inline]
  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryFileData::VT_DATA, data);
  }
  #[inline]
  pub fn add_created(&mut self, created: i64) {
    self.fbb_.push_slot::<i64>(BinaryFileData::VT_CREATED, created, 0);
  }
  #[inline]
  pub fn add_last_retrieved(&mut self, last_retrieved: i64) {
    self.fbb_.push_slot::<i64>(BinaryFileData::VT_LAST_RETRIEVED, last_retrieved, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BinaryFileDataBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BinaryFileDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BinaryFileData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BinaryFileData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BinaryFileData");
      ds.field("mime_type", &self.mime_type());
      ds.field("id", &self.id());
      ds.field("data", &self.data());
      ds.field("created", &self.created());
      ds.field("last_retrieved", &self.last_retrieved());
      ds.finish()
  }
}
pub enum BinaryFilesEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BinaryFilesEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BinaryFilesEntry<'a> {
  type Inner = BinaryFilesEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BinaryFilesEntry<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BinaryFilesEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BinaryFilesEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<BinaryFilesEntry<'bldr>> {
    let mut builder = BinaryFilesEntryBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BinaryFilesEntry::VT_KEY, None)}
  }
  #[inline]
  pub fn value(&self) -> Option<BinaryFileData<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<BinaryFileData>>(BinaryFilesEntry::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for BinaryFilesEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<BinaryFileData>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct BinaryFilesEntryArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<BinaryFileData<'a>>>,
}
impl<'a> Default for BinaryFilesEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    BinaryFilesEntryArgs {
      key: None,
      value: None,
    }
  }
}

pub struct BinaryFilesEntryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BinaryFilesEntryBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryFilesEntry::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<BinaryFileData<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<BinaryFileData>>(BinaryFilesEntry::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BinaryFilesEntryBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BinaryFilesEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BinaryFilesEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BinaryFilesEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BinaryFilesEntry");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum BinaryFilesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BinaryFiles<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BinaryFiles<'a> {
  type Inner = BinaryFiles<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BinaryFiles<'a> {
  pub const VT_ENTRIES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BinaryFiles { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args BinaryFilesArgs<'args>
  ) -> flatbuffers::WIPOffset<BinaryFiles<'bldr>> {
    let mut builder = BinaryFilesBuilder::new(_fbb);
    if let Some(x) = args.entries { builder.add_entries(x); }
    builder.finish()
  }


  #[inline]
  pub fn entries(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinaryFilesEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinaryFilesEntry>>>>(BinaryFiles::VT_ENTRIES, None)}
  }
}

impl flatbuffers::Verifiable for BinaryFiles<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BinaryFilesEntry>>>>("entries", Self::VT_ENTRIES, false)?
     .finish();
    Ok(())
  }
}
pub struct BinaryFilesArgs<'a> {
    pub entries: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BinaryFilesEntry<'a>>>>>,
}
impl<'a> Default for BinaryFilesArgs<'a> {
  #[inline]
  fn default() -> Self {
    BinaryFilesArgs {
      entries: None,
    }
  }
}

pub struct BinaryFilesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BinaryFilesBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_entries(&mut self, entries: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BinaryFilesEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BinaryFiles::VT_ENTRIES, entries);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BinaryFilesBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    BinaryFilesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BinaryFiles<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BinaryFiles<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BinaryFiles");
      ds.field("entries", &self.entries());
      ds.finish()
  }
}
pub enum ExportedDataStateOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ExportedDataState<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ExportedDataState<'a> {
  type Inner = ExportedDataState<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ExportedDataState<'a> {
  pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
  pub const VT_VERSION: flatbuffers::VOffsetT = 6;
  pub const VT_SOURCE: flatbuffers::VOffsetT = 8;
  pub const VT_ELEMENTS: flatbuffers::VOffsetT = 10;
  pub const VT_APP_STATE: flatbuffers::VOffsetT = 12;
  pub const VT_FILES: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ExportedDataState { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ExportedDataStateArgs<'args>
  ) -> flatbuffers::WIPOffset<ExportedDataState<'bldr>> {
    let mut builder = ExportedDataStateBuilder::new(_fbb);
    if let Some(x) = args.files { builder.add_files(x); }
    if let Some(x) = args.app_state { builder.add_app_state(x); }
    if let Some(x) = args.elements { builder.add_elements(x); }
    if let Some(x) = args.source { builder.add_source(x); }
    builder.add_version(args.version);
    if let Some(x) = args.type_ { builder.add_type_(x); }
    builder.finish()
  }


  #[inline]
  pub fn type_(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ExportedDataState::VT_TYPE_, None)}
  }
  #[inline]
  pub fn version(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(ExportedDataState::VT_VERSION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn source(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ExportedDataState::VT_SOURCE, None)}
  }
  #[inline]
  pub fn elements(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucElement<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucElement>>>>(ExportedDataState::VT_ELEMENTS, None)}
  }
  #[inline]
  pub fn app_state(&self) -> Option<AppState<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<AppState>>(ExportedDataState::VT_APP_STATE, None)}
  }
  #[inline]
  pub fn files(&self) -> Option<BinaryFiles<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<BinaryFiles>>(ExportedDataState::VT_FILES, None)}
  }
}

impl flatbuffers::Verifiable for ExportedDataState<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, false)?
     .visit_field::<i32>("version", Self::VT_VERSION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("source", Self::VT_SOURCE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<DucElement>>>>("elements", Self::VT_ELEMENTS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<AppState>>("app_state", Self::VT_APP_STATE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<BinaryFiles>>("files", Self::VT_FILES, false)?
     .finish();
    Ok(())
  }
}
pub struct ExportedDataStateArgs<'a> {
    pub type_: Option<flatbuffers::WIPOffset<&'a str>>,
    pub version: i32,
    pub source: Option<flatbuffers::WIPOffset<&'a str>>,
    pub elements: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<DucElement<'a>>>>>,
    pub app_state: Option<flatbuffers::WIPOffset<AppState<'a>>>,
    pub files: Option<flatbuffers::WIPOffset<BinaryFiles<'a>>>,
}
impl<'a> Default for ExportedDataStateArgs<'a> {
  #[inline]
  fn default() -> Self {
    ExportedDataStateArgs {
      type_: None,
      version: 0,
      source: None,
      elements: None,
      app_state: None,
      files: None,
    }
  }
}

pub struct ExportedDataStateBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ExportedDataStateBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ExportedDataState::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_version(&mut self, version: i32) {
    self.fbb_.push_slot::<i32>(ExportedDataState::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_source(&mut self, source: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ExportedDataState::VT_SOURCE, source);
  }
  #[inline]
  pub fn add_elements(&mut self, elements: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<DucElement<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ExportedDataState::VT_ELEMENTS, elements);
  }
  #[inline]
  pub fn add_app_state(&mut self, app_state: flatbuffers::WIPOffset<AppState<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<AppState>>(ExportedDataState::VT_APP_STATE, app_state);
  }
  #[inline]
  pub fn add_files(&mut self, files: flatbuffers::WIPOffset<BinaryFiles<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<BinaryFiles>>(ExportedDataState::VT_FILES, files);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ExportedDataStateBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ExportedDataStateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ExportedDataState<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ExportedDataState<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ExportedDataState");
      ds.field("type_", &self.type_());
      ds.field("version", &self.version());
      ds.field("source", &self.source());
      ds.field("elements", &self.elements());
      ds.field("app_state", &self.app_state());
      ds.field("files", &self.files());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `ExportedDataState`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_exported_data_state_unchecked`.
pub fn root_as_exported_data_state(buf: &[u8]) -> Result<ExportedDataState, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<ExportedDataState>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `ExportedDataState` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_exported_data_state_unchecked`.
pub fn size_prefixed_root_as_exported_data_state(buf: &[u8]) -> Result<ExportedDataState, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<ExportedDataState>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `ExportedDataState` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_exported_data_state_unchecked`.
pub fn root_as_exported_data_state_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ExportedDataState<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<ExportedDataState<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `ExportedDataState` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_exported_data_state_unchecked`.
pub fn size_prefixed_root_as_exported_data_state_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<ExportedDataState<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<ExportedDataState<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a ExportedDataState and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `ExportedDataState`.
pub unsafe fn root_as_exported_data_state_unchecked(buf: &[u8]) -> ExportedDataState {
  flatbuffers::root_unchecked::<ExportedDataState>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed ExportedDataState and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `ExportedDataState`.
pub unsafe fn size_prefixed_root_as_exported_data_state_unchecked(buf: &[u8]) -> ExportedDataState {
  flatbuffers::size_prefixed_root_unchecked::<ExportedDataState>(buf)
}
pub const EXPORTED_DATA_STATE_IDENTIFIER: &str = "DUC_";

#[inline]
pub fn exported_data_state_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, EXPORTED_DATA_STATE_IDENTIFIER, false)
}

#[inline]
pub fn exported_data_state_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  flatbuffers::buffer_has_identifier(buf, EXPORTED_DATA_STATE_IDENTIFIER, true)
}

#[inline]
pub fn finish_exported_data_state_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<ExportedDataState<'a>>) {
  fbb.finish(root, Some(EXPORTED_DATA_STATE_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_exported_data_state_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<ExportedDataState<'a>>) {
  fbb.finish_size_prefixed(root, Some(EXPORTED_DATA_STATE_IDENTIFIER));
}
}  // pub mod Duc

